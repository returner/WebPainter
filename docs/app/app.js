/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/app";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/fabric/dist/fabric.js":
/*!********************************************!*\
  !*** ./node_modules/fabric/dist/fabric.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/* build: `node build.js modules=ALL exclude=gestures,accessors requirejs minifier=uglifyjs` */
/*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */

var fabric = fabric || { version: '2.6.0' };
if (true) {
  exports.fabric = fabric;
}
/* _AMD_START_ */
else {}
/* _AMD_END_ */
if (typeof document !== 'undefined' && typeof window !== 'undefined') {
  fabric.document = document;
  fabric.window = window;
}
else {
  // assume we're running under node.js when document/window are not present
  fabric.document = __webpack_require__(/*! jsdom */ 0)
    .jsdom(
      decodeURIComponent('%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E'),
      { features: {
        FetchExternalResources: ['img']
      }
      });
  fabric.jsdomImplForWrapper = __webpack_require__(/*! jsdom/lib/jsdom/living/generated/utils */ 1).implForWrapper;
  fabric.nodeCanvas = __webpack_require__(/*! jsdom/lib/jsdom/utils */ 2).Canvas;
  fabric.window = fabric.document.defaultView;
  DOMParser = __webpack_require__(/*! xmldom */ 3).DOMParser;
}

/**
 * True when in environment that supports touch events
 * @type boolean
 */
fabric.isTouchSupported = 'ontouchstart' in fabric.window || 'ontouchstart' in fabric.document ||
  (fabric.window && fabric.window.navigator && fabric.window.navigator.maxTouchPoints > 0);

/**
 * True when in environment that's probably Node.js
 * @type boolean
 */
fabric.isLikelyNode = typeof Buffer !== 'undefined' &&
                      typeof window === 'undefined';

/* _FROM_SVG_START_ */
/**
 * Attributes parsed from all SVG elements
 * @type array
 */
fabric.SHARED_ATTRIBUTES = [
  'display',
  'transform',
  'fill', 'fill-opacity', 'fill-rule',
  'opacity',
  'stroke', 'stroke-dasharray', 'stroke-linecap', 'stroke-dashoffset',
  'stroke-linejoin', 'stroke-miterlimit',
  'stroke-opacity', 'stroke-width',
  'id', 'paint-order',
  'instantiated_by_use', 'clip-path'
];
/* _FROM_SVG_END_ */

/**
 * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.
 */
fabric.DPI = 96;
fabric.reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)';
fabric.fontPaths = { };
fabric.iMatrix = [1, 0, 0, 1, 0, 0];
fabric.canvasModule = 'canvas';

/**
 * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.perfLimitSizeTotal = 2097152;

/**
 * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.maxCacheSideLimit = 4096;

/**
 * Lowest pixel limit for cache canvases, set at 256PX
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.minCacheSideLimit = 256;

/**
 * Cache Object for widths of chars in text rendering.
 */
fabric.charWidthsCache = { };

/**
 * if webgl is enabled and available, textureSize will determine the size
 * of the canvas backend
 * @since 2.0.0
 * @type Number
 * @default
 */
fabric.textureSize = 2048;

/**
 * Enable webgl for filtering picture is available
 * A filtering backend will be initialized, this will both take memory and
 * time since a default 2048x2048 canvas will be created for the gl context
 * @since 2.0.0
 * @type Boolean
 * @default
 */
fabric.enableGLFiltering = true;

/**
 * Device Pixel Ratio
 * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html
 */
fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
                          fabric.window.webkitDevicePixelRatio ||
                          fabric.window.mozDevicePixelRatio ||
                          1;
/**
 * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,
 * which is unitless and not rendered equally across browsers.
 *
 * Values that work quite well (as of October 2017) are:
 * - Chrome: 1.5
 * - Edge: 1.75
 * - Firefox: 0.9
 * - Safari: 0.95
 *
 * @since 2.0.0
 * @type Number
 * @default 1
 */
fabric.browserShadowBlurConstant = 1;

/**
 * This object contains the result of arc to beizer conversion for faster retrieving if the same arc needs to be converted again.
 * It was an internal variable, is accessible since version 2.3.4
 */
fabric.arcToSegmentsCache = { };

/**
 * This object keeps the results of the boundsOfCurve calculation mapped by the joined arguments necessary to calculate it.
 * It does speed up calculation, if you parse and add always the same paths, but in case of heavy usage of freedrawing
 * you do not get any speed benefit and you get a big object in memory.
 * The object was a private variable before, while now is appended to the lib so that you have access to it and you
 * can eventually clear it.
 * It was an internal variable, is accessible since version 2.3.4
 */
fabric.boundsOfCurveCache = { };

/**
 * If disabled boundsOfCurveCache is not used. For apps that make heavy usage of pencil drawing probably disabling it is better
 * @default true
 */
fabric.cachesBoundsOfCurve = true;

fabric.initFilterBackend = function() {
  if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {
    console.log('max texture size: ' + fabric.maxTextureSize);
    return (new fabric.WebglFilterBackend({ tileSize: fabric.textureSize }));
  }
  else if (fabric.Canvas2dFilterBackend) {
    return (new fabric.Canvas2dFilterBackend());
  }
};


if (typeof document !== 'undefined' && typeof window !== 'undefined') {
  // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)
  window.fabric = fabric;
}


(function() {

  /**
   * @private
   * @param {String} eventName
   * @param {Function} handler
   */
  function _removeEventListener(eventName, handler) {
    if (!this.__eventListeners[eventName]) {
      return;
    }
    var eventListener = this.__eventListeners[eventName];
    if (handler) {
      eventListener[eventListener.indexOf(handler)] = false;
    }
    else {
      fabric.util.array.fill(eventListener, false);
    }
  }

  /**
   * Observes specified event
   * @deprecated `observe` deprecated since 0.8.34 (use `on` instead)
   * @memberOf fabric.Observable
   * @alias on
   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
   * @param {Function} handler Function that receives a notification when an event of the specified type occurs
   * @return {Self} thisArg
   * @chainable
   */
  function observe(eventName, handler) {
    if (!this.__eventListeners) {
      this.__eventListeners = { };
    }
    // one object with key/value pairs was passed
    if (arguments.length === 1) {
      for (var prop in eventName) {
        this.on(prop, eventName[prop]);
      }
    }
    else {
      if (!this.__eventListeners[eventName]) {
        this.__eventListeners[eventName] = [];
      }
      this.__eventListeners[eventName].push(handler);
    }
    return this;
  }

  /**
   * Stops event observing for a particular event handler. Calling this method
   * without arguments removes all handlers for all events
   * @deprecated `stopObserving` deprecated since 0.8.34 (use `off` instead)
   * @memberOf fabric.Observable
   * @alias off
   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
   * @param {Function} handler Function to be deleted from EventListeners
   * @return {Self} thisArg
   * @chainable
   */
  function stopObserving(eventName, handler) {
    if (!this.__eventListeners) {
      return;
    }

    // remove all key/value pairs (event name -> event handler)
    if (arguments.length === 0) {
      for (eventName in this.__eventListeners) {
        _removeEventListener.call(this, eventName);
      }
    }
    // one object with key/value pairs was passed
    else if (arguments.length === 1 && typeof arguments[0] === 'object') {
      for (var prop in eventName) {
        _removeEventListener.call(this, prop, eventName[prop]);
      }
    }
    else {
      _removeEventListener.call(this, eventName, handler);
    }
    return this;
  }

  /**
   * Fires event with an optional options object
   * @deprecated `fire` deprecated since 1.0.7 (use `trigger` instead)
   * @memberOf fabric.Observable
   * @alias trigger
   * @param {String} eventName Event name to fire
   * @param {Object} [options] Options object
   * @return {Self} thisArg
   * @chainable
   */
  function fire(eventName, options) {
    if (!this.__eventListeners) {
      return;
    }

    var listenersForEvent = this.__eventListeners[eventName];
    if (!listenersForEvent) {
      return;
    }

    for (var i = 0, len = listenersForEvent.length; i < len; i++) {
      listenersForEvent[i] && listenersForEvent[i].call(this, options || { });
    }
    this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {
      return value !== false;
    });
    return this;
  }

  /**
   * @namespace fabric.Observable
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}
   * @see {@link http://fabricjs.com/events|Events demo}
   */
  fabric.Observable = {
    observe: observe,
    stopObserving: stopObserving,
    fire: fire,

    on: observe,
    off: stopObserving,
    trigger: fire
  };
})();


/**
 * @namespace fabric.Collection
 */
fabric.Collection = {

  _objects: [],

  /**
   * Adds objects to collection, Canvas or Group, then renders canvas
   * (if `renderOnAddRemove` is not `false`).
   * in case of Group no changes to bounding box are made.
   * Objects should be instances of (or inherit from) fabric.Object
   * Use of this function is highly discouraged for groups.
   * you can add a bunch of objects with the add method but then you NEED
   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
   * @param {...fabric.Object} object Zero or more fabric instances
   * @return {Self} thisArg
   * @chainable
   */
  add: function () {
    this._objects.push.apply(this._objects, arguments);
    if (this._onObjectAdded) {
      for (var i = 0, length = arguments.length; i < length; i++) {
        this._onObjectAdded(arguments[i]);
      }
    }
    this.renderOnAddRemove && this.requestRenderAll();
    return this;
  },

  /**
   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
   * An object should be an instance of (or inherit from) fabric.Object
   * Use of this function is highly discouraged for groups.
   * you can add a bunch of objects with the insertAt method but then you NEED
   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
   * @param {Object} object Object to insert
   * @param {Number} index Index to insert object at
   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
   * @return {Self} thisArg
   * @chainable
   */
  insertAt: function (object, index, nonSplicing) {
    var objects = this._objects;
    if (nonSplicing) {
      objects[index] = object;
    }
    else {
      objects.splice(index, 0, object);
    }
    this._onObjectAdded && this._onObjectAdded(object);
    this.renderOnAddRemove && this.requestRenderAll();
    return this;
  },

  /**
   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
   * @param {...fabric.Object} object Zero or more fabric instances
   * @return {Self} thisArg
   * @chainable
   */
  remove: function() {
    var objects = this._objects,
        index, somethingRemoved = false;

    for (var i = 0, length = arguments.length; i < length; i++) {
      index = objects.indexOf(arguments[i]);

      // only call onObjectRemoved if an object was actually removed
      if (index !== -1) {
        somethingRemoved = true;
        objects.splice(index, 1);
        this._onObjectRemoved && this._onObjectRemoved(arguments[i]);
      }
    }

    this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();
    return this;
  },

  /**
   * Executes given function for each object in this group
   * @param {Function} callback
   *                   Callback invoked with current object as first argument,
   *                   index - as second and an array of all objects - as third.
   *                   Callback is invoked in a context of Global Object (e.g. `window`)
   *                   when no `context` argument is given
   *
   * @param {Object} context Context (aka thisObject)
   * @return {Self} thisArg
   * @chainable
   */
  forEachObject: function(callback, context) {
    var objects = this.getObjects();
    for (var i = 0, len = objects.length; i < len; i++) {
      callback.call(context, objects[i], i, objects);
    }
    return this;
  },

  /**
   * Returns an array of children objects of this instance
   * Type parameter introduced in 1.3.10
   * since 2.3.5 this method return always a COPY of the array;
   * @param {String} [type] When specified, only objects of this type are returned
   * @return {Array}
   */
  getObjects: function(type) {
    if (typeof type === 'undefined') {
      return this._objects.concat();
    }
    return this._objects.filter(function(o) {
      return o.type === type;
    });
  },

  /**
   * Returns object at specified index
   * @param {Number} index
   * @return {Self} thisArg
   */
  item: function (index) {
    return this._objects[index];
  },

  /**
   * Returns true if collection contains no objects
   * @return {Boolean} true if collection is empty
   */
  isEmpty: function () {
    return this._objects.length === 0;
  },

  /**
   * Returns a size of a collection (i.e: length of an array containing its objects)
   * @return {Number} Collection size
   */
  size: function() {
    return this._objects.length;
  },

  /**
   * Returns true if collection contains an object
   * @param {Object} object Object to check against
   * @return {Boolean} `true` if collection contains an object
   */
  contains: function(object) {
    return this._objects.indexOf(object) > -1;
  },

  /**
   * Returns number representation of a collection complexity
   * @return {Number} complexity
   */
  complexity: function () {
    return this._objects.reduce(function (memo, current) {
      memo += current.complexity ? current.complexity() : 0;
      return memo;
    }, 0);
  }
};


/**
 * @namespace fabric.CommonMethods
 */
fabric.CommonMethods = {

  /**
   * Sets object's properties from options
   * @param {Object} [options] Options object
   */
  _setOptions: function(options) {
    for (var prop in options) {
      this.set(prop, options[prop]);
    }
  },

  /**
   * @private
   * @param {Object} [filler] Options object
   * @param {String} [property] property to set the Gradient to
   */
  _initGradient: function(filler, property) {
    if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {
      this.set(property, new fabric.Gradient(filler));
    }
  },

  /**
   * @private
   * @param {Object} [filler] Options object
   * @param {String} [property] property to set the Pattern to
   * @param {Function} [callback] callback to invoke after pattern load
   */
  _initPattern: function(filler, property, callback) {
    if (filler && filler.source && !(filler instanceof fabric.Pattern)) {
      this.set(property, new fabric.Pattern(filler, callback));
    }
    else {
      callback && callback();
    }
  },

  /**
   * @private
   * @param {Object} [options] Options object
   */
  _initClipping: function(options) {
    if (!options.clipTo || typeof options.clipTo !== 'string') {
      return;
    }

    var functionBody = fabric.util.getFunctionBody(options.clipTo);
    if (typeof functionBody !== 'undefined') {
      this.clipTo = new Function('ctx', functionBody);
    }
  },

  /**
   * @private
   */
  _setObject: function(obj) {
    for (var prop in obj) {
      this._set(prop, obj[prop]);
    }
  },

  /**
   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
   * @param {String|Object} key Property name or object (if object, iterate over the object properties)
   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
   * @return {fabric.Object} thisArg
   * @chainable
   */
  set: function(key, value) {
    if (typeof key === 'object') {
      this._setObject(key);
    }
    else {
      if (typeof value === 'function' && key !== 'clipTo') {
        this._set(key, value(this.get(key)));
      }
      else {
        this._set(key, value);
      }
    }
    return this;
  },

  _set: function(key, value) {
    this[key] = value;
  },

  /**
   * Toggles specified property from `true` to `false` or from `false` to `true`
   * @param {String} property Property to toggle
   * @return {fabric.Object} thisArg
   * @chainable
   */
  toggle: function(property) {
    var value = this.get(property);
    if (typeof value === 'boolean') {
      this.set(property, !value);
    }
    return this;
  },

  /**
   * Basic getter
   * @param {String} property Property name
   * @return {*} value of a property
   */
  get: function(property) {
    return this[property];
  }
};


(function(global) {

  var sqrt = Math.sqrt,
      atan2 = Math.atan2,
      pow = Math.pow,
      abs = Math.abs,
      PiBy180 = Math.PI / 180,
      PiBy2 = Math.PI / 2;

  /**
   * @namespace fabric.util
   */
  fabric.util = {

    /**
     * Calculate the cos of an angle, avoiding returning floats for known results
     * @static
     * @memberOf fabric.util
     * @param {Number} angle the angle in radians or in degree
     * @return {Number}
     */
    cos: function(angle) {
      if (angle === 0) { return 1; }
      if (angle < 0) {
        // cos(a) = cos(-a)
        angle = -angle;
      }
      var angleSlice = angle / PiBy2;
      switch (angleSlice) {
        case 1: case 3: return 0;
        case 2: return -1;
      }
      return Math.cos(angle);
    },

    /**
     * Calculate the sin of an angle, avoiding returning floats for known results
     * @static
     * @memberOf fabric.util
     * @param {Number} angle the angle in radians or in degree
     * @return {Number}
     */
    sin: function(angle) {
      if (angle === 0) { return 0; }
      var angleSlice = angle / PiBy2, sign = 1;
      if (angle < 0) {
        // sin(-a) = -sin(a)
        sign = -1;
      }
      switch (angleSlice) {
        case 1: return sign;
        case 2: return 0;
        case 3: return -sign;
      }
      return Math.sin(angle);
    },

    /**
     * Removes value from an array.
     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
     * @static
     * @memberOf fabric.util
     * @param {Array} array
     * @param {*} value
     * @return {Array} original array
     */
    removeFromArray: function(array, value) {
      var idx = array.indexOf(value);
      if (idx !== -1) {
        array.splice(idx, 1);
      }
      return array;
    },

    /**
     * Returns random number between 2 specified ones.
     * @static
     * @memberOf fabric.util
     * @param {Number} min lower limit
     * @param {Number} max upper limit
     * @return {Number} random value (between min and max)
     */
    getRandomInt: function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    },

    /**
     * Transforms degrees to radians.
     * @static
     * @memberOf fabric.util
     * @param {Number} degrees value in degrees
     * @return {Number} value in radians
     */
    degreesToRadians: function(degrees) {
      return degrees * PiBy180;
    },

    /**
     * Transforms radians to degrees.
     * @static
     * @memberOf fabric.util
     * @param {Number} radians value in radians
     * @return {Number} value in degrees
     */
    radiansToDegrees: function(radians) {
      return radians / PiBy180;
    },

    /**
     * Rotates `point` around `origin` with `radians`
     * @static
     * @memberOf fabric.util
     * @param {fabric.Point} point The point to rotate
     * @param {fabric.Point} origin The origin of the rotation
     * @param {Number} radians The radians of the angle for the rotation
     * @return {fabric.Point} The new rotated point
     */
    rotatePoint: function(point, origin, radians) {
      point.subtractEquals(origin);
      var v = fabric.util.rotateVector(point, radians);
      return new fabric.Point(v.x, v.y).addEquals(origin);
    },

    /**
     * Rotates `vector` with `radians`
     * @static
     * @memberOf fabric.util
     * @param {Object} vector The vector to rotate (x and y)
     * @param {Number} radians The radians of the angle for the rotation
     * @return {Object} The new rotated point
     */
    rotateVector: function(vector, radians) {
      var sin = fabric.util.sin(radians),
          cos = fabric.util.cos(radians),
          rx = vector.x * cos - vector.y * sin,
          ry = vector.x * sin + vector.y * cos;
      return {
        x: rx,
        y: ry
      };
    },

    /**
     * Apply transform t to point p
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Point} p The point to transform
     * @param  {Array} t The transform
     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
     * @return {fabric.Point} The transformed point
     */
    transformPoint: function(p, t, ignoreOffset) {
      if (ignoreOffset) {
        return new fabric.Point(
          t[0] * p.x + t[2] * p.y,
          t[1] * p.x + t[3] * p.y
        );
      }
      return new fabric.Point(
        t[0] * p.x + t[2] * p.y + t[4],
        t[1] * p.x + t[3] * p.y + t[5]
      );
    },

    /**
     * Returns coordinates of points's bounding rectangle (left, top, width, height)
     * @param {Array} points 4 points array
     * @return {Object} Object with left, top, width, height properties
     */
    makeBoundingBoxFromPoints: function(points) {
      var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x],
          minX = fabric.util.array.min(xPoints),
          maxX = fabric.util.array.max(xPoints),
          width = maxX - minX,
          yPoints = [points[0].y, points[1].y, points[2].y, points[3].y],
          minY = fabric.util.array.min(yPoints),
          maxY = fabric.util.array.max(yPoints),
          height = maxY - minY;

      return {
        left: minX,
        top: minY,
        width: width,
        height: height
      };
    },

    /**
     * Invert transformation t
     * @static
     * @memberOf fabric.util
     * @param {Array} t The transform
     * @return {Array} The inverted transform
     */
    invertTransform: function(t) {
      var a = 1 / (t[0] * t[3] - t[1] * t[2]),
          r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],
          o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);
      r[4] = -o.x;
      r[5] = -o.y;
      return r;
    },

    /**
     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
     * @static
     * @memberOf fabric.util
     * @param {Number|String} number number to operate on
     * @param {Number} fractionDigits number of fraction digits to "leave"
     * @return {Number}
     */
    toFixed: function(number, fractionDigits) {
      return parseFloat(Number(number).toFixed(fractionDigits));
    },

    /**
     * Converts from attribute value to pixel value if applicable.
     * Returns converted pixels or original value not converted.
     * @param {Number|String} value number to operate on
     * @param {Number} fontSize
     * @return {Number|String}
     */
    parseUnit: function(value, fontSize) {
      var unit = /\D{0,2}$/.exec(value),
          number = parseFloat(value);
      if (!fontSize) {
        fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
      }
      switch (unit[0]) {
        case 'mm':
          return number * fabric.DPI / 25.4;

        case 'cm':
          return number * fabric.DPI / 2.54;

        case 'in':
          return number * fabric.DPI;

        case 'pt':
          return number * fabric.DPI / 72; // or * 4 / 3

        case 'pc':
          return number * fabric.DPI / 72 * 12; // or * 16

        case 'em':
          return number * fontSize;

        default:
          return number;
      }
    },

    /**
     * Function which always returns `false`.
     * @static
     * @memberOf fabric.util
     * @return {Boolean}
     */
    falseFunction: function() {
      return false;
    },

    /**
     * Returns klass "Class" object of given namespace
     * @memberOf fabric.util
     * @param {String} type Type of object (eg. 'circle')
     * @param {String} namespace Namespace to get klass "Class" object from
     * @return {Object} klass "Class"
     */
    getKlass: function(type, namespace) {
      // capitalize first letter only
      type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
      return fabric.util.resolveNamespace(namespace)[type];
    },

    /**
     * Returns array of attributes for given svg that fabric parses
     * @memberOf fabric.util
     * @param {String} type Type of svg element (eg. 'circle')
     * @return {Array} string names of supported attributes
     */
    getSvgAttributes: function(type) {
      var attributes = [
        'instantiated_by_use',
        'style',
        'id',
        'class'
      ];
      switch (type) {
        case 'linearGradient':
          attributes = attributes.concat(['x1', 'y1', 'x2', 'y2', 'gradientUnits', 'gradientTransform']);
          break;
        case 'radialGradient':
          attributes = attributes.concat(['gradientUnits', 'gradientTransform', 'cx', 'cy', 'r', 'fx', 'fy', 'fr']);
          break;
        case 'stop':
          attributes = attributes.concat(['offset', 'stop-color', 'stop-opacity']);
          break;
      }
      return attributes;
    },

    /**
     * Returns object of given namespace
     * @memberOf fabric.util
     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
     * @return {Object} Object for given namespace (default fabric)
     */
    resolveNamespace: function(namespace) {
      if (!namespace) {
        return fabric;
      }

      var parts = namespace.split('.'),
          len = parts.length, i,
          obj = global || fabric.window;

      for (i = 0; i < len; ++i) {
        obj = obj[parts[i]];
      }

      return obj;
    },

    /**
     * Loads image element from given url and passes it to a callback
     * @memberOf fabric.util
     * @param {String} url URL representing an image
     * @param {Function} callback Callback; invoked with loaded image
     * @param {*} [context] Context to invoke callback in
     * @param {Object} [crossOrigin] crossOrigin value to set image element to
     */
    loadImage: function(url, callback, context, crossOrigin) {
      if (!url) {
        callback && callback.call(context, url);
        return;
      }

      var img = fabric.util.createImage();

      /** @ignore */
      var onLoadCallback = function () {
        callback && callback.call(context, img);
        img = img.onload = img.onerror = null;
      };

      img.onload = onLoadCallback;
      /** @ignore */
      img.onerror = function() {
        fabric.log('Error loading ' + img.src);
        callback && callback.call(context, null, true);
        img = img.onload = img.onerror = null;
      };

      // data-urls appear to be buggy with crossOrigin
      // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767
      // see https://code.google.com/p/chromium/issues/detail?id=315152
      //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069
      if (url.indexOf('data') !== 0 && crossOrigin) {
        img.crossOrigin = crossOrigin;
      }

      // IE10 / IE11-Fix: SVG contents from data: URI
      // will only be available if the IMG is present
      // in the DOM (and visible)
      if (url.substring(0,14) === 'data:image/svg') {
        img.onload = null;
        fabric.util.loadImageInDom(img, onLoadCallback);
      }

      img.src = url;
    },

    /**
     * Attaches SVG image with data: URL to the dom
     * @memberOf fabric.util
     * @param {Object} img Image object with data:image/svg src
     * @param {Function} callback Callback; invoked with loaded image
     * @return {Object} DOM element (div containing the SVG image)
     */
    loadImageInDom: function(img, onLoadCallback) {
      var div = fabric.document.createElement('div');
      div.style.width = div.style.height = '1px';
      div.style.left = div.style.top = '-100%';
      div.style.position = 'absolute';
      div.appendChild(img);
      fabric.document.querySelector('body').appendChild(div);
      /**
       * Wrap in function to:
       *   1. Call existing callback
       *   2. Cleanup DOM
       */
      img.onload = function () {
        onLoadCallback();
        div.parentNode.removeChild(div);
        div = null;
      };
    },

    /**
     * Creates corresponding fabric instances from their object representations
     * @static
     * @memberOf fabric.util
     * @param {Array} objects Objects to enliven
     * @param {Function} callback Callback to invoke when all objects are created
     * @param {String} namespace Namespace to get klass "Class" object from
     * @param {Function} reviver Method for further parsing of object elements,
     * called after each fabric object created.
     */
    enlivenObjects: function(objects, callback, namespace, reviver) {
      objects = objects || [];

      function onLoaded() {
        if (++numLoadedObjects === numTotalObjects) {
          callback && callback(enlivenedObjects);
        }
      }

      var enlivenedObjects = [],
          numLoadedObjects = 0,
          numTotalObjects = objects.length;

      if (!numTotalObjects) {
        callback && callback(enlivenedObjects);
        return;
      }

      objects.forEach(function (o, index) {
        // if sparse array
        if (!o || !o.type) {
          onLoaded();
          return;
        }
        var klass = fabric.util.getKlass(o.type, namespace);
        klass.fromObject(o, function (obj, error) {
          error || (enlivenedObjects[index] = obj);
          reviver && reviver(o, obj, error);
          onLoaded();
        });
      });
    },

    /**
     * Create and wait for loading of patterns
     * @static
     * @memberOf fabric.util
     * @param {Array} patterns Objects to enliven
     * @param {Function} callback Callback to invoke when all objects are created
     * called after each fabric object created.
     */
    enlivenPatterns: function(patterns, callback) {
      patterns = patterns || [];

      function onLoaded() {
        if (++numLoadedPatterns === numPatterns) {
          callback && callback(enlivenedPatterns);
        }
      }

      var enlivenedPatterns = [],
          numLoadedPatterns = 0,
          numPatterns = patterns.length;

      if (!numPatterns) {
        callback && callback(enlivenedPatterns);
        return;
      }

      patterns.forEach(function (p, index) {
        if (p && p.source) {
          new fabric.Pattern(p, function(pattern) {
            enlivenedPatterns[index] = pattern;
            onLoaded();
          });
        }
        else {
          enlivenedPatterns[index] = p;
          onLoaded();
        }
      });
    },

    /**
     * Groups SVG elements (usually those retrieved from SVG document)
     * @static
     * @memberOf fabric.util
     * @param {Array} elements SVG elements to group
     * @param {Object} [options] Options object
     * @param {String} path Value to set sourcePath to
     * @return {fabric.Object|fabric.Group}
     */
    groupSVGElements: function(elements, options, path) {
      var object;
      if (elements && elements.length === 1) {
        return elements[0];
      }
      if (options) {
        if (options.width && options.height) {
          options.centerPoint = {
            x: options.width / 2,
            y: options.height / 2
          };
        }
        else {
          delete options.width;
          delete options.height;
        }
      }
      object = new fabric.Group(elements, options);
      if (typeof path !== 'undefined') {
        object.sourcePath = path;
      }
      return object;
    },

    /**
     * Populates an object with properties of another object
     * @static
     * @memberOf fabric.util
     * @param {Object} source Source object
     * @param {Object} destination Destination object
     * @return {Array} properties Properties names to include
     */
    populateWithProperties: function(source, destination, properties) {
      if (properties && Object.prototype.toString.call(properties) === '[object Array]') {
        for (var i = 0, len = properties.length; i < len; i++) {
          if (properties[i] in source) {
            destination[properties[i]] = source[properties[i]];
          }
        }
      }
    },

    /**
     * Draws a dashed line between two points
     *
     * This method is used to draw dashed line around selection area.
     * See <a href="http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas">dotted stroke in canvas</a>
     *
     * @param {CanvasRenderingContext2D} ctx context
     * @param {Number} x  start x coordinate
     * @param {Number} y start y coordinate
     * @param {Number} x2 end x coordinate
     * @param {Number} y2 end y coordinate
     * @param {Array} da dash array pattern
     */
    drawDashedLine: function(ctx, x, y, x2, y2, da) {
      var dx = x2 - x,
          dy = y2 - y,
          len = sqrt(dx * dx + dy * dy),
          rot = atan2(dy, dx),
          dc = da.length,
          di = 0,
          draw = true;

      ctx.save();
      ctx.translate(x, y);
      ctx.moveTo(0, 0);
      ctx.rotate(rot);

      x = 0;
      while (len > x) {
        x += da[di++ % dc];
        if (x > len) {
          x = len;
        }
        ctx[draw ? 'lineTo' : 'moveTo'](x, 0);
        draw = !draw;
      }

      ctx.restore();
    },

    /**
     * Creates canvas element
     * @static
     * @memberOf fabric.util
     * @return {CanvasElement} initialized canvas element
     */
    createCanvasElement: function() {
      return fabric.document.createElement('canvas');
    },

    /**
     * Creates a canvas element that is a copy of another and is also painted
     * @param {CanvasElement} canvas to copy size and content of
     * @static
     * @memberOf fabric.util
     * @return {CanvasElement} initialized canvas element
     */
    copyCanvasElement: function(canvas) {
      var newCanvas = fabric.util.createCanvasElement();
      newCanvas.width = canvas.width;
      newCanvas.height = canvas.height;
      newCanvas.getContext('2d').drawImage(canvas, 0, 0);
      return newCanvas;
    },

    /**
     * since 2.6.0 moved from canvas instance to utility.
     * @param {CanvasElement} canvasEl to copy size and content of
     * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too
     * @param {Number} quality <= 1 and > 0
     * @static
     * @memberOf fabric.util
     * @return {String} data url
     */
    toDataURL: function(canvasEl, format, quality) {
      return canvasEl.toDataURL('image/' + format, quality);
    },

    /**
     * Creates image element (works on client and node)
     * @static
     * @memberOf fabric.util
     * @return {HTMLImageElement} HTML image element
     */
    createImage: function() {
      return fabric.document.createElement('img');
    },

    /**
     * @static
     * @memberOf fabric.util
     * @deprecated since 2.0.0
     * @param {fabric.Object} receiver Object implementing `clipTo` method
     * @param {CanvasRenderingContext2D} ctx Context to clip
     */
    clipContext: function(receiver, ctx) {
      ctx.save();
      ctx.beginPath();
      receiver.clipTo(ctx);
      ctx.clip();
    },

    /**
     * Multiply matrix A by matrix B to nest transformations
     * @static
     * @memberOf fabric.util
     * @param  {Array} a First transformMatrix
     * @param  {Array} b Second transformMatrix
     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices
     * @return {Array} The product of the two transform matrices
     */
    multiplyTransformMatrices: function(a, b, is2x2) {
      // Matrix multiply a * b
      return [
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],
        is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]
      ];
    },

    /**
     * Decomposes standard 2x2 matrix into transform componentes
     * @static
     * @memberOf fabric.util
     * @param  {Array} a transformMatrix
     * @return {Object} Components of transform
     */
    qrDecompose: function(a) {
      var angle = atan2(a[1], a[0]),
          denom = pow(a[0], 2) + pow(a[1], 2),
          scaleX = sqrt(denom),
          scaleY = (a[0] * a[3] - a[2] * a [1]) / scaleX,
          skewX = atan2(a[0] * a[2] + a[1] * a [3], denom);
      return {
        angle: angle  / PiBy180,
        scaleX: scaleX,
        scaleY: scaleY,
        skewX: skewX / PiBy180,
        skewY: 0,
        translateX: a[4],
        translateY: a[5]
      };
    },

    customTransformMatrix: function(scaleX, scaleY, skewX) {
      var skewMatrixX = [1, 0, abs(Math.tan(skewX * PiBy180)), 1],
          scaleMatrix = [abs(scaleX), 0, 0, abs(scaleY)];
      return fabric.util.multiplyTransformMatrices(scaleMatrix, skewMatrixX, true);
    },

    /**
     * reset an object transform state to neutral. Top and left are not accounted for
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Object} target object to transform
     */
    resetObjectTransform: function (target) {
      target.scaleX = 1;
      target.scaleY = 1;
      target.skewX = 0;
      target.skewY = 0;
      target.flipX = false;
      target.flipY = false;
      target.rotate(0);
    },

    /**
     * Extract Object transform values
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Object} target object to read from
     * @return {Object} Components of transform
     */
    saveObjectTransform: function (target) {
      return {
        scaleX: target.scaleX,
        scaleY: target.scaleY,
        skewX: target.skewX,
        skewY: target.skewY,
        angle: target.angle,
        left: target.left,
        flipX: target.flipX,
        flipY: target.flipY,
        top: target.top
      };
    },

    /**
     * Returns string representation of function body
     * @param {Function} fn Function to get body of
     * @return {String} Function body
     */
    getFunctionBody: function(fn) {
      return (String(fn).match(/function[^{]*\{([\s\S]*)\}/) || {})[1];
    },

    /**
     * Returns true if context has transparent pixel
     * at specified location (taking tolerance into account)
     * @param {CanvasRenderingContext2D} ctx context
     * @param {Number} x x coordinate
     * @param {Number} y y coordinate
     * @param {Number} tolerance Tolerance
     */
    isTransparent: function(ctx, x, y, tolerance) {

      // If tolerance is > 0 adjust start coords to take into account.
      // If moves off Canvas fix to 0
      if (tolerance > 0) {
        if (x > tolerance) {
          x -= tolerance;
        }
        else {
          x = 0;
        }
        if (y > tolerance) {
          y -= tolerance;
        }
        else {
          y = 0;
        }
      }

      var _isTransparent = true, i, temp,
          imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1),
          l = imageData.data.length;

      // Split image data - for tolerance > 1, pixelDataSize = 4;
      for (i = 3; i < l; i += 4) {
        temp = imageData.data[i];
        _isTransparent = temp <= 0;
        if (_isTransparent === false) {
          break; // Stop if colour found
        }
      }

      imageData = null;

      return _isTransparent;
    },

    /**
     * Parse preserveAspectRatio attribute from element
     * @param {string} attribute to be parsed
     * @return {Object} an object containing align and meetOrSlice attribute
     */
    parsePreserveAspectRatioAttribute: function(attribute) {
      var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',
          aspectRatioAttrs = attribute.split(' '), align;

      if (aspectRatioAttrs && aspectRatioAttrs.length) {
        meetOrSlice = aspectRatioAttrs.pop();
        if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {
          align = meetOrSlice;
          meetOrSlice = 'meet';
        }
        else if (aspectRatioAttrs.length) {
          align = aspectRatioAttrs.pop();
        }
      }
      //divide align in alignX and alignY
      alignX = align !== 'none' ? align.slice(1, 4) : 'none';
      alignY = align !== 'none' ? align.slice(5, 8) : 'none';
      return {
        meetOrSlice: meetOrSlice,
        alignX: alignX,
        alignY: alignY
      };
    },

    /**
     * Clear char widths cache for the given font family or all the cache if no
     * fontFamily is specified.
     * Use it if you know you are loading fonts in a lazy way and you are not waiting
     * for custom fonts to load properly when adding text objects to the canvas.
     * If a text object is added when its own font is not loaded yet, you will get wrong
     * measurement and so wrong bounding boxes.
     * After the font cache is cleared, either change the textObject text content or call
     * initDimensions() to trigger a recalculation
     * @memberOf fabric.util
     * @param {String} [fontFamily] font family to clear
     */
    clearFabricFontCache: function(fontFamily) {
      fontFamily = (fontFamily || '').toLowerCase();
      if (!fontFamily) {
        fabric.charWidthsCache = { };
      }
      else if (fabric.charWidthsCache[fontFamily]) {
        delete fabric.charWidthsCache[fontFamily];
      }
    },

    /**
     * Given current aspect ratio, determines the max width and height that can
     * respect the total allowed area for the cache.
     * @memberOf fabric.util
     * @param {Number} ar aspect ratio
     * @param {Number} maximumArea Maximum area you want to achieve
     * @return {Object.x} Limited dimensions by X
     * @return {Object.y} Limited dimensions by Y
     */
    limitDimsByArea: function(ar, maximumArea) {
      var roughWidth = Math.sqrt(maximumArea * ar),
          perfLimitSizeY = Math.floor(maximumArea / roughWidth);
      return { x: Math.floor(roughWidth), y: perfLimitSizeY };
    },

    capValue: function(min, value, max) {
      return Math.max(min, Math.min(value, max));
    },

    findScaleToFit: function(source, destination) {
      return Math.min(destination.width / source.width, destination.height / source.height);
    },

    findScaleToCover: function(source, destination) {
      return Math.max(destination.width / source.width, destination.height / source.height);
    }
  };
})( true ? exports : undefined);


(function() {

  var _join = Array.prototype.join;

  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
   * http://mozilla.org/MPL/2.0/
   */
  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
    var argsString = _join.call(arguments);
    if (fabric.arcToSegmentsCache[argsString]) {
      return fabric.arcToSegmentsCache[argsString];
    }

    var PI = Math.PI, th = rotateX * PI / 180,
        sinTh = fabric.util.sin(th),
        cosTh = fabric.util.cos(th),
        fromX = 0, fromY = 0;

    rx = Math.abs(rx);
    ry = Math.abs(ry);

    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
        root = 0;

    if (pl < 0) {
      var s = Math.sqrt(1 - pl / (rx2 * ry2));
      rx *= s;
      ry *= s;
    }
    else {
      root = (large === sweep ? -1.0 : 1.0) *
              Math.sqrt( pl / (rx2 * py2 + ry2 * px2));
    }

    var cx = root * rx * py / ry,
        cy = -root * ry * px / rx,
        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);

    if (sweep === 0 && dtheta > 0) {
      dtheta -= 2 * PI;
    }
    else if (sweep === 1 && dtheta < 0) {
      dtheta += 2 * PI;
    }

    // Convert into cubic bezier segments <= 90deg
    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
        result = [], mDelta = dtheta / segments,
        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
        th3 = mTheta + mDelta;

    for (var i = 0; i < segments; i++) {
      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
      fromX = result[i][4];
      fromY = result[i][5];
      mTheta = th3;
      th3 += mDelta;
    }
    fabric.arcToSegmentsCache[argsString] = result;
    return result;
  }

  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
    var costh2 = fabric.util.cos(th2),
        sinth2 = fabric.util.sin(th2),
        costh3 = fabric.util.cos(th3),
        sinth3 = fabric.util.sin(th3),
        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
        cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),
        cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),
        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);

    return [
      cp1X, cp1Y,
      cp2X, cp2Y,
      toX, toY
    ];
  }

  /*
   * Private
   */
  function calcVectorAngle(ux, uy, vx, vy) {
    var ta = Math.atan2(uy, ux),
        tb = Math.atan2(vy, vx);
    if (tb >= ta) {
      return tb - ta;
    }
    else {
      return 2 * Math.PI - (ta - tb);
    }
  }

  /**
   * Draws arc
   * @param {CanvasRenderingContext2D} ctx
   * @param {Number} fx
   * @param {Number} fy
   * @param {Array} coords
   */
  fabric.util.drawArc = function(ctx, fx, fy, coords) {
    var rx = coords[0],
        ry = coords[1],
        rot = coords[2],
        large = coords[3],
        sweep = coords[4],
        tx = coords[5],
        ty = coords[6],
        segs = [[], [], [], []],
        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

    for (var i = 0, len = segsNorm.length; i < len; i++) {
      segs[i][0] = segsNorm[i][0] + fx;
      segs[i][1] = segsNorm[i][1] + fy;
      segs[i][2] = segsNorm[i][2] + fx;
      segs[i][3] = segsNorm[i][3] + fy;
      segs[i][4] = segsNorm[i][4] + fx;
      segs[i][5] = segsNorm[i][5] + fy;
      ctx.bezierCurveTo.apply(ctx, segs[i]);
    }
  };

  /**
   * Calculate bounding box of a elliptic-arc
   * @param {Number} fx start point of arc
   * @param {Number} fy
   * @param {Number} rx horizontal radius
   * @param {Number} ry vertical radius
   * @param {Number} rot angle of horizontal axe
   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
   * @param {Number} tx end point of arc
   * @param {Number} ty
   */
  fabric.util.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {

    var fromX = 0, fromY = 0, bound, bounds = [],
        segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

    for (var i = 0, len = segs.length; i < len; i++) {
      bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);
      bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
      bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
      fromX = segs[i][4];
      fromY = segs[i][5];
    }
    return bounds;
  };

  /**
   * Calculate bounding box of a beziercurve
   * @param {Number} x0 starting point
   * @param {Number} y0
   * @param {Number} x1 first control point
   * @param {Number} y1
   * @param {Number} x2 secondo control point
   * @param {Number} y2
   * @param {Number} x3 end of beizer
   * @param {Number} y3
   */
  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
    var argsString;
    if (fabric.cachesBoundsOfCurve) {
      argsString = _join.call(arguments);
      if (fabric.boundsOfCurveCache[argsString]) {
        return fabric.boundsOfCurveCache[argsString];
      }
    }

    var sqrt = Math.sqrt,
        min = Math.min, max = Math.max,
        abs = Math.abs, tvalues = [],
        bounds = [[], []],
        a, b, c, t, t1, t2, b2ac, sqrtb2ac;

    b = 6 * x0 - 12 * x1 + 6 * x2;
    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
    c = 3 * x1 - 3 * x0;

    for (var i = 0; i < 2; ++i) {
      if (i > 0) {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }

      if (abs(a) < 1e-12) {
        if (abs(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (0 < t && t < 1) {
          tvalues.push(t);
        }
        continue;
      }
      b2ac = b * b - 4 * c * a;
      if (b2ac < 0) {
        continue;
      }
      sqrtb2ac = sqrt(b2ac);
      t1 = (-b + sqrtb2ac) / (2 * a);
      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }
      t2 = (-b - sqrtb2ac) / (2 * a);
      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }

    var x, y, j = tvalues.length, jlen = j, mt;
    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
      bounds[0][j] = x;

      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
      bounds[1][j] = y;
    }

    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    var result = [
      {
        x: min.apply(null, bounds[0]),
        y: min.apply(null, bounds[1])
      },
      {
        x: max.apply(null, bounds[0]),
        y: max.apply(null, bounds[1])
      }
    ];
    if (fabric.cachesBoundsOfCurve) {
      fabric.boundsOfCurveCache[argsString] = result;
    }
    return result;
  }

  fabric.util.getBoundsOfCurve = getBoundsOfCurve;

})();


(function() {

  var slice = Array.prototype.slice;

  /**
   * Invokes method on all items in a given array
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} method Name of a method to invoke
   * @return {Array}
   */
  function invoke(array, method) {
    var args = slice.call(arguments, 2), result = [];
    for (var i = 0, len = array.length; i < len; i++) {
      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
    }
    return result;
  }

  /**
   * Finds maximum value in array (not necessarily "first" one)
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} byProperty
   * @return {*}
   */
  function max(array, byProperty) {
    return find(array, byProperty, function(value1, value2) {
      return value1 >= value2;
    });
  }

  /**
   * Finds minimum value in array (not necessarily "first" one)
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} byProperty
   * @return {*}
   */
  function min(array, byProperty) {
    return find(array, byProperty, function(value1, value2) {
      return value1 < value2;
    });
  }

  /**
   * @private
   */
  function fill(array, value) {
    var k = array.length;
    while (k--) {
      array[k] = value;
    }
    return array;
  }

  /**
   * @private
   */
  function find(array, byProperty, condition) {
    if (!array || array.length === 0) {
      return;
    }

    var i = array.length - 1,
        result = byProperty ? array[i][byProperty] : array[i];
    if (byProperty) {
      while (i--) {
        if (condition(array[i][byProperty], result)) {
          result = array[i][byProperty];
        }
      }
    }
    else {
      while (i--) {
        if (condition(array[i], result)) {
          result = array[i];
        }
      }
    }
    return result;
  }

  /**
   * @namespace fabric.util.array
   */
  fabric.util.array = {
    fill: fill,
    invoke: invoke,
    min: min,
    max: max
  };

})();


(function() {
  /**
   * Copies all enumerable properties of one js object to another
   * this does not and cannot compete with generic utils.
   * Does not clone or extend fabric.Object subclasses.
   * This is mostly for internal use and has extra handling for fabricJS objects
   * it skips the canvas property in deep cloning.
   * @memberOf fabric.util.object
   * @param {Object} destination Where to copy to
   * @param {Object} source Where to copy from
   * @return {Object}
   */

  function extend(destination, source, deep) {
    // JScript DontEnum bug is not taken care of
    // the deep clone is for internal use, is not meant to avoid
    // javascript traps or cloning html element or self referenced objects.
    if (deep) {
      if (!fabric.isLikelyNode && source instanceof Element) {
        // avoid cloning deep images, canvases,
        destination = source;
      }
      else if (source instanceof Array) {
        destination = [];
        for (var i = 0, len = source.length; i < len; i++) {
          destination[i] = extend({ }, source[i], deep);
        }
      }
      else if (source && typeof source === 'object') {
        for (var property in source) {
          if (property === 'canvas') {
            destination[property] = extend({ }, source[property]);
          }
          else if (source.hasOwnProperty(property)) {
            destination[property] = extend({ }, source[property], deep);
          }
        }
      }
      else {
        // this sounds odd for an extend but is ok for recursive use
        destination = source;
      }
    }
    else {
      for (var property in source) {
        destination[property] = source[property];
      }
    }
    return destination;
  }

  /**
   * Creates an empty object and copies all enumerable properties of another object to it
   * @memberOf fabric.util.object
   * TODO: this function return an empty object if you try to clone null
   * @param {Object} object Object to clone
   * @return {Object}
   */
  function clone(object, deep) {
    return extend({ }, object, deep);
  }

  /** @namespace fabric.util.object */
  fabric.util.object = {
    extend: extend,
    clone: clone
  };
  fabric.util.object.extend(fabric.util, fabric.Observable);
})();


(function() {

  /**
   * Camelizes a string
   * @memberOf fabric.util.string
   * @param {String} string String to camelize
   * @return {String} Camelized version of a string
   */
  function camelize(string) {
    return string.replace(/-+(.)?/g, function(match, character) {
      return character ? character.toUpperCase() : '';
    });
  }

  /**
   * Capitalizes a string
   * @memberOf fabric.util.string
   * @param {String} string String to capitalize
   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
   * and other letters stay untouched, if false first letter is capitalized
   * and other letters are converted to lowercase.
   * @return {String} Capitalized version of a string
   */
  function capitalize(string, firstLetterOnly) {
    return string.charAt(0).toUpperCase() +
      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
  }

  /**
   * Escapes XML in a string
   * @memberOf fabric.util.string
   * @param {String} string String to escape
   * @return {String} Escaped version of a string
   */
  function escapeXml(string) {
    return string.replace(/&/g, '&amp;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  }

  /**
   * Divide a string in the user perceived single units
   * @memberOf fabric.util.string
   * @param {String} textstring String to escape
   * @return {Array} array containing the graphemes
   */
  function graphemeSplit(textstring) {
    var i = 0, chr, graphemes = [];
    for (i = 0, chr; i < textstring.length; i++) {
      if ((chr = getWholeChar(textstring, i)) === false) {
        continue;
      }
      graphemes.push(chr);
    }
    return graphemes;
  }

  // taken from mdn in the charAt doc page.
  function getWholeChar(str, i) {
    var code = str.charCodeAt(i);

    if (isNaN(code)) {
      return ''; // Position not found
    }
    if (code < 0xD800 || code > 0xDFFF) {
      return str.charAt(i);
    }

    // High surrogate (could change last hex to 0xDB7F to treat high private
    // surrogates as single characters)
    if (0xD800 <= code && code <= 0xDBFF) {
      if (str.length <= (i + 1)) {
        throw 'High surrogate without following low surrogate';
      }
      var next = str.charCodeAt(i + 1);
      if (0xDC00 > next || next > 0xDFFF) {
        throw 'High surrogate without following low surrogate';
      }
      return str.charAt(i) + str.charAt(i + 1);
    }
    // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
    if (i === 0) {
      throw 'Low surrogate without preceding high surrogate';
    }
    var prev = str.charCodeAt(i - 1);

    // (could change last hex to 0xDB7F to treat high private
    // surrogates as single characters)
    if (0xD800 > prev || prev > 0xDBFF) {
      throw 'Low surrogate without preceding high surrogate';
    }
    // We can pass over low surrogates now as the second component
    // in a pair which we have already processed
    return false;
  }


  /**
   * String utilities
   * @namespace fabric.util.string
   */
  fabric.util.string = {
    camelize: camelize,
    capitalize: capitalize,
    escapeXml: escapeXml,
    graphemeSplit: graphemeSplit
  };
})();


(function() {

  var slice = Array.prototype.slice, emptyFunction = function() { },

      IS_DONTENUM_BUGGY = (function() {
        for (var p in { toString: 1 }) {
          if (p === 'toString') {
            return false;
          }
        }
        return true;
      })(),

      /** @ignore */
      addMethods = function(klass, source, parent) {
        for (var property in source) {

          if (property in klass.prototype &&
              typeof klass.prototype[property] === 'function' &&
              (source[property] + '').indexOf('callSuper') > -1) {

            klass.prototype[property] = (function(property) {
              return function() {

                var superclass = this.constructor.superclass;
                this.constructor.superclass = parent;
                var returnValue = source[property].apply(this, arguments);
                this.constructor.superclass = superclass;

                if (property !== 'initialize') {
                  return returnValue;
                }
              };
            })(property);
          }
          else {
            klass.prototype[property] = source[property];
          }

          if (IS_DONTENUM_BUGGY) {
            if (source.toString !== Object.prototype.toString) {
              klass.prototype.toString = source.toString;
            }
            if (source.valueOf !== Object.prototype.valueOf) {
              klass.prototype.valueOf = source.valueOf;
            }
          }
        }
      };

  function Subclass() { }

  function callSuper(methodName) {
    var parentMethod = null,
        _this = this;

    // climb prototype chain to find method not equal to callee's method
    while (_this.constructor.superclass) {
      var superClassMethod = _this.constructor.superclass.prototype[methodName];
      if (_this[methodName] !== superClassMethod) {
        parentMethod = superClassMethod;
        break;
      }
      // eslint-disable-next-line
      _this = _this.constructor.superclass.prototype;
    }

    if (!parentMethod) {
      return console.log('tried to callSuper ' + methodName + ', method not found in prototype chain', this);
    }

    return (arguments.length > 1)
      ? parentMethod.apply(this, slice.call(arguments, 1))
      : parentMethod.call(this);
  }

  /**
   * Helper for creation of "classes".
   * @memberOf fabric.util
   * @param {Function} [parent] optional "Class" to inherit from
   * @param {Object} [properties] Properties shared by all instances of this class
   *                  (be careful modifying objects defined here as this would affect all instances)
   */
  function createClass() {
    var parent = null,
        properties = slice.call(arguments, 0);

    if (typeof properties[0] === 'function') {
      parent = properties.shift();
    }
    function klass() {
      this.initialize.apply(this, arguments);
    }

    klass.superclass = parent;
    klass.subclasses = [];

    if (parent) {
      Subclass.prototype = parent.prototype;
      klass.prototype = new Subclass();
      parent.subclasses.push(klass);
    }
    for (var i = 0, length = properties.length; i < length; i++) {
      addMethods(klass, properties[i], parent);
    }
    if (!klass.prototype.initialize) {
      klass.prototype.initialize = emptyFunction;
    }
    klass.prototype.constructor = klass;
    klass.prototype.callSuper = callSuper;
    return klass;
  }

  fabric.util.createClass = createClass;
})();


(function () {

  var unknown = 'unknown';

  /* EVENT HANDLING */

  function areHostMethods(object) {
    var methodNames = Array.prototype.slice.call(arguments, 1),
        t, i, len = methodNames.length;
    for (i = 0; i < len; i++) {
      t = typeof object[methodNames[i]];
      if (!(/^(?:function|object|unknown)$/).test(t)) {
        return false;
      }
    }
    return true;
  }

  /** @ignore */
  var getElement,
      setElement,
      getUniqueId = (function () {
        var uid = 0;
        return function (element) {
          return element.__uniqueID || (element.__uniqueID = 'uniqueID__' + uid++);
        };
      })();

  (function () {
    var elements = { };
    /** @ignore */
    getElement = function (uid) {
      return elements[uid];
    };
    /** @ignore */
    setElement = function (uid, element) {
      elements[uid] = element;
    };
  })();

  function createListener(uid, handler) {
    return {
      handler: handler,
      wrappedHandler: createWrappedHandler(uid, handler)
    };
  }

  function createWrappedHandler(uid, handler) {
    return function (e) {
      handler.call(getElement(uid), e || fabric.window.event);
    };
  }

  function createDispatcher(uid, eventName) {
    return function (e) {
      if (handlers[uid] && handlers[uid][eventName]) {
        var handlersForEvent = handlers[uid][eventName];
        for (var i = 0, len = handlersForEvent.length; i < len; i++) {
          handlersForEvent[i].call(this, e || fabric.window.event);
        }
      }
    };
  }

  var shouldUseAddListenerRemoveListener = (
        areHostMethods(fabric.document.documentElement, 'addEventListener', 'removeEventListener') &&
        areHostMethods(fabric.window, 'addEventListener', 'removeEventListener')),

      shouldUseAttachEventDetachEvent = (
        areHostMethods(fabric.document.documentElement, 'attachEvent', 'detachEvent') &&
        areHostMethods(fabric.window, 'attachEvent', 'detachEvent')),

      // IE branch
      listeners = { },

      // DOM L0 branch
      handlers = { },

      addListener, removeListener;

  if (shouldUseAddListenerRemoveListener) {
    /** @ignore */
    addListener = function (element, eventName, handler, options) {
      // since ie10 or ie9 can use addEventListener but they do not support options, i need to check
      element && element.addEventListener(eventName, handler, shouldUseAttachEventDetachEvent ? false : options);
    };
    /** @ignore */
    removeListener = function (element, eventName, handler, options) {
      element && element.removeEventListener(eventName, handler, shouldUseAttachEventDetachEvent ? false : options);
    };
  }

  else if (shouldUseAttachEventDetachEvent) {
    /** @ignore */
    addListener = function (element, eventName, handler) {
      if (!element) {
        return;
      }
      var uid = getUniqueId(element);
      setElement(uid, element);
      if (!listeners[uid]) {
        listeners[uid] = { };
      }
      if (!listeners[uid][eventName]) {
        listeners[uid][eventName] = [];

      }
      var listener = createListener(uid, handler);
      listeners[uid][eventName].push(listener);
      element.attachEvent('on' + eventName, listener.wrappedHandler);
    };
    /** @ignore */
    removeListener = function (element, eventName, handler) {
      if (!element) {
        return;
      }
      var uid = getUniqueId(element), listener;
      if (listeners[uid] && listeners[uid][eventName]) {
        for (var i = 0, len = listeners[uid][eventName].length; i < len; i++) {
          listener = listeners[uid][eventName][i];
          if (listener && listener.handler === handler) {
            element.detachEvent('on' + eventName, listener.wrappedHandler);
            listeners[uid][eventName][i] = null;
          }
        }
      }
    };
  }
  else {
    /** @ignore */
    addListener = function (element, eventName, handler) {
      if (!element) {
        return;
      }
      var uid = getUniqueId(element);
      if (!handlers[uid]) {
        handlers[uid] = { };
      }
      if (!handlers[uid][eventName]) {
        handlers[uid][eventName] = [];
        var existingHandler = element['on' + eventName];
        if (existingHandler) {
          handlers[uid][eventName].push(existingHandler);
        }
        element['on' + eventName] = createDispatcher(uid, eventName);
      }
      handlers[uid][eventName].push(handler);
    };
    /** @ignore */
    removeListener = function (element, eventName, handler) {
      if (!element) {
        return;
      }
      var uid = getUniqueId(element);
      if (handlers[uid] && handlers[uid][eventName]) {
        var handlersForEvent = handlers[uid][eventName];
        for (var i = 0, len = handlersForEvent.length; i < len; i++) {
          if (handlersForEvent[i] === handler) {
            handlersForEvent.splice(i, 1);
          }
        }
      }
    };
  }

  /**
   * Adds an event listener to an element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {String} eventName
   * @param {Function} handler
   */
  fabric.util.addListener = addListener;

  /**
   * Removes an event listener from an element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {String} eventName
   * @param {Function} handler
   */
  fabric.util.removeListener = removeListener;

  /**
   * Cross-browser wrapper for getting event's coordinates
   * @memberOf fabric.util
   * @param {Event} event Event object
   */
  function getPointer(event) {
    event || (event = fabric.window.event);

    var element = event.target ||
                  (typeof event.srcElement !== unknown ? event.srcElement : null),

        scroll = fabric.util.getScrollLeftTop(element);
    return {
      x: pointerX(event) + scroll.left,
      y: pointerY(event) + scroll.top
    };
  }

  var pointerX = function(event) {
        return event.clientX;
      },

      pointerY = function(event) {
        return event.clientY;
      };

  function _getPointer(event, pageProp, clientProp) {
    var touchProp = event.type === 'touchend' ? 'changedTouches' : 'touches';
    var pointer, eventTouchProp = event[touchProp];

    if (eventTouchProp && eventTouchProp[0]) {
      pointer = eventTouchProp[0][clientProp];
    }

    if (typeof pointer === 'undefined') {
      pointer = event[clientProp];
    }

    return pointer;
  }

  if (fabric.isTouchSupported) {
    pointerX = function(event) {
      return _getPointer(event, 'pageX', 'clientX');
    };
    pointerY = function(event) {
      return _getPointer(event, 'pageY', 'clientY');
    };
  }

  fabric.util.getPointer = getPointer;

})();


(function () {

  /**
   * Cross-browser wrapper for setting element's style
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {Object} styles
   * @return {HTMLElement} Element that was passed as a first argument
   */
  function setStyle(element, styles) {
    var elementStyle = element.style;
    if (!elementStyle) {
      return element;
    }
    if (typeof styles === 'string') {
      element.style.cssText += ';' + styles;
      return styles.indexOf('opacity') > -1
        ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
        : element;
    }
    for (var property in styles) {
      if (property === 'opacity') {
        setOpacity(element, styles[property]);
      }
      else {
        var normalizedProperty = (property === 'float' || property === 'cssFloat')
          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
          : property;
        elementStyle[normalizedProperty] = styles[property];
      }
    }
    return element;
  }

  var parseEl = fabric.document.createElement('div'),
      supportsOpacity = typeof parseEl.style.opacity === 'string',
      supportsFilters = typeof parseEl.style.filter === 'string',
      reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,

      /** @ignore */
      setOpacity = function (element) { return element; };

  if (supportsOpacity) {
    /** @ignore */
    setOpacity = function(element, value) {
      element.style.opacity = value;
      return element;
    };
  }
  else if (supportsFilters) {
    /** @ignore */
    setOpacity = function(element, value) {
      var es = element.style;
      if (element.currentStyle && !element.currentStyle.hasLayout) {
        es.zoom = 1;
      }
      if (reOpacity.test(es.filter)) {
        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
        es.filter = es.filter.replace(reOpacity, value);
      }
      else {
        es.filter += ' alpha(opacity=' + (value * 100) + ')';
      }
      return element;
    };
  }

  fabric.util.setStyle = setStyle;

})();


(function() {

  var _slice = Array.prototype.slice;

  /**
   * Takes id and returns an element with that id (if one exists in a document)
   * @memberOf fabric.util
   * @param {String|HTMLElement} id
   * @return {HTMLElement|null}
   */
  function getById(id) {
    return typeof id === 'string' ? fabric.document.getElementById(id) : id;
  }

  var sliceCanConvertNodelists,
      /**
       * Converts an array-like object (e.g. arguments or NodeList) to an array
       * @memberOf fabric.util
       * @param {Object} arrayLike
       * @return {Array}
       */
      toArray = function(arrayLike) {
        return _slice.call(arrayLike, 0);
      };

  try {
    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
  }
  catch (err) { }

  if (!sliceCanConvertNodelists) {
    toArray = function(arrayLike) {
      var arr = new Array(arrayLike.length), i = arrayLike.length;
      while (i--) {
        arr[i] = arrayLike[i];
      }
      return arr;
    };
  }

  /**
   * Creates specified element with specified attributes
   * @memberOf fabric.util
   * @param {String} tagName Type of an element to create
   * @param {Object} [attributes] Attributes to set on an element
   * @return {HTMLElement} Newly created element
   */
  function makeElement(tagName, attributes) {
    var el = fabric.document.createElement(tagName);
    for (var prop in attributes) {
      if (prop === 'class') {
        el.className = attributes[prop];
      }
      else if (prop === 'for') {
        el.htmlFor = attributes[prop];
      }
      else {
        el.setAttribute(prop, attributes[prop]);
      }
    }
    return el;
  }

  /**
   * Adds class to an element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to add class to
   * @param {String} className Class to add to an element
   */
  function addClass(element, className) {
    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
      element.className += (element.className ? ' ' : '') + className;
    }
  }

  /**
   * Wraps element with another element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to wrap
   * @param {HTMLElement|String} wrapper Element to wrap with
   * @param {Object} [attributes] Attributes to set on a wrapper
   * @return {HTMLElement} wrapper
   */
  function wrapElement(element, wrapper, attributes) {
    if (typeof wrapper === 'string') {
      wrapper = makeElement(wrapper, attributes);
    }
    if (element.parentNode) {
      element.parentNode.replaceChild(wrapper, element);
    }
    wrapper.appendChild(element);
    return wrapper;
  }

  /**
   * Returns element scroll offsets
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to operate on
   * @return {Object} Object with left/top values
   */
  function getScrollLeftTop(element) {

    var left = 0,
        top = 0,
        docElement = fabric.document.documentElement,
        body = fabric.document.body || {
          scrollLeft: 0, scrollTop: 0
        };

    // While loop checks (and then sets element to) .parentNode OR .host
    //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,
    //  but the .parentNode of a root ShadowDOM node will always be null, instead
    //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938
    while (element && (element.parentNode || element.host)) {

      // Set element to element parent, or 'host' in case of ShadowDOM
      element = element.parentNode || element.host;

      if (element === fabric.document) {
        left = body.scrollLeft || docElement.scrollLeft || 0;
        top = body.scrollTop ||  docElement.scrollTop || 0;
      }
      else {
        left += element.scrollLeft || 0;
        top += element.scrollTop || 0;
      }

      if (element.nodeType === 1 && element.style.position === 'fixed') {
        break;
      }
    }

    return { left: left, top: top };
  }

  /**
   * Returns offset for a given element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to get offset for
   * @return {Object} Object with "left" and "top" properties
   */
  function getElementOffset(element) {
    var docElem,
        doc = element && element.ownerDocument,
        box = { left: 0, top: 0 },
        offset = { left: 0, top: 0 },
        scrollLeftTop,
        offsetAttributes = {
          borderLeftWidth: 'left',
          borderTopWidth:  'top',
          paddingLeft:     'left',
          paddingTop:      'top'
        };

    if (!doc) {
      return offset;
    }

    for (var attr in offsetAttributes) {
      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
    }

    docElem = doc.documentElement;
    if ( typeof element.getBoundingClientRect !== 'undefined' ) {
      box = element.getBoundingClientRect();
    }

    scrollLeftTop = getScrollLeftTop(element);

    return {
      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
    };
  }

  /**
   * Returns style attribute value of a given element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to get style attribute for
   * @param {String} attr Style attribute to get for element
   * @return {String} Style attribute value of the given element.
   */
  var getElementStyle;
  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
    getElementStyle = function(element, attr) {
      var style = fabric.document.defaultView.getComputedStyle(element, null);
      return style ? style[attr] : undefined;
    };
  }
  else {
    getElementStyle = function(element, attr) {
      var value = element.style[attr];
      if (!value && element.currentStyle) {
        value = element.currentStyle[attr];
      }
      return value;
    };
  }

  (function () {
    var style = fabric.document.documentElement.style,
        selectProp = 'userSelect' in style
          ? 'userSelect'
          : 'MozUserSelect' in style
            ? 'MozUserSelect'
            : 'WebkitUserSelect' in style
              ? 'WebkitUserSelect'
              : 'KhtmlUserSelect' in style
                ? 'KhtmlUserSelect'
                : '';

    /**
     * Makes element unselectable
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to make unselectable
     * @return {HTMLElement} Element that was passed in
     */
    function makeElementUnselectable(element) {
      if (typeof element.onselectstart !== 'undefined') {
        element.onselectstart = fabric.util.falseFunction;
      }
      if (selectProp) {
        element.style[selectProp] = 'none';
      }
      else if (typeof element.unselectable === 'string') {
        element.unselectable = 'on';
      }
      return element;
    }

    /**
     * Makes element selectable
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to make selectable
     * @return {HTMLElement} Element that was passed in
     */
    function makeElementSelectable(element) {
      if (typeof element.onselectstart !== 'undefined') {
        element.onselectstart = null;
      }
      if (selectProp) {
        element.style[selectProp] = '';
      }
      else if (typeof element.unselectable === 'string') {
        element.unselectable = '';
      }
      return element;
    }

    fabric.util.makeElementUnselectable = makeElementUnselectable;
    fabric.util.makeElementSelectable = makeElementSelectable;
  })();

  (function() {

    /**
     * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading
     * @memberOf fabric.util
     * @param {String} url URL of a script to load
     * @param {Function} callback Callback to execute when script is finished loading
     */
    function getScript(url, callback) {
      var headEl = fabric.document.getElementsByTagName('head')[0],
          scriptEl = fabric.document.createElement('script'),
          loading = true;

      /** @ignore */
      scriptEl.onload = /** @ignore */ scriptEl.onreadystatechange = function(e) {
        if (loading) {
          if (typeof this.readyState === 'string' &&
              this.readyState !== 'loaded' &&
              this.readyState !== 'complete') {
            return;
          }
          loading = false;
          callback(e || fabric.window.event);
          scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;
        }
      };
      scriptEl.src = url;
      headEl.appendChild(scriptEl);
      // causes issue in Opera
      // headEl.removeChild(scriptEl);
    }

    fabric.util.getScript = getScript;
  })();

  function getNodeCanvas(element) {
    var impl = fabric.jsdomImplForWrapper(element);
    return impl._canvas || impl._image;
  };

  function cleanUpJsdomNode(element) {
    if (!fabric.isLikelyNode) {
      return;
    }
    var impl = fabric.jsdomImplForWrapper(element);
    if (impl) {
      impl._image = null;
      impl._canvas = null;
      // unsure if necessary
      impl._currentSrc = null;
      impl._attributes = null;
      impl._classList = null;
    }
  }

  fabric.util.getById = getById;
  fabric.util.toArray = toArray;
  fabric.util.makeElement = makeElement;
  fabric.util.addClass = addClass;
  fabric.util.wrapElement = wrapElement;
  fabric.util.getScrollLeftTop = getScrollLeftTop;
  fabric.util.getElementOffset = getElementOffset;
  fabric.util.getElementStyle = getElementStyle;
  fabric.util.getNodeCanvas = getNodeCanvas;
  fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;

})();


(function() {

  function addParamToUrl(url, param) {
    return url + (/\?/.test(url) ? '&' : '?') + param;
  }

  function emptyFn() { }

  /**
   * Cross-browser abstraction for sending XMLHttpRequest
   * @memberOf fabric.util
   * @param {String} url URL to send XMLHttpRequest to
   * @param {Object} [options] Options object
   * @param {String} [options.method="GET"]
   * @param {String} [options.parameters] parameters to append to url in GET or in body
   * @param {String} [options.body] body to send with POST or PUT request
   * @param {Function} options.onComplete Callback to invoke when request is completed
   * @return {XMLHttpRequest} request
   */
  function request(url, options) {
    options || (options = { });

    var method = options.method ? options.method.toUpperCase() : 'GET',
        onComplete = options.onComplete || function() { },
        xhr = new fabric.window.XMLHttpRequest(),
        body = options.body || options.parameters;

    /** @ignore */
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        onComplete(xhr);
        xhr.onreadystatechange = emptyFn;
      }
    };

    if (method === 'GET') {
      body = null;
      if (typeof options.parameters === 'string') {
        url = addParamToUrl(url, options.parameters);
      }
    }

    xhr.open(method, url, true);

    if (method === 'POST' || method === 'PUT') {
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    }

    xhr.send(body);
    return xhr;
  }

  fabric.util.request = request;
})();


/**
 * Wrapper around `console.log` (when available)
 * @param {*} [values] Values to log
 */
fabric.log = function() { };

/**
 * Wrapper around `console.warn` (when available)
 * @param {*} [values] Values to log as a warning
 */
fabric.warn = function() { };

/* eslint-disable */
if (typeof console !== 'undefined') {

  ['log', 'warn'].forEach(function(methodName) {

    if (typeof console[methodName] !== 'undefined' &&
        typeof console[methodName].apply === 'function') {

      fabric[methodName] = function() {
        return console[methodName].apply(console, arguments);
      };
    }
  });
}
/* eslint-enable */


(function() {

  function noop() {
    return false;
  }

  /**
   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
   * @memberOf fabric.util
   * @param {Object} [options] Animation options
   * @param {Function} [options.onChange] Callback; invoked on every value change
   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
   * @param {Number} [options.startValue=0] Starting value
   * @param {Number} [options.endValue=100] Ending value
   * @param {Number} [options.byValue=100] Value to modify the property by
   * @param {Function} [options.easing] Easing function
   * @param {Number} [options.duration=500] Duration of change (in ms)
   */
  function animate(options) {

    requestAnimFrame(function(timestamp) {
      options || (options = { });

      var start = timestamp || +new Date(),
          duration = options.duration || 500,
          finish = start + duration, time,
          onChange = options.onChange || noop,
          abort = options.abort || noop,
          onComplete = options.onComplete || noop,
          easing = options.easing || function(t, b, c, d) {return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;},
          startValue = 'startValue' in options ? options.startValue : 0,
          endValue = 'endValue' in options ? options.endValue : 100,
          byValue = options.byValue || endValue - startValue;

      options.onStart && options.onStart();

      (function tick(ticktime) {
        if (abort()) {
          onComplete(endValue, 1, 1);
          return;
        }
        time = ticktime || +new Date();
        var currentTime = time > finish ? duration : (time - start),
            timePerc = currentTime / duration,
            current = easing(currentTime, startValue, byValue, duration),
            valuePerc = Math.abs((current - startValue) / byValue);
        onChange(current, valuePerc, timePerc);
        if (time > finish) {
          options.onComplete && options.onComplete();
          return;
        }
        requestAnimFrame(tick);
      })(start);
    });

  }

  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
                          fabric.window.webkitRequestAnimationFrame ||
                          fabric.window.mozRequestAnimationFrame    ||
                          fabric.window.oRequestAnimationFrame      ||
                          fabric.window.msRequestAnimationFrame     ||
                          function(callback) {
                            return fabric.window.setTimeout(callback, 1000 / 60);
                          };

  var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;

  /**
   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
   * @memberOf fabric.util
   * @param {Function} callback Callback to invoke
   * @param {DOMElement} element optional Element to associate with animation
   */
  function requestAnimFrame() {
    return _requestAnimFrame.apply(fabric.window, arguments);
  }

  function cancelAnimFrame() {
    return _cancelAnimFrame.apply(fabric.window, arguments);
  }

  fabric.util.animate = animate;
  fabric.util.requestAnimFrame = requestAnimFrame;
  fabric.util.cancelAnimFrame = cancelAnimFrame;
})();


(function() {
  // Calculate an in-between color. Returns a "rgba()" string.
  // Credit: Edwin Martin <edwin@bitstorm.org>
  //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js
  function calculateColor(begin, end, pos) {
    var color = 'rgba('
        + parseInt((begin[0] + pos * (end[0] - begin[0])), 10) + ','
        + parseInt((begin[1] + pos * (end[1] - begin[1])), 10) + ','
        + parseInt((begin[2] + pos * (end[2] - begin[2])), 10);

    color += ',' + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
    color += ')';
    return color;
  }

  /**
   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.
   * @memberOf fabric.util
   * @param {String} fromColor The starting color in hex or rgb(a) format.
   * @param {String} toColor The starting color in hex or rgb(a) format.
   * @param {Number} [duration] Duration of change (in ms).
   * @param {Object} [options] Animation options
   * @param {Function} [options.onChange] Callback; invoked on every value change
   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.
   */
  function animateColor(fromColor, toColor, duration, options) {
    var startColor = new fabric.Color(fromColor).getSource(),
        endColor = new fabric.Color(toColor).getSource();

    options = options || {};

    fabric.util.animate(fabric.util.object.extend(options, {
      duration: duration || 500,
      startValue: startColor,
      endValue: endColor,
      byValue: endColor,
      easing: function (currentTime, startValue, byValue, duration) {
        var posValue = options.colorEasing
          ? options.colorEasing(currentTime, duration)
          : 1 - Math.cos(currentTime / duration * (Math.PI / 2));
        return calculateColor(startValue, byValue, posValue);
      }
    }));
  }

  fabric.util.animateColor = animateColor;

})();


(function() {

  function normalize(a, c, p, s) {
    if (a < Math.abs(c)) {
      a = c;
      s = p / 4;
    }
    else {
      //handle the 0/0 case:
      if (c === 0 && a === 0) {
        s = p / (2 * Math.PI) * Math.asin(1);
      }
      else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
    }
    return { a: a, c: c, p: p, s: s };
  }

  function elastic(opts, t, d) {
    return opts.a *
      Math.pow(2, 10 * (t -= 1)) *
      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
  }

  /**
   * Cubic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutCubic(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t + 1) + b;
  }

  /**
   * Cubic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutCubic(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t + b;
    }
    return c / 2 * ((t -= 2) * t * t + 2) + b;
  }

  /**
   * Quartic easing in
   * @memberOf fabric.util.ease
   */
  function easeInQuart(t, b, c, d) {
    return c * (t /= d) * t * t * t + b;
  }

  /**
   * Quartic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutQuart(t, b, c, d) {
    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
  }

  /**
   * Quartic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutQuart(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t * t + b;
    }
    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
  }

  /**
   * Quintic easing in
   * @memberOf fabric.util.ease
   */
  function easeInQuint(t, b, c, d) {
    return c * (t /= d) * t * t * t * t + b;
  }

  /**
   * Quintic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutQuint(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
  }

  /**
   * Quintic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutQuint(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t * t * t + b;
    }
    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
  }

  /**
   * Sinusoidal easing in
   * @memberOf fabric.util.ease
   */
  function easeInSine(t, b, c, d) {
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
  }

  /**
   * Sinusoidal easing out
   * @memberOf fabric.util.ease
   */
  function easeOutSine(t, b, c, d) {
    return c * Math.sin(t / d * (Math.PI / 2)) + b;
  }

  /**
   * Sinusoidal easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutSine(t, b, c, d) {
    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
  }

  /**
   * Exponential easing in
   * @memberOf fabric.util.ease
   */
  function easeInExpo(t, b, c, d) {
    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
  }

  /**
   * Exponential easing out
   * @memberOf fabric.util.ease
   */
  function easeOutExpo(t, b, c, d) {
    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
  }

  /**
   * Exponential easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutExpo(t, b, c, d) {
    if (t === 0) {
      return b;
    }
    if (t === d) {
      return b + c;
    }
    t /= d / 2;
    if (t < 1) {
      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
    }
    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
  }

  /**
   * Circular easing in
   * @memberOf fabric.util.ease
   */
  function easeInCirc(t, b, c, d) {
    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
  }

  /**
   * Circular easing out
   * @memberOf fabric.util.ease
   */
  function easeOutCirc(t, b, c, d) {
    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
  }

  /**
   * Circular easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutCirc(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
    }
    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
  }

  /**
   * Elastic easing in
   * @memberOf fabric.util.ease
   */
  function easeInElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d;
    if (t === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    var opts = normalize(a, c, p, s);
    return -elastic(opts, t, d) + b;
  }

  /**
   * Elastic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d;
    if (t === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    var opts = normalize(a, c, p, s);
    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
  }

  /**
   * Elastic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d / 2;
    if (t === 2) {
      return b + c;
    }
    if (!p) {
      p = d * (0.3 * 1.5);
    }
    var opts = normalize(a, c, p, s);
    if (t < 1) {
      return -0.5 * elastic(opts, t, d) + b;
    }
    return opts.a * Math.pow(2, -10 * (t -= 1)) *
      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
  }

  /**
   * Backwards easing in
   * @memberOf fabric.util.ease
   */
  function easeInBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    return c * (t /= d) * t * ((s + 1) * t - s) + b;
  }

  /**
   * Backwards easing out
   * @memberOf fabric.util.ease
   */
  function easeOutBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
  }

  /**
   * Backwards easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    t /= d / 2;
    if (t < 1) {
      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
    }
    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
  }

  /**
   * Bouncing easing in
   * @memberOf fabric.util.ease
   */
  function easeInBounce(t, b, c, d) {
    return c - easeOutBounce (d - t, 0, c, d) + b;
  }

  /**
   * Bouncing easing out
   * @memberOf fabric.util.ease
   */
  function easeOutBounce(t, b, c, d) {
    if ((t /= d) < (1 / 2.75)) {
      return c * (7.5625 * t * t) + b;
    }
    else if (t < (2 / 2.75)) {
      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
    }
    else if (t < (2.5 / 2.75)) {
      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
    }
    else {
      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
    }
  }

  /**
   * Bouncing easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutBounce(t, b, c, d) {
    if (t < d / 2) {
      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
    }
    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
  }

  /**
   * Easing functions
   * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
   * @namespace fabric.util.ease
   */
  fabric.util.ease = {

    /**
     * Quadratic easing in
     * @memberOf fabric.util.ease
     */
    easeInQuad: function(t, b, c, d) {
      return c * (t /= d) * t + b;
    },

    /**
     * Quadratic easing out
     * @memberOf fabric.util.ease
     */
    easeOutQuad: function(t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    },

    /**
     * Quadratic easing in and out
     * @memberOf fabric.util.ease
     */
    easeInOutQuad: function(t, b, c, d) {
      t /= (d / 2);
      if (t < 1) {
        return c / 2 * t * t + b;
      }
      return -c / 2 * ((--t) * (t - 2) - 1) + b;
    },

    /**
     * Cubic easing in
     * @memberOf fabric.util.ease
     */
    easeInCubic: function(t, b, c, d) {
      return c * (t /= d) * t * t + b;
    },

    easeOutCubic: easeOutCubic,
    easeInOutCubic: easeInOutCubic,
    easeInQuart: easeInQuart,
    easeOutQuart: easeOutQuart,
    easeInOutQuart: easeInOutQuart,
    easeInQuint: easeInQuint,
    easeOutQuint: easeOutQuint,
    easeInOutQuint: easeInOutQuint,
    easeInSine: easeInSine,
    easeOutSine: easeOutSine,
    easeInOutSine: easeInOutSine,
    easeInExpo: easeInExpo,
    easeOutExpo: easeOutExpo,
    easeInOutExpo: easeInOutExpo,
    easeInCirc: easeInCirc,
    easeOutCirc: easeOutCirc,
    easeInOutCirc: easeInOutCirc,
    easeInElastic: easeInElastic,
    easeOutElastic: easeOutElastic,
    easeInOutElastic: easeInOutElastic,
    easeInBack: easeInBack,
    easeOutBack: easeOutBack,
    easeInOutBack: easeInOutBack,
    easeInBounce: easeInBounce,
    easeOutBounce: easeOutBounce,
    easeInOutBounce: easeInOutBounce
  };

})();


(function(global) {

  'use strict';

  /**
   * @name fabric
   * @namespace
   */

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      toFixed = fabric.util.toFixed,
      parseUnit = fabric.util.parseUnit,
      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,

      svgValidTagNames = ['path', 'circle', 'polygon', 'polyline', 'ellipse', 'rect', 'line',
        'image', 'text'],
      svgViewBoxElements = ['symbol', 'image', 'marker', 'pattern', 'view', 'svg'],
      svgInvalidAncestors = ['pattern', 'defs', 'symbol', 'metadata', 'clipPath', 'mask', 'desc'],
      svgValidParents = ['symbol', 'g', 'a', 'svg', 'clipPath', 'defs'],

      attributesMap = {
        cx:                   'left',
        x:                    'left',
        r:                    'radius',
        cy:                   'top',
        y:                    'top',
        display:              'visible',
        visibility:           'visible',
        transform:            'transformMatrix',
        'fill-opacity':       'fillOpacity',
        'fill-rule':          'fillRule',
        'font-family':        'fontFamily',
        'font-size':          'fontSize',
        'font-style':         'fontStyle',
        'font-weight':        'fontWeight',
        'letter-spacing':     'charSpacing',
        'paint-order':        'paintFirst',
        'stroke-dasharray':   'strokeDashArray',
        'stroke-dashoffset':  'strokeDashOffset',
        'stroke-linecap':     'strokeLineCap',
        'stroke-linejoin':    'strokeLineJoin',
        'stroke-miterlimit':  'strokeMiterLimit',
        'stroke-opacity':     'strokeOpacity',
        'stroke-width':       'strokeWidth',
        'text-decoration':    'textDecoration',
        'text-anchor':        'textAnchor',
        opacity:              'opacity',
        'clip-path':          'clipPath',
        'clip-rule':          'clipRule',
      },

      colorAttributes = {
        stroke: 'strokeOpacity',
        fill:   'fillOpacity'
      };

  fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);
  fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);
  fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);
  fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);

  fabric.cssRules = { };
  fabric.gradientDefs = { };
  fabric.clipPaths = { };

  function normalizeAttr(attr) {
    // transform attribute names
    if (attr in attributesMap) {
      return attributesMap[attr];
    }
    return attr;
  }

  function normalizeValue(attr, value, parentAttributes, fontSize) {
    var isArray = Object.prototype.toString.call(value) === '[object Array]',
        parsed;

    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
      value = '';
    }
    else if (attr === 'strokeDashArray') {
      if (value === 'none') {
        value = null;
      }
      else {
        value = value.replace(/,/g, ' ').split(/\s+/).map(parseFloat);
      }
    }
    else if (attr === 'transformMatrix') {
      if (parentAttributes && parentAttributes.transformMatrix) {
        value = multiplyTransformMatrices(
          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
      }
      else {
        value = fabric.parseTransformAttribute(value);
      }
    }
    else if (attr === 'visible') {
      value = value !== 'none' && value !== 'hidden';
      // display=none on parent element always takes precedence over child element
      if (parentAttributes && parentAttributes.visible === false) {
        value = false;
      }
    }
    else if (attr === 'opacity') {
      value = parseFloat(value);
      if (parentAttributes && typeof parentAttributes.opacity !== 'undefined') {
        value *= parentAttributes.opacity;
      }
    }
    else if (attr === 'textAnchor' /* text-anchor */) {
      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
    }
    else if (attr === 'charSpacing') {
      // parseUnit returns px and we convert it to em
      parsed = parseUnit(value, fontSize) / fontSize * 1000;
    }
    else if (attr === 'paintFirst') {
      var fillIndex = value.indexOf('fill');
      var strokeIndex = value.indexOf('stroke');
      var value = 'fill';
      if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {
        value = 'stroke';
      }
      else if (fillIndex === -1 && strokeIndex > -1) {
        value = 'stroke';
      }
    }
    else if (attr === 'href' || attr === 'xlink:href') {
      return value;
    }
    else {
      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
    }

    return (!isArray && isNaN(parsed) ? value : parsed);
  }

  /**
    * @private
    */
  function getSvgRegex(arr) {
    return new RegExp('^(' + arr.join('|') + ')\\b', 'i');
  }

  /**
   * @private
   * @param {Object} attributes Array of attributes to parse
   */
  function _setStrokeFillOpacity(attributes) {
    for (var attr in colorAttributes) {

      if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {
        continue;
      }

      if (typeof attributes[attr] === 'undefined') {
        if (!fabric.Object.prototype[attr]) {
          continue;
        }
        attributes[attr] = fabric.Object.prototype[attr];
      }

      if (attributes[attr].indexOf('url(') === 0) {
        continue;
      }

      var color = new fabric.Color(attributes[attr]);
      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
    }
    return attributes;
  }

  /**
   * @private
   */
  function _getMultipleNodes(doc, nodeNames) {
    var nodeName, nodeArray = [], nodeList, i, len;
    for (i = 0, len = nodeNames.length; i < len; i++) {
      nodeName = nodeNames[i];
      nodeList = doc.getElementsByTagName(nodeName);
      nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
    }
    return nodeArray;
  }

  /**
   * Parses "transform" attribute, returning an array of values
   * @static
   * @function
   * @memberOf fabric
   * @param {String} attributeValue String containing attribute value
   * @return {Array} Array of 6 elements representing transformation matrix
   */
  fabric.parseTransformAttribute = (function() {
    function rotateMatrix(matrix, args) {
      var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]),
          x = 0, y = 0;
      if (args.length === 3) {
        x = args[1];
        y = args[2];
      }

      matrix[0] = cos;
      matrix[1] = sin;
      matrix[2] = -sin;
      matrix[3] = cos;
      matrix[4] = x - (cos * x - sin * y);
      matrix[5] = y - (sin * x + cos * y);
    }

    function scaleMatrix(matrix, args) {
      var multiplierX = args[0],
          multiplierY = (args.length === 2) ? args[1] : args[0];

      matrix[0] = multiplierX;
      matrix[3] = multiplierY;
    }

    function skewMatrix(matrix, args, pos) {
      matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));
    }

    function translateMatrix(matrix, args) {
      matrix[4] = args[0];
      if (args.length === 2) {
        matrix[5] = args[1];
      }
    }

    // identity matrix
    var iMatrix = fabric.iMatrix,

        // == begin transform regexp
        number = fabric.reNum,

        commaWsp = '(?:\\s+,?\\s*|,\\s*)',

        skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',

        skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',

        rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + ')' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        matrix = '(?:(matrix)\\s*\\(\\s*' +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' +
                  '\\s*\\))',

        transform = '(?:' +
                    matrix + '|' +
                    translate + '|' +
                    scale + '|' +
                    rotate + '|' +
                    skewX + '|' +
                    skewY +
                    ')',

        transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',

        transformList = '^\\s*(?:' + transforms + '?)\\s*$',

        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
        reTransformList = new RegExp(transformList),
        // == end transform regexp

        reTransform = new RegExp(transform, 'g');

    return function(attributeValue) {

      // start with identity matrix
      var matrix = iMatrix.concat(),
          matrices = [];

      // return if no argument was given or
      // an argument does not match transform attribute regexp
      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
        return matrix;
      }

      attributeValue.replace(reTransform, function(match) {

        var m = new RegExp(transform).exec(match).filter(function (match) {
              // match !== '' && match != null
              return (!!match);
            }),
            operation = m[1],
            args = m.slice(2).map(parseFloat);

        switch (operation) {
          case 'translate':
            translateMatrix(matrix, args);
            break;
          case 'rotate':
            args[0] = fabric.util.degreesToRadians(args[0]);
            rotateMatrix(matrix, args);
            break;
          case 'scale':
            scaleMatrix(matrix, args);
            break;
          case 'skewX':
            skewMatrix(matrix, args, 2);
            break;
          case 'skewY':
            skewMatrix(matrix, args, 1);
            break;
          case 'matrix':
            matrix = args;
            break;
        }

        // snapshot current matrix into matrices array
        matrices.push(matrix.concat());
        // reset
        matrix = iMatrix.concat();
      });

      var combinedMatrix = matrices[0];
      while (matrices.length > 1) {
        matrices.shift();
        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
      }
      return combinedMatrix;
    };
  })();

  /**
   * @private
   */
  function parseStyleString(style, oStyle) {
    var attr, value;
    style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
      var pair = chunk.split(':');

      attr = pair[0].trim().toLowerCase();
      value =  pair[1].trim();

      oStyle[attr] = value;
    });
  }

  /**
   * @private
   */
  function parseStyleObject(style, oStyle) {
    var attr, value;
    for (var prop in style) {
      if (typeof style[prop] === 'undefined') {
        continue;
      }

      attr = prop.toLowerCase();
      value = style[prop];

      oStyle[attr] = value;
    }
  }

  /**
   * @private
   */
  function getGlobalStylesForElement(element, svgUid) {
    var styles = { };
    for (var rule in fabric.cssRules[svgUid]) {
      if (elementMatchesRule(element, rule.split(' '))) {
        for (var property in fabric.cssRules[svgUid][rule]) {
          styles[property] = fabric.cssRules[svgUid][rule][property];
        }
      }
    }
    return styles;
  }

  /**
   * @private
   */
  function elementMatchesRule(element, selectors) {
    var firstMatching, parentMatching = true;
    //start from rightmost selector.
    firstMatching = selectorMatches(element, selectors.pop());
    if (firstMatching && selectors.length) {
      parentMatching = doesSomeParentMatch(element, selectors);
    }
    return firstMatching && parentMatching && (selectors.length === 0);
  }

  function doesSomeParentMatch(element, selectors) {
    var selector, parentMatching = true;
    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
      if (parentMatching) {
        selector = selectors.pop();
      }
      element = element.parentNode;
      parentMatching = selectorMatches(element, selector);
    }
    return selectors.length === 0;
  }

  /**
   * @private
   */
  function selectorMatches(element, selector) {
    var nodeName = element.nodeName,
        classNames = element.getAttribute('class'),
        id = element.getAttribute('id'), matcher, i;
    // i check if a selector matches slicing away part from it.
    // if i get empty string i should match
    matcher = new RegExp('^' + nodeName, 'i');
    selector = selector.replace(matcher, '');
    if (id && selector.length) {
      matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
      selector = selector.replace(matcher, '');
    }
    if (classNames && selector.length) {
      classNames = classNames.split(' ');
      for (i = classNames.length; i--;) {
        matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
        selector = selector.replace(matcher, '');
      }
    }
    return selector.length === 0;
  }

  /**
   * @private
   * to support IE8 missing getElementById on SVGdocument and on node xmlDOM
   */
  function elementById(doc, id) {
    var el;
    doc.getElementById && (el = doc.getElementById(id));
    if (el) {
      return el;
    }
    var node, i, len, nodelist = doc.getElementsByTagName('*');
    for (i = 0, len = nodelist.length; i < len; i++) {
      node = nodelist[i];
      if (id === node.getAttribute('id')) {
        return node;
      }
    }
  }

  /**
   * @private
   */
  function parseUseDirectives(doc) {
    var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;
    while (nodelist.length && i < nodelist.length) {
      var el = nodelist[i],
          xlink = (el.getAttribute('xlink:href') || el.getAttribute('href')).substr(1),
          x = el.getAttribute('x') || 0,
          y = el.getAttribute('y') || 0,
          el2 = elementById(doc, xlink).cloneNode(true),
          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
          parentNode, oldLength = nodelist.length, attr, j, attrs, len;

      applyViewboxTransform(el2);
      if (/^svg$/i.test(el2.nodeName)) {
        var el3 = el2.ownerDocument.createElement('g');
        for (j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++) {
          attr = attrs.item(j);
          el3.setAttribute(attr.nodeName, attr.nodeValue);
        }
        // el2.firstChild != null
        while (el2.firstChild) {
          el3.appendChild(el2.firstChild);
        }
        el2 = el3;
      }

      for (j = 0, attrs = el.attributes, len = attrs.length; j < len; j++) {
        attr = attrs.item(j);
        if (attr.nodeName === 'x' || attr.nodeName === 'y' ||
          attr.nodeName === 'xlink:href' || attr.nodeName === 'href') {
          continue;
        }

        if (attr.nodeName === 'transform') {
          currentTrans = attr.nodeValue + ' ' + currentTrans;
        }
        else {
          el2.setAttribute(attr.nodeName, attr.nodeValue);
        }
      }

      el2.setAttribute('transform', currentTrans);
      el2.setAttribute('instantiated_by_use', '1');
      el2.removeAttribute('id');
      parentNode = el.parentNode;
      parentNode.replaceChild(el2, el);
      // some browsers do not shorten nodelist after replaceChild (IE8)
      if (nodelist.length === oldLength) {
        i++;
      }
    }
  }

  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
  // matches, e.g.: +14.56e-12, etc.
  var reViewBoxAttrValue = new RegExp(
    '^' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*' +
    '$'
  );

  /**
   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
   */
  function applyViewboxTransform(element) {

    var viewBoxAttr = element.getAttribute('viewBox'),
        scaleX = 1,
        scaleY = 1,
        minX = 0,
        minY = 0,
        viewBoxWidth, viewBoxHeight, matrix, el,
        widthAttr = element.getAttribute('width'),
        heightAttr = element.getAttribute('height'),
        x = element.getAttribute('x') || 0,
        y = element.getAttribute('y') || 0,
        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',
        missingViewBox = (!viewBoxAttr || !fabric.svgViewBoxElementsRegEx.test(element.nodeName)
                           || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
        toBeParsed = missingViewBox && missingDimAttr,
        parsedDim = { }, translateMatrix = '', widthDiff = 0, heightDiff = 0;

    parsedDim.width = 0;
    parsedDim.height = 0;
    parsedDim.toBeParsed = toBeParsed;

    if (toBeParsed) {
      return parsedDim;
    }

    if (missingViewBox) {
      parsedDim.width = parseUnit(widthAttr);
      parsedDim.height = parseUnit(heightAttr);
      return parsedDim;
    }

    minX = -parseFloat(viewBoxAttr[1]);
    minY = -parseFloat(viewBoxAttr[2]);
    viewBoxWidth = parseFloat(viewBoxAttr[3]);
    viewBoxHeight = parseFloat(viewBoxAttr[4]);

    if (!missingDimAttr) {
      parsedDim.width = parseUnit(widthAttr);
      parsedDim.height = parseUnit(heightAttr);
      scaleX = parsedDim.width / viewBoxWidth;
      scaleY = parsedDim.height / viewBoxHeight;
    }
    else {
      parsedDim.width = viewBoxWidth;
      parsedDim.height = viewBoxHeight;
    }

    // default is to preserve aspect ratio
    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
    if (preserveAspectRatio.alignX !== 'none') {
      //translate all container for the effect of Mid, Min, Max
      if (preserveAspectRatio.meetOrSlice === 'meet') {
        scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
        // calculate additional translation to move the viewbox
      }
      if (preserveAspectRatio.meetOrSlice === 'slice') {
        scaleY = scaleX = (scaleX > scaleY ? scaleX : scaleY);
        // calculate additional translation to move the viewbox
      }
      widthDiff = parsedDim.width - viewBoxWidth * scaleX;
      heightDiff = parsedDim.height - viewBoxHeight * scaleX;
      if (preserveAspectRatio.alignX === 'Mid') {
        widthDiff /= 2;
      }
      if (preserveAspectRatio.alignY === 'Mid') {
        heightDiff /= 2;
      }
      if (preserveAspectRatio.alignX === 'Min') {
        widthDiff = 0;
      }
      if (preserveAspectRatio.alignY === 'Min') {
        heightDiff = 0;
      }
    }

    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
      return parsedDim;
    }

    if (x || y) {
      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
    }

    matrix = translateMatrix + ' matrix(' + scaleX +
                  ' 0' +
                  ' 0 ' +
                  scaleY + ' ' +
                  (minX * scaleX + widthDiff) + ' ' +
                  (minY * scaleY + heightDiff) + ') ';
    parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);
    if (element.nodeName === 'svg') {
      el = element.ownerDocument.createElement('g');
      // element.firstChild != null
      while (element.firstChild) {
        el.appendChild(element.firstChild);
      }
      element.appendChild(el);
    }
    else {
      el = element;
      matrix = el.getAttribute('transform') + matrix;
    }
    el.setAttribute('transform', matrix);
    return parsedDim;
  }

  function hasAncestorWithNodeName(element, nodeName) {
    while (element && (element = element.parentNode)) {
      if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))
        && !element.getAttribute('instantiated_by_use')) {
        return true;
      }
    }
    return false;
  }

  /**
   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
   * @static
   * @function
   * @memberOf fabric
   * @param {SVGDocument} doc SVG document to parse
   * @param {Function} callback Callback to call when parsing is finished;
   * It's being passed an array of elements (parsed from a document).
   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
   * @param {Object} [parsingOptions] options for parsing document
   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings
   */
  fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {
    if (!doc) {
      return;
    }

    parseUseDirectives(doc);

    var svgUid =  fabric.Object.__uid++, i, len,
        options = applyViewboxTransform(doc),
        descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
    options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;
    options.svgUid = svgUid;

    if (descendants.length === 0 && fabric.isLikelyNode) {
      // we're likely in node, where "o3-xml" library fails to gEBTN("*")
      // https://github.com/ajaxorg/node-o3-xml/issues/21
      descendants = doc.selectNodes('//*[name(.)!="svg"]');
      var arr = [];
      for (i = 0, len = descendants.length; i < len; i++) {
        arr[i] = descendants[i];
      }
      descendants = arr;
    }

    var elements = descendants.filter(function(el) {
      applyViewboxTransform(el);
      return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', '')) &&
            !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement
    });

    if (!elements || (elements && !elements.length)) {
      callback && callback([], {});
      return;
    }
    var clipPaths = { };
    descendants.filter(function(el) {
      return el.nodeName.replace('svg:', '') === 'clipPath';
    }).forEach(function(el) {
      var id = el.getAttribute('id');
      clipPaths[id] = fabric.util.toArray(el.getElementsByTagName('*')).filter(function(el) {
        return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', ''));
      });
    });
    fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
    fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
    fabric.clipPaths[svgUid] = clipPaths;
    // Precedence of rules:   style > class > attribute
    fabric.parseElements(elements, function(instances, elements) {
      if (callback) {
        callback(instances, options, elements, descendants);
        delete fabric.gradientDefs[svgUid];
        delete fabric.cssRules[svgUid];
        delete fabric.clipPaths[svgUid];
      }
    }, clone(options), reviver, parsingOptions);
  };

  function recursivelyParseGradientsXlink(doc, gradient) {
    var gradientsAttrs = ['gradientTransform', 'x1', 'x2', 'y1', 'y2', 'gradientUnits', 'cx', 'cy', 'r', 'fx', 'fy'],
        xlinkAttr = 'xlink:href',
        xLink = gradient.getAttribute(xlinkAttr).substr(1),
        referencedGradient = elementById(doc, xLink);
    if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {
      recursivelyParseGradientsXlink(doc, referencedGradient);
    }
    gradientsAttrs.forEach(function(attr) {
      if (!gradient.hasAttribute(attr)) {
        gradient.setAttribute(attr, referencedGradient.getAttribute(attr));
      }
    });
    if (!gradient.children.length) {
      var referenceClone = referencedGradient.cloneNode(true);
      while (referenceClone.firstChild) {
        gradient.appendChild(referenceClone.firstChild);
      }
    }
    gradient.removeAttribute(xlinkAttr);
  }

  var reFontDeclaration = new RegExp(
    '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
      fabric.reNum +
    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');

  extend(fabric, {
    /**
     * Parses a short font declaration, building adding its properties to a style object
     * @static
     * @function
     * @memberOf fabric
     * @param {String} value font declaration
     * @param {Object} oStyle definition
     */
    parseFontDeclaration: function(value, oStyle) {
      var match = value.match(reFontDeclaration);

      if (!match) {
        return;
      }
      var fontStyle = match[1],
          // font variant is not used
          // fontVariant = match[2],
          fontWeight = match[3],
          fontSize = match[4],
          lineHeight = match[5],
          fontFamily = match[6];

      if (fontStyle) {
        oStyle.fontStyle = fontStyle;
      }
      if (fontWeight) {
        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
      }
      if (fontSize) {
        oStyle.fontSize = parseUnit(fontSize);
      }
      if (fontFamily) {
        oStyle.fontFamily = fontFamily;
      }
      if (lineHeight) {
        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
      }
    },

    /**
     * Parses an SVG document, returning all of the gradient declarations found in it
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
     */
    getGradientDefs: function(doc) {
      var tagArray = [
            'linearGradient',
            'radialGradient',
            'svg:linearGradient',
            'svg:radialGradient'],
          elList = _getMultipleNodes(doc, tagArray),
          el, j = 0, gradientDefs = { };
      j = elList.length;
      while (j--) {
        el = elList[j];
        if (el.getAttribute('xlink:href')) {
          recursivelyParseGradientsXlink(doc, el);
        }
        gradientDefs[el.getAttribute('id')] = el;
      }
      return gradientDefs;
    },

    /**
     * Returns an object of attributes' name/value, given element and an array of attribute names;
     * Parses parent "g" nodes recursively upwards.
     * @static
     * @memberOf fabric
     * @param {DOMElement} element Element to parse
     * @param {Array} attributes Array of attributes to parse
     * @return {Object} object containing parsed attributes' names/values
     */
    parseAttributes: function(element, attributes, svgUid) {

      if (!element) {
        return;
      }

      var value,
          parentAttributes = { },
          fontSize, parentFontSize;

      if (typeof svgUid === 'undefined') {
        svgUid = element.getAttribute('svgUid');
      }
      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
      if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {
        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
      }

      var ownAttributes = attributes.reduce(function(memo, attr) {
        value = element.getAttribute(attr);
        if (value) { // eslint-disable-line
          memo[attr] = value;
        }
        return memo;
      }, { });
      // add values parsed from style, which take precedence over attributes
      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
      ownAttributes = extend(ownAttributes,
        extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element)));

      fontSize = parentFontSize = parentAttributes.fontSize || fabric.Text.DEFAULT_SVG_FONT_SIZE;
      if (ownAttributes['font-size']) {
        // looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.
        ownAttributes['font-size'] = fontSize = parseUnit(ownAttributes['font-size'], parentFontSize);
      }

      var normalizedAttr, normalizedValue, normalizedStyle = {};
      for (var attr in ownAttributes) {
        normalizedAttr = normalizeAttr(attr);
        normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);
        normalizedStyle[normalizedAttr] = normalizedValue;
      }
      if (normalizedStyle && normalizedStyle.font) {
        fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);
      }
      var mergedAttrs = extend(parentAttributes, normalizedStyle);
      return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);
    },

    /**
     * Transforms an array of svg elements to corresponding fabric.* instances
     * @static
     * @memberOf fabric
     * @param {Array} elements Array of elements to parse
     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
     * @param {Object} [options] Options object
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     */
    parseElements: function(elements, callback, options, reviver, parsingOptions) {
      new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();
    },

    /**
     * Parses "style" attribute, retuning an object with values
     * @static
     * @memberOf fabric
     * @param {SVGElement} element Element to parse
     * @return {Object} Objects with values parsed from style attribute of an element
     */
    parseStyleAttribute: function(element) {
      var oStyle = { },
          style = element.getAttribute('style');

      if (!style) {
        return oStyle;
      }

      if (typeof style === 'string') {
        parseStyleString(style, oStyle);
      }
      else {
        parseStyleObject(style, oStyle);
      }

      return oStyle;
    },

    /**
     * Parses "points" attribute, returning an array of values
     * @static
     * @memberOf fabric
     * @param {String} points points attribute string
     * @return {Array} array of points
     */
    parsePointsAttribute: function(points) {

      // points attribute is required and must not be empty
      if (!points) {
        return null;
      }

      // replace commas with whitespace and remove bookending whitespace
      points = points.replace(/,/g, ' ').trim();

      points = points.split(/\s+/);
      var parsedPoints = [], i, len;

      for (i = 0, len = points.length; i < len; i += 2) {
        parsedPoints.push({
          x: parseFloat(points[i]),
          y: parseFloat(points[i + 1])
        });
      }

      // odd number of points is an error
      // if (parsedPoints.length % 2 !== 0) {
      //   return null;
      // }

      return parsedPoints;
    },

    /**
     * Returns CSS rules for a given SVG document
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @return {Object} CSS rules of this document
     */
    getCSSRules: function(doc) {
      var styles = doc.getElementsByTagName('style'), i, len,
          allRules = { }, rules;

      // very crude parsing of style contents
      for (i = 0, len = styles.length; i < len; i++) {
        // IE9 doesn't support textContent, but provides text instead.
        var styleContents = styles[i].textContent || styles[i].text;

        // remove comments
        styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
        if (styleContents.trim() === '') {
          continue;
        }
        rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
        rules = rules.map(function(rule) { return rule.trim(); });
        // eslint-disable-next-line no-loop-func
        rules.forEach(function(rule) {

          var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
              ruleObj = { }, declaration = match[2].trim(),
              propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);

          for (i = 0, len = propertyValuePairs.length; i < len; i++) {
            var pair = propertyValuePairs[i].split(/\s*:\s*/),
                property = pair[0],
                value = pair[1];
            ruleObj[property] = value;
          }
          rule = match[1];
          rule.split(',').forEach(function(_rule) {
            _rule = _rule.replace(/^svg/i, '').trim();
            if (_rule === '') {
              return;
            }
            if (allRules[_rule]) {
              fabric.util.object.extend(allRules[_rule], ruleObj);
            }
            else {
              allRules[_rule] = fabric.util.object.clone(ruleObj);
            }
          });
        });
      }
      return allRules;
    },

    /**
     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
     * @memberOf fabric
     * @param {String} url
     * @param {Function} callback
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [options] Object containing options for parsing
     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
     */
    loadSVGFromURL: function(url, callback, reviver, options) {

      url = url.replace(/^\n\s*/, '').trim();
      new fabric.util.request(url, {
        method: 'get',
        onComplete: onComplete
      });

      function onComplete(r) {

        var xml = r.responseXML;
        if (xml && !xml.documentElement && fabric.window.ActiveXObject && r.responseText) {
          xml = new ActiveXObject('Microsoft.XMLDOM');
          xml.async = 'false';
          //IE chokes on DOCTYPE
          xml.loadXML(r.responseText.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
        }
        if (!xml || !xml.documentElement) {
          callback && callback(null);
          return false;
        }

        fabric.parseSVGDocument(xml.documentElement, function (results, _options, elements, allElements) {
          callback && callback(results, _options, elements, allElements);
        }, reviver, options);
      }
    },

    /**
     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
     * @memberOf fabric
     * @param {String} string
     * @param {Function} callback
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [options] Object containing options for parsing
     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
     */
    loadSVGFromString: function(string, callback, reviver, options) {
      string = string.trim();
      var doc;
      if (typeof DOMParser !== 'undefined') {
        var parser = new DOMParser();
        if (parser && parser.parseFromString) {
          doc = parser.parseFromString(string, 'text/xml');
        }
      }
      else if (fabric.window.ActiveXObject) {
        doc = new ActiveXObject('Microsoft.XMLDOM');
        doc.async = 'false';
        // IE chokes on DOCTYPE
        doc.loadXML(string.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
      }

      fabric.parseSVGDocument(doc.documentElement, function (results, _options, elements, allElements) {
        callback(results, _options, elements, allElements);
      }, reviver, options);
    }
  });

})( true ? exports : undefined);


fabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions) {
  this.elements = elements;
  this.callback = callback;
  this.options = options;
  this.reviver = reviver;
  this.svgUid = (options && options.svgUid) || 0;
  this.parsingOptions = parsingOptions;
  this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g;
};

(function(proto) {
  proto.parse = function() {
    this.instances = new Array(this.elements.length);
    this.numElements = this.elements.length;
    this.createObjects();
  };

  proto.createObjects = function() {
    var _this = this;
    this.elements.forEach(function(element, i) {
      element.setAttribute('svgUid', _this.svgUid);
      _this.createObject(element, i);
    });
  };

  proto.findTag = function(el) {
    return fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];
  };

  proto.createObject = function(el, index) {
    var klass = this.findTag(el);
    if (klass && klass.fromElement) {
      try {
        klass.fromElement(el, this.createCallback(index, el), this.options);
      }
      catch (err) {
        fabric.log(err);
      }
    }
    else {
      this.checkIfDone();
    }
  };

  proto.createCallback = function(index, el) {
    var _this = this;
    return function(obj) {
      var _options;
      _this.resolveGradient(obj, 'fill');
      _this.resolveGradient(obj, 'stroke');
      if (obj instanceof fabric.Image && obj._originalElement) {
        _options = obj.parsePreserveAspectRatioAttribute(el);
      }
      obj._removeTransformMatrix(_options);
      _this.resolveClipPath(obj);
      _this.reviver && _this.reviver(el, obj);
      _this.instances[index] = obj;
      _this.checkIfDone();
    };
  };

  proto.extractPropertyDefinition = function(obj, property, storage) {
    var value = obj[property];
    if (!(/^url\(/).test(value)) {
      return;
    }
    var id = this.regexUrl.exec(value)[1];
    this.regexUrl.lastIndex = 0;
    return fabric[storage][this.svgUid][id];
  };

  proto.resolveGradient = function(obj, property) {
    var gradientDef = this.extractPropertyDefinition(obj, property, 'gradientDefs');
    if (gradientDef) {
      obj.set(property, fabric.Gradient.fromElement(gradientDef, obj));
    }
  };

  proto.createClipPathCallback = function(obj, container) {
    return function(_newObj) {
      _newObj._removeTransformMatrix();
      _newObj.fillRule = _newObj.clipRule;
      container.push(_newObj);
    };
  };

  proto.resolveClipPath = function(obj) {
    var clipPath = this.extractPropertyDefinition(obj, 'clipPath', 'clipPaths'),
        element, klass, objTransformInv, container, gTransform, options;
    if (clipPath) {
      container = [];
      objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());
      for (var i = 0; i < clipPath.length; i++) {
        element = clipPath[i];
        klass = this.findTag(element);
        klass.fromElement(
          element,
          this.createClipPathCallback(obj, container),
          this.options
        );
      }
      if (container.length === 1) {
        clipPath = container[0];
      }
      else {
        clipPath = new fabric.Group(container);
      }
      gTransform = fabric.util.multiplyTransformMatrices(
        objTransformInv,
        clipPath.calcTransformMatrix()
      );
      var options = fabric.util.qrDecompose(gTransform);
      clipPath.flipX = false;
      clipPath.flipY = false;
      clipPath.set('scaleX', options.scaleX);
      clipPath.set('scaleY', options.scaleY);
      clipPath.angle = options.angle;
      clipPath.skewX = options.skewX;
      clipPath.skewY = 0;
      clipPath.setPositionByOrigin({ x: options.translateX, y: options.translateY }, 'center', 'center');
      obj.clipPath = clipPath;
    }
  };

  proto.checkIfDone = function() {
    if (--this.numElements === 0) {
      this.instances = this.instances.filter(function(el) {
        // eslint-disable-next-line no-eq-null, eqeqeq
        return el != null;
      });
      this.callback(this.instances, this.elements);
    }
  };
})(fabric.ElementsParser.prototype);


(function(global) {

  'use strict';

  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Point) {
    fabric.warn('fabric.Point is already defined');
    return;
  }

  fabric.Point = Point;

  /**
   * Point class
   * @class fabric.Point
   * @memberOf fabric
   * @constructor
   * @param {Number} x
   * @param {Number} y
   * @return {fabric.Point} thisArg
   */
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  Point.prototype = /** @lends fabric.Point.prototype */ {

    type: 'point',

    constructor: Point,

    /**
     * Adds another point to this one and returns another one
     * @param {fabric.Point} that
     * @return {fabric.Point} new Point instance with added values
     */
    add: function (that) {
      return new Point(this.x + that.x, this.y + that.y);
    },

    /**
     * Adds another point to this one
     * @param {fabric.Point} that
     * @return {fabric.Point} thisArg
     * @chainable
     */
    addEquals: function (that) {
      this.x += that.x;
      this.y += that.y;
      return this;
    },

    /**
     * Adds value to this point and returns a new one
     * @param {Number} scalar
     * @return {fabric.Point} new Point with added value
     */
    scalarAdd: function (scalar) {
      return new Point(this.x + scalar, this.y + scalar);
    },

    /**
     * Adds value to this point
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    scalarAddEquals: function (scalar) {
      this.x += scalar;
      this.y += scalar;
      return this;
    },

    /**
     * Subtracts another point from this point and returns a new one
     * @param {fabric.Point} that
     * @return {fabric.Point} new Point object with subtracted values
     */
    subtract: function (that) {
      return new Point(this.x - that.x, this.y - that.y);
    },

    /**
     * Subtracts another point from this point
     * @param {fabric.Point} that
     * @return {fabric.Point} thisArg
     * @chainable
     */
    subtractEquals: function (that) {
      this.x -= that.x;
      this.y -= that.y;
      return this;
    },

    /**
     * Subtracts value from this point and returns a new one
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    scalarSubtract: function (scalar) {
      return new Point(this.x - scalar, this.y - scalar);
    },

    /**
     * Subtracts value from this point
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    scalarSubtractEquals: function (scalar) {
      this.x -= scalar;
      this.y -= scalar;
      return this;
    },

    /**
     * Multiplies this point by a value and returns a new one
     * TODO: rename in scalarMultiply in 2.0
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    multiply: function (scalar) {
      return new Point(this.x * scalar, this.y * scalar);
    },

    /**
     * Multiplies this point by a value
     * TODO: rename in scalarMultiplyEquals in 2.0
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    multiplyEquals: function (scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    },

    /**
     * Divides this point by a value and returns a new one
     * TODO: rename in scalarDivide in 2.0
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    divide: function (scalar) {
      return new Point(this.x / scalar, this.y / scalar);
    },

    /**
     * Divides this point by a value
     * TODO: rename in scalarDivideEquals in 2.0
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    divideEquals: function (scalar) {
      this.x /= scalar;
      this.y /= scalar;
      return this;
    },

    /**
     * Returns true if this point is equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    eq: function (that) {
      return (this.x === that.x && this.y === that.y);
    },

    /**
     * Returns true if this point is less than another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    lt: function (that) {
      return (this.x < that.x && this.y < that.y);
    },

    /**
     * Returns true if this point is less than or equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    lte: function (that) {
      return (this.x <= that.x && this.y <= that.y);
    },

    /**

     * Returns true if this point is greater another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    gt: function (that) {
      return (this.x > that.x && this.y > that.y);
    },

    /**
     * Returns true if this point is greater than or equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    gte: function (that) {
      return (this.x >= that.x && this.y >= that.y);
    },

    /**
     * Returns new point which is the result of linear interpolation with this one and another one
     * @param {fabric.Point} that
     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
     * @return {fabric.Point}
     */
    lerp: function (that, t) {
      if (typeof t === 'undefined') {
        t = 0.5;
      }
      t = Math.max(Math.min(1, t), 0);
      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
    },

    /**
     * Returns distance from this point and another one
     * @param {fabric.Point} that
     * @return {Number}
     */
    distanceFrom: function (that) {
      var dx = this.x - that.x,
          dy = this.y - that.y;
      return Math.sqrt(dx * dx + dy * dy);
    },

    /**
     * Returns the point between this point and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    midPointFrom: function (that) {
      return this.lerp(that);
    },

    /**
     * Returns a new point which is the min of this and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    min: function (that) {
      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
    },

    /**
     * Returns a new point which is the max of this and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    max: function (that) {
      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
    },

    /**
     * Returns string representation of this point
     * @return {String}
     */
    toString: function () {
      return this.x + ',' + this.y;
    },

    /**
     * Sets x/y of this point
     * @param {Number} x
     * @param {Number} y
     * @chainable
     */
    setXY: function (x, y) {
      this.x = x;
      this.y = y;
      return this;
    },

    /**
     * Sets x of this point
     * @param {Number} x
     * @chainable
     */
    setX: function (x) {
      this.x = x;
      return this;
    },

    /**
     * Sets y of this point
     * @param {Number} y
     * @chainable
     */
    setY: function (y) {
      this.y = y;
      return this;
    },

    /**
     * Sets x/y of this point from another point
     * @param {fabric.Point} that
     * @chainable
     */
    setFromPoint: function (that) {
      this.x = that.x;
      this.y = that.y;
      return this;
    },

    /**
     * Swaps x/y of this point and another point
     * @param {fabric.Point} that
     */
    swap: function (that) {
      var x = this.x,
          y = this.y;
      this.x = that.x;
      this.y = that.y;
      that.x = x;
      that.y = y;
    },

    /**
     * return a cloned instance of the point
     * @return {fabric.Point}
     */
    clone: function () {
      return new Point(this.x, this.y);
    }
  };

})( true ? exports : undefined);


(function(global) {

  'use strict';

  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Intersection) {
    fabric.warn('fabric.Intersection is already defined');
    return;
  }

  /**
   * Intersection class
   * @class fabric.Intersection
   * @memberOf fabric
   * @constructor
   */
  function Intersection(status) {
    this.status = status;
    this.points = [];
  }

  fabric.Intersection = Intersection;

  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {

    constructor: Intersection,

    /**
     * Appends a point to intersection
     * @param {fabric.Point} point
     * @return {fabric.Intersection} thisArg
     * @chainable
     */
    appendPoint: function (point) {
      this.points.push(point);
      return this;
    },

    /**
     * Appends points to intersection
     * @param {Array} points
     * @return {fabric.Intersection} thisArg
     * @chainable
     */
    appendPoints: function (points) {
      this.points = this.points.concat(points);
      return this;
    }
  };

  /**
   * Checks if one line intersects another
   * TODO: rename in intersectSegmentSegment
   * @static
   * @param {fabric.Point} a1
   * @param {fabric.Point} a2
   * @param {fabric.Point} b1
   * @param {fabric.Point} b2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
    var result,
        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
    if (uB !== 0) {
      var ua = uaT / uB,
          ub = ubT / uB;
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
        result = new Intersection('Intersection');
        result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
      }
      else {
        result = new Intersection();
      }
    }
    else {
      if (uaT === 0 || ubT === 0) {
        result = new Intersection('Coincident');
      }
      else {
        result = new Intersection('Parallel');
      }
    }
    return result;
  };

  /**
   * Checks if line intersects polygon
   * TODO: rename in intersectSegmentPolygon
   * fix detection of coincident
   * @static
   * @param {fabric.Point} a1
   * @param {fabric.Point} a2
   * @param {Array} points
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
    var result = new Intersection(),
        length = points.length,
        b1, b2, inter, i;

    for (i = 0; i < length; i++) {
      b1 = points[i];
      b2 = points[(i + 1) % length];
      inter = Intersection.intersectLineLine(a1, a2, b1, b2);

      result.appendPoints(inter.points);
    }
    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

  /**
   * Checks if polygon intersects another polygon
   * @static
   * @param {Array} points1
   * @param {Array} points2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
    var result = new Intersection(),
        length = points1.length, i;

    for (i = 0; i < length; i++) {
      var a1 = points1[i],
          a2 = points1[(i + 1) % length],
          inter = Intersection.intersectLinePolygon(a1, a2, points2);

      result.appendPoints(inter.points);
    }
    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

  /**
   * Checks if polygon intersects rectangle
   * @static
   * @param {Array} points
   * @param {fabric.Point} r1
   * @param {fabric.Point} r2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
    var min = r1.min(r2),
        max = r1.max(r2),
        topRight = new fabric.Point(max.x, min.y),
        bottomLeft = new fabric.Point(min.x, max.y),
        inter1 = Intersection.intersectLinePolygon(min, topRight, points),
        inter2 = Intersection.intersectLinePolygon(topRight, max, points),
        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
        result = new Intersection();

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Color) {
    fabric.warn('fabric.Color is already defined.');
    return;
  }

  /**
   * Color class
   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
   *
   * @class fabric.Color
   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list
   * @return {fabric.Color} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
   */
  function Color(color) {
    if (!color) {
      this.setSource([0, 0, 0, 1]);
    }
    else {
      this._tryParsingColor(color);
    }
  }

  fabric.Color = Color;

  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {

    /**
     * @private
     * @param {String|Array} color Color value to parse
     */
    _tryParsingColor: function(color) {
      var source;

      if (color in Color.colorNameMap) {
        color = Color.colorNameMap[color];
      }

      if (color === 'transparent') {
        source = [255, 255, 255, 0];
      }

      if (!source) {
        source = Color.sourceFromHex(color);
      }
      if (!source) {
        source = Color.sourceFromRgb(color);
      }
      if (!source) {
        source = Color.sourceFromHsl(color);
      }
      if (!source) {
        //if color is not recognize let's make black as canvas does
        source = [0, 0, 0, 1];
      }
      if (source) {
        this.setSource(source);
      }
    },

    /**
     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
     * @private
     * @param {Number} r Red color value
     * @param {Number} g Green color value
     * @param {Number} b Blue color value
     * @return {Array} Hsl color
     */
    _rgbToHsl: function(r, g, b) {
      r /= 255; g /= 255; b /= 255;

      var h, s, l,
          max = fabric.util.array.max([r, g, b]),
          min = fabric.util.array.min([r, g, b]);

      l = (max + min) / 2;

      if (max === min) {
        h = s = 0; // achromatic
      }
      else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }

      return [
        Math.round(h * 360),
        Math.round(s * 100),
        Math.round(l * 100)
      ];
    },

    /**
     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
     * @return {Array}
     */
    getSource: function() {
      return this._source;
    },

    /**
     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
     * @param {Array} source
     */
    setSource: function(source) {
      this._source = source;
    },

    /**
     * Returns color representation in RGB format
     * @return {String} ex: rgb(0-255,0-255,0-255)
     */
    toRgb: function() {
      var source = this.getSource();
      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
    },

    /**
     * Returns color representation in RGBA format
     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
     */
    toRgba: function() {
      var source = this.getSource();
      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
    },

    /**
     * Returns color representation in HSL format
     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
     */
    toHsl: function() {
      var source = this.getSource(),
          hsl = this._rgbToHsl(source[0], source[1], source[2]);

      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
    },

    /**
     * Returns color representation in HSLA format
     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
     */
    toHsla: function() {
      var source = this.getSource(),
          hsl = this._rgbToHsl(source[0], source[1], source[2]);

      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
    },

    /**
     * Returns color representation in HEX format
     * @return {String} ex: FF5555
     */
    toHex: function() {
      var source = this.getSource(), r, g, b;

      r = source[0].toString(16);
      r = (r.length === 1) ? ('0' + r) : r;

      g = source[1].toString(16);
      g = (g.length === 1) ? ('0' + g) : g;

      b = source[2].toString(16);
      b = (b.length === 1) ? ('0' + b) : b;

      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
    },

    /**
     * Returns color representation in HEXA format
     * @return {String} ex: FF5555CC
     */
    toHexa: function() {
      var source = this.getSource(), a;

      a = Math.round(source[3] * 255);
      a = a.toString(16);
      a = (a.length === 1) ? ('0' + a) : a;

      return this.toHex() + a.toUpperCase();
    },

    /**
     * Gets value of alpha channel for this color
     * @return {Number} 0-1
     */
    getAlpha: function() {
      return this.getSource()[3];
    },

    /**
     * Sets value of alpha channel for this color
     * @param {Number} alpha Alpha value 0-1
     * @return {fabric.Color} thisArg
     */
    setAlpha: function(alpha) {
      var source = this.getSource();
      source[3] = alpha;
      this.setSource(source);
      return this;
    },

    /**
     * Transforms color to its grayscale representation
     * @return {fabric.Color} thisArg
     */
    toGrayscale: function() {
      var source = this.getSource(),
          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
          currentAlpha = source[3];
      this.setSource([average, average, average, currentAlpha]);
      return this;
    },

    /**
     * Transforms color to its black and white representation
     * @param {Number} threshold
     * @return {fabric.Color} thisArg
     */
    toBlackWhite: function(threshold) {
      var source = this.getSource(),
          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
          currentAlpha = source[3];

      threshold = threshold || 127;

      average = (Number(average) < Number(threshold)) ? 0 : 255;
      this.setSource([average, average, average, currentAlpha]);
      return this;
    },

    /**
     * Overlays color with another color
     * @param {String|fabric.Color} otherColor
     * @return {fabric.Color} thisArg
     */
    overlayWith: function(otherColor) {
      if (!(otherColor instanceof Color)) {
        otherColor = new Color(otherColor);
      }

      var result = [],
          alpha = this.getAlpha(),
          otherAlpha = 0.5,
          source = this.getSource(),
          otherSource = otherColor.getSource(), i;

      for (i = 0; i < 3; i++) {
        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
      }

      result[3] = alpha;
      this.setSource(result);
      return this;
    }
  };

  /**
   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
   * @static
   * @field
   * @memberOf fabric.Color
   */
  // eslint-disable-next-line max-len
  fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i;

  /**
   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))
   * @static
   * @field
   * @memberOf fabric.Color
   */
  fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i;

  /**
   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)
   * @static
   * @field
   * @memberOf fabric.Color
   */
  fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;

  /**
   * Map of the 148 color names with HEX code
   * @static
   * @field
   * @memberOf fabric.Color
   * @see: https://www.w3.org/TR/css3-color/#svg-color
   */
  fabric.Color.colorNameMap = {
    aliceblue:            '#F0F8FF',
    antiquewhite:         '#FAEBD7',
    aqua:                 '#00FFFF',
    aquamarine:           '#7FFFD4',
    azure:                '#F0FFFF',
    beige:                '#F5F5DC',
    bisque:               '#FFE4C4',
    black:                '#000000',
    blanchedalmond:       '#FFEBCD',
    blue:                 '#0000FF',
    blueviolet:           '#8A2BE2',
    brown:                '#A52A2A',
    burlywood:            '#DEB887',
    cadetblue:            '#5F9EA0',
    chartreuse:           '#7FFF00',
    chocolate:            '#D2691E',
    coral:                '#FF7F50',
    cornflowerblue:       '#6495ED',
    cornsilk:             '#FFF8DC',
    crimson:              '#DC143C',
    cyan:                 '#00FFFF',
    darkblue:             '#00008B',
    darkcyan:             '#008B8B',
    darkgoldenrod:        '#B8860B',
    darkgray:             '#A9A9A9',
    darkgrey:             '#A9A9A9',
    darkgreen:            '#006400',
    darkkhaki:            '#BDB76B',
    darkmagenta:          '#8B008B',
    darkolivegreen:       '#556B2F',
    darkorange:           '#FF8C00',
    darkorchid:           '#9932CC',
    darkred:              '#8B0000',
    darksalmon:           '#E9967A',
    darkseagreen:         '#8FBC8F',
    darkslateblue:        '#483D8B',
    darkslategray:        '#2F4F4F',
    darkslategrey:        '#2F4F4F',
    darkturquoise:        '#00CED1',
    darkviolet:           '#9400D3',
    deeppink:             '#FF1493',
    deepskyblue:          '#00BFFF',
    dimgray:              '#696969',
    dimgrey:              '#696969',
    dodgerblue:           '#1E90FF',
    firebrick:            '#B22222',
    floralwhite:          '#FFFAF0',
    forestgreen:          '#228B22',
    fuchsia:              '#FF00FF',
    gainsboro:            '#DCDCDC',
    ghostwhite:           '#F8F8FF',
    gold:                 '#FFD700',
    goldenrod:            '#DAA520',
    gray:                 '#808080',
    grey:                 '#808080',
    green:                '#008000',
    greenyellow:          '#ADFF2F',
    honeydew:             '#F0FFF0',
    hotpink:              '#FF69B4',
    indianred:            '#CD5C5C',
    indigo:               '#4B0082',
    ivory:                '#FFFFF0',
    khaki:                '#F0E68C',
    lavender:             '#E6E6FA',
    lavenderblush:        '#FFF0F5',
    lawngreen:            '#7CFC00',
    lemonchiffon:         '#FFFACD',
    lightblue:            '#ADD8E6',
    lightcoral:           '#F08080',
    lightcyan:            '#E0FFFF',
    lightgoldenrodyellow: '#FAFAD2',
    lightgray:            '#D3D3D3',
    lightgrey:            '#D3D3D3',
    lightgreen:           '#90EE90',
    lightpink:            '#FFB6C1',
    lightsalmon:          '#FFA07A',
    lightseagreen:        '#20B2AA',
    lightskyblue:         '#87CEFA',
    lightslategray:       '#778899',
    lightslategrey:       '#778899',
    lightsteelblue:       '#B0C4DE',
    lightyellow:          '#FFFFE0',
    lime:                 '#00FF00',
    limegreen:            '#32CD32',
    linen:                '#FAF0E6',
    magenta:              '#FF00FF',
    maroon:               '#800000',
    mediumaquamarine:     '#66CDAA',
    mediumblue:           '#0000CD',
    mediumorchid:         '#BA55D3',
    mediumpurple:         '#9370DB',
    mediumseagreen:       '#3CB371',
    mediumslateblue:      '#7B68EE',
    mediumspringgreen:    '#00FA9A',
    mediumturquoise:      '#48D1CC',
    mediumvioletred:      '#C71585',
    midnightblue:         '#191970',
    mintcream:            '#F5FFFA',
    mistyrose:            '#FFE4E1',
    moccasin:             '#FFE4B5',
    navajowhite:          '#FFDEAD',
    navy:                 '#000080',
    oldlace:              '#FDF5E6',
    olive:                '#808000',
    olivedrab:            '#6B8E23',
    orange:               '#FFA500',
    orangered:            '#FF4500',
    orchid:               '#DA70D6',
    palegoldenrod:        '#EEE8AA',
    palegreen:            '#98FB98',
    paleturquoise:        '#AFEEEE',
    palevioletred:        '#DB7093',
    papayawhip:           '#FFEFD5',
    peachpuff:            '#FFDAB9',
    peru:                 '#CD853F',
    pink:                 '#FFC0CB',
    plum:                 '#DDA0DD',
    powderblue:           '#B0E0E6',
    purple:               '#800080',
    rebeccapurple:        '#663399',
    red:                  '#FF0000',
    rosybrown:            '#BC8F8F',
    royalblue:            '#4169E1',
    saddlebrown:          '#8B4513',
    salmon:               '#FA8072',
    sandybrown:           '#F4A460',
    seagreen:             '#2E8B57',
    seashell:             '#FFF5EE',
    sienna:               '#A0522D',
    silver:               '#C0C0C0',
    skyblue:              '#87CEEB',
    slateblue:            '#6A5ACD',
    slategray:            '#708090',
    slategrey:            '#708090',
    snow:                 '#FFFAFA',
    springgreen:          '#00FF7F',
    steelblue:            '#4682B4',
    tan:                  '#D2B48C',
    teal:                 '#008080',
    thistle:              '#D8BFD8',
    tomato:               '#FF6347',
    turquoise:            '#40E0D0',
    violet:               '#EE82EE',
    wheat:                '#F5DEB3',
    white:                '#FFFFFF',
    whitesmoke:           '#F5F5F5',
    yellow:               '#FFFF00',
    yellowgreen:          '#9ACD32'
  };

  /**
   * @private
   * @param {Number} p
   * @param {Number} q
   * @param {Number} t
   * @return {Number}
   */
  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }

  /**
   * Returns new color object, when given a color in RGB format
   * @memberOf fabric.Color
   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)
   * @return {fabric.Color}
   */
  fabric.Color.fromRgb = function(color) {
    return Color.fromSource(Color.sourceFromRgb(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
   * @memberOf fabric.Color
   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)
   * @return {Array} source
   */
  fabric.Color.sourceFromRgb = function(color) {
    var match = color.match(Color.reRGBa);
    if (match) {
      var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),
          g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),
          b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);

      return [
        parseInt(r, 10),
        parseInt(g, 10),
        parseInt(b, 10),
        match[4] ? parseFloat(match[4]) : 1
      ];
    }
  };

  /**
   * Returns new color object, when given a color in RGBA format
   * @static
   * @function
   * @memberOf fabric.Color
   * @param {String} color
   * @return {fabric.Color}
   */
  fabric.Color.fromRgba = Color.fromRgb;

  /**
   * Returns new color object, when given a color in HSL format
   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)
   * @memberOf fabric.Color
   * @return {fabric.Color}
   */
  fabric.Color.fromHsl = function(color) {
    return Color.fromSource(Color.sourceFromHsl(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
   * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
   * @memberOf fabric.Color
   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)
   * @return {Array} source
   * @see http://http://www.w3.org/TR/css3-color/#hsl-color
   */
  fabric.Color.sourceFromHsl = function(color) {
    var match = color.match(Color.reHSLa);
    if (!match) {
      return;
    }

    var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,
        s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),
        l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),
        r, g, b;

    if (s === 0) {
      r = g = b = l;
    }
    else {
      var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,
          p = l * 2 - q;

      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255),
      match[4] ? parseFloat(match[4]) : 1
    ];
  };

  /**
   * Returns new color object, when given a color in HSLA format
   * @static
   * @function
   * @memberOf fabric.Color
   * @param {String} color
   * @return {fabric.Color}
   */
  fabric.Color.fromHsla = Color.fromHsl;

  /**
   * Returns new color object, when given a color in HEX format
   * @static
   * @memberOf fabric.Color
   * @param {String} color Color value ex: FF5555
   * @return {fabric.Color}
   */
  fabric.Color.fromHex = function(color) {
    return Color.fromSource(Color.sourceFromHex(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format
   * @static
   * @memberOf fabric.Color
   * @param {String} color ex: FF5555 or FF5544CC (RGBa)
   * @return {Array} source
   */
  fabric.Color.sourceFromHex = function(color) {
    if (color.match(Color.reHex)) {
      var value = color.slice(color.indexOf('#') + 1),
          isShortNotation = (value.length === 3 || value.length === 4),
          isRGBa = (value.length === 8 || value.length === 4),
          r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),
          g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),
          b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6),
          a = isRGBa ? (isShortNotation ? (value.charAt(3) + value.charAt(3)) : value.substring(6, 8)) : 'FF';

      return [
        parseInt(r, 16),
        parseInt(g, 16),
        parseInt(b, 16),
        parseFloat((parseInt(a, 16) / 255).toFixed(2))
      ];
    }
  };

  /**
   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
   * @static
   * @memberOf fabric.Color
   * @param {Array} source
   * @return {fabric.Color}
   */
  fabric.Color.fromSource = function(source) {
    var oColor = new Color();
    oColor.setSource(source);
    return oColor;
  };

})( true ? exports : undefined);


(function() {

  /* _FROM_SVG_START_ */
  function getColorStop(el) {
    var style = el.getAttribute('style'),
        offset = el.getAttribute('offset') || 0,
        color, colorAlpha, opacity, i;

    // convert percents to absolute values
    offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
    offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
    if (style) {
      var keyValuePairs = style.split(/\s*;\s*/);

      if (keyValuePairs[keyValuePairs.length - 1] === '') {
        keyValuePairs.pop();
      }

      for (i = keyValuePairs.length; i--; ) {

        var split = keyValuePairs[i].split(/\s*:\s*/),
            key = split[0].trim(),
            value = split[1].trim();

        if (key === 'stop-color') {
          color = value;
        }
        else if (key === 'stop-opacity') {
          opacity = value;
        }
      }
    }

    if (!color) {
      color = el.getAttribute('stop-color') || 'rgb(0,0,0)';
    }
    if (!opacity) {
      opacity = el.getAttribute('stop-opacity');
    }

    color = new fabric.Color(color);
    colorAlpha = color.getAlpha();
    opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
    opacity *= colorAlpha;

    return {
      offset: offset,
      color: color.toRgb(),
      opacity: opacity
    };
  }

  function getLinearCoords(el) {
    return {
      x1: el.getAttribute('x1') || 0,
      y1: el.getAttribute('y1') || 0,
      x2: el.getAttribute('x2') || '100%',
      y2: el.getAttribute('y2') || 0
    };
  }

  function getRadialCoords(el) {
    return {
      x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',
      y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',
      r1: 0,
      x2: el.getAttribute('cx') || '50%',
      y2: el.getAttribute('cy') || '50%',
      r2: el.getAttribute('r') || '50%'
    };
  }
  /* _FROM_SVG_END_ */

  var clone = fabric.util.object.clone;

  /**
   * Gradient class
   * @class fabric.Gradient
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}
   * @see {@link fabric.Gradient#initialize} for constructor definition
   */
  fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {

    /**
     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
     * @type Number
     * @default 0
     */
    offsetX: 0,

    /**
     * Vertical offset for aligning gradients coming from SVG when outside pathgroups
     * @type Number
     * @default 0
     */
    offsetY: 0,

    /**
     * Constructor
     * @param {Object} [options] Options object with type, coords, gradientUnits and colorStops
     * @return {fabric.Gradient} thisArg
     */
    initialize: function(options) {
      options || (options = { });

      var coords = { };

      this.id = fabric.Object.__uid++;
      this.type = options.type || 'linear';

      coords = {
        x1: options.coords.x1 || 0,
        y1: options.coords.y1 || 0,
        x2: options.coords.x2 || 0,
        y2: options.coords.y2 || 0
      };

      if (this.type === 'radial') {
        coords.r1 = options.coords.r1 || 0;
        coords.r2 = options.coords.r2 || 0;
      }
      this.coords = coords;
      this.colorStops = options.colorStops.slice();
      if (options.gradientTransform) {
        this.gradientTransform = options.gradientTransform;
      }
      this.offsetX = options.offsetX || this.offsetX;
      this.offsetY = options.offsetY || this.offsetY;
    },

    /**
     * Adds another colorStop
     * @param {Object} colorStop Object with offset and color
     * @return {fabric.Gradient} thisArg
     */
    addColorStop: function(colorStops) {
      for (var position in colorStops) {
        var color = new fabric.Color(colorStops[position]);
        this.colorStops.push({
          offset: parseFloat(position),
          color: color.toRgb(),
          opacity: color.getAlpha()
        });
      }
      return this;
    },

    /**
     * Returns object representation of a gradient
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object}
     */
    toObject: function(propertiesToInclude) {
      var object = {
        type: this.type,
        coords: this.coords,
        colorStops: this.colorStops,
        offsetX: this.offsetX,
        offsetY: this.offsetY,
        gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
      };
      fabric.util.populateWithProperties(this, object, propertiesToInclude);

      return object;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of an gradient
     * @param {Object} object Object to create a gradient for
     * @return {String} SVG representation of an gradient (linear/radial)
     */
    toSVG: function(object) {
      var coords = clone(this.coords, true), i, len,
          markup, commonAttributes, colorStops = clone(this.colorStops, true),
          needsSwap = coords.r1 > coords.r2,
          transform = this.gradientTransform ? this.gradientTransform.concat() : fabric.iMatrix.concat(),
          offsetX = object.width / 2 - this.offsetX, offsetY = object.height / 2 - this.offsetY;
      // colorStops must be sorted ascending
      colorStops.sort(function(a, b) {
        return a.offset - b.offset;
      });

      if (object.type === 'path') {
        offsetX -= object.pathOffset.x;
        offsetY -= object.pathOffset.y;
      }

      transform[4] -= offsetX;
      transform[5] -= offsetY;

      commonAttributes = 'id="SVGID_' + this.id +
                     '" gradientUnits="userSpaceOnUse"';
      commonAttributes += ' gradientTransform="matrix(' + transform.join(' ') + ')" ';

      if (this.type === 'linear') {
        markup = [
          '<linearGradient ',
          commonAttributes,
          ' x1="', coords.x1,
          '" y1="', coords.y1,
          '" x2="', coords.x2,
          '" y2="', coords.y2,
          '">\n'
        ];
      }
      else if (this.type === 'radial') {
        // svg radial gradient has just 1 radius. the biggest.
        markup = [
          '<radialGradient ',
          commonAttributes,
          ' cx="', needsSwap ? coords.x1 : coords.x2,
          '" cy="', needsSwap ? coords.y1 : coords.y2,
          '" r="', needsSwap ? coords.r1 : coords.r2,
          '" fx="', needsSwap ? coords.x2 : coords.x1,
          '" fy="', needsSwap ? coords.y2 : coords.y1,
          '">\n'
        ];
      }

      if (this.type === 'radial') {
        if (needsSwap) {
          // svg goes from internal to external radius. if radius are inverted, swap color stops.
          colorStops = colorStops.concat();
          colorStops.reverse();
          for (i = 0, len = colorStops.length; i < len; i++) {
            colorStops[i].offset = 1 - colorStops[i].offset;
          }
        }
        var minRadius = Math.min(coords.r1, coords.r2);
        if (minRadius > 0) {
          // i have to shift all colorStops and add new one in 0.
          var maxRadius = Math.max(coords.r1, coords.r2),
              percentageShift = minRadius / maxRadius;
          for (i = 0, len = colorStops.length; i < len; i++) {
            colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);
          }
        }
      }

      for (i = 0, len = colorStops.length; i < len; i++) {
        var colorStop = colorStops[i];
        markup.push(
          '<stop ',
          'offset="', (colorStop.offset * 100) + '%',
          '" style="stop-color:', colorStop.color,
          (typeof colorStop.opacity !== 'undefined' ? ';stop-opacity: ' + colorStop.opacity : ';'),
          '"/>\n'
        );
      }

      markup.push((this.type === 'linear' ? '</linearGradient>\n' : '</radialGradient>\n'));

      return markup.join('');
    },
    /* _TO_SVG_END_ */

    /**
     * Returns an instance of CanvasGradient
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @return {CanvasGradient}
     */
    toLive: function(ctx) {
      var gradient, coords = fabric.util.object.clone(this.coords), i, len;

      if (!this.type) {
        return;
      }

      if (this.type === 'linear') {
        gradient = ctx.createLinearGradient(
          coords.x1, coords.y1, coords.x2, coords.y2);
      }
      else if (this.type === 'radial') {
        gradient = ctx.createRadialGradient(
          coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);
      }

      for (i = 0, len = this.colorStops.length; i < len; i++) {
        var color = this.colorStops[i].color,
            opacity = this.colorStops[i].opacity,
            offset = this.colorStops[i].offset;

        if (typeof opacity !== 'undefined') {
          color = new fabric.Color(color).setAlpha(opacity).toRgba();
        }
        gradient.addColorStop(offset, color);
      }

      return gradient;
    }
  });

  fabric.util.object.extend(fabric.Gradient, {

    /* _FROM_SVG_START_ */
    /**
     * Returns {@link fabric.Gradient} instance from an SVG element
     * @static
     * @memberOf fabric.Gradient
     * @param {SVGGradientElement} el SVG gradient element
     * @param {fabric.Object} instance
     * @return {fabric.Gradient} Gradient instance
     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
     */
    fromElement: function(el, instance) {
      /**
       *  @example:
       *
       *  <linearGradient id="linearGrad1">
       *    <stop offset="0%" stop-color="white"/>
       *    <stop offset="100%" stop-color="black"/>
       *  </linearGradient>
       *
       *  OR
       *
       *  <linearGradient id="linearGrad2">
       *    <stop offset="0" style="stop-color:rgb(255,255,255)"/>
       *    <stop offset="1" style="stop-color:rgb(0,0,0)"/>
       *  </linearGradient>
       *
       *  OR
       *
       *  <radialGradient id="radialGrad1">
       *    <stop offset="0%" stop-color="white" stop-opacity="1" />
       *    <stop offset="50%" stop-color="black" stop-opacity="0.5" />
       *    <stop offset="100%" stop-color="white" stop-opacity="1" />
       *  </radialGradient>
       *
       *  OR
       *
       *  <radialGradient id="radialGrad2">
       *    <stop offset="0" stop-color="rgb(255,255,255)" />
       *    <stop offset="0.5" stop-color="rgb(0,0,0)" />
       *    <stop offset="1" stop-color="rgb(255,255,255)" />
       *  </radialGradient>
       *
       */

      var colorStopEls = el.getElementsByTagName('stop'),
          type,
          gradientUnits = el.getAttribute('gradientUnits') || 'objectBoundingBox',
          gradientTransform = el.getAttribute('gradientTransform'),
          colorStops = [],
          coords, ellipseMatrix, i;

      if (el.nodeName === 'linearGradient' || el.nodeName === 'LINEARGRADIENT') {
        type = 'linear';
      }
      else {
        type = 'radial';
      }

      if (type === 'linear') {
        coords = getLinearCoords(el);
      }
      else if (type === 'radial') {
        coords = getRadialCoords(el);
      }

      for (i = colorStopEls.length; i--; ) {
        colorStops.push(getColorStop(colorStopEls[i]));
      }

      ellipseMatrix = _convertPercentUnitsToValues(instance, coords, gradientUnits);

      var gradient = new fabric.Gradient({
        type: type,
        coords: coords,
        colorStops: colorStops,
        offsetX: -instance.left,
        offsetY: -instance.top
      });

      if (gradientTransform || ellipseMatrix !== '') {
        gradient.gradientTransform = fabric.parseTransformAttribute((gradientTransform || '') + ellipseMatrix);
      }

      return gradient;
    },
    /* _FROM_SVG_END_ */

    /**
     * Returns {@link fabric.Gradient} instance from its object representation
     * @static
     * @memberOf fabric.Gradient
     * @param {Object} obj
     * @param {Object} [options] Options object
     */
    forObject: function(obj, options) {
      options || (options = { });
      _convertPercentUnitsToValues(obj, options.coords, 'userSpaceOnUse');
      return new fabric.Gradient(options);
    }
  });

  /**
   * @private
   */
  function _convertPercentUnitsToValues(object, options, gradientUnits) {
    var propValue, addFactor = 0, multFactor = 1, ellipseMatrix = '';
    for (var prop in options) {
      if (options[prop] === 'Infinity') {
        options[prop] = 1;
      }
      else if (options[prop] === '-Infinity') {
        options[prop] = 0;
      }
      propValue = parseFloat(options[prop], 10);
      if (typeof options[prop] === 'string' && /^(\d+\.\d+)%|(\d+)%$/.test(options[prop])) {
        multFactor = 0.01;
      }
      else {
        multFactor = 1;
      }
      if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
        multFactor *= gradientUnits === 'objectBoundingBox' ? object.width : 1;
        addFactor = gradientUnits === 'objectBoundingBox' ? object.left || 0 : 0;
      }
      else if (prop === 'y1' || prop === 'y2') {
        multFactor *= gradientUnits === 'objectBoundingBox' ? object.height : 1;
        addFactor = gradientUnits === 'objectBoundingBox' ? object.top || 0 : 0;
      }
      options[prop] = propValue * multFactor + addFactor;
    }
    if (object.type === 'ellipse' &&
        options.r2 !== null &&
        gradientUnits === 'objectBoundingBox' &&
        object.rx !== object.ry) {

      var scaleFactor = object.ry / object.rx;
      ellipseMatrix = ' scale(1, ' + scaleFactor + ')';
      if (options.y1) {
        options.y1 /= scaleFactor;
      }
      if (options.y2) {
        options.y2 /= scaleFactor;
      }
    }
    return ellipseMatrix;
  }
})();


(function() {

  'use strict';

  var toFixed = fabric.util.toFixed;

  /**
   * Pattern class
   * @class fabric.Pattern
   * @see {@link http://fabricjs.com/patterns|Pattern demo}
   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}
   * @see {@link fabric.Pattern#initialize} for constructor definition
   */


  fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {

    /**
     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
     * @type String
     * @default
     */
    repeat: 'repeat',

    /**
     * Pattern horizontal offset from object's left/top corner
     * @type Number
     * @default
     */
    offsetX: 0,

    /**
     * Pattern vertical offset from object's left/top corner
     * @type Number
     * @default
     */
    offsetY: 0,

    /**
     * crossOrigin value (one of "", "anonymous", "use-credentials")
     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
     * @type String
     * @default
     */
    crossOrigin: '',

    /**
     * transform matrix to change the pattern, imported from svgs.
     * @type Array
     * @default
     */
    patternTransform: null,

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @param {Function} [callback] function to invoke after callback init.
     * @return {fabric.Pattern} thisArg
     */
    initialize: function(options, callback) {
      options || (options = { });

      this.id = fabric.Object.__uid++;
      this.setOptions(options);
      if (!options.source || (options.source && typeof options.source !== 'string')) {
        callback && callback(this);
        return;
      }
      // function string
      if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {
        this.source = new Function(fabric.util.getFunctionBody(options.source));
        callback && callback(this);
      }
      else {
        // img src string
        var _this = this;
        this.source = fabric.util.createImage();
        fabric.util.loadImage(options.source, function(img) {
          _this.source = img;
          callback && callback(_this);
        }, null, this.crossOrigin);
      }
    },

    /**
     * Returns object representation of a pattern
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of a pattern instance
     */
    toObject: function(propertiesToInclude) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
          source, object;

      // callback
      if (typeof this.source === 'function') {
        source = String(this.source);
      }
      // <img> element
      else if (typeof this.source.src === 'string') {
        source = this.source.src;
      }
      // <canvas> element
      else if (typeof this.source === 'object' && this.source.toDataURL) {
        source = this.source.toDataURL();
      }

      object = {
        type: 'pattern',
        source: source,
        repeat: this.repeat,
        crossOrigin: this.crossOrigin,
        offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),
        offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),
        patternTransform: this.patternTransform ? this.patternTransform.concat() : null
      };
      fabric.util.populateWithProperties(this, object, propertiesToInclude);

      return object;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of a pattern
     * @param {fabric.Object} object
     * @return {String} SVG representation of a pattern
     */
    toSVG: function(object) {
      var patternSource = typeof this.source === 'function' ? this.source() : this.source,
          patternWidth = patternSource.width / object.width,
          patternHeight = patternSource.height / object.height,
          patternOffsetX = this.offsetX / object.width,
          patternOffsetY = this.offsetY / object.height,
          patternImgSrc = '';
      if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {
        patternHeight = 1;
        if (patternOffsetY) {
          patternHeight += Math.abs(patternOffsetY);
        }
      }
      if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {
        patternWidth = 1;
        if (patternOffsetX) {
          patternWidth += Math.abs(patternOffsetX);
        }

      }
      if (patternSource.src) {
        patternImgSrc = patternSource.src;
      }
      else if (patternSource.toDataURL) {
        patternImgSrc = patternSource.toDataURL();
      }

      return '<pattern id="SVGID_' + this.id +
                    '" x="' + patternOffsetX +
                    '" y="' + patternOffsetY +
                    '" width="' + patternWidth +
                    '" height="' + patternHeight + '">\n' +
               '<image x="0" y="0"' +
                      ' width="' + patternSource.width +
                      '" height="' + patternSource.height +
                      '" xlink:href="' + patternImgSrc +
               '"></image>\n' +
             '</pattern>\n';
    },
    /* _TO_SVG_END_ */

    setOptions: function(options) {
      for (var prop in options) {
        this[prop] = options[prop];
      }
    },

    /**
     * Returns an instance of CanvasPattern
     * @param {CanvasRenderingContext2D} ctx Context to create pattern
     * @return {CanvasPattern}
     */
    toLive: function(ctx) {
      var source = typeof this.source === 'function' ? this.source() : this.source;

      // if the image failed to load, return, and allow rest to continue loading
      if (!source) {
        return '';
      }

      // if an image
      if (typeof source.src !== 'undefined') {
        if (!source.complete) {
          return '';
        }
        if (source.naturalWidth === 0 || source.naturalHeight === 0) {
          return '';
        }
      }
      return ctx.createPattern(source, this.repeat);
    }
  });
})();


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      toFixed = fabric.util.toFixed;

  if (fabric.Shadow) {
    fabric.warn('fabric.Shadow is already defined.');
    return;
  }

  /**
   * Shadow class
   * @class fabric.Shadow
   * @see {@link http://fabricjs.com/shadows|Shadow demo}
   * @see {@link fabric.Shadow#initialize} for constructor definition
   */
  fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {

    /**
     * Shadow color
     * @type String
     * @default
     */
    color: 'rgb(0,0,0)',

    /**
     * Shadow blur
     * @type Number
     */
    blur: 0,

    /**
     * Shadow horizontal offset
     * @type Number
     * @default
     */
    offsetX: 0,

    /**
     * Shadow vertical offset
     * @type Number
     * @default
     */
    offsetY: 0,

    /**
     * Whether the shadow should affect stroke operations
     * @type Boolean
     * @default
     */
    affectStroke: false,

    /**
     * Indicates whether toObject should include default values
     * @type Boolean
     * @default
     */
    includeDefaultValues: true,

    /**
     * Constructor
     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px")
     * @return {fabric.Shadow} thisArg
     */
    initialize: function(options) {

      if (typeof options === 'string') {
        options = this._parseShadow(options);
      }

      for (var prop in options) {
        this[prop] = options[prop];
      }

      this.id = fabric.Object.__uid++;
    },

    /**
     * @private
     * @param {String} shadow Shadow value to parse
     * @return {Object} Shadow object with color, offsetX, offsetY and blur
     */
    _parseShadow: function(shadow) {
      var shadowStr = shadow.trim(),
          offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],
          color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';

      return {
        color: color.trim(),
        offsetX: parseInt(offsetsAndBlur[1], 10) || 0,
        offsetY: parseInt(offsetsAndBlur[2], 10) || 0,
        blur: parseInt(offsetsAndBlur[3], 10) || 0
      };
    },

    /**
     * Returns a string representation of an instance
     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
     * @return {String} Returns CSS3 text-shadow declaration
     */
    toString: function() {
      return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of a shadow
     * @param {fabric.Object} object
     * @return {String} SVG representation of a shadow
     */
    toSVG: function(object) {
      var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
          offset = fabric.util.rotateVector(
            { x: this.offsetX, y: this.offsetY },
            fabric.util.degreesToRadians(-object.angle)),
          BLUR_BOX = 20, color = new fabric.Color(this.color);

      if (object.width && object.height) {
        //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion
        // we add some extra space to filter box to contain the blur ( 20 )
        fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
        fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
      }
      if (object.flipX) {
        offset.x *= -1;
      }
      if (object.flipY) {
        offset.y *= -1;
      }

      return (
        '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" ' +
          'x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" ' + '>\n' +
          '\t<feGaussianBlur in="SourceAlpha" stdDeviation="' +
            toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"></feGaussianBlur>\n' +
          '\t<feOffset dx="' + toFixed(offset.x, NUM_FRACTION_DIGITS) +
          '" dy="' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" ></feOffset>\n' +
          '\t<feFlood flood-color="' + color.toRgb() + '" flood-opacity="' + color.getAlpha() + '"/>\n' +
          '\t<feComposite in2="oBlur" operator="in" />\n' +
          '\t<feMerge>\n' +
            '\t\t<feMergeNode></feMergeNode>\n' +
            '\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n' +
          '\t</feMerge>\n' +
        '</filter>\n');
    },
    /* _TO_SVG_END_ */

    /**
     * Returns object representation of a shadow
     * @return {Object} Object representation of a shadow instance
     */
    toObject: function() {
      if (this.includeDefaultValues) {
        return {
          color: this.color,
          blur: this.blur,
          offsetX: this.offsetX,
          offsetY: this.offsetY,
          affectStroke: this.affectStroke
        };
      }
      var obj = { }, proto = fabric.Shadow.prototype;

      ['color', 'blur', 'offsetX', 'offsetY', 'affectStroke'].forEach(function(prop) {
        if (this[prop] !== proto[prop]) {
          obj[prop] = this[prop];
        }
      }, this);

      return obj;
    }
  });

  /**
   * Regex matching shadow offsetX, offsetY and blur (ex: "2px 2px 10px rgba(0,0,0,0.2)", "rgb(0,255,0) 2px 2px")
   * @static
   * @field
   * @memberOf fabric.Shadow
   */
  // eslint-disable-next-line max-len
  fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/;

})( true ? exports : undefined);


(function () {

  'use strict';

  if (fabric.StaticCanvas) {
    fabric.warn('fabric.StaticCanvas is already defined.');
    return;
  }

  // aliases for faster resolution
  var extend = fabric.util.object.extend,
      getElementOffset = fabric.util.getElementOffset,
      removeFromArray = fabric.util.removeFromArray,
      toFixed = fabric.util.toFixed,
      transformPoint = fabric.util.transformPoint,
      invertTransform = fabric.util.invertTransform,
      getNodeCanvas = fabric.util.getNodeCanvas,
      createCanvasElement = fabric.util.createCanvasElement,

      CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');

  /**
   * Static canvas class
   * @class fabric.StaticCanvas
   * @mixes fabric.Collection
   * @mixes fabric.Observable
   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}
   * @see {@link fabric.StaticCanvas#initialize} for constructor definition
   * @fires before:render
   * @fires after:render
   * @fires canvas:cleared
   * @fires object:added
   * @fires object:removed
   */
  fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Constructor
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(el, options) {
      options || (options = { });
      this.renderAndResetBound = this.renderAndReset.bind(this);
      this.requestRenderAllBound = this.requestRenderAll.bind(this);
      this._initStatic(el, options);
    },

    /**
     * Background color of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
     * @type {(String|fabric.Pattern)}
     * @default
     */
    backgroundColor: '',

    /**
     * Background image of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setBackgroundImage}.
     * <b>Backwards incompatibility note:</b> The "backgroundImageOpacity"
     * and "backgroundImageStretch" properties are deprecated since 1.3.9.
     * Use {@link fabric.Image#opacity}, {@link fabric.Image#width} and {@link fabric.Image#height}.
     * since 2.4.0 image caching is active, please when putting an image as background, add to the
     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
     * vale. As an alternative you can disable image objectCaching
     * @type fabric.Image
     * @default
     */
    backgroundImage: null,

    /**
     * Overlay color of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
     * @since 1.3.9
     * @type {(String|fabric.Pattern)}
     * @default
     */
    overlayColor: '',

    /**
     * Overlay image of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setOverlayImage}.
     * <b>Backwards incompatibility note:</b> The "overlayImageLeft"
     * and "overlayImageTop" properties are deprecated since 1.3.9.
     * Use {@link fabric.Image#left} and {@link fabric.Image#top}.
     * since 2.4.0 image caching is active, please when putting an image as overlay, add to the
     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
     * vale. As an alternative you can disable image objectCaching
     * @type fabric.Image
     * @default
     */
    overlayImage: null,

    /**
     * Indicates whether toObject/toDatalessObject should include default values
     * if set to false, takes precedence over the object value.
     * @type Boolean
     * @default
     */
    includeDefaultValues: true,

    /**
     * Indicates whether objects' state should be saved
     * @type Boolean
     * @default
     */
    stateful: false,

    /**
     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},
     * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.
     * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once
     * since the renders are quequed and executed one per frame.
     * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )
     * Left default to true to do not break documentation and old app, fiddles.
     * @type Boolean
     * @default
     */
    renderOnAddRemove: true,

    /**
     * Function that determines clipping of entire canvas area
     * Being passed context as first argument.
     * If you are using code minification, ctx argument can be minified/manglied you should use
     * as a workaround `var ctx = arguments[0];` in the function;
     * See clipping canvas area in {@link https://github.com/kangax/fabric.js/wiki/FAQ}
     * @deprecated since 2.0.0
     * @type Function
     * @default
     */
    clipTo: null,

    /**
     * Indicates whether object controls (borders/controls) are rendered above overlay image
     * @type Boolean
     * @default
     */
    controlsAboveOverlay: false,

    /**
     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
     * @type Boolean
     * @default
     */
    allowTouchScrolling: false,

    /**
     * Indicates whether this canvas will use image smoothing, this is on by default in browsers
     * @type Boolean
     * @default
     */
    imageSmoothingEnabled: true,

    /**
     * The transformation (in the format of Canvas transform) which focuses the viewport
     * @type Array
     * @default
     */
    viewportTransform: fabric.iMatrix.concat(),

    /**
     * if set to false background image is not affected by viewport transform
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    backgroundVpt: true,

    /**
     * if set to false overlya image is not affected by viewport transform
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    overlayVpt: true,

    /**
     * Callback; invoked right before object is about to be scaled/rotated
     * @deprecated since 2.3.0
     * Use before:transform event
     */
    onBeforeScaleRotate: function () {
      /* NOOP */
    },

    /**
     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
     * @type Boolean
     * @default
     */
    enableRetinaScaling: true,

    /**
     * Describe canvas element extension over design
     * properties are tl,tr,bl,br.
     * if canvas is not zoomed/panned those points are the four corner of canvas
     * if canvas is viewportTransformed you those points indicate the extension
     * of canvas element in plain untrasformed coordinates
     * The coordinates get updated with @method calcViewportBoundaries.
     * @memberOf fabric.StaticCanvas.prototype
     */
    vptCoords: { },

    /**
     * Based on vptCoords and object.aCoords, skip rendering of objects that
     * are not included in current viewport.
     * May greatly help in applications with crowded canvas and use of zoom/pan
     * If One of the corner of the bounding box of the object is on the canvas
     * the objects get rendered.
     * @memberOf fabric.StaticCanvas.prototype
     * @type Boolean
     * @default
     */
    skipOffscreen: true,

    /**
     * a fabricObject that, without stroke define a clipping area with their shape. filled in black
     * the clipPath object gets used when the canvas has rendered, and the context is placed in the
     * top left corner of the canvas.
     * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true
     * @type fabric.Object
     */
    clipPath: undefined,

    /**
     * @private
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     */
    _initStatic: function(el, options) {
      var cb = this.requestRenderAllBound;
      this._objects = [];
      this._createLowerCanvas(el);
      this._initOptions(options);
      this._setImageSmoothing();
      // only initialize retina scaling once
      if (!this.interactive) {
        this._initRetinaScaling();
      }

      if (options.overlayImage) {
        this.setOverlayImage(options.overlayImage, cb);
      }
      if (options.backgroundImage) {
        this.setBackgroundImage(options.backgroundImage, cb);
      }
      if (options.backgroundColor) {
        this.setBackgroundColor(options.backgroundColor, cb);
      }
      if (options.overlayColor) {
        this.setOverlayColor(options.overlayColor, cb);
      }
      this.calcOffset();
    },

    /**
     * @private
     */
    _isRetinaScaling: function() {
      return (fabric.devicePixelRatio !== 1 && this.enableRetinaScaling);
    },

    /**
     * @private
     * @return {Number} retinaScaling if applied, otherwise 1;
     */
    getRetinaScaling: function() {
      return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;
    },

    /**
     * @private
     */
    _initRetinaScaling: function() {
      if (!this._isRetinaScaling()) {
        return;
      }
      this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);
      this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);

      this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);
    },

    /**
     * Calculates canvas element offset relative to the document
     * This method is also attached as "resize" event handler of window
     * @return {fabric.Canvas} instance
     * @chainable
     */
    calcOffset: function () {
      this._offset = getElementOffset(this.lowerCanvasEl);
      return this;
    },

    /**
     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
     * @param {Function} callback callback to invoke when image is loaded and set as an overlay
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
     * @example <caption>Normal overlayImage with left/top = 0</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   // Needed to position overlayImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>overlayImage with different properties</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img) {
     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
     * });
     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   width: canvas.width,
     *   height: canvas.height,
     *   // Needed to position overlayImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>overlayImage loaded from cross-origin</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top',
     *   crossOrigin: 'anonymous'
     * });
     */
    setOverlayImage: function (image, callback, options) {
      return this.__setBgOverlayImage('overlayImage', image, callback, options);
    },

    /**
     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
     * @param {Function} callback Callback to invoke when image is loaded and set as background
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}
     * @example <caption>Normal backgroundImage with left/top = 0</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   // Needed to position backgroundImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>backgroundImage with different properties</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img) {
     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
     * });
     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   width: canvas.width,
     *   height: canvas.height,
     *   // Needed to position backgroundImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>backgroundImage loaded from cross-origin</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top',
     *   crossOrigin: 'anonymous'
     * });
     */
    // TODO: fix stretched examples
    setBackgroundImage: function (image, callback, options) {
      return this.__setBgOverlayImage('backgroundImage', image, callback, options);
    },

    /**
     * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas
     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to
     * @param {Function} callback Callback to invoke when foreground color is set
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
     * @example <caption>Normal overlayColor - color value</caption>
     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as overlayColor</caption>
     * canvas.setOverlayColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
     * }, canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
     * canvas.setOverlayColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
     *   repeat: 'repeat',
     *   offsetX: 200,
     *   offsetY: 100
     * }, canvas.renderAll.bind(canvas));
     */
    setOverlayColor: function(overlayColor, callback) {
      return this.__setBgOverlayColor('overlayColor', overlayColor, callback);
    },

    /**
     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
     * @param {Function} callback Callback to invoke when background color is set
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
     * @example <caption>Normal backgroundColor - color value</caption>
     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as backgroundColor</caption>
     * canvas.setBackgroundColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
     * }, canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
     * canvas.setBackgroundColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
     *   repeat: 'repeat',
     *   offsetX: 200,
     *   offsetY: 100
     * }, canvas.renderAll.bind(canvas));
     */
    setBackgroundColor: function(backgroundColor, callback) {
      return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);
    },

    /**
     * @private
     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-imagesmoothingenabled|WhatWG Canvas Standard}
     */
    _setImageSmoothing: function() {
      var ctx = this.getContext();

      ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled
        || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
      ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;
    },

    /**
     * @private
     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
     */
    __setBgOverlayImage: function(property, image, callback, options) {
      if (typeof image === 'string') {
        fabric.util.loadImage(image, function(img) {
          if (img) {
            var instance = new fabric.Image(img, options);
            this[property] = instance;
            instance.canvas = this;
          }
          callback && callback(img);
        }, this, options && options.crossOrigin);
      }
      else {
        options && image.setOptions(options);
        this[property] = image;
        image && (image.canvas = this);
        callback && callback(image);
      }

      return this;
    },

    /**
     * @private
     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
     * @param {(Object|String|null)} color Object with pattern information, color value or null
     * @param {Function} [callback] Callback is invoked when color is set
     */
    __setBgOverlayColor: function(property, color, callback) {
      this[property] = color;
      this._initGradient(color, property);
      this._initPattern(color, property, callback);
      return this;
    },

    /**
     * @private
     */
    _createCanvasElement: function() {
      var element = createCanvasElement();
      if (!element) {
        throw CANVAS_INIT_ERROR;
      }
      if (!element.style) {
        element.style = { };
      }
      if (typeof element.getContext === 'undefined') {
        throw CANVAS_INIT_ERROR;
      }
      return element;
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initOptions: function (options) {
      var lowerCanvasEl = this.lowerCanvasEl;
      this._setOptions(options);

      this.width = this.width || parseInt(lowerCanvasEl.width, 10) || 0;
      this.height = this.height || parseInt(lowerCanvasEl.height, 10) || 0;

      if (!this.lowerCanvasEl.style) {
        return;
      }

      lowerCanvasEl.width = this.width;
      lowerCanvasEl.height = this.height;

      lowerCanvasEl.style.width = this.width + 'px';
      lowerCanvasEl.style.height = this.height + 'px';

      this.viewportTransform = this.viewportTransform.slice();
    },

    /**
     * Creates a bottom canvas
     * @private
     * @param {HTMLElement} [canvasEl]
     */
    _createLowerCanvas: function (canvasEl) {
      // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node
      if (canvasEl && canvasEl.getContext) {
        this.lowerCanvasEl = canvasEl;
      }
      else {
        this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();
      }

      fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');

      if (this.interactive) {
        this._applyCanvasStyle(this.lowerCanvasEl);
      }

      this.contextContainer = this.lowerCanvasEl.getContext('2d');
    },

    /**
     * Returns canvas width (in px)
     * @return {Number}
     */
    getWidth: function () {
      return this.width;
    },

    /**
     * Returns canvas height (in px)
     * @return {Number}
     */
    getHeight: function () {
      return this.height;
    },

    /**
     * Sets width of this canvas instance
     * @param {Number|String} value                         Value to set width to
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setWidth: function (value, options) {
      return this.setDimensions({ width: value }, options);
    },

    /**
     * Sets height of this canvas instance
     * @param {Number|String} value                         Value to set height to
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setHeight: function (value, options) {
      return this.setDimensions({ height: value }, options);
    },

    /**
     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
     * @param {Object}        dimensions                    Object with width/height properties
     * @param {Number|String} [dimensions.width]            Width of canvas element
     * @param {Number|String} [dimensions.height]           Height of canvas element
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    setDimensions: function (dimensions, options) {
      var cssValue;

      options = options || {};

      for (var prop in dimensions) {
        cssValue = dimensions[prop];

        if (!options.cssOnly) {
          this._setBackstoreDimension(prop, dimensions[prop]);
          cssValue += 'px';
          this.hasLostContext = true;
        }

        if (!options.backstoreOnly) {
          this._setCssDimension(prop, cssValue);
        }
      }
      if (this._isCurrentlyDrawing) {
        this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles();
      }
      this._initRetinaScaling();
      this._setImageSmoothing();
      this.calcOffset();

      if (!options.cssOnly) {
        this.requestRenderAll();
      }

      return this;
    },

    /**
     * Helper for setting width/height
     * @private
     * @param {String} prop property (width|height)
     * @param {Number} value value to set property to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    _setBackstoreDimension: function (prop, value) {
      this.lowerCanvasEl[prop] = value;

      if (this.upperCanvasEl) {
        this.upperCanvasEl[prop] = value;
      }

      if (this.cacheCanvasEl) {
        this.cacheCanvasEl[prop] = value;
      }

      this[prop] = value;

      return this;
    },

    /**
     * Helper for setting css width/height
     * @private
     * @param {String} prop property (width|height)
     * @param {String} value value to set property to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    _setCssDimension: function (prop, value) {
      this.lowerCanvasEl.style[prop] = value;

      if (this.upperCanvasEl) {
        this.upperCanvasEl.style[prop] = value;
      }

      if (this.wrapperEl) {
        this.wrapperEl.style[prop] = value;
      }

      return this;
    },

    /**
     * Returns canvas zoom level
     * @return {Number}
     */
    getZoom: function () {
      return this.viewportTransform[0];
    },

    /**
     * Sets viewport transform of this canvas instance
     * @param {Array} vpt the transform in the form of context.transform
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setViewportTransform: function (vpt) {
      var activeObject = this._activeObject, object, ignoreVpt = false, skipAbsolute = true, i, len;
      this.viewportTransform = vpt;
      for (i = 0, len = this._objects.length; i < len; i++) {
        object = this._objects[i];
        object.group || object.setCoords(ignoreVpt, skipAbsolute);
      }
      if (activeObject && activeObject.type === 'activeSelection') {
        activeObject.setCoords(ignoreVpt, skipAbsolute);
      }
      this.calcViewportBoundaries();
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Sets zoom level of this canvas instance, zoom centered around point
     * @param {fabric.Point} point to zoom with respect to
     * @param {Number} value to set zoom to, less than 1 zooms out
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    zoomToPoint: function (point, value) {
      // TODO: just change the scale, preserve other transformations
      var before = point, vpt = this.viewportTransform.slice(0);
      point = transformPoint(point, invertTransform(this.viewportTransform));
      vpt[0] = value;
      vpt[3] = value;
      var after = transformPoint(point, vpt);
      vpt[4] += before.x - after.x;
      vpt[5] += before.y - after.y;
      return this.setViewportTransform(vpt);
    },

    /**
     * Sets zoom level of this canvas instance
     * @param {Number} value to set zoom to, less than 1 zooms out
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setZoom: function (value) {
      this.zoomToPoint(new fabric.Point(0, 0), value);
      return this;
    },

    /**
     * Pan viewport so as to place point at top left corner of canvas
     * @param {fabric.Point} point to move to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    absolutePan: function (point) {
      var vpt = this.viewportTransform.slice(0);
      vpt[4] = -point.x;
      vpt[5] = -point.y;
      return this.setViewportTransform(vpt);
    },

    /**
     * Pans viewpoint relatively
     * @param {fabric.Point} point (position vector) to move by
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    relativePan: function (point) {
      return this.absolutePan(new fabric.Point(
        -point.x - this.viewportTransform[4],
        -point.y - this.viewportTransform[5]
      ));
    },

    /**
     * Returns &lt;canvas> element corresponding to this instance
     * @return {HTMLCanvasElement}
     */
    getElement: function () {
      return this.lowerCanvasEl;
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was added
     */
    _onObjectAdded: function(obj) {
      this.stateful && obj.setupState();
      obj._set('canvas', this);
      obj.setCoords();
      this.fire('object:added', { target: obj });
      obj.fire('added');
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was removed
     */
    _onObjectRemoved: function(obj) {
      this.fire('object:removed', { target: obj });
      obj.fire('removed');
      delete obj.canvas;
    },

    /**
     * Clears specified context of canvas element
     * @param {CanvasRenderingContext2D} ctx Context to clear
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clearContext: function(ctx) {
      ctx.clearRect(0, 0, this.width, this.height);
      return this;
    },

    /**
     * Returns context of canvas where objects are drawn
     * @return {CanvasRenderingContext2D}
     */
    getContext: function () {
      return this.contextContainer;
    },

    /**
     * Clears all contexts (background, main, top) of an instance
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clear: function () {
      this._objects.length = 0;
      this.backgroundImage = null;
      this.overlayImage = null;
      this.backgroundColor = '';
      this.overlayColor = '';
      if (this._hasITextHandlers) {
        this.off('mouse:up', this._mouseUpITextHandler);
        this._iTextInstances = null;
        this._hasITextHandlers = false;
      }
      this.clearContext(this.contextContainer);
      this.fire('canvas:cleared');
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Renders the canvas
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAll: function () {
      var canvasToDrawOn = this.contextContainer;
      this.renderCanvas(canvasToDrawOn, this._objects);
      return this;
    },

    /**
     * Function created to be instance bound at initialization
     * used in requestAnimationFrame rendering
     * Let the fabricJS call it. If you call it manually you could have more
     * animationFrame stacking on to of each other
     * for an imperative rendering, use canvas.renderAll
     * @private
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAndReset: function() {
      this.isRendering = 0;
      this.renderAll();
    },

    /**
     * Append a renderAll request to next animation frame.
     * unless one is already in progress, in that case nothing is done
     * a boolean flag will avoid appending more.
     * @return {fabric.Canvas} instance
     * @chainable
     */
    requestRenderAll: function () {
      if (!this.isRendering) {
        this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);
      }
      return this;
    },

    /**
     * Calculate the position of the 4 corner of canvas with current viewportTransform.
     * helps to determinate when an object is in the current rendering viewport using
     * object absolute coordinates ( aCoords )
     * @return {Object} points.tl
     * @chainable
     */
    calcViewportBoundaries: function() {
      var points = { }, width = this.width, height = this.height,
          iVpt = invertTransform(this.viewportTransform);
      points.tl = transformPoint({ x: 0, y: 0 }, iVpt);
      points.br = transformPoint({ x: width, y: height }, iVpt);
      points.tr = new fabric.Point(points.br.x, points.tl.y);
      points.bl = new fabric.Point(points.tl.x, points.br.y);
      this.vptCoords = points;
      return points;
    },

    cancelRequestedRender: function() {
      if (this.isRendering) {
        fabric.util.cancelAnimFrame(this.isRendering);
        this.isRendering = 0;
      }
    },

    /**
     * Renders background, objects, overlay and controls.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Array} objects to render
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderCanvas: function(ctx, objects) {
      var v = this.viewportTransform, path = this.clipPath;
      this.cancelRequestedRender();
      this.calcViewportBoundaries();
      this.clearContext(ctx);
      this.fire('before:render', { ctx: ctx, });
      if (this.clipTo) {
        fabric.util.clipContext(this, ctx);
      }
      this._renderBackground(ctx);

      ctx.save();
      //apply viewport transform once for all rendering process
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      this._renderObjects(ctx, objects);
      ctx.restore();
      if (!this.controlsAboveOverlay && this.interactive) {
        this.drawControls(ctx);
      }
      if (this.clipTo) {
        ctx.restore();
      }
      if (path) {
        path.canvas = this;
        // needed to setup a couple of variables
        path.shouldCache();
        path._transformDone = true;
        path.renderCache({ forClipping: true });
        this.drawClipPathOnCanvas(ctx);
      }
      this._renderOverlay(ctx);
      if (this.controlsAboveOverlay && this.interactive) {
        this.drawControls(ctx);
      }
      this.fire('after:render', { ctx: ctx, });
    },

    /**
     * Paint the cached clipPath on the lowerCanvasEl
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawClipPathOnCanvas: function(ctx) {
      var v = this.viewportTransform, path = this.clipPath;
      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      // DEBUG: uncomment this line, comment the following
      // ctx.globalAlpha = 0.4;
      ctx.globalCompositeOperation = 'destination-in';
      path.transform(ctx);
      ctx.scale(1 / path.zoomX, 1 / path.zoomY);
      ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Array} objects to render
     */
    _renderObjects: function(ctx, objects) {
      var i, len;
      for (i = 0, len = objects.length; i < len; ++i) {
        objects[i] && objects[i].render(ctx);
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {string} property 'background' or 'overlay'
     */
    _renderBackgroundOrOverlay: function(ctx, property) {
      var object = this[property + 'Color'], v;
      if (object) {
        ctx.fillStyle = object.toLive
          ? object.toLive(ctx, this)
          : object;

        ctx.fillRect(
          object.offsetX || 0,
          object.offsetY || 0,
          this.width,
          this.height);
      }
      object = this[property + 'Image'];
      if (object) {
        if (this[property + 'Vpt']) {
          v = this.viewportTransform;
          ctx.save();
          ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        }
        object.render(ctx);
        this[property + 'Vpt'] && ctx.restore();
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderBackground: function(ctx) {
      this._renderBackgroundOrOverlay(ctx, 'background');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderOverlay: function(ctx) {
      this._renderBackgroundOrOverlay(ctx, 'overlay');
    },

    /**
     * Returns coordinates of a center of canvas.
     * Returned value is an object with top and left properties
     * @return {Object} object with "top" and "left" number values
     */
    getCenter: function () {
      return {
        top: this.height / 2,
        left: this.width / 2
      };
    },

    /**
     * Centers object horizontally in the canvas
     * @param {fabric.Object} object Object to center horizontally
     * @return {fabric.Canvas} thisArg
     */
    centerObjectH: function (object) {
      return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));
    },

    /**
     * Centers object vertically in the canvas
     * @param {fabric.Object} object Object to center vertically
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    centerObjectV: function (object) {
      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));
    },

    /**
     * Centers object vertically and horizontally in the canvas
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    centerObject: function(object) {
      var center = this.getCenter();

      return this._centerObject(object, new fabric.Point(center.left, center.top));
    },

    /**
     * Centers object vertically and horizontally in the viewport
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObject: function(object) {
      var vpCenter = this.getVpCenter();

      return this._centerObject(object, vpCenter);
    },

    /**
     * Centers object horizontally in the viewport, object.top is unchanged
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObjectH: function(object) {
      var vpCenter = this.getVpCenter();
      this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));
      return this;
    },

    /**
     * Centers object Vertically in the viewport, object.top is unchanged
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObjectV: function(object) {
      var vpCenter = this.getVpCenter();

      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));
    },

    /**
     * Calculate the point in canvas that correspond to the center of actual viewport.
     * @return {fabric.Point} vpCenter, viewport center
     * @chainable
     */
    getVpCenter: function() {
      var center = this.getCenter(),
          iVpt = invertTransform(this.viewportTransform);
      return transformPoint({ x: center.left, y: center.top }, iVpt);
    },

    /**
     * @private
     * @param {fabric.Object} object Object to center
     * @param {fabric.Point} center Center point
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    _centerObject: function(object, center) {
      object.setPositionByOrigin(center, 'center', 'center');
      object.setCoords();
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Returs dataless JSON representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {String} json string
     */
    toDatalessJSON: function (propertiesToInclude) {
      return this.toDatalessObject(propertiesToInclude);
    },

    /**
     * Returns object representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function (propertiesToInclude) {
      return this._toObjectMethod('toObject', propertiesToInclude);
    },

    /**
     * Returns dataless object representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function (propertiesToInclude) {
      return this._toObjectMethod('toDatalessObject', propertiesToInclude);
    },

    /**
     * @private
     */
    _toObjectMethod: function (methodName, propertiesToInclude) {

      var clipPath = this.clipPath, data = {
        version: fabric.version,
        objects: this._toObjects(methodName, propertiesToInclude),
      };
      if (clipPath) {
        data.clipPath = this._toObjectMethod(clipPath, methodName, propertiesToInclude);
      }
      extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));

      fabric.util.populateWithProperties(this, data, propertiesToInclude);

      return data;
    },

    /**
     * @private
     */
    _toObjects: function(methodName, propertiesToInclude) {
      return this._objects.filter(function(object) {
        return !object.excludeFromExport;
      }).map(function(instance) {
        return this._toObject(instance, methodName, propertiesToInclude);
      }, this);
    },

    /**
     * @private
     */
    _toObject: function(instance, methodName, propertiesToInclude) {
      var originalValue;

      if (!this.includeDefaultValues) {
        originalValue = instance.includeDefaultValues;
        instance.includeDefaultValues = false;
      }

      var object = instance[methodName](propertiesToInclude);
      if (!this.includeDefaultValues) {
        instance.includeDefaultValues = originalValue;
      }
      return object;
    },

    /**
     * @private
     */
    __serializeBgOverlay: function(methodName, propertiesToInclude) {
      var data = { }, bgImage = this.backgroundImage, overlay = this.overlayImage;

      if (this.backgroundColor) {
        data.background = this.backgroundColor.toObject
          ? this.backgroundColor.toObject(propertiesToInclude)
          : this.backgroundColor;
      }

      if (this.overlayColor) {
        data.overlay = this.overlayColor.toObject
          ? this.overlayColor.toObject(propertiesToInclude)
          : this.overlayColor;
      }
      if (bgImage && !bgImage.excludeFromExport) {
        data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);
      }
      if (overlay && !overlay.excludeFromExport) {
        data.overlayImage = this._toObject(overlay, methodName, propertiesToInclude);
      }

      return data;
    },

    /* _TO_SVG_START_ */
    /**
     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
     * a zoomed canvas will then produce zoomed SVG output.
     * @type Boolean
     * @default
     */
    svgViewportTransformation: true,

    /**
     * Returns SVG representation of canvas
     * @function
     * @param {Object} [options] Options object for SVG output
     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
     * @param {Object} [options.viewBox] SVG viewbox object
     * @param {Number} [options.viewBox.x] x-cooridnate of viewbox
     * @param {Number} [options.viewBox.y] y-coordinate of viewbox
     * @param {Number} [options.viewBox.width] Width of viewbox
     * @param {Number} [options.viewBox.height] Height of viewbox
     * @param {String} [options.encoding=UTF-8] Encoding of SVG output
     * @param {String} [options.width] desired width of svg with or without units
     * @param {String} [options.height] desired height of svg with or without units
     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
     * @return {String} SVG string
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
     * @example <caption>Normal SVG output</caption>
     * var svg = canvas.toSVG();
     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
     * var svg = canvas.toSVG({suppressPreamble: true});
     * @example <caption>SVG output with viewBox attribute</caption>
     * var svg = canvas.toSVG({
     *   viewBox: {
     *     x: 100,
     *     y: 100,
     *     width: 200,
     *     height: 300
     *   }
     * });
     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
     * @example <caption>Modify SVG output with reviver function</caption>
     * var svg = canvas.toSVG(null, function(svg) {
     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
     * });
     */
    toSVG: function(options, reviver) {
      options || (options = { });
      options.reviver = reviver;
      var markup = [];

      this._setSVGPreamble(markup, options);
      this._setSVGHeader(markup, options);
      if (this.clipPath) {
        markup.push('<g clip-path="url(#' + this.clipPath.clipPathId + ')" >\n');
      }
      this._setSVGBgOverlayColor(markup, 'backgroundColor');
      this._setSVGBgOverlayImage(markup, 'backgroundImage', reviver);
      this._setSVGObjects(markup, reviver);
      if (this.clipPath) {
        markup.push('</g>\n');
      }
      this._setSVGBgOverlayColor(markup, 'overlayColor');
      this._setSVGBgOverlayImage(markup, 'overlayImage', reviver);

      markup.push('</svg>');

      return markup.join('');
    },

    /**
     * @private
     */
    _setSVGPreamble: function(markup, options) {
      if (options.suppressPreamble) {
        return;
      }
      markup.push(
        '<?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?>\n',
        '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
        '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
      );
    },

    /**
     * @private
     */
    _setSVGHeader: function(markup, options) {
      var width = options.width || this.width,
          height = options.height || this.height,
          vpt, viewBox = 'viewBox="0 0 ' + this.width + ' ' + this.height + '" ',
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

      if (options.viewBox) {
        viewBox = 'viewBox="' +
                options.viewBox.x + ' ' +
                options.viewBox.y + ' ' +
                options.viewBox.width + ' ' +
                options.viewBox.height + '" ';
      }
      else {
        if (this.svgViewportTransformation) {
          vpt = this.viewportTransform;
          viewBox = 'viewBox="' +
                  toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';
        }
      }

      markup.push(
        '<svg ',
        'xmlns="http://www.w3.org/2000/svg" ',
        'xmlns:xlink="http://www.w3.org/1999/xlink" ',
        'version="1.1" ',
        'width="', width, '" ',
        'height="', height, '" ',
        viewBox,
        'xml:space="preserve">\n',
        '<desc>Created with Fabric.js ', fabric.version, '</desc>\n',
        '<defs>\n',
        this.createSVGFontFacesMarkup(),
        this.createSVGRefElementsMarkup(),
        this.createSVGClipPathMarkup(options),
        '</defs>\n'
      );
    },

    createSVGClipPathMarkup: function(options) {
      var clipPath = this.clipPath;
      if (clipPath) {
        clipPath.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
        return  '<clipPath id="' + clipPath.clipPathId + '" >\n' +
          this.clipPath.toClipPathSVG(options.reviver) +
          '</clipPath>\n';
      }
      return '';
    },

    /**
     * Creates markup containing SVG referenced elements like patterns, gradients etc.
     * @return {String}
     */
    createSVGRefElementsMarkup: function() {
      var _this = this,
          markup = ['backgroundColor', 'overlayColor'].map(function(prop) {
            var fill = _this[prop];
            if (fill && fill.toLive) {
              return fill.toSVG(_this, false);
            }
          });
      return markup.join('');
    },

    /**
     * Creates markup containing SVG font faces,
     * font URLs for font faces must be collected by developers
     * and are not extracted from the DOM by fabricjs
     * @param {Array} objects Array of fabric objects
     * @return {String}
     */
    createSVGFontFacesMarkup: function() {
      var markup = '', fontList = { }, obj, fontFamily,
          style, row, rowIndex, _char, charIndex, i, len,
          fontPaths = fabric.fontPaths, objects = this._objects;

      for (i = 0, len = objects.length; i < len; i++) {
        obj = objects[i];
        fontFamily = obj.fontFamily;
        if (obj.type.indexOf('text') === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {
          continue;
        }
        fontList[fontFamily] = true;
        if (!obj.styles) {
          continue;
        }
        style = obj.styles;
        for (rowIndex in style) {
          row = style[rowIndex];
          for (charIndex in row) {
            _char = row[charIndex];
            fontFamily = _char.fontFamily;
            if (!fontList[fontFamily] && fontPaths[fontFamily]) {
              fontList[fontFamily] = true;
            }
          }
        }
      }

      for (var j in fontList) {
        markup += [
          '\t\t@font-face {\n',
          '\t\t\tfont-family: \'', j, '\';\n',
          '\t\t\tsrc: url(\'', fontPaths[j], '\');\n',
          '\t\t}\n'
        ].join('');
      }

      if (markup) {
        markup = [
          '\t<style type="text/css">',
          '<![CDATA[\n',
          markup,
          ']]>',
          '</style>\n'
        ].join('');
      }

      return markup;
    },

    /**
     * @private
     */
    _setSVGObjects: function(markup, reviver) {
      var instance, i, len, objects = this._objects;
      for (i = 0, len = objects.length; i < len; i++) {
        instance = objects[i];
        if (instance.excludeFromExport) {
          continue;
        }
        this._setSVGObject(markup, instance, reviver);
      }
    },

    /**
     * @private
     */
    _setSVGObject: function(markup, instance, reviver) {
      markup.push(instance.toSVG(reviver));
    },

    /**
     * @private
     */
    _setSVGBgOverlayImage: function(markup, property, reviver) {
      if (this[property] && !this[property].excludeFromExport && this[property].toSVG) {
        markup.push(this[property].toSVG(reviver));
      }
    },

    /**
     * @private
     */
    _setSVGBgOverlayColor: function(markup, property) {
      var filler = this[property], vpt = this.viewportTransform, finalWidth = this.width / vpt[0],
          finalHeight = this.height / vpt[3];
      if (!filler) {
        return;
      }
      if (filler.toLive) {
        var repeat = filler.repeat;
        markup.push(
          '<rect transform="translate(', finalWidth / 2, ',', finalHeight / 2, ')"',
          ' x="', filler.offsetX - finalWidth / 2, '" y="', filler.offsetY - finalHeight / 2, '" ',
          'width="',
          (repeat === 'repeat-y' || repeat === 'no-repeat'
            ? filler.source.width
            : finalWidth ),
          '" height="',
          (repeat === 'repeat-x' || repeat === 'no-repeat'
            ? filler.source.height
            : finalHeight),
          '" fill="url(#SVGID_' + filler.id + ')"',
          '></rect>\n'
        );
      }
      else {
        markup.push(
          '<rect x="0" y="0" width="100%" height="100%" ',
          'fill="', this[property], '"',
          '></rect>\n'
        );
      }
    },
    /* _TO_SVG_END_ */

    /**
     * Moves an object or the objects of a multiple selection
     * to the bottom of the stack of drawn objects
     * @param {fabric.Object} object Object to send to back
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    sendToBack: function (object) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, objs;
      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = objs.length; i--;) {
          obj = objs[i];
          removeFromArray(this._objects, obj);
          this._objects.unshift(obj);
        }
      }
      else {
        removeFromArray(this._objects, object);
        this._objects.unshift(object);
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Moves an object or the objects of a multiple selection
     * to the top of the stack of drawn objects
     * @param {fabric.Object} object Object to send
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    bringToFront: function (object) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, objs;
      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = 0; i < objs.length; i++) {
          obj = objs[i];
          removeFromArray(this._objects, obj);
          this._objects.push(obj);
        }
      }
      else {
        removeFromArray(this._objects, object);
        this._objects.push(object);
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Moves an object or a selection down in stack of drawn objects
     * An optional paramter, intersecting allowes to move the object in behind
     * the first intersecting object. Where intersection is calculated with
     * bounding box. If no intersection is found, there will not be change in the
     * stack.
     * @param {fabric.Object} object Object to send
     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    sendBackwards: function (object, intersecting) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, idx, newIdx, objs, objsMoved = 0;

      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = 0; i < objs.length; i++) {
          obj = objs[i];
          idx = this._objects.indexOf(obj);
          if (idx > 0 + objsMoved) {
            newIdx = idx - 1;
            removeFromArray(this._objects, obj);
            this._objects.splice(newIdx, 0, obj);
          }
          objsMoved++;
        }
      }
      else {
        idx = this._objects.indexOf(object);
        if (idx !== 0) {
          // if object is not on the bottom of stack
          newIdx = this._findNewLowerIndex(object, idx, intersecting);
          removeFromArray(this._objects, object);
          this._objects.splice(newIdx, 0, object);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * @private
     */
    _findNewLowerIndex: function(object, idx, intersecting) {
      var newIdx, i;

      if (intersecting) {
        newIdx = idx;

        // traverse down the stack looking for the nearest intersecting object
        for (i = idx - 1; i >= 0; --i) {

          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                               object.isContainedWithinObject(this._objects[i]) ||
                               this._objects[i].isContainedWithinObject(object);

          if (isIntersecting) {
            newIdx = i;
            break;
          }
        }
      }
      else {
        newIdx = idx - 1;
      }

      return newIdx;
    },

    /**
     * Moves an object or a selection up in stack of drawn objects
     * An optional paramter, intersecting allowes to move the object in front
     * of the first intersecting object. Where intersection is calculated with
     * bounding box. If no intersection is found, there will not be change in the
     * stack.
     * @param {fabric.Object} object Object to send
     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    bringForward: function (object, intersecting) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, idx, newIdx, objs, objsMoved = 0;

      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = objs.length; i--;) {
          obj = objs[i];
          idx = this._objects.indexOf(obj);
          if (idx < this._objects.length - 1 - objsMoved) {
            newIdx = idx + 1;
            removeFromArray(this._objects, obj);
            this._objects.splice(newIdx, 0, obj);
          }
          objsMoved++;
        }
      }
      else {
        idx = this._objects.indexOf(object);
        if (idx !== this._objects.length - 1) {
          // if object is not on top of stack (last item in an array)
          newIdx = this._findNewUpperIndex(object, idx, intersecting);
          removeFromArray(this._objects, object);
          this._objects.splice(newIdx, 0, object);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * @private
     */
    _findNewUpperIndex: function(object, idx, intersecting) {
      var newIdx, i, len;

      if (intersecting) {
        newIdx = idx;

        // traverse up the stack looking for the nearest intersecting object
        for (i = idx + 1, len = this._objects.length; i < len; ++i) {

          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                               object.isContainedWithinObject(this._objects[i]) ||
                               this._objects[i].isContainedWithinObject(object);

          if (isIntersecting) {
            newIdx = i;
            break;
          }
        }
      }
      else {
        newIdx = idx + 1;
      }

      return newIdx;
    },

    /**
     * Moves an object to specified level in stack of drawn objects
     * @param {fabric.Object} object Object to send
     * @param {Number} index Position to move to
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    moveTo: function (object, index) {
      removeFromArray(this._objects, object);
      this._objects.splice(index, 0, object);
      return this.renderOnAddRemove && this.requestRenderAll();
    },

    /**
     * Clears a canvas element and dispose objects
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    dispose: function () {
      // cancel eventually ongoing renders
      if (this.isRendering) {
        fabric.util.cancelAnimFrame(this.isRendering);
        this.isRendering = 0;
      }
      this.forEachObject(function(object) {
        object.dispose && object.dispose();
      });
      this._objects = [];
      if (this.backgroundImage && this.backgroundImage.dispose) {
        this.backgroundImage.dispose();
      }
      this.backgroundImage = null;
      if (this.overlayImage && this.overlayImage.dispose) {
        this.overlayImage.dispose();
      }
      this.overlayImage = null;
      this._iTextInstances = null;
      this.contextContainer = null;
      fabric.util.cleanUpJsdomNode(this.lowerCanvasEl);
      this.lowerCanvasEl = undefined;
      return this;
    },

    /**
     * Returns a string representation of an instance
     * @return {String} string representation of an instance
     */
    toString: function () {
      return '#<fabric.Canvas (' + this.complexity() + '): ' +
               '{ objects: ' + this._objects.length + ' }>';
    }
  });

  extend(fabric.StaticCanvas.prototype, fabric.Observable);
  extend(fabric.StaticCanvas.prototype, fabric.Collection);
  extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);

  extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {

    /**
     * @static
     * @type String
     * @default
     */
    EMPTY_JSON: '{"objects": [], "background": "white"}',

    /**
     * Provides a way to check support of some of the canvas methods
     * (either those of HTMLCanvasElement itself, or rendering context)
     *
     * @param {String} methodName Method to check support for;
     *                            Could be one of "setLineDash"
     * @return {Boolean | null} `true` if method is supported (or at least exists),
     *                          `null` if canvas element or context can not be initialized
     */
    supports: function (methodName) {
      var el = createCanvasElement();

      if (!el || !el.getContext) {
        return null;
      }

      var ctx = el.getContext('2d');
      if (!ctx) {
        return null;
      }

      switch (methodName) {

        case 'setLineDash':
          return typeof ctx.setLineDash !== 'undefined';

        default:
          return null;
      }
    }
  });

  /**
   * Returns JSON representation of canvas
   * @function
   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
   * @return {String} JSON string
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}
   * @example <caption>JSON without additional properties</caption>
   * var json = canvas.toJSON();
   * @example <caption>JSON with additional properties included</caption>
   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'lockUniScaling']);
   * @example <caption>JSON without default values</caption>
   * canvas.includeDefaultValues = false;
   * var json = canvas.toJSON();
   */
  fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;

  if (fabric.isLikelyNode) {
    fabric.StaticCanvas.prototype.createPNGStream = function() {
      var impl = getNodeCanvas(this.lowerCanvasEl);
      return impl && impl.createPNGStream();
    };
    fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {
      var impl = getNodeCanvas(this.lowerCanvasEl);
      return impl && impl.createJPEGStream(opts);
    };
  }
})();


/**
 * BaseBrush class
 * @class fabric.BaseBrush
 * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}
 */
fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {

  /**
   * Color of a brush
   * @type String
   * @default
   */
  color: 'rgb(0, 0, 0)',

  /**
   * Width of a brush, has to be a Number, no string literals
   * @type Number
   * @default
   */
  width: 1,

  /**
   * Shadow object representing shadow of this shape.
   * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
   * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
   * @type fabric.Shadow
   * @default
   */
  shadow: null,

  /**
   * Line endings style of a brush (one of "butt", "round", "square")
   * @type String
   * @default
   */
  strokeLineCap: 'round',

  /**
   * Corner style of a brush (one of "bevel", "round", "miter")
   * @type String
   * @default
   */
  strokeLineJoin: 'round',

  /**
   * Maximum miter length (used for strokeLineJoin = "miter") of a brush's
   * @type Number
   * @default
   */
  strokeMiterLimit:         10,

  /**
   * Stroke Dash Array.
   * @type Array
   * @default
   */
  strokeDashArray: null,

  /**
   * Sets shadow of an object
   * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
   * @return {fabric.Object} thisArg
   * @chainable
   */
  setShadow: function(options) {
    this.shadow = new fabric.Shadow(options);
    return this;
  },

  /**
   * Sets brush styles
   * @private
   */
  _setBrushStyles: function() {
    var ctx = this.canvas.contextTop;
    ctx.strokeStyle = this.color;
    ctx.lineWidth = this.width;
    ctx.lineCap = this.strokeLineCap;
    ctx.miterLimit = this.strokeMiterLimit;
    ctx.lineJoin = this.strokeLineJoin;
    if (fabric.StaticCanvas.supports('setLineDash')) {
      ctx.setLineDash(this.strokeDashArray || []);
    }
  },

  /**
   * Sets the transformation on given context
   * @param {RenderingContext2d} ctx context to render on
   * @private
   */
  _saveAndTransform: function(ctx) {
    var v = this.canvas.viewportTransform;
    ctx.save();
    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
  },

  /**
   * Sets brush shadow styles
   * @private
   */
  _setShadow: function() {
    if (!this.shadow) {
      return;
    }

    var ctx = this.canvas.contextTop,
        zoom = this.canvas.getZoom();

    ctx.shadowColor = this.shadow.color;
    ctx.shadowBlur = this.shadow.blur * zoom;
    ctx.shadowOffsetX = this.shadow.offsetX * zoom;
    ctx.shadowOffsetY = this.shadow.offsetY * zoom;
  },

  /**
   * Removes brush shadow styles
   * @private
   */
  _resetShadow: function() {
    var ctx = this.canvas.contextTop;

    ctx.shadowColor = '';
    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
  }
});


(function() {

  /**
   * PencilBrush class
   * @class fabric.PencilBrush
   * @extends fabric.BaseBrush
   */
  fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {

    /**
     * Constructor
     * @param {fabric.Canvas} canvas
     * @return {fabric.PencilBrush} Instance of a pencil brush
     */
    initialize: function(canvas) {
      this.canvas = canvas;
      this._points = [];
    },

    /**
     * Invoked inside on mouse down and mouse move
     * @param {Object} pointer
     */
    _drawSegment: function (ctx, p1, p2) {
      var midPoint = p1.midPointFrom(p2);
      ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
      return midPoint;
    },

    /**
     * Inovoked on mouse down
     * @param {Object} pointer
     */
    onMouseDown: function(pointer) {
      this._prepareForDrawing(pointer);
      // capture coordinates immediately
      // this allows to draw dots (when movement never occurs)
      this._captureDrawingPath(pointer);
      this._render();
    },

    /**
     * Inovoked on mouse move
     * @param {Object} pointer
     */
    onMouseMove: function(pointer) {
      if (this._captureDrawingPath(pointer) && this._points.length > 1) {
        if (this.needsFullRender) {
          // redraw curve
          // clear top canvas
          this.canvas.clearContext(this.canvas.contextTop);
          this._render();
        }
        else {
          var points = this._points, length = points.length, ctx = this.canvas.contextTop;
          // draw the curve update
          this._saveAndTransform(ctx);
          if (this.oldEnd) {
            ctx.beginPath();
            ctx.moveTo(this.oldEnd.x, this.oldEnd.y);
          }
          this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);
          ctx.stroke();
          ctx.restore();
        }
      }
    },

    /**
     * Invoked on mouse up
     */
    onMouseUp: function() {
      this.oldEnd = undefined;
      this._finalizeAndAddPath();
    },

    /**
     * @private
     * @param {Object} pointer Actual mouse position related to the canvas.
     */
    _prepareForDrawing: function(pointer) {

      var p = new fabric.Point(pointer.x, pointer.y);

      this._reset();
      this._addPoint(p);
      this.canvas.contextTop.moveTo(p.x, p.y);
    },

    /**
     * @private
     * @param {fabric.Point} point Point to be added to points array
     */
    _addPoint: function(point) {
      if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {
        return false;
      }
      this._points.push(point);
      return true;
    },

    /**
     * Clear points array and set contextTop canvas style.
     * @private
     */
    _reset: function() {
      this._points.length = 0;
      this._setBrushStyles();
      var color = new fabric.Color(this.color);
      this.needsFullRender = (color.getAlpha() < 1);
      this._setShadow();
    },

    /**
     * @private
     * @param {Object} pointer Actual mouse position related to the canvas.
     */
    _captureDrawingPath: function(pointer) {
      var pointerPoint = new fabric.Point(pointer.x, pointer.y);
      return this._addPoint(pointerPoint);
    },

    /**
     * Draw a smooth path on the topCanvas using quadraticCurveTo
     * @private
     */
    _render: function() {
      var ctx  = this.canvas.contextTop, i, len,
          p1 = this._points[0],
          p2 = this._points[1];

      this._saveAndTransform(ctx);
      ctx.beginPath();
      //if we only have 2 points in the path and they are the same
      //it means that the user only clicked the canvas without moving the mouse
      //then we should be drawing a dot. A path isn't drawn between two identical dots
      //that's why we set them apart a bit
      if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
        var width = this.width / 1000;
        p1 = new fabric.Point(p1.x, p1.y);
        p2 = new fabric.Point(p2.x, p2.y);
        p1.x -= width;
        p2.x += width;
      }
      ctx.moveTo(p1.x, p1.y);

      for (i = 1, len = this._points.length; i < len; i++) {
        // we pick the point between pi + 1 & pi + 2 as the
        // end point and p1 as our control point.
        this._drawSegment(ctx, p1, p2);
        p1 = this._points[i];
        p2 = this._points[i + 1];
      }
      // Draw last line as a straight line while
      // we wait for the next point to be able to calculate
      // the bezier control point
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
      ctx.restore();
    },

    /**
     * Converts points to SVG path
     * @param {Array} points Array of points
     * @return {String} SVG path
     */
    convertPointsToSVGPath: function(points) {
      var path = [], i, width = this.width / 1000,
          p1 = new fabric.Point(points[0].x, points[0].y),
          p2 = new fabric.Point(points[1].x, points[1].y),
          len = points.length, multSignX = 1, multSignY = 1, manyPoints = len > 2;

      if (manyPoints) {
        multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;
        multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;
      }
      path.push('M ', p1.x - multSignX * width, ' ', p1.y - multSignY * width, ' ');
      for (i = 1; i < len; i++) {
        if (!p1.eq(p2)) {
          var midPoint = p1.midPointFrom(p2);
          // p1 is our bezier control point
          // midpoint is our endpoint
          // start point is p(i-1) value.
          path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
        }
        p1 = points[i];
        if ((i + 1) < points.length) {
          p2 = points[i + 1];
        }
      }
      if (manyPoints) {
        multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;
        multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;
      }
      path.push('L ', p1.x + multSignX * width, ' ', p1.y + multSignY * width);
      return path;
    },

    /**
     * Creates fabric.Path object to add on canvas
     * @param {String} pathData Path data
     * @return {fabric.Path} Path to add on canvas
     */
    createPath: function(pathData) {
      var path = new fabric.Path(pathData, {
        fill: null,
        stroke: this.color,
        strokeWidth: this.width,
        strokeLineCap: this.strokeLineCap,
        strokeMiterLimit: this.strokeMiterLimit,
        strokeLineJoin: this.strokeLineJoin,
        strokeDashArray: this.strokeDashArray,
      });
      var position = new fabric.Point(path.left + path.width / 2, path.top + path.height / 2);
      position = path.translateToGivenOrigin(position, 'center', 'center', path.originX, path.originY);
      path.top = position.y;
      path.left = position.x;
      if (this.shadow) {
        this.shadow.affectStroke = true;
        path.setShadow(this.shadow);
      }

      return path;
    },

    /**
     * On mouseup after drawing the path on contextTop canvas
     * we use the points captured to create an new fabric path object
     * and add it to the fabric canvas.
     */
    _finalizeAndAddPath: function() {
      var ctx = this.canvas.contextTop;
      ctx.closePath();

      var pathData = this.convertPointsToSVGPath(this._points).join('');
      if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {
        // do not create 0 width/height paths, as they are
        // rendered inconsistently across browsers
        // Firefox 4, for example, renders a dot,
        // whereas Chrome 10 renders nothing
        this.canvas.requestRenderAll();
        return;
      }

      var path = this.createPath(pathData);
      this.canvas.clearContext(this.canvas.contextTop);
      this.canvas.add(path);
      this.canvas.renderAll();
      path.setCoords();
      this._resetShadow();


      // fire event 'path' created
      this.canvas.fire('path:created', { path: path });
    }
  });
})();


/**
 * CircleBrush class
 * @class fabric.CircleBrush
 */
fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {

  /**
   * Width of a brush
   * @type Number
   * @default
   */
  width: 10,

  /**
   * Constructor
   * @param {fabric.Canvas} canvas
   * @return {fabric.CircleBrush} Instance of a circle brush
   */
  initialize: function(canvas) {
    this.canvas = canvas;
    this.points = [];
  },

  /**
   * Invoked inside on mouse down and mouse move
   * @param {Object} pointer
   */
  drawDot: function(pointer) {
    var point = this.addPoint(pointer),
        ctx = this.canvas.contextTop;
    this._saveAndTransform(ctx);
    ctx.fillStyle = point.fill;
    ctx.beginPath();
    ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  },

  /**
   * Invoked on mouse down
   */
  onMouseDown: function(pointer) {
    this.points.length = 0;
    this.canvas.clearContext(this.canvas.contextTop);
    this._setShadow();
    this.drawDot(pointer);
  },

  /**
   * Render the full state of the brush
   * @private
   */
  _render: function() {
    var ctx  = this.canvas.contextTop, i, len,
        points = this.points, point;
    this._saveAndTransform(ctx);
    for (i = 0, len = points.length; i < len; i++) {
      point = points[i];
      ctx.fillStyle = point.fill;
      ctx.beginPath();
      ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  },

  /**
   * Invoked on mouse move
   * @param {Object} pointer
   */
  onMouseMove: function(pointer) {
    this.drawDot(pointer);
  },

  /**
   * Invoked on mouse up
   */
  onMouseUp: function() {
    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;
    this.canvas.renderOnAddRemove = false;

    var circles = [];

    for (i = 0, len = this.points.length; i < len; i++) {
      var point = this.points[i],
          circle = new fabric.Circle({
            radius: point.radius,
            left: point.x,
            top: point.y,
            originX: 'center',
            originY: 'center',
            fill: point.fill
          });

      this.shadow && circle.setShadow(this.shadow);

      circles.push(circle);
    }
    var group = new fabric.Group(circles);
    group.canvas = this.canvas;

    this.canvas.add(group);
    this.canvas.fire('path:created', { path: group });

    this.canvas.clearContext(this.canvas.contextTop);
    this._resetShadow();
    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
    this.canvas.requestRenderAll();
  },

  /**
   * @param {Object} pointer
   * @return {fabric.Point} Just added pointer point
   */
  addPoint: function(pointer) {
    var pointerPoint = new fabric.Point(pointer.x, pointer.y),

        circleRadius = fabric.util.getRandomInt(
          Math.max(0, this.width - 20), this.width + 20) / 2,

        circleColor = new fabric.Color(this.color)
          .setAlpha(fabric.util.getRandomInt(0, 100) / 100)
          .toRgba();

    pointerPoint.radius = circleRadius;
    pointerPoint.fill = circleColor;

    this.points.push(pointerPoint);

    return pointerPoint;
  }
});


/**
 * SprayBrush class
 * @class fabric.SprayBrush
 */
fabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {

  /**
   * Width of a spray
   * @type Number
   * @default
   */
  width:              10,

  /**
   * Density of a spray (number of dots per chunk)
   * @type Number
   * @default
   */
  density:            20,

  /**
   * Width of spray dots
   * @type Number
   * @default
   */
  dotWidth:           1,

  /**
   * Width variance of spray dots
   * @type Number
   * @default
   */
  dotWidthVariance:   1,

  /**
   * Whether opacity of a dot should be random
   * @type Boolean
   * @default
   */
  randomOpacity:        false,

  /**
   * Whether overlapping dots (rectangles) should be removed (for performance reasons)
   * @type Boolean
   * @default
   */
  optimizeOverlapping:  true,

  /**
   * Constructor
   * @param {fabric.Canvas} canvas
   * @return {fabric.SprayBrush} Instance of a spray brush
   */
  initialize: function(canvas) {
    this.canvas = canvas;
    this.sprayChunks = [];
  },

  /**
   * Invoked on mouse down
   * @param {Object} pointer
   */
  onMouseDown: function(pointer) {
    this.sprayChunks.length = 0;
    this.canvas.clearContext(this.canvas.contextTop);
    this._setShadow();

    this.addSprayChunk(pointer);
    this.render(this.sprayChunkPoints);
  },

  /**
   * Invoked on mouse move
   * @param {Object} pointer
   */
  onMouseMove: function(pointer) {
    this.addSprayChunk(pointer);
    this.render(this.sprayChunkPoints);
  },

  /**
   * Invoked on mouse up
   */
  onMouseUp: function() {
    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
    this.canvas.renderOnAddRemove = false;

    var rects = [];

    for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
      var sprayChunk = this.sprayChunks[i];

      for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {

        var rect = new fabric.Rect({
          width: sprayChunk[j].width,
          height: sprayChunk[j].width,
          left: sprayChunk[j].x + 1,
          top: sprayChunk[j].y + 1,
          originX: 'center',
          originY: 'center',
          fill: this.color
        });
        rects.push(rect);
      }
    }

    if (this.optimizeOverlapping) {
      rects = this._getOptimizedRects(rects);
    }

    var group = new fabric.Group(rects);
    this.shadow && group.setShadow(this.shadow);
    this.canvas.add(group);
    this.canvas.fire('path:created', { path: group });

    this.canvas.clearContext(this.canvas.contextTop);
    this._resetShadow();
    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
    this.canvas.requestRenderAll();
  },

  /**
   * @private
   * @param {Array} rects
   */
  _getOptimizedRects: function(rects) {

    // avoid creating duplicate rects at the same coordinates
    var uniqueRects = { }, key, i, len;

    for (i = 0, len = rects.length; i < len; i++) {
      key = rects[i].left + '' + rects[i].top;
      if (!uniqueRects[key]) {
        uniqueRects[key] = rects[i];
      }
    }
    var uniqueRectsArray = [];
    for (key in uniqueRects) {
      uniqueRectsArray.push(uniqueRects[key]);
    }

    return uniqueRectsArray;
  },

  /**
   * Render new chunk of spray brush
   */
  render: function(sprayChunk) {
    var ctx = this.canvas.contextTop, i, len;
    ctx.fillStyle = this.color;

    this._saveAndTransform(ctx);

    for (i = 0, len = sprayChunk.length; i < len; i++) {
      var point = sprayChunk[i];
      if (typeof point.opacity !== 'undefined') {
        ctx.globalAlpha = point.opacity;
      }
      ctx.fillRect(point.x, point.y, point.width, point.width);
    }
    ctx.restore();
  },

  /**
   * Render all spray chunks
   */
  _render: function() {
    var ctx = this.canvas.contextTop, i, ilen;
    ctx.fillStyle = this.color;

    this._saveAndTransform(ctx);

    for (i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
      this.render(this.sprayChunks[i]);
    }
    ctx.restore();
  },

  /**
   * @param {Object} pointer
   */
  addSprayChunk: function(pointer) {
    this.sprayChunkPoints = [];

    var x, y, width, radius = this.width / 2, i;

    for (i = 0; i < this.density; i++) {

      x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
      y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);

      if (this.dotWidthVariance) {
        width = fabric.util.getRandomInt(
          // bottom clamp width to 1
          Math.max(1, this.dotWidth - this.dotWidthVariance),
          this.dotWidth + this.dotWidthVariance);
      }
      else {
        width = this.dotWidth;
      }

      var point = new fabric.Point(x, y);
      point.width = width;

      if (this.randomOpacity) {
        point.opacity = fabric.util.getRandomInt(0, 100) / 100;
      }

      this.sprayChunkPoints.push(point);
    }

    this.sprayChunks.push(this.sprayChunkPoints);
  }
});


/**
 * PatternBrush class
 * @class fabric.PatternBrush
 * @extends fabric.BaseBrush
 */
fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {

  getPatternSrc: function() {

    var dotWidth = 20,
        dotDistance = 5,
        patternCanvas = fabric.util.createCanvasElement(),
        patternCtx = patternCanvas.getContext('2d');

    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;

    patternCtx.fillStyle = this.color;
    patternCtx.beginPath();
    patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
    patternCtx.closePath();
    patternCtx.fill();

    return patternCanvas;
  },

  getPatternSrcFunction: function() {
    return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');
  },

  /**
   * Creates "pattern" instance property
   */
  getPattern: function() {
    return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');
  },

  /**
   * Sets brush styles
   */
  _setBrushStyles: function() {
    this.callSuper('_setBrushStyles');
    this.canvas.contextTop.strokeStyle = this.getPattern();
  },

  /**
   * Creates path
   */
  createPath: function(pathData) {
    var path = this.callSuper('createPath', pathData),
        topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);

    path.stroke = new fabric.Pattern({
      source: this.source || this.getPatternSrcFunction(),
      offsetX: -topLeft.x,
      offsetY: -topLeft.y
    });
    return path;
  }
});


(function() {

  var getPointer = fabric.util.getPointer,
      degreesToRadians = fabric.util.degreesToRadians,
      radiansToDegrees = fabric.util.radiansToDegrees,
      atan2 = Math.atan2,
      abs = Math.abs,
      supportLineDash = fabric.StaticCanvas.supports('setLineDash'),

      STROKE_OFFSET = 0.5;

  /**
   * Canvas class
   * @class fabric.Canvas
   * @extends fabric.StaticCanvas
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}
   * @see {@link fabric.Canvas#initialize} for constructor definition
   *
   * @fires object:modified
   * @fires object:rotated
   * @fires object:scaled
   * @fires object:moved
   * @fires object:skewed
   * @fires object:rotating
   * @fires object:scaling
   * @fires object:moving
   * @fires object:skewing
   * @fires object:selected this event is deprecated. use selection:created
   *
   * @fires before:transform
   * @fires before:selection:cleared
   * @fires selection:cleared
   * @fires selection:updated
   * @fires selection:created
   *
   * @fires path:created
   * @fires mouse:down
   * @fires mouse:move
   * @fires mouse:up
   * @fires mouse:down:before
   * @fires mouse:move:before
   * @fires mouse:up:before
   * @fires mouse:over
   * @fires mouse:out
   * @fires mouse:dblclick
   *
   * @fires dragover
   * @fires dragenter
   * @fires dragleave
   * @fires drop
   *
   */
  fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {

    /**
     * Constructor
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(el, options) {
      options || (options = { });
      this.renderAndResetBound = this.renderAndReset.bind(this);
      this.requestRenderAllBound = this.requestRenderAll.bind(this);
      this._initStatic(el, options);
      this._initInteractive();
      this._createCacheCanvas();
    },

    /**
     * When true, objects can be transformed by one side (unproportionally)
     * @type Boolean
     * @default
     */
    uniScaleTransform:      false,

    /**
     * Indicates which key enable unproportional scaling
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    uniScaleKey:           'shiftKey',

    /**
     * When true, objects use center point as the origin of scale transformation.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredScaling:        false,

    /**
     * When true, objects use center point as the origin of rotate transformation.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredRotation:       false,

    /**
     * Indicates which key enable centered Transform
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    centeredKey:           'altKey',

    /**
     * Indicates which key enable alternate action on corner
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    altActionKey:           'shiftKey',

    /**
     * Indicates that canvas is interactive. This property should not be changed.
     * @type Boolean
     * @default
     */
    interactive:            true,

    /**
     * Indicates whether group selection should be enabled
     * @type Boolean
     * @default
     */
    selection:              true,

    /**
     * Indicates which key or keys enable multiple click selection
     * Pass value as a string or array of strings
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or empty or containing any other string that is not a modifier key
     * feature is disabled.
     * @since 1.6.2
     * @type String|Array
     * @default
     */
    selectionKey:           'shiftKey',

    /**
     * Indicates which key enable alternative selection
     * in case of target overlapping with active object
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * For a series of reason that come from the general expectations on how
     * things should work, this feature works only for preserveObjectStacking true.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled.
     * @since 1.6.5
     * @type null|String
     * @default
     */
    altSelectionKey:           null,

    /**
     * Color of selection
     * @type String
     * @default
     */
    selectionColor:         'rgba(100, 100, 255, 0.3)', // blue

    /**
     * Default dash array pattern
     * If not empty the selection border is dashed
     * @type Array
     */
    selectionDashArray:     [],

    /**
     * Color of the border of selection (usually slightly darker than color of selection itself)
     * @type String
     * @default
     */
    selectionBorderColor:   'rgba(255, 255, 255, 0.3)',

    /**
     * Width of a line used in object/group selection
     * @type Number
     * @default
     */
    selectionLineWidth:     1,

    /**
     * Select only shapes that are fully contained in the dragged selection rectangle.
     * @type Boolean
     * @default
     */
    selectionFullyContained: false,

    /**
     * Default cursor value used when hovering over an object on canvas
     * @type String
     * @default
     */
    hoverCursor:            'move',

    /**
     * Default cursor value used when moving an object on canvas
     * @type String
     * @default
     */
    moveCursor:             'move',

    /**
     * Default cursor value used for the entire canvas
     * @type String
     * @default
     */
    defaultCursor:          'default',

    /**
     * Cursor value used during free drawing
     * @type String
     * @default
     */
    freeDrawingCursor:      'crosshair',

    /**
     * Cursor value used for rotation point
     * @type String
     * @default
     */
    rotationCursor:         'crosshair',

    /**
     * Cursor value used for disabled elements ( corners with disabled action )
     * @type String
     * @since 2.0.0
     * @default
     */
    notAllowedCursor:         'not-allowed',

    /**
     * Default element class that's given to wrapper (div) element of canvas
     * @type String
     * @default
     */
    containerClass:         'canvas-container',

    /**
     * When true, object detection happens on per-pixel basis rather than on per-bounding-box
     * @type Boolean
     * @default
     */
    perPixelTargetFind:     false,

    /**
     * Number of pixels around target pixel to tolerate (consider active) during object detection
     * @type Number
     * @default
     */
    targetFindTolerance:    0,

    /**
     * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.
     * @type Boolean
     * @default
     */
    skipTargetFind:         false,

    /**
     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
     * After mousedown, mousemove creates a shape,
     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}
     * @type Boolean
     * @default
     */
    isDrawingMode:          false,

    /**
     * Indicates whether objects should remain in current stack position when selected.
     * When false objects are brought to top and rendered as part of the selection group
     * @type Boolean
     * @default
     */
    preserveObjectStacking: false,

    /**
     * Indicates the angle that an object will lock to while rotating.
     * @type Number
     * @since 1.6.7
     * @default
     */
    snapAngle: 0,

    /**
     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.
     * When `null`, the snapThreshold will default to the snapAngle.
     * @type null|Number
     * @since 1.6.7
     * @default
     */
    snapThreshold: null,

    /**
     * Indicates if the right click on canvas can output the context menu or not
     * @type Boolean
     * @since 1.6.5
     * @default
     */
    stopContextMenu: false,

    /**
     * Indicates if the canvas can fire right click events
     * @type Boolean
     * @since 1.6.5
     * @default
     */
    fireRightClick: false,

    /**
     * Indicates if the canvas can fire middle click events
     * @type Boolean
     * @since 1.7.8
     * @default
     */
    fireMiddleClick: false,

    /**
     * @private
     */
    _initInteractive: function() {
      this._currentTransform = null;
      this._groupSelector = null;
      this._initWrapperElement();
      this._createUpperCanvas();
      this._initEventListeners();

      this._initRetinaScaling();

      this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);

      this.calcOffset();
    },

    /**
     * Divides objects in two groups, one to render immediately
     * and one to render as activeGroup.
     * @return {Array} objects to render immediately and pushes the other in the activeGroup.
     */
    _chooseObjectsToRender: function() {
      var activeObjects = this.getActiveObjects(),
          object, objsToRender, activeGroupObjects;

      if (activeObjects.length > 0 && !this.preserveObjectStacking) {
        objsToRender = [];
        activeGroupObjects = [];
        for (var i = 0, length = this._objects.length; i < length; i++) {
          object = this._objects[i];
          if (activeObjects.indexOf(object) === -1 ) {
            objsToRender.push(object);
          }
          else {
            activeGroupObjects.push(object);
          }
        }
        if (activeObjects.length > 1) {
          this._activeObject._objects = activeGroupObjects;
        }
        objsToRender.push.apply(objsToRender, activeGroupObjects);
      }
      else {
        objsToRender = this._objects;
      }
      return objsToRender;
    },

    /**
     * Renders both the top canvas and the secondary container canvas.
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAll: function () {
      if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {
        this.clearContext(this.contextTop);
        this.contextTopDirty = false;
      }
      if (this.hasLostContext) {
        this.renderTopLayer(this.contextTop);
      }
      var canvasToDrawOn = this.contextContainer;
      this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
      return this;
    },

    renderTopLayer: function(ctx) {
      ctx.save();
      if (this.isDrawingMode && this._isCurrentlyDrawing) {
        this.freeDrawingBrush && this.freeDrawingBrush._render();
        this.contextTopDirty = true;
      }
      // we render the top context - last object
      if (this.selection && this._groupSelector) {
        this._drawSelection(ctx);
        this.contextTopDirty = true;
      }
      ctx.restore();
    },

    /**
     * Method to render only the top canvas.
     * Also used to render the group selection box.
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    renderTop: function () {
      var ctx = this.contextTop;
      this.clearContext(ctx);
      this.renderTopLayer(ctx);
      this.fire('after:render');
      return this;
    },

    /**
     * Resets the current transform to its original values and chooses the type of resizing based on the event
     * @private
     */
    _resetCurrentTransform: function() {
      var t = this._currentTransform;

      t.target.set({
        scaleX: t.original.scaleX,
        scaleY: t.original.scaleY,
        skewX: t.original.skewX,
        skewY: t.original.skewY,
        left: t.original.left,
        top: t.original.top
      });

      if (this._shouldCenterTransform(t.target)) {
        if (t.originX !== 'center') {
          if (t.originX === 'right') {
            t.mouseXSign = -1;
          }
          else {
            t.mouseXSign = 1;
          }
        }
        if (t.originY !== 'center') {
          if (t.originY === 'bottom') {
            t.mouseYSign = -1;
          }
          else {
            t.mouseYSign = 1;
          }
        }

        t.originX = 'center';
        t.originY = 'center';
      }
      else {
        t.originX = t.original.originX;
        t.originY = t.original.originY;
      }
    },

    /**
     * Checks if point is contained within an area of given object
     * @param {Event} e Event object
     * @param {fabric.Object} target Object to test against
     * @param {Object} [point] x,y object of point coordinates we want to check.
     * @return {Boolean} true if point is contained within an area of given object
     */
    containsPoint: function (e, target, point) {
      var ignoreZoom = true,
          pointer = point || this.getPointer(e, ignoreZoom),
          xy;

      if (target.group && target.group === this._activeObject && target.group.type === 'activeSelection') {
        xy = this._normalizePointer(target.group, pointer);
      }
      else {
        xy = { x: pointer.x, y: pointer.y };
      }
      // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
      // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
      return (target.containsPoint(xy) || target._findTargetCorner(pointer));
    },

    /**
     * @private
     */
    _normalizePointer: function (object, pointer) {
      var m = object.calcTransformMatrix(),
          invertedM = fabric.util.invertTransform(m),
          vptPointer = this.restorePointerVpt(pointer);
      return fabric.util.transformPoint(vptPointer, invertedM);
    },

    /**
     * Returns true if object is transparent at a certain location
     * @param {fabric.Object} target Object to check
     * @param {Number} x Left coordinate
     * @param {Number} y Top coordinate
     * @return {Boolean}
     */
    isTargetTransparent: function (target, x, y) {
      // in case the target is the activeObject, we cannot execute this optimization
      // because we need to draw controls too.
      if (target.shouldCache() && target._cacheCanvas && target !== this._activeObject) {
        var normalizedPointer = this._normalizePointer(target, {x: x, y: y}),
            targetRelativeX = Math.max(target.cacheTranslationX + (normalizedPointer.x * target.zoomX), 0),
            targetRelativeY = Math.max(target.cacheTranslationY + (normalizedPointer.y * target.zoomY), 0);

        var isTransparent = fabric.util.isTransparent(
          target._cacheContext, Math.round(targetRelativeX), Math.round(targetRelativeY), this.targetFindTolerance);

        return isTransparent;
      }

      var ctx = this.contextCache,
          originalColor = target.selectionBackgroundColor, v = this.viewportTransform;

      target.selectionBackgroundColor = '';

      this.clearContext(ctx);

      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      target.render(ctx);
      ctx.restore();

      target === this._activeObject && target._renderControls(ctx, {
        hasBorders: false,
        transparentCorners: false
      }, {
        hasBorders: false,
      });

      target.selectionBackgroundColor = originalColor;

      var isTransparent = fabric.util.isTransparent(
        ctx, x, y, this.targetFindTolerance);

      return isTransparent;
    },

    /**
     * takes an event and determins if selection key has been pressed
     * @private
     * @param {Event} e Event object
     */
    _isSelectionKeyPressed: function(e) {
      var selectionKeyPressed = false;

      if (Object.prototype.toString.call(this.selectionKey) === '[object Array]') {
        selectionKeyPressed = !!this.selectionKey.find(function(key) { return e[key] === true; });
      }
      else {
        selectionKeyPressed = e[this.selectionKey];
      }

      return selectionKeyPressed;
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _shouldClearSelection: function (e, target) {
      var activeObjects = this.getActiveObjects(),
          activeObject = this._activeObject;

      return (
        !target
        ||
        (target &&
          activeObject &&
          activeObjects.length > 1 &&
          activeObjects.indexOf(target) === -1 &&
          activeObject !== target &&
          !this._isSelectionKeyPressed(e))
        ||
        (target && !target.evented)
        ||
        (target &&
          !target.selectable &&
          activeObject &&
          activeObject !== target)
      );
    },

    /**
     * centeredScaling from object can't override centeredScaling from canvas.
     * this should be fixed, since object setting should take precedence over canvas.
     * @private
     * @param {fabric.Object} target
     */
    _shouldCenterTransform: function (target) {
      if (!target) {
        return;
      }

      var t = this._currentTransform,
          centerTransform;

      if (t.action === 'scale' || t.action === 'scaleX' || t.action === 'scaleY') {
        centerTransform = this.centeredScaling || target.centeredScaling;
      }
      else if (t.action === 'rotate') {
        centerTransform = this.centeredRotation || target.centeredRotation;
      }

      return centerTransform ? !t.altKey : t.altKey;
    },

    /**
     * @private
     */
    _getOriginFromCorner: function(target, corner) {
      var origin = {
        x: target.originX,
        y: target.originY
      };

      if (corner === 'ml' || corner === 'tl' || corner === 'bl') {
        origin.x = 'right';
      }
      else if (corner === 'mr' || corner === 'tr' || corner === 'br') {
        origin.x = 'left';
      }

      if (corner === 'tl' || corner === 'mt' || corner === 'tr') {
        origin.y = 'bottom';
      }
      else if (corner === 'bl' || corner === 'mb' || corner === 'br') {
        origin.y = 'top';
      }

      return origin;
    },

    /**
     * @private
     */
    _getActionFromCorner: function(alreadySelected, corner, e) {
      if (!corner || !alreadySelected) {
        return 'drag';
      }

      switch (corner) {
        case 'mtr':
          return 'rotate';
        case 'ml':
        case 'mr':
          return e[this.altActionKey] ? 'skewY' : 'scaleX';
        case 'mt':
        case 'mb':
          return e[this.altActionKey] ? 'skewX' : 'scaleY';
        default:
          return 'scale';
      }
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _setupCurrentTransform: function (e, target, alreadySelected) {
      if (!target) {
        return;
      }

      var pointer = this.getPointer(e),
          corner = target._findTargetCorner(this.getPointer(e, true)),
          action = this._getActionFromCorner(alreadySelected, corner, e),
          origin = this._getOriginFromCorner(target, corner);

      this._currentTransform = {
        target: target,
        action: action,
        corner: corner,
        scaleX: target.scaleX,
        scaleY: target.scaleY,
        skewX: target.skewX,
        skewY: target.skewY,
        // used by transation
        offsetX: pointer.x - target.left,
        offsetY: pointer.y - target.top,
        originX: origin.x,
        originY: origin.y,
        ex: pointer.x,
        ey: pointer.y,
        lastX: pointer.x,
        lastY: pointer.y,
        // unsure they are usefull anymore.
        // left: target.left,
        // top: target.top,
        theta: degreesToRadians(target.angle),
        // end of unsure
        width: target.width * target.scaleX,
        mouseXSign: 1,
        mouseYSign: 1,
        shiftKey: e.shiftKey,
        altKey: e[this.centeredKey],
        original: fabric.util.saveObjectTransform(target),
      };

      this._currentTransform.original.originX = origin.x;
      this._currentTransform.original.originY = origin.y;

      this._resetCurrentTransform();
      this._beforeTransform(e);
    },

    /**
     * Translates object by "setting" its left/top
     * @private
     * @param {Number} x pointer's x coordinate
     * @param {Number} y pointer's y coordinate
     * @return {Boolean} true if the translation occurred
     */
    _translateObject: function (x, y) {
      var transform = this._currentTransform,
          target = transform.target,
          newLeft = x - transform.offsetX,
          newTop = y - transform.offsetY,
          moveX = !target.get('lockMovementX') && target.left !== newLeft,
          moveY = !target.get('lockMovementY') && target.top !== newTop;

      moveX && target.set('left', newLeft);
      moveY && target.set('top', newTop);
      return moveX || moveY;
    },

    /**
     * Check if we are increasing a positive skew or lower it,
     * checking mouse direction and pressed corner.
     * @private
     */
    _changeSkewTransformOrigin: function(mouseMove, t, by) {
      var property = 'originX', origins = { 0: 'center' },
          skew = t.target.skewX, originA = 'left', originB = 'right',
          corner = t.corner === 'mt' || t.corner === 'ml' ? 1 : -1,
          flipSign = 1;

      mouseMove = mouseMove > 0 ? 1 : -1;
      if (by === 'y') {
        skew = t.target.skewY;
        originA = 'top';
        originB = 'bottom';
        property = 'originY';
      }
      origins[-1] = originA;
      origins[1] = originB;

      t.target.flipX && (flipSign *= -1);
      t.target.flipY && (flipSign *= -1);

      if (skew === 0) {
        t.skewSign = -corner * mouseMove * flipSign;
        t[property] = origins[-mouseMove];
      }
      else {
        skew = skew > 0 ? 1 : -1;
        t.skewSign = skew;
        t[property] = origins[skew * corner * flipSign];
      }
    },

    /**
     * Skew object by mouse events
     * @private
     * @param {Number} x pointer's x coordinate
     * @param {Number} y pointer's y coordinate
     * @param {String} by Either 'x' or 'y'
     * @return {Boolean} true if the skewing occurred
     */
    _skewObject: function (x, y, by) {
      var t = this._currentTransform,
          target = t.target, skewed = false,
          lockSkewingX = target.get('lockSkewingX'),
          lockSkewingY = target.get('lockSkewingY');

      if ((lockSkewingX && by === 'x') || (lockSkewingY && by === 'y')) {
        return false;
      }

      // Get the constraint point
      var center = target.getCenterPoint(),
          actualMouseByCenter = target.toLocalPoint(new fabric.Point(x, y), 'center', 'center')[by],
          lastMouseByCenter = target.toLocalPoint(new fabric.Point(t.lastX, t.lastY), 'center', 'center')[by],
          actualMouseByOrigin, constraintPosition, dim = target._getTransformedDimensions();

      this._changeSkewTransformOrigin(actualMouseByCenter - lastMouseByCenter, t, by);
      actualMouseByOrigin = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY)[by];
      constraintPosition = target.translateToOriginPoint(center, t.originX, t.originY);
      // Actually skew the object
      skewed = this._setObjectSkew(actualMouseByOrigin, t, by, dim);
      t.lastX = x;
      t.lastY = y;
      // Make sure the constraints apply
      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
      return skewed;
    },

    /**
     * Set object skew
     * @private
     * @return {Boolean} true if the skewing occurred
     */
    _setObjectSkew: function(localMouse, transform, by, _dim) {
      var target = transform.target, newValue, skewed = false,
          skewSign = transform.skewSign, newDim, dimNoSkew,
          otherBy, _otherBy, _by, newDimMouse, skewX, skewY;

      if (by === 'x') {
        otherBy = 'y';
        _otherBy = 'Y';
        _by = 'X';
        skewX = 0;
        skewY = target.skewY;
      }
      else {
        otherBy = 'x';
        _otherBy = 'X';
        _by = 'Y';
        skewX = target.skewX;
        skewY = 0;
      }

      dimNoSkew = target._getTransformedDimensions(skewX, skewY);
      newDimMouse = 2 * Math.abs(localMouse) - dimNoSkew[by];
      if (newDimMouse <= 2) {
        newValue = 0;
      }
      else {
        newValue = skewSign * Math.atan((newDimMouse / target['scale' + _by]) /
                                        (dimNoSkew[otherBy] / target['scale' + _otherBy]));
        newValue = fabric.util.radiansToDegrees(newValue);
      }
      skewed = target['skew' + _by] !== newValue;
      target.set('skew' + _by, newValue);
      if (target['skew' + _otherBy] !== 0) {
        newDim = target._getTransformedDimensions();
        newValue = (_dim[otherBy] / newDim[otherBy]) * target['scale' + _otherBy];
        target.set('scale' + _otherBy, newValue);
      }
      return skewed;
    },

    /**
     * Scales object by invoking its scaleX/scaleY methods
     * @private
     * @param {Number} x pointer's x coordinate
     * @param {Number} y pointer's y coordinate
     * @param {String} by Either 'x' or 'y' - specifies dimension constraint by which to scale an object.
     *                    When not provided, an object is scaled by both dimensions equally
     * @return {Boolean} true if the scaling occurred
     */
    _scaleObject: function (x, y, by) {
      var t = this._currentTransform,
          target = t.target,
          lockScalingX = target.lockScalingX,
          lockScalingY = target.lockScalingY,
          lockScalingFlip = target.lockScalingFlip;

      if (lockScalingX && lockScalingY) {
        return false;
      }

      // Get the constraint point
      var constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY),
          localMouse = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY),
          dim = target._getTransformedDimensions(), scaled = false;

      this._setLocalMouse(localMouse, t);

      // Actually scale the object
      scaled = this._setObjectScale(localMouse, t, lockScalingX, lockScalingY, by, lockScalingFlip, dim);

      // Make sure the constraints apply
      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
      return scaled;
    },

    /**
     * @private
     * @return {Boolean} true if the scaling occurred
     */
    _setObjectScale: function(localMouse, transform, lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {
      var target = transform.target, forbidScalingX = false, forbidScalingY = false, scaled = false,
          scaleX = localMouse.x * target.scaleX / _dim.x,
          scaleY = localMouse.y * target.scaleY / _dim.y,
          changeX = target.scaleX !== scaleX,
          changeY = target.scaleY !== scaleY;

      if (lockScalingFlip && scaleX <= 0 && scaleX < target.scaleX) {
        forbidScalingX = true;
        localMouse.x = 0;
      }

      if (lockScalingFlip && scaleY <= 0 && scaleY < target.scaleY) {
        forbidScalingY = true;
        localMouse.y = 0;
      }

      if (by === 'equally' && !lockScalingX && !lockScalingY) {
        scaled = this._scaleObjectEqually(localMouse, target, transform, _dim);
      }
      else if (!by) {
        forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));
        forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));
      }
      else if (by === 'x' && !target.get('lockUniScaling')) {
        forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = changeX));
      }
      else if (by === 'y' && !target.get('lockUniScaling')) {
        forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = changeY));
      }
      transform.newScaleX = scaleX;
      transform.newScaleY = scaleY;
      forbidScalingX || forbidScalingY || this._flipObject(transform, by);
      return scaled;
    },

    /**
     * @private
     * @return {Boolean} true if the scaling occurred
     */
    _scaleObjectEqually: function(localMouse, target, transform, _dim) {

      var dist = localMouse.y + localMouse.x,
          lastDist = _dim.y * transform.original.scaleY / target.scaleY +
                     _dim.x * transform.original.scaleX / target.scaleX,
          scaled, signX = localMouse.x < 0 ? -1 : 1,
          signY = localMouse.y < 0 ? -1 : 1, newScaleX, newScaleY;

      // We use transform.scaleX/Y instead of target.scaleX/Y
      // because the object may have a min scale and we'll loose the proportions
      newScaleX = signX * Math.abs(transform.original.scaleX * dist / lastDist);
      newScaleY = signY * Math.abs(transform.original.scaleY * dist / lastDist);
      scaled = newScaleX !== target.scaleX || newScaleY !== target.scaleY;
      target.set('scaleX', newScaleX);
      target.set('scaleY', newScaleY);
      return scaled;
    },

    /**
     * @private
     */
    _flipObject: function(transform, by) {
      if (transform.newScaleX < 0 && by !== 'y') {
        if (transform.originX === 'left') {
          transform.originX = 'right';
        }
        else if (transform.originX === 'right') {
          transform.originX = 'left';
        }
      }

      if (transform.newScaleY < 0 && by !== 'x') {
        if (transform.originY === 'top') {
          transform.originY = 'bottom';
        }
        else if (transform.originY === 'bottom') {
          transform.originY = 'top';
        }
      }
    },

    /**
     * @private
     */
    _setLocalMouse: function(localMouse, t) {
      var target = t.target, zoom = this.getZoom(),
          padding = target.padding / zoom;

      if (t.originX === 'right') {
        localMouse.x *= -1;
      }
      else if (t.originX === 'center') {
        localMouse.x *= t.mouseXSign * 2;
        if (localMouse.x < 0) {
          t.mouseXSign = -t.mouseXSign;
        }
      }

      if (t.originY === 'bottom') {
        localMouse.y *= -1;
      }
      else if (t.originY === 'center') {
        localMouse.y *= t.mouseYSign * 2;
        if (localMouse.y < 0) {
          t.mouseYSign = -t.mouseYSign;
        }
      }

      // adjust the mouse coordinates when dealing with padding
      if (abs(localMouse.x) > padding) {
        if (localMouse.x < 0) {
          localMouse.x += padding;
        }
        else {
          localMouse.x -= padding;
        }
      }
      else { // mouse is within the padding, set to 0
        localMouse.x = 0;
      }

      if (abs(localMouse.y) > padding) {
        if (localMouse.y < 0) {
          localMouse.y += padding;
        }
        else {
          localMouse.y -= padding;
        }
      }
      else {
        localMouse.y = 0;
      }
    },

    /**
     * Rotates object by invoking its rotate method
     * @private
     * @param {Number} x pointer's x coordinate
     * @param {Number} y pointer's y coordinate
     * @return {Boolean} true if the rotation occurred
     */
    _rotateObject: function (x, y) {

      var t = this._currentTransform,
          target = t.target, constraintPosition,
          constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);

      if (target.lockRotation) {
        return false;
      }

      var lastAngle = atan2(t.ey - constraintPosition.y, t.ex - constraintPosition.x),
          curAngle = atan2(y - constraintPosition.y, x - constraintPosition.x),
          angle = radiansToDegrees(curAngle - lastAngle + t.theta),
          hasRotated = true;

      if (target.snapAngle > 0) {
        var snapAngle  = target.snapAngle,
            snapThreshold  = target.snapThreshold || snapAngle,
            rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle,
            leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;

        if (Math.abs(angle - leftAngleLocked) < snapThreshold) {
          angle = leftAngleLocked;
        }
        else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {
          angle = rightAngleLocked;
        }
      }

      // normalize angle to positive value
      if (angle < 0) {
        angle = 360 + angle;
      }
      angle %= 360;

      if (target.angle === angle) {
        hasRotated = false;
      }
      else {
        // rotation only happen here
        target.angle = angle;
        // Make sure the constraints apply
        target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
      }

      return hasRotated;
    },

    /**
     * Set the cursor type of the canvas element
     * @param {String} value Cursor type of the canvas element.
     * @see http://www.w3.org/TR/css3-ui/#cursor
     */
    setCursor: function (value) {
      this.upperCanvasEl.style.cursor = value;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx to draw the selection on
     */
    _drawSelection: function (ctx) {
      var groupSelector = this._groupSelector,
          left = groupSelector.left,
          top = groupSelector.top,
          aleft = abs(left),
          atop = abs(top);

      if (this.selectionColor) {
        ctx.fillStyle = this.selectionColor;

        ctx.fillRect(
          groupSelector.ex - ((left > 0) ? 0 : -left),
          groupSelector.ey - ((top > 0) ? 0 : -top),
          aleft,
          atop
        );
      }

      if (!this.selectionLineWidth || !this.selectionBorderColor) {
        return;
      }
      ctx.lineWidth = this.selectionLineWidth;
      ctx.strokeStyle = this.selectionBorderColor;

      // selection border
      if (this.selectionDashArray.length > 1 && !supportLineDash) {

        var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
            py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop);

        ctx.beginPath();

        fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);
        fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);
        fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);
        fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);

        ctx.closePath();
        ctx.stroke();
      }
      else {
        fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);
        ctx.strokeRect(
          groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
          groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),
          aleft,
          atop
        );
      }
    },

    /**
     * Method that determines what object we are clicking on
     * the skipGroup parameter is for internal use, is needed for shift+click action
     * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target
     * or the outside part of the corner.
     * @param {Event} e mouse event
     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through
     * @return {fabric.Object} the target found
     */
    findTarget: function (e, skipGroup) {
      if (this.skipTargetFind) {
        return;
      }

      var ignoreZoom = true,
          pointer = this.getPointer(e, ignoreZoom),
          activeObject = this._activeObject,
          aObjects = this.getActiveObjects(),
          activeTarget, activeTargetSubs;

      // first check current group (if one exists)
      // active group does not check sub targets like normal groups.
      // if active group just exits.
      this.targets = [];

      if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([activeObject], pointer)) {
        return activeObject;
      }
      // if we hit the corner of an activeObject, let's return that.
      if (aObjects.length === 1 && activeObject._findTargetCorner(pointer)) {
        return activeObject;
      }
      if (aObjects.length === 1 &&
        activeObject === this._searchPossibleTargets([activeObject], pointer)) {
        if (!this.preserveObjectStacking) {
          return activeObject;
        }
        else {
          activeTarget = activeObject;
          activeTargetSubs = this.targets;
          this.targets = [];
        }
      }
      var target = this._searchPossibleTargets(this._objects, pointer);
      if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {
        target = activeTarget;
        this.targets = activeTargetSubs;
      }
      return target;
    },

    /**
     * Checks point is inside the object.
     * @param {Object} [pointer] x,y object of point coordinates we want to check.
     * @param {fabric.Object} obj Object to test against
     * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.
     * @return {Boolean} true if point is contained within an area of given object
     * @private
     */
    _checkTarget: function(pointer, obj, globalPointer) {
      if (obj &&
          obj.visible &&
          obj.evented &&
          this.containsPoint(null, obj, pointer)){
        if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
          var isTransparent = this.isTargetTransparent(obj, globalPointer.x, globalPointer.y);
          if (!isTransparent) {
            return true;
          }
        }
        else {
          return true;
        }
      }
    },

    /**
     * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted
     * @param {Array} [objects] objects array to look into
     * @param {Object} [pointer] x,y object of point coordinates we want to check.
     * @return {fabric.Object} object that contains pointer
     * @private
     */
    _searchPossibleTargets: function(objects, pointer) {
      // Cache all targets where their bounding box contains point.
      var target, i = objects.length, subTarget;
      // Do not check for currently grouped objects, since we check the parent group itself.
      // until we call this function specifically to search inside the activeGroup
      while (i--) {
        var objToCheck = objects[i];
        var pointerToUse = objToCheck.group && objToCheck.group.type !== 'activeSelection' ?
          this._normalizePointer(objToCheck.group, pointer) : pointer;
        if (this._checkTarget(pointerToUse, objToCheck, pointer)) {
          target = objects[i];
          if (target.subTargetCheck && target instanceof fabric.Group) {
            subTarget = this._searchPossibleTargets(target._objects, pointer);
            subTarget && this.targets.push(subTarget);
          }
          break;
        }
      }
      return target;
    },

    /**
     * Returns pointer coordinates without the effect of the viewport
     * @param {Object} pointer with "x" and "y" number values
     * @return {Object} object with "x" and "y" number values
     */
    restorePointerVpt: function(pointer) {
      return fabric.util.transformPoint(
        pointer,
        fabric.util.invertTransform(this.viewportTransform)
      );
    },

    /**
     * Returns pointer coordinates relative to canvas.
     * Can return coordinates with or without viewportTransform.
     * ignoreZoom false gives back coordinates that represent
     * the point clicked on canvas element.
     * ignoreZoom true gives back coordinates after being processed
     * by the viewportTransform ( sort of coordinates of what is displayed
     * on the canvas where you are clicking.
     * ignoreZoom true = HTMLElement coordinates relative to top,left
     * ignoreZoom false, default = fabric space coordinates, the same used for shape position
     * To interact with your shapes top and left you want to use ignoreZoom true
     * most of the time, while ignoreZoom false will give you coordinates
     * compatible with the object.oCoords system.
     * of the time.
     * @param {Event} e
     * @param {Boolean} ignoreZoom
     * @return {Object} object with "x" and "y" number values
     */
    getPointer: function (e, ignoreZoom) {
      // return cached values if we are in the event processing chain
      if (this._absolutePointer && !ignoreZoom) {
        return this._absolutePointer;
      }
      if (this._pointer && ignoreZoom) {
        return this._pointer;
      }

      var pointer = getPointer(e),
          upperCanvasEl = this.upperCanvasEl,
          bounds = upperCanvasEl.getBoundingClientRect(),
          boundsWidth = bounds.width || 0,
          boundsHeight = bounds.height || 0,
          cssScale;

      if (!boundsWidth || !boundsHeight ) {
        if ('top' in bounds && 'bottom' in bounds) {
          boundsHeight = Math.abs( bounds.top - bounds.bottom );
        }
        if ('right' in bounds && 'left' in bounds) {
          boundsWidth = Math.abs( bounds.right - bounds.left );
        }
      }

      this.calcOffset();
      pointer.x = pointer.x - this._offset.left;
      pointer.y = pointer.y - this._offset.top;
      if (!ignoreZoom) {
        pointer = this.restorePointerVpt(pointer);
      }

      if (boundsWidth === 0 || boundsHeight === 0) {
        // If bounds are not available (i.e. not visible), do not apply scale.
        cssScale = { width: 1, height: 1 };
      }
      else {
        cssScale = {
          width: upperCanvasEl.width / boundsWidth,
          height: upperCanvasEl.height / boundsHeight
        };
      }

      return {
        x: pointer.x * cssScale.width,
        y: pointer.y * cssScale.height
      };
    },

    /**
     * @private
     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
     */
    _createUpperCanvas: function () {
      var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, '');

      // there is no need to create a new upperCanvas element if we have already one.
      if (this.upperCanvasEl) {
        this.upperCanvasEl.className = '';
      }
      else {
        this.upperCanvasEl = this._createCanvasElement();
      }
      fabric.util.addClass(this.upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);

      this.wrapperEl.appendChild(this.upperCanvasEl);

      this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl);
      this._applyCanvasStyle(this.upperCanvasEl);
      this.contextTop = this.upperCanvasEl.getContext('2d');
    },

    /**
     * @private
     */
    _createCacheCanvas: function () {
      this.cacheCanvasEl = this._createCanvasElement();
      this.cacheCanvasEl.setAttribute('width', this.width);
      this.cacheCanvasEl.setAttribute('height', this.height);
      this.contextCache = this.cacheCanvasEl.getContext('2d');
    },

    /**
     * @private
     */
    _initWrapperElement: function () {
      this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {
        'class': this.containerClass
      });
      fabric.util.setStyle(this.wrapperEl, {
        width: this.width + 'px',
        height: this.height + 'px',
        position: 'relative'
      });
      fabric.util.makeElementUnselectable(this.wrapperEl);
    },

    /**
     * @private
     * @param {HTMLElement} element canvas element to apply styles on
     */
    _applyCanvasStyle: function (element) {
      var width = this.width || element.width,
          height = this.height || element.height;

      fabric.util.setStyle(element, {
        position: 'absolute',
        width: width + 'px',
        height: height + 'px',
        left: 0,
        top: 0,
        'touch-action': this.allowTouchScrolling ? 'manipulation' : 'none'
      });
      element.width = width;
      element.height = height;
      fabric.util.makeElementUnselectable(element);
    },

    /**
     * Copy the entire inline style from one element (fromEl) to another (toEl)
     * @private
     * @param {Element} fromEl Element style is copied from
     * @param {Element} toEl Element copied style is applied to
     */
    _copyCanvasStyle: function (fromEl, toEl) {
      toEl.style.cssText = fromEl.style.cssText;
    },

    /**
     * Returns context of canvas where object selection is drawn
     * @return {CanvasRenderingContext2D}
     */
    getSelectionContext: function() {
      return this.contextTop;
    },

    /**
     * Returns &lt;canvas> element on which object selection is drawn
     * @return {HTMLCanvasElement}
     */
    getSelectionElement: function () {
      return this.upperCanvasEl;
    },

    /**
     * Returns currently active object
     * @return {fabric.Object} active object
     */
    getActiveObject: function () {
      return this._activeObject;
    },

    /**
     * Returns an array with the current selected objects
     * @return {fabric.Object} active object
     */
    getActiveObjects: function () {
      var active = this._activeObject;
      if (active) {
        if (active.type === 'activeSelection' && active._objects) {
          return active._objects.slice(0);
        }
        else {
          return [active];
        }
      }
      return [];
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was removed
     */
    _onObjectRemoved: function(obj) {
      // removing active object should fire "selection:cleared" events
      if (obj === this._activeObject) {
        this.fire('before:selection:cleared', { target: obj });
        this._discardActiveObject();
        this.fire('selection:cleared', { target: obj });
        obj.fire('deselected');
      }
      if (this._hoveredTarget === obj) {
        this._hoveredTarget = null;
      }
      this.callSuper('_onObjectRemoved', obj);
    },

    /**
     * @private
     * Compares the old activeObject with the current one and fires correct events
     * @param {fabric.Object} obj old activeObject
     */
    _fireSelectionEvents: function(oldObjects, e) {
      var somethingChanged = false, objects = this.getActiveObjects(),
          added = [], removed = [], opt = { e: e };
      oldObjects.forEach(function(oldObject) {
        if (objects.indexOf(oldObject) === -1) {
          somethingChanged = true;
          oldObject.fire('deselected', opt);
          removed.push(oldObject);
        }
      });
      objects.forEach(function(object) {
        if (oldObjects.indexOf(object) === -1) {
          somethingChanged = true;
          object.fire('selected', opt);
          added.push(object);
        }
      });
      if (oldObjects.length > 0 && objects.length > 0) {
        opt.selected = added;
        opt.deselected = removed;
        // added for backward compatibility
        opt.updated = added[0] || removed[0];
        opt.target = this._activeObject;
        somethingChanged && this.fire('selection:updated', opt);
      }
      else if (objects.length > 0) {
        // deprecated event
        if (objects.length === 1) {
          opt.target = added[0];
          this.fire('object:selected', opt);
        }
        opt.selected = added;
        // added for backward compatibility
        opt.target = this._activeObject;
        this.fire('selection:created', opt);
      }
      else if (oldObjects.length > 0) {
        opt.deselected = removed;
        this.fire('selection:cleared', opt);
      }
    },

    /**
     * Sets given object as the only active object on canvas
     * @param {fabric.Object} object Object to set as an active one
     * @param {Event} [e] Event (passed along when firing "object:selected")
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    setActiveObject: function (object, e) {
      var currentActives = this.getActiveObjects();
      this._setActiveObject(object, e);
      this._fireSelectionEvents(currentActives, e);
      return this;
    },

    /**
     * @private
     * @param {Object} object to set as active
     * @param {Event} [e] Event (passed along when firing "object:selected")
     * @return {Boolean} true if the selection happened
     */
    _setActiveObject: function(object, e) {
      if (this._activeObject === object) {
        return false;
      }
      if (!this._discardActiveObject(e, object)) {
        return false;
      }
      if (object.onSelect({ e: e })) {
        return false;
      }
      this._activeObject = object;
      return true;
    },

    /**
     * @private
     */
    _discardActiveObject: function(e, object) {
      var obj = this._activeObject;
      if (obj) {
        // onDeselect return TRUE to cancel selection;
        if (obj.onDeselect({ e: e, object: object })) {
          return false;
        }
        this._activeObject = null;
      }
      return true;
    },

    /**
     * Discards currently active object and fire events. If the function is called by fabric
     * as a consequence of a mouse event, the event is passed as a parameter and
     * sent to the fire function for the custom events. When used as a method the
     * e param does not have any application.
     * @param {event} e
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    discardActiveObject: function (e) {
      var currentActives = this.getActiveObjects();
      if (currentActives.length) {
        this.fire('before:selection:cleared', { target: currentActives[0], e: e });
      }
      this._discardActiveObject(e);
      this._fireSelectionEvents(currentActives, e);
      return this;
    },

    /**
     * Clears a canvas element and removes all event listeners
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    dispose: function () {
      var wrapper = this.wrapperEl;
      this.removeListeners();
      wrapper.removeChild(this.upperCanvasEl);
      wrapper.removeChild(this.lowerCanvasEl);
      this.contextCache = null;
      this.contextTop = null;
      ['upperCanvasEl', 'cacheCanvasEl'].forEach((function(element) {
        fabric.util.cleanUpJsdomNode(this[element]);
        this[element] = undefined;
      }).bind(this));
      if (wrapper.parentNode) {
        wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);
      }
      delete this.wrapperEl;
      fabric.StaticCanvas.prototype.dispose.call(this);
      return this;
    },

    /**
     * Clears all contexts (background, main, top) of an instance
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clear: function () {
      // this.discardActiveGroup();
      this.discardActiveObject();
      this.clearContext(this.contextTop);
      return this.callSuper('clear');
    },

    /**
     * Draws objects' controls (borders/controls)
     * @param {CanvasRenderingContext2D} ctx Context to render controls on
     */
    drawControls: function(ctx) {
      var activeObject = this._activeObject;

      if (activeObject) {
        activeObject._renderControls(ctx);
      }
    },

    /**
     * @private
     */
    _toObject: function(instance, methodName, propertiesToInclude) {
      //If the object is part of the current selection group, it should
      //be transformed appropriately
      //i.e. it should be serialised as it would appear if the selection group
      //were to be destroyed.
      var originalProperties = this._realizeGroupTransformOnObject(instance),
          object = this.callSuper('_toObject', instance, methodName, propertiesToInclude);
      //Undo the damage we did by changing all of its properties
      this._unwindGroupTransformOnObject(instance, originalProperties);
      return object;
    },

    /**
     * Realises an object's group transformation on it
     * @private
     * @param {fabric.Object} [instance] the object to transform (gets mutated)
     * @returns the original values of instance which were changed
     */
    _realizeGroupTransformOnObject: function(instance) {
      if (instance.group && instance.group.type === 'activeSelection' && this._activeObject === instance.group) {
        var layoutProps = ['angle', 'flipX', 'flipY', 'left', 'scaleX', 'scaleY', 'skewX', 'skewY', 'top'];
        //Copy all the positionally relevant properties across now
        var originalValues = {};
        layoutProps.forEach(function(prop) {
          originalValues[prop] = instance[prop];
        });
        this._activeObject.realizeTransform(instance);
        return originalValues;
      }
      else {
        return null;
      }
    },

    /**
     * Restores the changed properties of instance
     * @private
     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
     */
    _unwindGroupTransformOnObject: function(instance, originalValues) {
      if (originalValues) {
        instance.set(originalValues);
      }
    },

    /**
     * @private
     */
    _setSVGObject: function(markup, instance, reviver) {
      //If the object is in a selection group, simulate what would happen to that
      //object when the group is deselected
      var originalProperties = this._realizeGroupTransformOnObject(instance);
      this.callSuper('_setSVGObject', markup, instance, reviver);
      this._unwindGroupTransformOnObject(instance, originalProperties);
    },

    setViewportTransform: function (vpt) {
      if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {
        this._activeObject.clearContextTop();
      }
      fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);
    }
  });

  // copying static properties manually to work around Opera's bug,
  // where "prototype" property is enumerable and overrides existing prototype
  for (var prop in fabric.StaticCanvas) {
    if (prop !== 'prototype') {
      fabric.Canvas[prop] = fabric.StaticCanvas[prop];
    }
  }

  if (fabric.isTouchSupported) {
    /** @ignore */
    fabric.Canvas.prototype._setCursorFromEvent = function() { };
  }
})();


(function() {

  var cursorOffset = {
        mt: 0, // n
        tr: 1, // ne
        mr: 2, // e
        br: 3, // se
        mb: 4, // s
        bl: 5, // sw
        ml: 6, // w
        tl: 7 // nw
      },
      addListener = fabric.util.addListener,
      removeListener = fabric.util.removeListener,
      RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1,
      addEventOptions = { passive: false };

  function checkClick(e, value) {
    return 'which' in e ? e.which === value : e.button === value - 1;
  }

  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

    /**
     * Map of cursor style values for each of the object controls
     * @private
     */
    cursorMap: [
      'n-resize',
      'ne-resize',
      'e-resize',
      'se-resize',
      's-resize',
      'sw-resize',
      'w-resize',
      'nw-resize'
    ],

    /**
     * Adds mouse listeners to canvas
     * @private
     */
    _initEventListeners: function () {
      // in case we initialized the class twice. This should not happen normally
      // but in some kind of applications where the canvas element may be changed
      // this is a workaround to having double listeners.
      this.removeListeners();
      this._bindEvents();
      this.addOrRemove(addListener, 'add');
    },

    addOrRemove: function(functor, eventjsFunctor) {
      functor(fabric.window, 'resize', this._onResize);
      functor(this.upperCanvasEl, 'mousedown', this._onMouseDown);
      functor(this.upperCanvasEl, 'mousemove', this._onMouseMove, addEventOptions);
      functor(this.upperCanvasEl, 'mouseout', this._onMouseOut);
      functor(this.upperCanvasEl, 'mouseenter', this._onMouseEnter);
      functor(this.upperCanvasEl, 'wheel', this._onMouseWheel);
      functor(this.upperCanvasEl, 'contextmenu', this._onContextMenu);
      functor(this.upperCanvasEl, 'dblclick', this._onDoubleClick);
      functor(this.upperCanvasEl, 'touchstart', this._onMouseDown, addEventOptions);
      functor(this.upperCanvasEl, 'touchmove', this._onMouseMove, addEventOptions);
      functor(this.upperCanvasEl, 'dragover', this._onDragOver);
      functor(this.upperCanvasEl, 'dragenter', this._onDragEnter);
      functor(this.upperCanvasEl, 'dragleave', this._onDragLeave);
      functor(this.upperCanvasEl, 'drop', this._onDrop);
      if (typeof eventjs !== 'undefined' && eventjsFunctor in eventjs) {
        eventjs[eventjsFunctor](this.upperCanvasEl, 'gesture', this._onGesture);
        eventjs[eventjsFunctor](this.upperCanvasEl, 'drag', this._onDrag);
        eventjs[eventjsFunctor](this.upperCanvasEl, 'orientation', this._onOrientationChange);
        eventjs[eventjsFunctor](this.upperCanvasEl, 'shake', this._onShake);
        eventjs[eventjsFunctor](this.upperCanvasEl, 'longpress', this._onLongPress);
      }
    },

    /**
     * Removes all event listeners
     */
    removeListeners: function() {
      this.addOrRemove(removeListener, 'remove');
      // if you dispose on a mouseDown, before mouse up, you need to clean document to...
      removeListener(fabric.document, 'mouseup', this._onMouseUp);
      removeListener(fabric.document, 'touchend', this._onMouseUp, addEventOptions);
      removeListener(fabric.document, 'mousemove', this._onMouseMove, addEventOptions);
      removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
    },

    /**
     * @private
     */
    _bindEvents: function() {
      if (this.eventsBound) {
        // for any reason we pass here twice we do not want to bind events twice.
        return;
      }
      this._onMouseDown = this._onMouseDown.bind(this);
      this._onMouseMove = this._onMouseMove.bind(this);
      this._onMouseUp = this._onMouseUp.bind(this);
      this._onResize = this._onResize.bind(this);
      this._onGesture = this._onGesture.bind(this);
      this._onDrag = this._onDrag.bind(this);
      this._onShake = this._onShake.bind(this);
      this._onLongPress = this._onLongPress.bind(this);
      this._onOrientationChange = this._onOrientationChange.bind(this);
      this._onMouseWheel = this._onMouseWheel.bind(this);
      this._onMouseOut = this._onMouseOut.bind(this);
      this._onMouseEnter = this._onMouseEnter.bind(this);
      this._onContextMenu = this._onContextMenu.bind(this);
      this._onDoubleClick = this._onDoubleClick.bind(this);
      this._onDragOver = this._onDragOver.bind(this);
      this._onDragEnter = this._simpleEventHandler.bind(this, 'dragenter');
      this._onDragLeave = this._simpleEventHandler.bind(this, 'dragleave');
      this._onDrop = this._simpleEventHandler.bind(this, 'drop');
      this.eventsBound = true;
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js gesture
     * @param {Event} [self] Inner Event object
     */
    _onGesture: function(e, self) {
      this.__onTransformGesture && this.__onTransformGesture(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js drag
     * @param {Event} [self] Inner Event object
     */
    _onDrag: function(e, self) {
      this.__onDrag && this.__onDrag(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on wheel event
     */
    _onMouseWheel: function(e) {
      this.__onMouseWheel(e);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseOut: function(e) {
      var target = this._hoveredTarget;
      this.fire('mouse:out', { target: target, e: e });
      this._hoveredTarget = null;
      target && target.fire('mouseout', { e: e });
      if (this._iTextInstances) {
        this._iTextInstances.forEach(function(obj) {
          if (obj.isEditing) {
            obj.hiddenTextarea.focus();
          }
        });
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseenter
     */
    _onMouseEnter: function(e) {
      if (!this.findTarget(e)) {
        this.fire('mouse:over', { target: null, e: e });
        this._hoveredTarget = null;
      }
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js orientation change
     * @param {Event} [self] Inner Event object
     */
    _onOrientationChange: function(e, self) {
      this.__onOrientationChange && this.__onOrientationChange(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     * @param {Event} [self] Inner Event object
     */
    _onShake: function(e, self) {
      this.__onShake && this.__onShake(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     * @param {Event} [self] Inner Event object
     */
    _onLongPress: function(e, self) {
      this.__onLongPress && this.__onLongPress(e, self);
    },

    /**
     * prevent default to allow drop event to be fired
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     */
    _onDragOver: function(e) {
      e.preventDefault();
      var target = this._simpleEventHandler('dragover', e);
      this._fireEnterLeaveEvents(target, e);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onContextMenu: function (e) {
      if (this.stopContextMenu) {
        e.stopPropagation();
        e.preventDefault();
      }
      return false;
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onDoubleClick: function (e) {
      this._cacheTransformEventData(e);
      this._handleEvent(e, 'dblclick');
      this._resetTransformEventData(e);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseDown: function (e) {
      this.__onMouseDown(e);
      this._resetTransformEventData();
      addListener(fabric.document, 'touchend', this._onMouseUp, addEventOptions);
      addListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);

      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove, addEventOptions);
      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove, addEventOptions);

      if (e.type === 'touchstart') {
        // Unbind mousedown to prevent double triggers from touch devices
        removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
      }
      else {
        addListener(fabric.document, 'mouseup', this._onMouseUp);
        addListener(fabric.document, 'mousemove', this._onMouseMove, addEventOptions);
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    _onMouseUp: function (e) {
      this.__onMouseUp(e);
      this._resetTransformEventData();
      removeListener(fabric.document, 'mouseup', this._onMouseUp);
      removeListener(fabric.document, 'touchend', this._onMouseUp, addEventOptions);

      removeListener(fabric.document, 'mousemove', this._onMouseMove, addEventOptions);
      removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);

      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove, addEventOptions);
      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove, addEventOptions);

      if (e.type === 'touchend') {
        // Wait 400ms before rebinding mousedown to prevent double triggers
        // from touch devices
        var _this = this;
        setTimeout(function() {
          addListener(_this.upperCanvasEl, 'mousedown', _this._onMouseDown);
        }, 400);
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    _onMouseMove: function (e) {
      !this.allowTouchScrolling && e.preventDefault && e.preventDefault();
      this.__onMouseMove(e);
    },

    /**
     * @private
     */
    _onResize: function () {
      this.calcOffset();
    },

    /**
     * Decides whether the canvas should be redrawn in mouseup and mousedown events.
     * @private
     * @param {Object} target
     */
    _shouldRender: function(target) {
      var activeObject = this._activeObject;

      if (
        !!activeObject !== !!target ||
        (activeObject && target && (activeObject !== target))
      ) {
        // this covers: switch of target, from target to no target, selection of target
        // multiSelection with key and mouse
        return true;
      }
      else if (activeObject && activeObject.isEditing) {
        // if we mouse up/down over a editing textbox a cursor change,
        // there is no need to re render
        return false;
      }
      return false;
    },

    /**
     * Method that defines the actions when mouse is released on canvas.
     * The method resets the currentTransform parameters, store the image corner
     * position in the image object and render the canvas on top.
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    __onMouseUp: function (e) {
      var target, transform = this._currentTransform,
          groupSelector = this._groupSelector, shouldRender = false,
          isClick = (!groupSelector || (groupSelector.left === 0 && groupSelector.top === 0));
      this._cacheTransformEventData(e);
      target = this._target;
      this._handleEvent(e, 'up:before');
      // if right/middle click just fire events and return
      // target undefined will make the _handleEvent search the target
      if (checkClick(e, RIGHT_CLICK)) {
        if (this.fireRightClick) {
          this._handleEvent(e, 'up', RIGHT_CLICK, isClick);
        }
        return;
      }

      if (checkClick(e, MIDDLE_CLICK)) {
        if (this.fireMiddleClick) {
          this._handleEvent(e, 'up', MIDDLE_CLICK, isClick);
        }
        this._resetTransformEventData();
        return;
      }

      if (this.isDrawingMode && this._isCurrentlyDrawing) {
        this._onMouseUpInDrawingMode(e);
        return;
      }

      if (transform) {
        this._finalizeCurrentTransform(e);
        shouldRender = transform.actionPerformed;
      }

      if (!isClick) {
        this._maybeGroupObjects(e);
        shouldRender || (shouldRender = this._shouldRender(target));
      }
      if (target) {
        target.isMoving = false;
      }
      this._setCursorFromEvent(e, target);
      this._handleEvent(e, 'up', LEFT_CLICK, isClick);
      this._groupSelector = null;
      this._currentTransform = null;
      // reset the target information about which corner is selected
      target && (target.__corner = 0);
      if (shouldRender) {
        this.requestRenderAll();
      }
      else if (!isClick) {
        this.renderTop();
      }
    },

    /**
     * @private
     * Handle event firing for target and subtargets
     * @param {Event} e event from mouse
     * @param {String} eventType event to fire (up, down or move)
     * @return {Fabric.Object} target return the the target found, for internal reasons.
     */
    _simpleEventHandler: function(eventType, e) {
      var target = this.findTarget(e),
          targets = this.targets,
          options = {
            e: e,
            target: target,
            subTargets: targets,
          };
      this.fire(eventType, options);
      target && target.fire(eventType, options);
      if (!targets) {
        return target;
      }
      for (var i = 0; i < targets.length; i++) {
        targets[i].fire(eventType, options);
      }
      return target;
    },

    /**
     * @private
     * Handle event firing for target and subtargets
     * @param {Event} e event from mouse
     * @param {String} eventType event to fire (up, down or move)
     * @param {fabric.Object} targetObj receiving event
     * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right
     * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.
     */
    _handleEvent: function(e, eventType, button, isClick) {
      var target = this._target,
          targets = this.targets || [],
          options = {
            e: e,
            target: target,
            subTargets: targets,
            button: button || LEFT_CLICK,
            isClick: isClick || false,
            pointer: this._pointer,
            absolutePointer: this._absolutePointer,
            transform: this._currentTransform
          };
      this.fire('mouse:' + eventType, options);
      target && target.fire('mouse' + eventType, options);
      for (var i = 0; i < targets.length; i++) {
        targets[i].fire('mouse' + eventType, options);
      }
    },

    /**
     * @private
     * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event
     */
    _finalizeCurrentTransform: function(e) {

      var transform = this._currentTransform,
          target = transform.target,
          eventName,
          options = {
            e: e,
            target: target,
            transform: transform,
          };

      if (target._scaling) {
        target._scaling = false;
      }

      target.setCoords();

      if (transform.actionPerformed || (this.stateful && target.hasStateChanged())) {
        if (transform.actionPerformed) {
          eventName = this._addEventOptions(options, transform);
          this._fire(eventName, options);
        }
        this._fire('modified', options);
      }
    },

    /**
     * Mutate option object in order to add by property and give back the event name.
     * @private
     * @param {Object} options to mutate
     * @param {Object} transform to inspect action from
     */
    _addEventOptions: function(options, transform) {
      // we can probably add more details at low cost
      // scale change, rotation changes, translation changes
      var eventName, by;
      switch (transform.action) {
        case 'scaleX':
          eventName = 'scaled';
          by = 'x';
          break;
        case 'scaleY':
          eventName = 'scaled';
          by = 'y';
          break;
        case 'skewX':
          eventName = 'skewed';
          by = 'x';
          break;
        case 'skewY':
          eventName = 'skewed';
          by = 'y';
          break;
        case 'scale':
          eventName = 'scaled';
          by = 'equally';
          break;
        case 'rotate':
          eventName = 'rotated';
          break;
        case 'drag':
          eventName = 'moved';
          break;
      }
      options.by = by;
      return eventName;
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseDownInDrawingMode: function(e) {
      this._isCurrentlyDrawing = true;
      if (this.getActiveObject()) {
        this.discardActiveObject(e).requestRenderAll();
      }
      if (this.clipTo) {
        fabric.util.clipContext(this, this.contextTop);
      }
      var pointer = this.getPointer(e);
      this.freeDrawingBrush.onMouseDown(pointer);
      this._handleEvent(e, 'down');
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    _onMouseMoveInDrawingMode: function(e) {
      if (this._isCurrentlyDrawing) {
        var pointer = this.getPointer(e);
        this.freeDrawingBrush.onMouseMove(pointer);
      }
      this.setCursor(this.freeDrawingCursor);
      this._handleEvent(e, 'move');
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    _onMouseUpInDrawingMode: function(e) {
      this._isCurrentlyDrawing = false;
      if (this.clipTo) {
        this.contextTop.restore();
      }
      this.freeDrawingBrush.onMouseUp();
      this._handleEvent(e, 'up');
    },

    /**
     * Method that defines the actions when mouse is clicked on canvas.
     * The method inits the currentTransform parameters and renders all the
     * canvas so the current image can be placed on the top canvas and the rest
     * in on the container one.
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    __onMouseDown: function (e) {
      this._cacheTransformEventData(e);
      this._handleEvent(e, 'down:before');
      var target = this._target;
      // if right click just fire events
      if (checkClick(e, RIGHT_CLICK)) {
        if (this.fireRightClick) {
          this._handleEvent(e, 'down', RIGHT_CLICK);
        }
        return;
      }

      if (checkClick(e, MIDDLE_CLICK)) {
        if (this.fireMiddleClick) {
          this._handleEvent(e, 'down', MIDDLE_CLICK);
        }
        return;
      }

      if (this.isDrawingMode) {
        this._onMouseDownInDrawingMode(e);
        return;
      }

      // ignore if some object is being transformed at this moment
      if (this._currentTransform) {
        return;
      }

      var pointer = this._pointer;
      // save pointer for check in __onMouseUp event
      this._previousPointer = pointer;
      var shouldRender = this._shouldRender(target),
          shouldGroup = this._shouldGroup(e, target);
      if (this._shouldClearSelection(e, target)) {
        this.discardActiveObject(e);
      }
      else if (shouldGroup) {
        this._handleGrouping(e, target);
        target = this._activeObject;
      }

      if (this.selection && (!target ||
        (!target.selectable && !target.isEditing && target !== this._activeObject))) {
        this._groupSelector = {
          ex: pointer.x,
          ey: pointer.y,
          top: 0,
          left: 0
        };
      }

      if (target) {
        var alreadySelected = target === this._activeObject;
        if (target.selectable) {
          this.setActiveObject(target, e);
        }
        if (target === this._activeObject && (target.__corner || !shouldGroup)) {
          this._setupCurrentTransform(e, target, alreadySelected);
        }
      }
      this._handleEvent(e, 'down');
      // we must renderAll so that we update the visuals
      (shouldRender || shouldGroup) && this.requestRenderAll();
    },

    /**
     * reset cache form common information needed during event processing
     * @private
     */
    _resetTransformEventData: function() {
      this._target = null;
      this._pointer = null;
      this._absolutePointer = null;
    },

    /**
     * Cache common information needed during event processing
     * @private
     * @param {Event} e Event object fired on event
     */
    _cacheTransformEventData: function(e) {
      // reset in order to avoid stale caching
      this._resetTransformEventData();
      this._pointer = this.getPointer(e, true);
      this._absolutePointer = this.restorePointerVpt(this._pointer);
      this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e) || null;
    },

    /**
     * @private
     */
    _beforeTransform: function(e) {
      var t = this._currentTransform;
      this.stateful && t.target.saveState();
      this.fire('before:transform', {
        e: e,
        transform: t,
      });
      // determine if it's a drag or rotate case
      if (t.corner) {
        this.onBeforeScaleRotate(t.target);
      }
    },

    /**
     * Method that defines the actions when mouse is hovering the canvas.
     * The currentTransform parameter will definde whether the user is rotating/scaling/translating
     * an image or neither of them (only hovering). A group selection is also possible and would cancel
     * all any other type of action.
     * In case of an image transformation only the top canvas will be rendered.
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    __onMouseMove: function (e) {
      this._handleEvent(e, 'move:before');
      this._cacheTransformEventData(e);
      var target, pointer;

      if (this.isDrawingMode) {
        this._onMouseMoveInDrawingMode(e);
        return;
      }
      if (typeof e.touches !== 'undefined' && e.touches.length > 1) {
        return;
      }

      var groupSelector = this._groupSelector;

      // We initially clicked in an empty area, so we draw a box for multiple selection
      if (groupSelector) {
        pointer = this._pointer;

        groupSelector.left = pointer.x - groupSelector.ex;
        groupSelector.top = pointer.y - groupSelector.ey;

        this.renderTop();
      }
      else if (!this._currentTransform) {
        target = this.findTarget(e) || null;
        this._setCursorFromEvent(e, target);
        this._fireOverOutEvents(target, e);
      }
      else {
        this._transformObject(e);
      }
      this._handleEvent(e, 'move');
      this._resetTransformEventData();
    },

    /**
     * Manage the mouseout, mouseover events for the fabric object on the canvas
     * @param {Fabric.Object} target the target where the target from the mousemove event
     * @param {Event} e Event object fired on mousemove
     * @private
     */
    _fireOverOutEvents: function(target, e) {
      this.fireSynteticInOutEvents(target, e, {
        targetName: '_hoveredTarget',
        canvasEvtOut: 'mouse:out',
        evtOut: 'mouseout',
        canvasEvtIn: 'mouse:over',
        evtIn: 'mouseover',
      });
    },

    /**
     * Manage the dragEnter, dragLeave events for the fabric objects on the canvas
     * @param {Fabric.Object} target the target where the target from the onDrag event
     * @param {Event} e Event object fired on ondrag
     * @private
     */
    _fireEnterLeaveEvents: function(target, e) {
      this.fireSynteticInOutEvents(target, e, {
        targetName: '_draggedoverTarget',
        evtOut: 'dragleave',
        evtIn: 'dragenter',
      });
    },

    /**
     * Manage the syntetic in/out events for the fabric objects on the canvas
     * @param {Fabric.Object} target the target where the target from the supported events
     * @param {Event} e Event object fired
     * @param {Object} config configuration for the function to work
     * @param {String} config.targetName property on the canvas where the old target is stored
     * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out
     * @param {String} config.evtOut name of the event to fire for out
     * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in
     * @param {String} config.evtIn name of the event to fire for in
     * @private
     */
    fireSynteticInOutEvents: function(target, e, config) {
      var inOpt, outOpt, oldTarget = this[config.targetName], outFires, inFires,
          targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;
      if (targetChanged) {
        inOpt = { e: e, target: target, previousTarget: oldTarget };
        outOpt = { e: e, target: oldTarget, nextTarget: target };
        this[config.targetName] = target;
      }
      inFires = target && targetChanged;
      outFires = oldTarget && targetChanged;
      if (outFires) {
        canvasEvtOut && this.fire(canvasEvtOut, outOpt);
        oldTarget.fire(config.evtOut, outOpt);
      }
      if (inFires) {
        canvasEvtIn && this.fire(canvasEvtIn, inOpt);
        target.fire(config.evtIn, inOpt);
      }
    },

    /**
     * Method that defines actions when an Event Mouse Wheel
     * @param {Event} e Event object fired on mouseup
     */
    __onMouseWheel: function(e) {
      this._cacheTransformEventData(e);
      this._handleEvent(e, 'wheel');
      this._resetTransformEventData();
    },

    /**
     * @private
     * @param {Event} e Event fired on mousemove
     */
    _transformObject: function(e) {
      var pointer = this.getPointer(e),
          transform = this._currentTransform;

      transform.reset = false;
      transform.target.isMoving = true;
      transform.shiftKey = e.shiftKey;
      transform.altKey = e[this.centeredKey];

      this._beforeScaleTransform(e, transform);
      this._performTransformAction(e, transform, pointer);

      transform.actionPerformed && this.requestRenderAll();
    },

    /**
     * @private
     */
    _performTransformAction: function(e, transform, pointer) {
      var x = pointer.x,
          y = pointer.y,
          action = transform.action,
          actionPerformed = false,
          options = {
            target: transform.target,
            e: e,
            transform: transform,
            pointer: pointer
          };

      if (action === 'rotate') {
        (actionPerformed = this._rotateObject(x, y)) && this._fire('rotating', options);
      }
      else if (action === 'scale') {
        (actionPerformed = this._onScale(e, transform, x, y)) && this._fire('scaling', options);
      }
      else if (action === 'scaleX') {
        (actionPerformed = this._scaleObject(x, y, 'x')) && this._fire('scaling', options);
      }
      else if (action === 'scaleY') {
        (actionPerformed = this._scaleObject(x, y, 'y')) && this._fire('scaling', options);
      }
      else if (action === 'skewX') {
        (actionPerformed = this._skewObject(x, y, 'x')) && this._fire('skewing', options);
      }
      else if (action === 'skewY') {
        (actionPerformed = this._skewObject(x, y, 'y')) && this._fire('skewing', options);
      }
      else {
        actionPerformed = this._translateObject(x, y);
        if (actionPerformed) {
          this._fire('moving', options);
          this.setCursor(options.target.moveCursor || this.moveCursor);
        }
      }
      transform.actionPerformed = transform.actionPerformed || actionPerformed;
    },

    /**
     * @private
     */
    _fire: function(eventName, options) {
      this.fire('object:' + eventName, options);
      options.target.fire(eventName, options);
    },

    /**
     * @private
     */
    _beforeScaleTransform: function(e, transform) {
      if (transform.action === 'scale' || transform.action === 'scaleX' || transform.action === 'scaleY') {
        var centerTransform = this._shouldCenterTransform(transform.target);

        // Switch from a normal resize to center-based
        if ((centerTransform && (transform.originX !== 'center' || transform.originY !== 'center')) ||
           // Switch from center-based resize to normal one
           (!centerTransform && transform.originX === 'center' && transform.originY === 'center')
        ) {
          this._resetCurrentTransform();
          transform.reset = true;
        }
      }
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {Object} transform current tranform
     * @param {Number} x mouse position x from origin
     * @param {Number} y mouse poistion y from origin
     * @return {Boolean} true if the scaling occurred
     */
    _onScale: function(e, transform, x, y) {
      if (this._isUniscalePossible(e, transform.target)) {
        transform.currentAction = 'scale';
        return this._scaleObject(x, y);
      }
      else {
        // Switch from a normal resize to proportional
        if (!transform.reset && transform.currentAction === 'scale') {
          this._resetCurrentTransform();
        }

        transform.currentAction = 'scaleEqually';
        return this._scaleObject(x, y, 'equally');
      }
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target current target
     * @return {Boolean} true if unproportional scaling is possible
     */
    _isUniscalePossible: function(e, target) {
      return (e[this.uniScaleKey] || this.uniScaleTransform) && !target.get('lockUniScaling');
    },

    /**
     * Sets the cursor depending on where the canvas is being hovered.
     * Note: very buggy in Opera
     * @param {Event} e Event object
     * @param {Object} target Object that the mouse is hovering, if so.
     */
    _setCursorFromEvent: function (e, target) {
      if (!target) {
        this.setCursor(this.defaultCursor);
        return false;
      }

      var hoverCursor = target.hoverCursor || this.hoverCursor,
          activeSelection = this._activeObject && this._activeObject.type === 'activeSelection' ?
            this._activeObject : null,
          // only show proper corner when group selection is not active
          corner = (!activeSelection || !activeSelection.contains(target))
                    && target._findTargetCorner(this.getPointer(e, true));

      if (!corner) {
        this.setCursor(hoverCursor);
      }
      else {
        this.setCursor(this.getCornerCursor(corner, target, e));
      }
    },

    /**
     * @private
     */
    getCornerCursor: function(corner, target, e) {
      if (this.actionIsDisabled(corner, target, e)) {
        return this.notAllowedCursor;
      }
      else if (corner in cursorOffset) {
        return this._getRotatedCornerCursor(corner, target, e);
      }
      else if (corner === 'mtr' && target.hasRotatingPoint) {
        return this.rotationCursor;
      }
      else {
        return this.defaultCursor;
      }
    },

    actionIsDisabled: function(corner, target, e) {
      if (corner === 'mt' || corner === 'mb') {
        return e[this.altActionKey] ? target.lockSkewingX : target.lockScalingY;
      }
      else if (corner === 'ml' || corner === 'mr') {
        return e[this.altActionKey] ? target.lockSkewingY : target.lockScalingX;
      }
      else if (corner === 'mtr') {
        return target.lockRotation;
      }
      else {
        return this._isUniscalePossible(e, target) ?
          target.lockScalingX && target.lockScalingY : target.lockScalingX || target.lockScalingY;
      }
    },

    /**
     * @private
     */
    _getRotatedCornerCursor: function(corner, target, e) {
      var n = Math.round((target.angle % 360) / 45);

      if (n < 0) {
        n += 8; // full circle ahead
      }
      n += cursorOffset[corner];
      if (e[this.altActionKey] && cursorOffset[corner] % 2 === 0) {
        //if we are holding shift and we are on a mx corner...
        n += 2;
      }
      // normalize n to be from 0 to 7
      n %= 8;

      return this.cursorMap[n];
    }
  });
})();


(function() {

  var min = Math.min,
      max = Math.max;

  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     * @return {Boolean}
     */
    _shouldGroup: function(e, target) {
      var activeObject = this._activeObject;
      return activeObject && this._isSelectionKeyPressed(e) && target && target.selectable && this.selection &&
            (activeObject !== target || activeObject.type === 'activeSelection') && !target.onSelect({ e: e });
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _handleGrouping: function (e, target) {
      var activeObject = this._activeObject;
      // avoid multi select when shift click on a corner
      if (activeObject.__corner) {
        return;
      }
      if (target === activeObject) {
        // if it's a group, find target again, using activeGroup objects
        target = this.findTarget(e, true);
        // if even object is not found or we are on activeObjectCorner, bail out
        if (!target || !target.selectable) {
          return;
        }
      }
      if (activeObject && activeObject.type === 'activeSelection') {
        this._updateActiveSelection(target, e);
      }
      else {
        this._createActiveSelection(target, e);
      }
    },

    /**
     * @private
     */
    _updateActiveSelection: function(target, e) {
      var activeSelection = this._activeObject,
          currentActiveObjects = activeSelection._objects.slice(0);
      if (activeSelection.contains(target)) {
        activeSelection.removeWithUpdate(target);
        this._hoveredTarget = target;
        if (activeSelection.size() === 1) {
          // activate last remaining object
          this._setActiveObject(activeSelection.item(0), e);
        }
      }
      else {
        activeSelection.addWithUpdate(target);
        this._hoveredTarget = activeSelection;
      }
      this._fireSelectionEvents(currentActiveObjects, e);
    },

    /**
     * @private
     */
    _createActiveSelection: function(target, e) {
      var currentActives = this.getActiveObjects(), group = this._createGroup(target);
      this._hoveredTarget = group;
      this._setActiveObject(group, e);
      this._fireSelectionEvents(currentActives, e);
    },

    /**
     * @private
     * @param {Object} target
     */
    _createGroup: function(target) {
      var objects = this._objects,
          isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),
          groupObjects = isActiveLower
            ? [this._activeObject, target]
            : [target, this._activeObject];
      this._activeObject.isEditing && this._activeObject.exitEditing();
      return new fabric.ActiveSelection(groupObjects, {
        canvas: this
      });
    },

    /**
     * @private
     * @param {Event} e mouse event
     */
    _groupSelectedObjects: function (e) {

      var group = this._collectObjects(e),
          aGroup;

      // do not create group for 1 element only
      if (group.length === 1) {
        this.setActiveObject(group[0], e);
      }
      else if (group.length > 1) {
        aGroup = new fabric.ActiveSelection(group.reverse(), {
          canvas: this
        });
        this.setActiveObject(aGroup, e);
      }
    },

    /**
     * @private
     */
    _collectObjects: function(e) {
      var group = [],
          currentObject,
          x1 = this._groupSelector.ex,
          y1 = this._groupSelector.ey,
          x2 = x1 + this._groupSelector.left,
          y2 = y1 + this._groupSelector.top,
          selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),
          selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),
          allowIntersect = !this.selectionFullyContained,
          isClick = x1 === x2 && y1 === y2;
      // we iterate reverse order to collect top first in case of click.
      for (var i = this._objects.length; i--; ) {
        currentObject = this._objects[i];

        if (!currentObject || !currentObject.selectable || !currentObject.visible || currentObject.onSelect({ e: e })) {
          continue;
        }

        if ((allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2)) ||
            currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||
            (allowIntersect && currentObject.containsPoint(selectionX1Y1)) ||
            (allowIntersect && currentObject.containsPoint(selectionX2Y2))
        ) {
          group.push(currentObject);

          // only add one object if it's a click
          if (isClick) {
            break;
          }
        }
      }

      return group;
    },

    /**
     * @private
     */
    _maybeGroupObjects: function(e) {
      if (this.selection && this._groupSelector) {
        this._groupSelectedObjects(e);
      }
      this.setCursor(this.defaultCursor);
      // clear selection and current transformation
      this._groupSelector = null;
    }
  });

})();


(function () {
  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
     * @param {Object} [options] Options object
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
     * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
     * @example <caption>Generate jpeg dataURL with lower quality</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'jpeg',
     *   quality: 0.8
     * });
     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'png',
     *   left: 100,
     *   top: 100,
     *   width: 200,
     *   height: 200
     * });
     * @example <caption>Generate double scaled png dataURL</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'png',
     *   multiplier: 2
     * });
     */
    toDataURL: function (options) {
      options || (options = { });

      var format = options.format || 'png',
          quality = options.quality || 1,
          multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? this.getRetinaScaling() : 1),
          canvasEl = this.toCanvasElement(multiplier, options);
      return fabric.util.toDataURL(canvasEl, format, quality);
    },

    /**
     * Create a new HTMLCanvas element painted with the current canvas content.
     * No need to resize the actual one or repaint it.
     * Will transfer object ownership to a new canvas, paint it, and set everything back.
     * This is an intermediary step used to get to a dataUrl but also it is usefull to
     * create quick image copies of a canvas without passing for the dataUrl string
     * @param {Number} [multiplier] a zoom factor.
     * @param {Object} [cropping] Cropping informations
     * @param {Number} [cropping.left] Cropping left offset.
     * @param {Number} [cropping.top] Cropping top offset.
     * @param {Number} [cropping.width] Cropping width.
     * @param {Number} [cropping.height] Cropping height.
     */
    toCanvasElement: function(multiplier, cropping) {
      multiplier = multiplier || 1;
      cropping = cropping || { };
      var scaledWidth = (cropping.width || this.width) * multiplier,
          scaledHeight = (cropping.height || this.height) * multiplier,
          zoom = this.getZoom(),
          originalWidth = this.width,
          originalHeight = this.height,
          newZoom = zoom * multiplier,
          vp = this.viewportTransform,
          translateX = (vp[4] - (cropping.left || 0)) * multiplier,
          translateY = (vp[5] - (cropping.top || 0)) * multiplier,
          originalInteractive = this.interactive,
          originalContext = this.contextContainer,
          newVp = [newZoom, 0, 0, newZoom, translateX, translateY],
          canvasEl = fabric.util.createCanvasElement();
      canvasEl.width = scaledWidth;
      canvasEl.height = scaledHeight;
      this.interactive = false;
      this.viewportTransform = newVp;
      this.width = scaledWidth;
      this.height = scaledHeight;
      this.calcViewportBoundaries();
      this.contextContainer = canvasEl.getContext('2d');
      // will be renderAllExport();
      this.renderAll();
      this.viewportTransform = vp;
      this.width = originalWidth;
      this.height = originalHeight;
      this.calcViewportBoundaries();
      this.contextContainer = originalContext;
      this.interactive = originalInteractive;
      return canvasEl;
    },
  });

})();


fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

  /**
   * Populates canvas with data from the specified dataless JSON.
   * JSON format must conform to the one of {@link fabric.Canvas#toDatalessJSON}
   * @deprecated since 1.2.2
   * @param {String|Object} json JSON string or object
   * @param {Function} callback Callback, invoked when json is parsed
   *                            and corresponding objects (e.g: {@link fabric.Image})
   *                            are initialized
   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
   * @return {fabric.Canvas} instance
   * @chainable
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
   */
  loadFromDatalessJSON: function (json, callback, reviver) {
    return this.loadFromJSON(json, callback, reviver);
  },

  /**
   * Populates canvas with data from the specified JSON.
   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
   * @param {String|Object} json JSON string or object
   * @param {Function} callback Callback, invoked when json is parsed
   *                            and corresponding objects (e.g: {@link fabric.Image})
   *                            are initialized
   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
   * @return {fabric.Canvas} instance
   * @chainable
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
   * @example <caption>loadFromJSON</caption>
   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
   * @example <caption>loadFromJSON with reviver</caption>
   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
   *   // `o` = json object
   *   // `object` = fabric.Object instance
   *   // ... do some stuff ...
   * });
   */
  loadFromJSON: function (json, callback, reviver) {
    if (!json) {
      return;
    }

    // serialize if it wasn't already
    var serialized = (typeof json === 'string')
      ? JSON.parse(json)
      : fabric.util.object.clone(json);

    var _this = this,
        renderOnAddRemove = this.renderOnAddRemove;
    this.renderOnAddRemove = false;

    this._enlivenObjects(serialized.objects, function (enlivenedObjects) {
      _this.clear();
      _this._setBgOverlay(serialized, function () {
        enlivenedObjects.forEach(function(obj, index) {
          // we splice the array just in case some custom classes restored from JSON
          // will add more object to canvas at canvas init.
          _this.insertAt(obj, index);
        });
        _this.renderOnAddRemove = renderOnAddRemove;
        // remove parts i cannot set as options
        delete serialized.objects;
        delete serialized.backgroundImage;
        delete serialized.overlayImage;
        delete serialized.background;
        delete serialized.overlay;
        // this._initOptions does too many things to just
        // call it. Normally loading an Object from JSON
        // create the Object instance. Here the Canvas is
        // already an instance and we are just loading things over it
        _this._setOptions(serialized);
        _this.renderAll();
        callback && callback();
      });
    }, reviver);
    return this;
  },

  /**
   * @private
   * @param {Object} serialized Object with background and overlay information
   * @param {Function} callback Invoked after all background and overlay images/patterns loaded
   */
  _setBgOverlay: function(serialized, callback) {
    var loaded = {
      backgroundColor: false,
      overlayColor: false,
      backgroundImage: false,
      overlayImage: false
    };

    if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
      callback && callback();
      return;
    }

    var cbIfLoaded = function () {
      if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
        callback && callback();
      }
    };

    this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);
    this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);
    this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);
    this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);
  },

  /**
   * @private
   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
   * @param {(Object|String)} value Value to set
   * @param {Object} loaded Set loaded property to true if property is set
   * @param {Object} callback Callback function to invoke after property is set
   */
  __setBgOverlay: function(property, value, loaded, callback) {
    var _this = this;

    if (!value) {
      loaded[property] = true;
      callback && callback();
      return;
    }

    if (property === 'backgroundImage' || property === 'overlayImage') {
      fabric.util.enlivenObjects([value], function(enlivedObject){
        _this[property] = enlivedObject[0];
        loaded[property] = true;
        callback && callback();
      });
    }
    else {
      this['set' + fabric.util.string.capitalize(property, true)](value, function() {
        loaded[property] = true;
        callback && callback();
      });
    }
  },

  /**
   * @private
   * @param {Array} objects
   * @param {Function} callback
   * @param {Function} [reviver]
   */
  _enlivenObjects: function (objects, callback, reviver) {
    if (!objects || objects.length === 0) {
      callback && callback([]);
      return;
    }

    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
      callback && callback(enlivenedObjects);
    }, null, reviver);
  },

  /**
   * @private
   * @param {String} format
   * @param {Function} callback
   */
  _toDataURL: function (format, callback) {
    this.clone(function (clone) {
      callback(clone.toDataURL(format));
    });
  },

  /**
   * @private
   * @param {String} format
   * @param {Number} multiplier
   * @param {Function} callback
   */
  _toDataURLWithMultiplier: function (format, multiplier, callback) {
    this.clone(function (clone) {
      callback(clone.toDataURLWithMultiplier(format, multiplier));
    });
  },

  /**
   * Clones canvas instance
   * @param {Object} [callback] Receives cloned instance as a first argument
   * @param {Array} [properties] Array of properties to include in the cloned canvas and children
   */
  clone: function (callback, properties) {
    var data = JSON.stringify(this.toJSON(properties));
    this.cloneWithoutData(function(clone) {
      clone.loadFromJSON(data, function() {
        callback && callback(clone);
      });
    });
  },

  /**
   * Clones canvas instance without cloning existing data.
   * This essentially copies canvas dimensions, clipping properties, etc.
   * but leaves data empty (so that you can populate it with your own)
   * @param {Object} [callback] Receives cloned instance as a first argument
   */
  cloneWithoutData: function(callback) {
    var el = fabric.util.createCanvasElement();

    el.width = this.width;
    el.height = this.height;

    var clone = new fabric.Canvas(el);
    clone.clipTo = this.clipTo;
    if (this.backgroundImage) {
      clone.setBackgroundImage(this.backgroundImage.src, function() {
        clone.renderAll();
        callback && callback(clone);
      });
      clone.backgroundImageOpacity = this.backgroundImageOpacity;
      clone.backgroundImageStretch = this.backgroundImageStretch;
    }
    else {
      callback && callback(clone);
    }
  }
});


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      toFixed = fabric.util.toFixed,
      capitalize = fabric.util.string.capitalize,
      degreesToRadians = fabric.util.degreesToRadians,
      supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),
      objectCaching = !fabric.isLikelyNode,
      ALIASING_LIMIT = 2;

  if (fabric.Object) {
    return;
  }

  /**
   * Root object class from which all 2d shape classes inherit from
   * @class fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}
   * @see {@link fabric.Object#initialize} for constructor definition
   *
   * @fires added
   * @fires removed
   *
   * @fires selected
   * @fires deselected
   * @fires modified
   * @fires modified
   * @fires moved
   * @fires scaled
   * @fires rotated
   * @fires skewed
   *
   * @fires rotating
   * @fires scaling
   * @fires moving
   * @fires skewing
   *
   * @fires mousedown
   * @fires mouseup
   * @fires mouseover
   * @fires mouseout
   * @fires mousewheel
   * @fires mousedblclick
   *
   * @fires dragover
   * @fires dragenter
   * @fires dragleave
   * @fires drop
   */
  fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {

    /**
     * Type of an object (rect, circle, path, etc.).
     * Note that this property is meant to be read-only and not meant to be modified.
     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
     * @type String
     * @default
     */
    type:                     'object',

    /**
     * Horizontal origin of transformation of an object (one of "left", "right", "center")
     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
     * @type String
     * @default
     */
    originX:                  'left',

    /**
     * Vertical origin of transformation of an object (one of "top", "bottom", "center")
     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
     * @type String
     * @default
     */
    originY:                  'top',

    /**
     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}
     * @type Number
     * @default
     */
    top:                      0,

    /**
     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}
     * @type Number
     * @default
     */
    left:                     0,

    /**
     * Object width
     * @type Number
     * @default
     */
    width:                    0,

    /**
     * Object height
     * @type Number
     * @default
     */
    height:                   0,

    /**
     * Object scale factor (horizontal)
     * @type Number
     * @default
     */
    scaleX:                   1,

    /**
     * Object scale factor (vertical)
     * @type Number
     * @default
     */
    scaleY:                   1,

    /**
     * When true, an object is rendered as flipped horizontally
     * @type Boolean
     * @default
     */
    flipX:                    false,

    /**
     * When true, an object is rendered as flipped vertically
     * @type Boolean
     * @default
     */
    flipY:                    false,

    /**
     * Opacity of an object
     * @type Number
     * @default
     */
    opacity:                  1,

    /**
     * Angle of rotation of an object (in degrees)
     * @type Number
     * @default
     */
    angle:                    0,

    /**
     * Angle of skew on x axes of an object (in degrees)
     * @type Number
     * @default
     */
    skewX:                    0,

    /**
     * Angle of skew on y axes of an object (in degrees)
     * @type Number
     * @default
     */
    skewY:                    0,

    /**
     * Size of object's controlling corners (in pixels)
     * @type Number
     * @default
     */
    cornerSize:               13,

    /**
     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
     * @type Boolean
     * @default
     */
    transparentCorners:       true,

    /**
     * Default cursor value used when hovering over this object on canvas
     * @type String
     * @default
     */
    hoverCursor:              null,

    /**
     * Default cursor value used when moving this object on canvas
     * @type String
     * @default
     */
    moveCursor:               null,

    /**
     * Padding between object and its controlling borders (in pixels)
     * @type Number
     * @default
     */
    padding:                  0,

    /**
     * Color of controlling borders of an object (when it's active)
     * @type String
     * @default
     */
    borderColor:              'rgba(102,153,255,0.75)',

    /**
     * Array specifying dash pattern of an object's borders (hasBorder must be true)
     * @since 1.6.2
     * @type Array
     */
    borderDashArray:          null,

    /**
     * Color of controlling corners of an object (when it's active)
     * @type String
     * @default
     */
    cornerColor:              'rgba(102,153,255,0.5)',

    /**
     * Color of controlling corners of an object (when it's active and transparentCorners false)
     * @since 1.6.2
     * @type String
     * @default
     */
    cornerStrokeColor:        null,

    /**
     * Specify style of control, 'rect' or 'circle'
     * @since 1.6.2
     * @type String
     */
    cornerStyle:          'rect',

    /**
     * Array specifying dash pattern of an object's control (hasBorder must be true)
     * @since 1.6.2
     * @type Array
     */
    cornerDashArray:          null,

    /**
     * When true, this object will use center point as the origin of transformation
     * when being scaled via the controls.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredScaling:          false,

    /**
     * When true, this object will use center point as the origin of transformation
     * when being rotated via the controls.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredRotation:         true,

    /**
     * Color of object's fill
     * takes css colors https://www.w3.org/TR/css-color-3/
     * @type String
     * @default
     */
    fill:                     'rgb(0,0,0)',

    /**
     * Fill rule used to fill an object
     * accepted values are nonzero, evenodd
     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
     * @type String
     * @default
     */
    fillRule:                 'nonzero',

    /**
     * Composite rule used for canvas globalCompositeOperation
     * @type String
     * @default
     */
    globalCompositeOperation: 'source-over',

    /**
     * Background color of an object.
     * takes css colors https://www.w3.org/TR/css-color-3/
     * @type String
     * @default
     */
    backgroundColor:          '',

    /**
     * Selection Background color of an object. colored layer behind the object when it is active.
     * does not mix good with globalCompositeOperation methods.
     * @type String
     * @default
     */
    selectionBackgroundColor:          '',

    /**
     * When defined, an object is rendered via stroke and this property specifies its color
     * takes css colors https://www.w3.org/TR/css-color-3/
     * @type String
     * @default
     */
    stroke:                   null,

    /**
     * Width of a stroke used to render this object
     * @type Number
     * @default
     */
    strokeWidth:              1,

    /**
     * Array specifying dash pattern of an object's stroke (stroke must be defined)
     * @type Array
     */
    strokeDashArray:          null,

    /**
     * Line offset of an object's stroke
     * @type Number
     * @default
     */
    strokeDashOffset: 0,

    /**
     * Line endings style of an object's stroke (one of "butt", "round", "square")
     * @type String
     * @default
     */
    strokeLineCap:            'butt',

    /**
     * Corner style of an object's stroke (one of "bevil", "round", "miter")
     * @type String
     * @default
     */
    strokeLineJoin:           'miter',

    /**
     * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
     * @type Number
     * @default
     */
    strokeMiterLimit:         4,

    /**
     * Shadow object representing shadow of this shape
     * @type fabric.Shadow
     * @default
     */
    shadow:                   null,

    /**
     * Opacity of object's controlling borders when object is active and moving
     * @type Number
     * @default
     */
    borderOpacityWhenMoving:  0.4,

    /**
     * Scale factor of object's controlling borders
     * @type Number
     * @default
     */
    borderScaleFactor:        1,

    /**
     * Transform matrix (similar to SVG's transform matrix)
     * @type Array
     */
    transformMatrix:          null,

    /**
     * Minimum allowed scale value of an object
     * @type Number
     * @default
     */
    minScaleLimit:            0,

    /**
     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
     * But events still fire on it.
     * @type Boolean
     * @default
     */
    selectable:               true,

    /**
     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
     * @type Boolean
     * @default
     */
    evented:                  true,

    /**
     * When set to `false`, an object is not rendered on canvas
     * @type Boolean
     * @default
     */
    visible:                  true,

    /**
     * When set to `false`, object's controls are not displayed and can not be used to manipulate object
     * @type Boolean
     * @default
     */
    hasControls:              true,

    /**
     * When set to `false`, object's controlling borders are not rendered
     * @type Boolean
     * @default
     */
    hasBorders:               true,

    /**
     * When set to `false`, object's controlling rotating point will not be visible or selectable
     * @type Boolean
     * @default
     */
    hasRotatingPoint:         true,

    /**
     * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)
     * @type Number
     * @default
     */
    rotatingPointOffset:      40,

    /**
     * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
     * @type Boolean
     * @default
     */
    perPixelTargetFind:       false,

    /**
     * When `false`, default object's values are not included in its serialization
     * @type Boolean
     * @default
     */
    includeDefaultValues:     true,

    /**
     * Function that determines clipping of an object (context is passed as a first argument).
     * If you are using code minification, ctx argument can be minified/manglied you should use
     * as a workaround `var ctx = arguments[0];` in the function;
     * Note that context origin is at the object's center point (not left/top corner)
     * @deprecated since 2.0.0
     * @type Function
     */
    clipTo:                   null,

    /**
     * When `true`, object horizontal movement is locked
     * @type Boolean
     * @default
     */
    lockMovementX:            false,

    /**
     * When `true`, object vertical movement is locked
     * @type Boolean
     * @default
     */
    lockMovementY:            false,

    /**
     * When `true`, object rotation is locked
     * @type Boolean
     * @default
     */
    lockRotation:             false,

    /**
     * When `true`, object horizontal scaling is locked
     * @type Boolean
     * @default
     */
    lockScalingX:             false,

    /**
     * When `true`, object vertical scaling is locked
     * @type Boolean
     * @default
     */
    lockScalingY:             false,

    /**
     * When `true`, object non-uniform scaling is locked
     * @type Boolean
     * @default
     */
    lockUniScaling:           false,

    /**
     * When `true`, object horizontal skewing is locked
     * @type Boolean
     * @default
     */
    lockSkewingX:             false,

    /**
     * When `true`, object vertical skewing is locked
     * @type Boolean
     * @default
     */
    lockSkewingY:             false,

    /**
     * When `true`, object cannot be flipped by scaling into negative values
     * @type Boolean
     * @default
     */
    lockScalingFlip:          false,

    /**
     * When `true`, object is not exported in OBJECT/JSON
     * since 1.6.3
     * @type Boolean
     * @default
     */
    excludeFromExport:        false,

    /**
     * When `true`, object is cached on an additional canvas.
     * default to true
     * since 1.7.0
     * @type Boolean
     * @default true
     */
    objectCaching:            objectCaching,

    /**
     * When `true`, object properties are checked for cache invalidation. In some particular
     * situation you may want this to be disabled ( spray brush, very big, groups)
     * or if your application does not allow you to modify properties for groups child you want
     * to disable it for groups.
     * default to false
     * since 1.7.0
     * @type Boolean
     * @default false
     */
    statefullCache:            false,

    /**
     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
     * too much and will be redrawn with correct details at the end of scaling.
     * this setting is performance and application dependant.
     * default to true
     * since 1.7.0
     * @type Boolean
     * @default true
     */
    noScaleCache:              true,

    /**
     * When set to `true`, object's cache will be rerendered next render call.
     * since 1.7.0
     * @type Boolean
     * @default true
     */
    dirty:                true,

    /**
     * keeps the value of the last hovered corner during mouse move.
     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..
     * It should be private, but there is no harm in using it as
     * a read-only property.
     * @type number|string|any
     * @default 0
     */
    __corner: 0,

    /**
     * Determines if the fill or the stroke is drawn first (one of "fill" or "stroke")
     * @type String
     * @default
     */
    paintFirst:           'fill',

    /**
     * List of properties to consider when checking if state
     * of an object is changed (fabric.Object#hasStateChanged)
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: (
      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
      'stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit ' +
      'angle opacity fill globalCompositeOperation shadow clipTo visible backgroundColor ' +
      'skewX skewY fillRule paintFirst clipPath'
    ).split(' '),

    /**
     * List of properties to consider when checking if cache needs refresh
     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single
     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty
     * and refreshed at the next render
     * @type Array
     */
    cacheProperties: (
      'fill stroke strokeWidth strokeDashArray width height paintFirst' +
      ' strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath'
    ).split(' '),

    /**
     * a fabricObject that, without stroke define a clipping area with their shape. filled in black
     * the clipPath object gets used when the object has rendered, and the context is placed in the center
     * of the object cacheCanvas.
     * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'
     * @type fabric.Object
     */
    clipPath: undefined,

    /**
     * Meaningful ONLY when the object is used as clipPath.
     * if true, the clipPath will make the object clip to the outside of the clipPath
     * since 2.4.0
     * @type boolean
     * @default false
     */
    inverted: false,

    /**
     * Meaningful ONLY when the object is used as clipPath.
     * if true, the clipPath will have its top and left relative to canvas, and will
     * not be influenced by the object transform. This will make the clipPath relative
     * to the canvas, but clipping just a particular object.
     * WARNING this is beta, this feature may change or be renamed.
     * since 2.4.0
     * @type boolean
     * @default false
     */
    absolutePositioned: false,

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      if (options) {
        this.setOptions(options);
      }
    },

    /**
     * Create a the canvas used to keep the cached copy of the object
     * @private
     */
    _createCacheCanvas: function() {
      this._cacheProperties = {};
      this._cacheCanvas = fabric.util.createCanvasElement();
      this._cacheContext = this._cacheCanvas.getContext('2d');
      this._updateCacheCanvas();
      // if canvas gets created, is empty, so dirty.
      this.dirty = true;
    },

    /**
     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal
     * and each side do not cross fabric.cacheSideLimit
     * those numbers are configurable so that you can get as much detail as you want
     * making bargain with performances.
     * @param {Object} dims
     * @param {Object} dims.width width of canvas
     * @param {Object} dims.height height of canvas
     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _limitCacheSize: function(dims) {
      var perfLimitSizeTotal = fabric.perfLimitSizeTotal,
          width = dims.width, height = dims.height,
          max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;
      if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {
        if (width < min) {
          dims.width = min;
        }
        if (height < min) {
          dims.height = min;
        }
        return dims;
      }
      var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal),
          capValue = fabric.util.capValue,
          x = capValue(min, limitedDims.x, max),
          y = capValue(min, limitedDims.y, max);
      if (width > x) {
        dims.zoomX /= width / x;
        dims.width = x;
        dims.capped = true;
      }
      if (height > y) {
        dims.zoomY /= height / y;
        dims.height = y;
        dims.capped = true;
      }
      return dims;
    },

    /**
     * Return the dimension and the zoom level needed to create a cache canvas
     * big enough to host the object to be cached.
     * @private
     * @return {Object}.x width of object to be cached
     * @return {Object}.y height of object to be cached
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _getCacheCanvasDimensions: function() {
      var objectScale = this.getTotalObjectScaling(),
          dim = this._getNonTransformedDimensions(),
          zoomX = objectScale.scaleX,
          zoomY = objectScale.scaleY,
          width = dim.x * zoomX,
          height = dim.y * zoomY;
      return {
        // for sure this ALIASING_LIMIT is slightly crating problem
        // in situation in wich the cache canvas gets an upper limit
        width: width + ALIASING_LIMIT,
        height: height + ALIASING_LIMIT,
        zoomX: zoomX,
        zoomY: zoomY,
        x: dim.x,
        y: dim.y
      };
    },

    /**
     * Update width and height of the canvas for cache
     * returns true or false if canvas needed resize.
     * @private
     * @return {Boolean} true if the canvas has been resized
     */
    _updateCacheCanvas: function() {
      var targetCanvas = this.canvas;
      if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {
        var target = targetCanvas._currentTransform.target,
            action = targetCanvas._currentTransform.action;
        if (this === target && action.slice && action.slice(0, 5) === 'scale') {
          return false;
        }
      }
      var canvas = this._cacheCanvas,
          dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
          minCacheSize = fabric.minCacheSideLimit,
          width = dims.width, height = dims.height, drawingWidth, drawingHeight,
          zoomX = dims.zoomX, zoomY = dims.zoomY,
          dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight,
          zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY,
          shouldRedraw = dimensionsChanged || zoomChanged,
          additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;
      if (dimensionsChanged) {
        var canvasWidth = this._cacheCanvas.width,
            canvasHeight = this._cacheCanvas.height,
            sizeGrowing = width > canvasWidth || height > canvasHeight,
            sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) &&
              canvasWidth > minCacheSize && canvasHeight > minCacheSize;
        shouldResizeCanvas = sizeGrowing || sizeShrinking;
        if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {
          additionalWidth = width * 0.1;
          additionalHeight = height * 0.1;
        }
      }
      if (shouldRedraw) {
        if (shouldResizeCanvas) {
          canvas.width = Math.ceil(width + additionalWidth);
          canvas.height = Math.ceil(height + additionalHeight);
        }
        else {
          this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);
          this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);
        }
        drawingWidth = dims.x * zoomX / 2;
        drawingHeight = dims.y * zoomY / 2;
        this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;
        this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;
        this.cacheWidth = width;
        this.cacheHeight = height;
        this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);
        this._cacheContext.scale(zoomX, zoomY);
        this.zoomX = zoomX;
        this.zoomY = zoomY;
        return true;
      }
      return false;
    },

    /**
     * Sets object's properties from options
     * @param {Object} [options] Options object
     */
    setOptions: function(options) {
      this._setOptions(options);
      this._initGradient(options.fill, 'fill');
      this._initGradient(options.stroke, 'stroke');
      this._initClipping(options);
      this._initPattern(options.fill, 'fill');
      this._initPattern(options.stroke, 'stroke');
    },

    /**
     * Transforms context when rendering an object
     * @param {CanvasRenderingContext2D} ctx Context
     */
    transform: function(ctx) {
      var m;
      if (this.group && !this.group._transformDone) {
        m = this.calcTransformMatrix();
      }
      else {
        m = this.calcOwnMatrix();
      }
      ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    },

    /**
     * Returns an object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,

          object = {
            type:                     this.type,
            version:                  fabric.version,
            originX:                  this.originX,
            originY:                  this.originY,
            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
            strokeLineCap:            this.strokeLineCap,
            strokeDashOffset:         this.strokeDashOffset,
            strokeLineJoin:           this.strokeLineJoin,
            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
            angle:                    toFixed(this.angle, NUM_FRACTION_DIGITS),
            flipX:                    this.flipX,
            flipY:                    this.flipY,
            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
            visible:                  this.visible,
            clipTo:                   this.clipTo && String(this.clipTo),
            backgroundColor:          this.backgroundColor,
            fillRule:                 this.fillRule,
            paintFirst:               this.paintFirst,
            globalCompositeOperation: this.globalCompositeOperation,
            transformMatrix:          this.transformMatrix ? this.transformMatrix.concat() : null,
            skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
            skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS),
          };

      if (this.clipPath) {
        object.clipPath = this.clipPath.toObject(propertiesToInclude);
        object.clipPath.inverted = this.clipPath.inverted;
        object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;
      }

      fabric.util.populateWithProperties(this, object, propertiesToInclude);
      if (!this.includeDefaultValues) {
        object = this._removeDefaultValues(object);
      }

      return object;
    },

    /**
     * Returns (dataless) object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      // will be overwritten by subclasses
      return this.toObject(propertiesToInclude);
    },

    /**
     * @private
     * @param {Object} object
     */
    _removeDefaultValues: function(object) {
      var prototype = fabric.util.getKlass(object.type).prototype,
          stateProperties = prototype.stateProperties;
      stateProperties.forEach(function(prop) {
        if (object[prop] === prototype[prop]) {
          delete object[prop];
        }
        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&
                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';

        // basically a check for [] === []
        if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {
          delete object[prop];
        }
      });

      return object;
    },

    /**
     * Returns a string representation of an instance
     * @return {String}
     */
    toString: function() {
      return '#<fabric.' + capitalize(this.type) + '>';
    },

    /**
     * Return the object scale factor counting also the group scaling
     * @return {Object} object with scaleX and scaleY properties
     */
    getObjectScaling: function() {
      var scaleX = this.scaleX, scaleY = this.scaleY;
      if (this.group) {
        var scaling = this.group.getObjectScaling();
        scaleX *= scaling.scaleX;
        scaleY *= scaling.scaleY;
      }
      return { scaleX: scaleX, scaleY: scaleY };
    },

    /**
     * Return the object scale factor counting also the group scaling, zoom and retina
     * @return {Object} object with scaleX and scaleY properties
     */
    getTotalObjectScaling: function() {
      var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;
      if (this.canvas) {
        var zoom = this.canvas.getZoom();
        var retina = this.canvas.getRetinaScaling();
        scaleX *= zoom * retina;
        scaleY *= zoom * retina;
      }
      return { scaleX: scaleX, scaleY: scaleY };
    },

    /**
     * Return the object opacity counting also the group property
     * @return {Number}
     */
    getObjectOpacity: function() {
      var opacity = this.opacity;
      if (this.group) {
        opacity *= this.group.getObjectOpacity();
      }
      return opacity;
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Object} thisArg
     */
    _set: function(key, value) {
      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY'),
          isChanged = this[key] !== value, groupNeedsUpdate = false;

      if (shouldConstrainValue) {
        value = this._constrainScale(value);
      }
      if (key === 'scaleX' && value < 0) {
        this.flipX = !this.flipX;
        value *= -1;
      }
      else if (key === 'scaleY' && value < 0) {
        this.flipY = !this.flipY;
        value *= -1;
      }
      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
        value = new fabric.Shadow(value);
      }
      else if (key === 'dirty' && this.group) {
        this.group.set('dirty', value);
      }

      this[key] = value;

      if (isChanged) {
        groupNeedsUpdate = this.group && this.group.isOnACache();
        if (this.cacheProperties.indexOf(key) > -1) {
          this.dirty = true;
          groupNeedsUpdate && this.group.set('dirty', true);
        }
        else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {
          this.group.set('dirty', true);
        }
      }

      return this;
    },

    /**
     * This callback function is called by the parent group of an object every
     * time a non-delegated property changes on the group. It is passed the key
     * and value as parameters. Not adding in this function's signature to avoid
     * Travis build error about unused variables.
     */
    setOnGroup: function() {
      // implemented by sub-classes, as needed.
    },

    /**
     * Retrieves viewportTransform from Object's canvas if possible
     * @method getViewportTransform
     * @memberOf fabric.Object.prototype
     * @return {Array}
     */
    getViewportTransform: function() {
      if (this.canvas && this.canvas.viewportTransform) {
        return this.canvas.viewportTransform;
      }
      return fabric.iMatrix.concat();
    },

    /*
     * @private
     * return if the object would be visible in rendering
     * @memberOf fabric.Object.prototype
     * @return {Boolean}
     */
    isNotVisible: function() {
      return this.opacity === 0 ||
        (this.width === 0 && this.height === 0 && this.strokeWidth === 0) ||
        !this.visible;
    },

    /**
     * Renders an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      // do not render if width/height are zeros or object is not visible
      if (this.isNotVisible()) {
        return;
      }
      if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
        return;
      }
      ctx.save();
      this._setupCompositeOperation(ctx);
      this.drawSelectionBackground(ctx);
      this.transform(ctx);
      this._setOpacity(ctx);
      this._setShadow(ctx, this);
      if (this.transformMatrix) {
        ctx.transform.apply(ctx, this.transformMatrix);
      }
      this.clipTo && fabric.util.clipContext(this, ctx);
      if (this.shouldCache()) {
        this.renderCache();
        this.drawCacheOnCanvas(ctx);
      }
      else {
        this._removeCacheCanvas();
        this.dirty = false;
        this.drawObject(ctx);
        if (this.objectCaching && this.statefullCache) {
          this.saveState({ propertySet: 'cacheProperties' });
        }
      }
      this.clipTo && ctx.restore();
      ctx.restore();
    },

    renderCache: function(options) {
      options = options || {};
      if (!this._cacheCanvas) {
        this._createCacheCanvas();
      }
      if (this.isCacheDirty()) {
        this.statefullCache && this.saveState({ propertySet: 'cacheProperties' });
        this.drawObject(this._cacheContext, options.forClipping);
        this.dirty = false;
      }
    },

    /**
     * Remove cacheCanvas and its dimensions from the objects
     */
    _removeCacheCanvas: function() {
      this._cacheCanvas = null;
      this.cacheWidth = 0;
      this.cacheHeight = 0;
    },

    /**
     * When set to `true`, force the object to have its own cache, even if it is inside a group
     * it may be needed when your object behave in a particular way on the cache and always needs
     * its own isolated canvas to render correctly.
     * Created to be overridden
     * since 1.7.12
     * @returns false
     */
    needsItsOwnCache: function() {
      if (this.paintFirst === 'stroke' && typeof this.shadow === 'object') {
        return true;
      }
      if (this.clipPath) {
        return true;
      }
      return false;
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * @return {Boolean}
     */
    shouldCache: function() {
      this.ownCaching = this.objectCaching &&
      (!this.group || this.needsItsOwnCache() || !this.group.isOnACache());
      return this.ownCaching;
    },

    /**
     * Check if this object or a child object will cast a shadow
     * used by Group.shouldCache to know if child has a shadow recursively
     * @return {Boolean}
     */
    willDrawShadow: function() {
      return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
    },

    /**
     * Execute the drawing operation for an object clipPath
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawClipPathOnCache: function(ctx) {
      var path = this.clipPath;
      ctx.save();
      // DEBUG: uncomment this line, comment the following
      // ctx.globalAlpha = 0.4
      if (path.inverted) {
        ctx.globalCompositeOperation = 'destination-out';
      }
      else {
        ctx.globalCompositeOperation = 'destination-in';
      }
      //ctx.scale(1 / 2, 1 / 2);
      if (path.absolutePositioned) {
        var m = fabric.util.invertTransform(this.calcTransformMatrix());
        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      }
      path.transform(ctx);
      ctx.scale(1 / path.zoomX, 1 / path.zoomY);
      ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
      ctx.restore();
    },

    /**
     * Execute the drawing operation for an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawObject: function(ctx, forClipping) {
      var originalFill = this.fill, originalStroke = this.stroke;
      if (forClipping) {
        this.fill = 'black';
        this.stroke = '';
        this._setClippingProperties(ctx);
      }
      else {
        this._renderBackground(ctx);
        this._setStrokeStyles(ctx, this);
        this._setFillStyles(ctx, this);
      }
      this._render(ctx);
      this._drawClipPath(ctx);
      this.fill = originalFill;
      this.stroke = originalStroke;
    },

    _drawClipPath: function(ctx) {
      var path = this.clipPath;
      if (!path) { return; }
      // needed to setup a couple of variables
      // path canvas gets overridden with this one.
      // TODO find a better solution?
      path.canvas = this.canvas;
      path.shouldCache();
      path._transformDone = true;
      path.renderCache({ forClipping: true });
      this.drawClipPathOnCache(ctx);
    },

    /**
     * Paint the cached copy of the object on the target context.
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawCacheOnCanvas: function(ctx) {
      ctx.scale(1 / this.zoomX, 1 / this.zoomY);
      ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
    },

    /**
     * Check if cache is dirty
     * @param {Boolean} skipCanvas skip canvas checks because this object is painted
     * on parent canvas.
     */
    isCacheDirty: function(skipCanvas) {
      if (this.isNotVisible()) {
        return false;
      }
      if (this._cacheCanvas && !skipCanvas && this._updateCacheCanvas()) {
        // in this case the context is already cleared.
        return true;
      }
      else {
        if (this.dirty ||
          (this.clipPath && this.clipPath.absolutePositioned) ||
          (this.statefullCache && this.hasStateChanged('cacheProperties'))
        ) {
          if (this._cacheCanvas && !skipCanvas) {
            var width = this.cacheWidth / this.zoomX;
            var height = this.cacheHeight / this.zoomY;
            this._cacheContext.clearRect(-width / 2, -height / 2, width, height);
          }
          return true;
        }
      }
      return false;
    },

    /**
     * Draws a background for the object big as its untransformed dimensions
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderBackground: function(ctx) {
      if (!this.backgroundColor) {
        return;
      }
      var dim = this._getNonTransformedDimensions();
      ctx.fillStyle = this.backgroundColor;

      ctx.fillRect(
        -dim.x / 2,
        -dim.y / 2,
        dim.x,
        dim.y
      );
      // if there is background color no other shadows
      // should be casted
      this._removeShadow(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _setOpacity: function(ctx) {
      if (this.group && !this.group._transformDone) {
        ctx.globalAlpha = this.getObjectOpacity();
      }
      else {
        ctx.globalAlpha *= this.opacity;
      }
    },

    _setStrokeStyles: function(ctx, decl) {
      if (decl.stroke) {
        ctx.lineWidth = decl.strokeWidth;
        ctx.lineCap = decl.strokeLineCap;
        ctx.lineDashOffset = decl.strokeDashOffset;
        ctx.lineJoin = decl.strokeLineJoin;
        ctx.miterLimit = decl.strokeMiterLimit;
        ctx.strokeStyle = decl.stroke.toLive
          ? decl.stroke.toLive(ctx, this)
          : decl.stroke;
      }
    },

    _setFillStyles: function(ctx, decl) {
      if (decl.fill) {
        ctx.fillStyle = decl.fill.toLive
          ? decl.fill.toLive(ctx, this)
          : decl.fill;
      }
    },

    _setClippingProperties: function(ctx) {
      ctx.globalAlpha = 1;
      ctx.strokeStyle = 'transparent';
      ctx.fillStyle = '#000000';
    },

    /**
     * @private
     * Sets line dash
     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
     * @param {Array} dashArray array representing dashes
     * @param {Function} alternative function to call if browser does not support lineDash
     */
    _setLineDash: function(ctx, dashArray, alternative) {
      if (!dashArray) {
        return;
      }
      // Spec requires the concatenation of two copies the dash list when the number of elements is odd
      if (1 & dashArray.length) {
        dashArray.push.apply(dashArray, dashArray);
      }
      if (supportsLineDash) {
        ctx.setLineDash(dashArray);
      }
      else {
        alternative && alternative(ctx);
      }
    },

    /**
     * Renders controls and borders for the object
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [styleOverride] properties to override the object style
     */
    _renderControls: function(ctx, styleOverride) {
      var vpt = this.getViewportTransform(),
          matrix = this.calcTransformMatrix(),
          options, drawBorders, drawControls;
      styleOverride = styleOverride || { };
      drawBorders = typeof styleOverride.hasBorders !== 'undefined' ? styleOverride.hasBorders : this.hasBorders;
      drawControls = typeof styleOverride.hasControls !== 'undefined' ? styleOverride.hasControls : this.hasControls;
      matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);
      options = fabric.util.qrDecompose(matrix);
      ctx.save();
      ctx.translate(options.translateX, options.translateY);
      ctx.lineWidth = 1 * this.borderScaleFactor;
      if (!this.group) {
        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
      }
      if (styleOverride.forActiveSelection) {
        ctx.rotate(degreesToRadians(options.angle));
        drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);
      }
      else {
        ctx.rotate(degreesToRadians(this.angle));
        drawBorders && this.drawBorders(ctx, styleOverride);
      }
      drawControls && this.drawControls(ctx, styleOverride);
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _setShadow: function(ctx) {
      if (!this.shadow) {
        return;
      }

      var shadow = this.shadow, canvas = this.canvas,
          multX = (canvas && canvas.viewportTransform[0]) || 1,
          multY = (canvas && canvas.viewportTransform[3]) || 1,
          scaling = this.getObjectScaling();
      if (canvas && canvas._isRetinaScaling()) {
        multX *= fabric.devicePixelRatio;
        multY *= fabric.devicePixelRatio;
      }
      ctx.shadowColor = shadow.color;
      ctx.shadowBlur = shadow.blur * fabric.browserShadowBlurConstant *
        (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
      ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;
      ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _removeShadow: function(ctx) {
      if (!this.shadow) {
        return;
      }

      ctx.shadowColor = '';
      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} filler fabric.Pattern or fabric.Gradient
     * @return {Object} offset.offsetX offset for text rendering
     * @return {Object} offset.offsetY offset for text rendering
     */
    _applyPatternGradientTransform: function(ctx, filler) {
      if (!filler || !filler.toLive) {
        return { offsetX: 0, offsetY: 0 };
      }
      var t = filler.gradientTransform || filler.patternTransform;
      var offsetX = -this.width / 2 + filler.offsetX || 0,
          offsetY = -this.height / 2 + filler.offsetY || 0;
      ctx.translate(offsetX, offsetY);
      if (t) {
        ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
      }
      return { offsetX: offsetX, offsetY: offsetY };
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderPaintInOrder: function(ctx) {
      if (this.paintFirst === 'stroke') {
        this._renderStroke(ctx);
        this._renderFill(ctx);
      }
      else {
        this._renderFill(ctx);
        this._renderStroke(ctx);
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderFill: function(ctx) {
      if (!this.fill) {
        return;
      }

      ctx.save();
      this._applyPatternGradientTransform(ctx, this.fill);
      if (this.fillRule === 'evenodd') {
        ctx.fill('evenodd');
      }
      else {
        ctx.fill();
      }
      ctx.restore();
    },

    _renderStroke: function(ctx) {
      if (!this.stroke || this.strokeWidth === 0) {
        return;
      }

      if (this.shadow && !this.shadow.affectStroke) {
        this._removeShadow(ctx);
      }

      ctx.save();
      this._setLineDash(ctx, this.strokeDashArray, this._renderDashedStroke);
      this._applyPatternGradientTransform(ctx, this.stroke);
      ctx.stroke();
      ctx.restore();
    },

    /**
     * This function is an helper for svg import. it returns the center of the object in the svg
     * untransformed coordinates
     * @private
     * @return {Object} center point from element coordinates
     */
    _findCenterFromElement: function() {
      return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
    },

    /**
     * This function is an helper for svg import. it decompose the transformMatrix
     * and assign properties to object.
     * untransformed coordinates
     * @private
     * @chainable
     */
    _assignTransformMatrixProps: function() {
      if (this.transformMatrix) {
        var options = fabric.util.qrDecompose(this.transformMatrix);
        this.flipX = false;
        this.flipY = false;
        this.set('scaleX', options.scaleX);
        this.set('scaleY', options.scaleY);
        this.angle = options.angle;
        this.skewX = options.skewX;
        this.skewY = 0;
      }
    },

    /**
     * This function is an helper for svg import. it removes the transform matrix
     * and set to object properties that fabricjs can handle
     * @private
     * @param {Object} preserveAspectRatioOptions
     * @return {thisArg}
     */
    _removeTransformMatrix: function(preserveAspectRatioOptions) {
      var center = this._findCenterFromElement();
      if (this.transformMatrix) {
        this._assignTransformMatrixProps();
        center = fabric.util.transformPoint(center, this.transformMatrix);
      }
      this.transformMatrix = null;
      if (preserveAspectRatioOptions) {
        this.scaleX *= preserveAspectRatioOptions.scaleX;
        this.scaleY *= preserveAspectRatioOptions.scaleY;
        this.cropX = preserveAspectRatioOptions.cropX;
        this.cropY = preserveAspectRatioOptions.cropY;
        center.x += preserveAspectRatioOptions.offsetLeft;
        center.y += preserveAspectRatioOptions.offsetTop;
        this.width = preserveAspectRatioOptions.width;
        this.height = preserveAspectRatioOptions.height;
      }
      this.setPositionByOrigin(center, 'center', 'center');
    },

    /**
     * Clones an instance, using a callback method will work for every object.
     * @param {Function} callback Callback is invoked with a clone as a first argument
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     */
    clone: function(callback, propertiesToInclude) {
      var objectForm = this.toObject(propertiesToInclude);
      if (this.constructor.fromObject) {
        this.constructor.fromObject(objectForm, callback);
      }
      else {
        fabric.Object._fromObject('Object', objectForm, callback);
      }
    },

    /**
     * Creates an instance of fabric.Image out of an object
     * could make use of both toDataUrl or toCanvasElement.
     * @param {Function} callback callback, invoked with an instance as a first argument
     * @param {Object} [options] for clone as image, passed to toDataURL
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
     * @return {fabric.Object} thisArg
     */
    cloneAsImage: function(callback, options) {
      var canvasEl = this.toCanvasElement(options);
      if (callback) {
        callback(new fabric.Image(canvasEl));
      }
      return this;
    },

    /**
     * Converts an object into a HTMLCanvas element
     * @param {Object} options Options object
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
     */
    toCanvasElement: function(options) {
      options || (options = { });

      var utils = fabric.util, origParams = utils.saveObjectTransform(this),
          originalShadow = this.shadow, abs = Math.abs,
          multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric.devicePixelRatio : 1);

      if (options.withoutTransform) {
        utils.resetObjectTransform(this);
      }
      if (options.withoutShadow) {
        this.shadow = null;
      }

      var el = fabric.util.createCanvasElement(),
          // skip canvas zoom and calculate with setCoords now.
          boundingRect = this.getBoundingRect(true, true),
          shadow = this.shadow, scaling,
          shadowOffset = { x: 0, y: 0 }, shadowBlur;

      if (shadow) {
        shadowBlur = shadow.blur;
        scaling = this.getObjectScaling();
        shadowOffset.x = 2 * Math.round((abs(shadow.offsetX) + shadowBlur) * abs(scaling.scaleX));
        shadowOffset.y = 2 * Math.round((abs(shadow.offsetY) + shadowBlur) * abs(scaling.scaleY));
      }
      el.width = boundingRect.width + shadowOffset.x;
      el.height = boundingRect.height + shadowOffset.y;
      el.width += el.width % 2 ? 2 - el.width % 2 : 0;
      el.height += el.height % 2 ? 2 - el.height % 2 : 0;
      var canvas = new fabric.StaticCanvas(el, {
        enableRetinaScaling: false,
        renderOnAddRemove: false,
        skipOffscreen: false,
      });
      if (options.format === 'jpeg') {
        canvas.backgroundColor = '#fff';
      }
      this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), 'center', 'center');

      var originalCanvas = this.canvas;
      canvas.add(this);
      var canvasEl = canvas.toCanvasElement(multiplier || 1, options);
      this.shadow = originalShadow;
      this.canvas = originalCanvas;
      this.set(origParams).setCoords();
      // canvas.dispose will call image.dispose that will nullify the elements
      // since this canvas is a simple element for the process, we remove references
      // to objects in this way in order to avoid object trashing.
      canvas._objects = [];
      canvas.dispose();
      canvas = null;

      return canvasEl;
    },

    /**
     * Converts an object into a data-url-like string
     * @param {Object} options Options object
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
     */
    toDataURL: function(options) {
      options || (options = { });
      return fabric.util.toDataURL(this.toCanvasElement(options), options.format || 'png', options.quality || 1);
    },

    /**
     * Returns true if specified type is identical to the type of an instance
     * @param {String} type Type to check against
     * @return {Boolean}
     */
    isType: function(type) {
      return this.type === type;
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity of this instance (is 1 unless subclassed)
     */
    complexity: function() {
      return 1;
    },

    /**
     * Returns a JSON representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} JSON
     */
    toJSON: function(propertiesToInclude) {
      // delegate, not alias
      return this.toObject(propertiesToInclude);
    },

    /**
     * Sets gradient (fill or stroke) of an object
     * <b>Backwards incompatibility note:</b> This method was named "setGradientFill" until v1.1.0
     * @param {String} property Property name 'stroke' or 'fill'
     * @param {Object} [options] Options object
     * @param {String} [options.type] Type of gradient 'radial' or 'linear'
     * @param {Number} [options.x1=0] x-coordinate of start point
     * @param {Number} [options.y1=0] y-coordinate of start point
     * @param {Number} [options.x2=0] x-coordinate of end point
     * @param {Number} [options.y2=0] y-coordinate of end point
     * @param {Number} [options.r1=0] Radius of start point (only for radial gradients)
     * @param {Number} [options.r2=0] Radius of end point (only for radial gradients)
     * @param {Object} [options.colorStops] Color stops object eg. {0: 'ff0000', 1: '000000'}
     * @param {Object} [options.gradientTransform] transformMatrix for gradient
     * @return {fabric.Object} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/58y8b/|jsFiddle demo}
     * @example <caption>Set linear gradient</caption>
     * object.setGradient('fill', {
     *   type: 'linear',
     *   x1: -object.width / 2,
     *   y1: 0,
     *   x2: object.width / 2,
     *   y2: 0,
     *   colorStops: {
     *     0: 'red',
     *     0.5: '#005555',
     *     1: 'rgba(0,0,255,0.5)'
     *   }
     * });
     * canvas.renderAll();
     * @example <caption>Set radial gradient</caption>
     * object.setGradient('fill', {
     *   type: 'radial',
     *   x1: 0,
     *   y1: 0,
     *   x2: 0,
     *   y2: 0,
     *   r1: object.width / 2,
     *   r2: 10,
     *   colorStops: {
     *     0: 'red',
     *     0.5: '#005555',
     *     1: 'rgba(0,0,255,0.5)'
     *   }
     * });
     * canvas.renderAll();
     */
    setGradient: function(property, options) {
      options || (options = { });

      var gradient = { colorStops: [] };

      gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');
      gradient.coords = {
        x1: options.x1,
        y1: options.y1,
        x2: options.x2,
        y2: options.y2
      };

      if (options.r1 || options.r2) {
        gradient.coords.r1 = options.r1;
        gradient.coords.r2 = options.r2;
      }

      gradient.gradientTransform = options.gradientTransform;
      fabric.Gradient.prototype.addColorStop.call(gradient, options.colorStops);

      return this.set(property, fabric.Gradient.forObject(this, gradient));
    },

    /**
     * Sets pattern fill of an object
     * @param {Object} options Options object
     * @param {(String|HTMLImageElement)} options.source Pattern source
     * @param {String} [options.repeat=repeat] Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
     * @param {Number} [options.offsetX=0] Pattern horizontal offset from object's left/top corner
     * @param {Number} [options.offsetY=0] Pattern vertical offset from object's left/top corner
     * @param {Function} [callback] Callback to invoke when image set as a pattern
     * @return {fabric.Object} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/QT3pa/|jsFiddle demo}
     * @example <caption>Set pattern</caption>
     * object.setPatternFill({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
     *   repeat: 'repeat'
     * },canvas.renderAll.bind(canvas));
     */
    setPatternFill: function(options, callback) {
      return this.set('fill', new fabric.Pattern(options, callback));
    },

    /**
     * Sets {@link fabric.Object#shadow|shadow} of an object
     * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
     * @param {String} [options.color=rgb(0,0,0)] Shadow color
     * @param {Number} [options.blur=0] Shadow blur
     * @param {Number} [options.offsetX=0] Shadow horizontal offset
     * @param {Number} [options.offsetY=0] Shadow vertical offset
     * @return {fabric.Object} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/7gvJG/|jsFiddle demo}
     * @example <caption>Set shadow with string notation</caption>
     * object.setShadow('2px 2px 10px rgba(0,0,0,0.2)');
     * canvas.renderAll();
     * @example <caption>Set shadow with object notation</caption>
     * object.setShadow({
     *   color: 'red',
     *   blur: 10,
     *   offsetX: 20,
     *   offsetY: 20
     * });
     * canvas.renderAll();
     */
    setShadow: function(options) {
      return this.set('shadow', options ? new fabric.Shadow(options) : null);
    },

    /**
     * Sets "color" of an instance (alias of `set('fill', &hellip;)`)
     * @param {String} color Color value
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setColor: function(color) {
      this.set('fill', color);
      return this;
    },

    /**
     * Sets "angle" of an instance with centered rotation
     * @param {Number} angle Angle value (in degrees)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    rotate: function(angle) {
      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;

      if (shouldCenterOrigin) {
        this._setOriginToCenter();
      }

      this.set('angle', angle);

      if (shouldCenterOrigin) {
        this._resetOrigin();
      }

      return this;
    },

    /**
     * Centers object horizontally on canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    centerH: function () {
      this.canvas && this.canvas.centerObjectH(this);
      return this;
    },

    /**
     * Centers object horizontally on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenterH: function () {
      this.canvas && this.canvas.viewportCenterObjectH(this);
      return this;
    },

    /**
     * Centers object vertically on canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    centerV: function () {
      this.canvas && this.canvas.centerObjectV(this);
      return this;
    },

    /**
     * Centers object vertically on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenterV: function () {
      this.canvas && this.canvas.viewportCenterObjectV(this);
      return this;
    },

    /**
     * Centers object vertically and horizontally on canvas to which is was added last
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    center: function () {
      this.canvas && this.canvas.centerObject(this);
      return this;
    },

    /**
     * Centers object on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenter: function () {
      this.canvas && this.canvas.viewportCenterObject(this);
      return this;
    },

    /**
     * Returns coordinates of a pointer relative to an object
     * @param {Event} e Event to operate upon
     * @param {Object} [pointer] Pointer to operate upon (instead of event)
     * @return {Object} Coordinates of a pointer (x, y)
     */
    getLocalPointer: function(e, pointer) {
      pointer = pointer || this.canvas.getPointer(e);
      var pClicked = new fabric.Point(pointer.x, pointer.y),
          objectLeftTop = this._getLeftTopCoords();
      if (this.angle) {
        pClicked = fabric.util.rotatePoint(
          pClicked, objectLeftTop, degreesToRadians(-this.angle));
      }
      return {
        x: pClicked.x - objectLeftTop.x,
        y: pClicked.y - objectLeftTop.y
      };
    },

    /**
     * Sets canvas globalCompositeOperation for specific object
     * custom composition operation for the particular object can be specified using globalCompositeOperation property
     * @param {CanvasRenderingContext2D} ctx Rendering canvas context
     */
    _setupCompositeOperation: function (ctx) {
      if (this.globalCompositeOperation) {
        ctx.globalCompositeOperation = this.globalCompositeOperation;
      }
    }
  });

  fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);

  extend(fabric.Object.prototype, fabric.Observable);

  /**
   * Defines the number of fraction digits to use when serializing object values.
   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
   * @static
   * @memberOf fabric.Object
   * @constant
   * @type Number
   */
  fabric.Object.NUM_FRACTION_DIGITS = 2;

  fabric.Object._fromObject = function(className, object, callback, extraParam) {
    var klass = fabric[className];
    object = clone(object, true);
    fabric.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
      if (typeof patterns[0] !== 'undefined') {
        object.fill = patterns[0];
      }
      if (typeof patterns[1] !== 'undefined') {
        object.stroke = patterns[1];
      }
      fabric.util.enlivenObjects([object.clipPath], function(enlivedProps) {
        object.clipPath = enlivedProps[0];
        var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
        callback && callback(instance);
      });
    });
  };

  /**
   * Unique id used internally when creating SVG elements
   * @static
   * @memberOf fabric.Object
   * @type Number
   */
  fabric.Object.__uid = 0;

})( true ? exports : undefined);


(function() {

  var degreesToRadians = fabric.util.degreesToRadians,
      originXOffset = {
        left: -0.5,
        center: 0,
        right: 0.5
      },
      originYOffset = {
        top: -0.5,
        center: 0,
        bottom: 0.5
      };

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Translates the coordinates from a set of origin to another (based on the object's dimensions)
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
      var x = point.x,
          y = point.y,
          offsetX, offsetY, dim;

      if (typeof fromOriginX === 'string') {
        fromOriginX = originXOffset[fromOriginX];
      }
      else {
        fromOriginX -= 0.5;
      }

      if (typeof toOriginX === 'string') {
        toOriginX = originXOffset[toOriginX];
      }
      else {
        toOriginX -= 0.5;
      }

      offsetX = toOriginX - fromOriginX;

      if (typeof fromOriginY === 'string') {
        fromOriginY = originYOffset[fromOriginY];
      }
      else {
        fromOriginY -= 0.5;
      }

      if (typeof toOriginY === 'string') {
        toOriginY = originYOffset[toOriginY];
      }
      else {
        toOriginY -= 0.5;
      }

      offsetY = toOriginY - fromOriginY;

      if (offsetX || offsetY) {
        dim = this._getTransformedDimensions();
        x = point.x + offsetX * dim.x;
        y = point.y + offsetY * dim.y;
      }

      return new fabric.Point(x, y);
    },

    /**
     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToCenterPoint: function(point, originX, originY) {
      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
      if (this.angle) {
        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
      }
      return p;
    },

    /**
     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
     * @param {fabric.Point} center The point which corresponds to center of the object
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToOriginPoint: function(center, originX, originY) {
      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
      if (this.angle) {
        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
      }
      return p;
    },

    /**
     * Returns the real center coordinates of the object
     * @return {fabric.Point}
     */
    getCenterPoint: function() {
      var leftTop = new fabric.Point(this.left, this.top);
      return this.translateToCenterPoint(leftTop, this.originX, this.originY);
    },

    /**
     * Returns the coordinates of the object based on center coordinates
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @return {fabric.Point}
     */
    // getOriginPoint: function(center) {
    //   return this.translateToOriginPoint(center, this.originX, this.originY);
    // },

    /**
     * Returns the coordinates of the object as if it has a different origin
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    getPointByOrigin: function(originX, originY) {
      var center = this.getCenterPoint();
      return this.translateToOriginPoint(center, originX, originY);
    },

    /**
     * Returns the point in local coordinates
     * @param {fabric.Point} point The point relative to the global coordinate system
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    toLocalPoint: function(point, originX, originY) {
      var center = this.getCenterPoint(),
          p, p2;

      if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {
        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
      }
      else {
        p = new fabric.Point(this.left, this.top);
      }

      p2 = new fabric.Point(point.x, point.y);
      if (this.angle) {
        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
      }
      return p2.subtractEquals(p);
    },

    /**
     * Returns the point in global coordinates
     * @param {fabric.Point} The point relative to the local coordinate system
     * @return {fabric.Point}
     */
    // toGlobalPoint: function(point) {
    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
    // },

    /**
     * Sets the position of the object taking into consideration the object's origin
     * @param {fabric.Point} pos The new position of the object
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {void}
     */
    setPositionByOrigin: function(pos, originX, originY) {
      var center = this.translateToCenterPoint(pos, originX, originY),
          position = this.translateToOriginPoint(center, this.originX, this.originY);
      this.set('left', position.x);
      this.set('top', position.y);
    },

    /**
     * @param {String} to One of 'left', 'center', 'right'
     */
    adjustPosition: function(to) {
      var angle = degreesToRadians(this.angle),
          hypotFull = this.getScaledWidth(),
          xFull = fabric.util.cos(angle) * hypotFull,
          yFull = fabric.util.sin(angle) * hypotFull,
          offsetFrom, offsetTo;

      //TODO: this function does not consider mixed situation like top, center.
      if (typeof this.originX === 'string') {
        offsetFrom = originXOffset[this.originX];
      }
      else {
        offsetFrom = this.originX - 0.5;
      }
      if (typeof to === 'string') {
        offsetTo = originXOffset[to];
      }
      else {
        offsetTo = to - 0.5;
      }
      this.left += xFull * (offsetTo - offsetFrom);
      this.top += yFull * (offsetTo - offsetFrom);
      this.setCoords();
      this.originX = to;
    },

    /**
     * Sets the origin/position of the object to it's center point
     * @private
     * @return {void}
     */
    _setOriginToCenter: function() {
      this._originalOriginX = this.originX;
      this._originalOriginY = this.originY;

      var center = this.getCenterPoint();

      this.originX = 'center';
      this.originY = 'center';

      this.left = center.x;
      this.top = center.y;
    },

    /**
     * Resets the origin/position of the object to it's original origin
     * @private
     * @return {void}
     */
    _resetOrigin: function() {
      var originPoint = this.translateToOriginPoint(
        this.getCenterPoint(),
        this._originalOriginX,
        this._originalOriginY);

      this.originX = this._originalOriginX;
      this.originY = this._originalOriginY;

      this.left = originPoint.x;
      this.top = originPoint.y;

      this._originalOriginX = null;
      this._originalOriginY = null;
    },

    /**
     * @private
     */
    _getLeftTopCoords: function() {
      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
    },
  });

})();


(function() {

  function getCoords(coords) {
    return [
      new fabric.Point(coords.tl.x, coords.tl.y),
      new fabric.Point(coords.tr.x, coords.tr.y),
      new fabric.Point(coords.br.x, coords.br.y),
      new fabric.Point(coords.bl.x, coords.bl.y)
    ];
  }

  var degreesToRadians = fabric.util.degreesToRadians,
      multiplyMatrices = fabric.util.multiplyTransformMatrices,
      transformPoint = fabric.util.transformPoint;

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Describe object's corner position in canvas element coordinates.
     * properties are tl,mt,tr,ml,mr,bl,mb,br,mtr for the main controls.
     * each property is an object with x, y and corner.
     * The `corner` property contains in a similar manner the 4 points of the
     * interactive area of the corner.
     * The coordinates depends from this properties: width, height, scaleX, scaleY
     * skewX, skewY, angle, strokeWidth, viewportTransform, top, left, padding.
     * The coordinates get updated with @method setCoords.
     * You can calculate them without updating with @method calcCoords;
     * @memberOf fabric.Object.prototype
     */
    oCoords: null,

    /**
     * Describe object's corner position in canvas object absolute coordinates
     * properties are tl,tr,bl,br and describe the four main corner.
     * each property is an object with x, y, instance of Fabric.Point.
     * The coordinates depends from this properties: width, height, scaleX, scaleY
     * skewX, skewY, angle, strokeWidth, top, left.
     * Those coordinates are usefull to understand where an object is. They get updated
     * with oCoords but they do not need to be updated when zoom or panning change.
     * The coordinates get updated with @method setCoords.
     * You can calculate them without updating with @method calcCoords(true);
     * @memberOf fabric.Object.prototype
     */
    aCoords: null,

    /**
     * storage for object transform matrix
     */
    ownMatrixCache: null,

    /**
     * storage for object full transform matrix
     */
    matrixCache: null,

    /**
     * return correct set of coordinates for intersection
     */
    getCoords: function(absolute, calculate) {
      if (!this.oCoords) {
        this.setCoords();
      }
      var coords = absolute ? this.aCoords : this.oCoords;
      return getCoords(calculate ? this.calcCoords(absolute) : coords);
    },

    /**
     * Checks if object intersects with an area formed by 2 points
     * @param {Object} pointTL top-left point of area
     * @param {Object} pointBR bottom-right point of area
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object intersects with an area formed by 2 points
     */
    intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {
      var coords = this.getCoords(absolute, calculate),
          intersection = fabric.Intersection.intersectPolygonRectangle(
            coords,
            pointTL,
            pointBR
          );
      return intersection.status === 'Intersection';
    },

    /**
     * Checks if object intersects with another object
     * @param {Object} other Object to test
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object intersects with another object
     */
    intersectsWithObject: function(other, absolute, calculate) {
      var intersection = fabric.Intersection.intersectPolygonPolygon(
        this.getCoords(absolute, calculate),
        other.getCoords(absolute, calculate)
      );

      return intersection.status === 'Intersection'
        || other.isContainedWithinObject(this, absolute, calculate)
        || this.isContainedWithinObject(other, absolute, calculate);
    },

    /**
     * Checks if object is fully contained within area of another object
     * @param {Object} other Object to test
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is fully contained within area of another object
     */
    isContainedWithinObject: function(other, absolute, calculate) {
      var points = this.getCoords(absolute, calculate),
          i = 0, lines = other._getImageLines(
            calculate ? other.calcCoords(absolute) : absolute ? other.aCoords : other.oCoords
          );
      for (; i < 4; i++) {
        if (!other.containsPoint(points[i], lines)) {
          return false;
        }
      }
      return true;
    },

    /**
     * Checks if object is fully contained within area formed by 2 points
     * @param {Object} pointTL top-left point of area
     * @param {Object} pointBR bottom-right point of area
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is fully contained within area formed by 2 points
     */
    isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {
      var boundingRect = this.getBoundingRect(absolute, calculate);

      return (
        boundingRect.left >= pointTL.x &&
        boundingRect.left + boundingRect.width <= pointBR.x &&
        boundingRect.top >= pointTL.y &&
        boundingRect.top + boundingRect.height <= pointBR.y
      );
    },

    /**
     * Checks if point is inside the object
     * @param {fabric.Point} point Point to check against
     * @param {Object} [lines] object returned from @method _getImageLines
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if point is inside the object
     */
    containsPoint: function(point, lines, absolute, calculate) {
      var lines = lines || this._getImageLines(
            calculate ? this.calcCoords(absolute) : absolute ? this.aCoords : this.oCoords
          ),
          xPoints = this._findCrossPoints(point, lines);

      // if xPoints is odd then point is inside the object
      return (xPoints !== 0 && xPoints % 2 === 1);
    },

    /**
     * Checks if object is contained within the canvas with current viewportTransform
     * the check is done stopping at first point that appears on screen
     * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords
     * @return {Boolean} true if object is fully or partially contained within canvas
     */
    isOnScreen: function(calculate) {
      if (!this.canvas) {
        return false;
      }
      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
      var points = this.getCoords(true, calculate), point;
      for (var i = 0; i < 4; i++) {
        point = points[i];
        if (point.x <= pointBR.x && point.x >= pointTL.x && point.y <= pointBR.y && point.y >= pointTL.y) {
          return true;
        }
      }
      // no points on screen, check intersection with absolute coordinates
      if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
        return true;
      }
      return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
    },

    /**
     * Checks if the object contains the midpoint between canvas extremities
     * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen
     * @private
     * @param {Fabric.Point} pointTL Top Left point
     * @param {Fabric.Point} pointBR Top Right point
     * @param {Boolean} calculate use coordinates of current position instead of .oCoords
     * @return {Boolean} true if the objects containe the point
     */
    _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {
      // worst case scenario the object is so big that contains the screen
      var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };
      if (this.containsPoint(centerPoint, null, true, calculate)) {
        return true;
      }
      return false;
    },

    /**
     * Checks if object is partially contained within the canvas with current viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is partially contained within canvas
     */
    isPartiallyOnScreen: function(calculate) {
      if (!this.canvas) {
        return false;
      }
      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
      if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
        return true;
      }
      return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
    },

    /**
     * Method that returns an object with the object edges in it, given the coordinates of the corners
     * @private
     * @param {Object} oCoords Coordinates of the object corners
     */
    _getImageLines: function(oCoords) {
      return {
        topline: {
          o: oCoords.tl,
          d: oCoords.tr
        },
        rightline: {
          o: oCoords.tr,
          d: oCoords.br
        },
        bottomline: {
          o: oCoords.br,
          d: oCoords.bl
        },
        leftline: {
          o: oCoords.bl,
          d: oCoords.tl
        }
      };
    },

    /**
     * Helper method to determine how many cross points are between the 4 object edges
     * and the horizontal line determined by a point on canvas
     * @private
     * @param {fabric.Point} point Point to check
     * @param {Object} lines Coordinates of the object being evaluated
     */
    // remove yi, not used but left code here just in case.
    _findCrossPoints: function(point, lines) {
      var b1, b2, a1, a2, xi, // yi,
          xcount = 0,
          iLine;

      for (var lineKey in lines) {
        iLine = lines[lineKey];
        // optimisation 1: line below point. no cross
        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
          continue;
        }
        // optimisation 2: line above point. no cross
        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
          continue;
        }
        // optimisation 3: vertical line case
        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
          xi = iLine.o.x;
          // yi = point.y;
        }
        // calculate the intersection point
        else {
          b1 = 0;
          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
          a1 = point.y - b1 * point.x;
          a2 = iLine.o.y - b2 * iLine.o.x;

          xi = -(a1 - a2) / (b1 - b2);
          // yi = a1 + b1 * xi;
        }
        // dont count xi < point.x cases
        if (xi >= point.x) {
          xcount += 1;
        }
        // optimisation 4: specific for square images
        if (xcount === 2) {
          break;
        }
      }
      return xcount;
    },

    /**
     * Returns coordinates of object's bounding rectangle (left, top, width, height)
     * the box is intented as aligned to axis of canvas.
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords
     * @return {Object} Object with left, top, width, height properties
     */
    getBoundingRect: function(absolute, calculate) {
      var coords = this.getCoords(absolute, calculate);
      return fabric.util.makeBoundingBoxFromPoints(coords);
    },

    /**
     * Returns width of an object bounding box counting transformations
     * before 2.0 it was named getWidth();
     * @return {Number} width value
     */
    getScaledWidth: function() {
      return this._getTransformedDimensions().x;
    },

    /**
     * Returns height of an object bounding box counting transformations
     * before 2.0 it was named getHeight();
     * @return {Number} height value
     */
    getScaledHeight: function() {
      return this._getTransformedDimensions().y;
    },

    /**
     * Makes sure the scale is valid and modifies it if necessary
     * @private
     * @param {Number} value
     * @return {Number}
     */
    _constrainScale: function(value) {
      if (Math.abs(value) < this.minScaleLimit) {
        if (value < 0) {
          return -this.minScaleLimit;
        }
        else {
          return this.minScaleLimit;
        }
      }
      else if (value === 0) {
        return 0.0001;
      }
      return value;
    },

    /**
     * Scales an object (equally by x and y)
     * @param {Number} value Scale factor
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scale: function(value) {
      this._set('scaleX', value);
      this._set('scaleY', value);
      return this.setCoords();
    },

    /**
     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
     * @param {Number} value New width value
     * @param {Boolean} absolute ignore viewport
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scaleToWidth: function(value, absolute) {
      // adjust to bounding rect factor so that rotated shapes would fit as well
      var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();
      return this.scale(value / this.width / boundingRectFactor);
    },

    /**
     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
     * @param {Number} value New height value
     * @param {Boolean} absolute ignore viewport
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scaleToHeight: function(value, absolute) {
      // adjust to bounding rect factor so that rotated shapes would fit as well
      var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();
      return this.scale(value / this.height / boundingRectFactor);
    },

    /**
     * Calculate and returns the .coords of an object.
     * @return {Object} Object with tl, tr, br, bl ....
     * @chainable
     */
    calcCoords: function(absolute) {
      var rotateMatrix = this._calcRotateMatrix(),
          translateMatrix = this._calcTranslateMatrix(),
          startMatrix = multiplyMatrices(translateMatrix, rotateMatrix),
          vpt = this.getViewportTransform(),
          finalMatrix = absolute ? startMatrix : multiplyMatrices(vpt, startMatrix),
          dim = this._getTransformedDimensions(),
          w = dim.x / 2, h = dim.y / 2,
          tl = transformPoint({ x: -w, y: -h }, finalMatrix),
          tr = transformPoint({ x: w, y: -h }, finalMatrix),
          bl = transformPoint({ x: -w, y: h }, finalMatrix),
          br = transformPoint({ x: w, y: h }, finalMatrix);
      if (!absolute) {
        var padding = this.padding, angle = degreesToRadians(this.angle),
            cos = fabric.util.cos(angle), sin = fabric.util.sin(angle),
            cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP,
            cosPMinusSinP = cosP - sinP;
        if (padding) {
          tl.x -= cosPMinusSinP;
          tl.y -= cosPSinP;
          tr.x += cosPSinP;
          tr.y -= cosPMinusSinP;
          bl.x -= cosPSinP;
          bl.y += cosPMinusSinP;
          br.x += cosPMinusSinP;
          br.y += cosPSinP;
        }
        var ml  = new fabric.Point((tl.x + bl.x) / 2, (tl.y + bl.y) / 2),
            mt  = new fabric.Point((tr.x + tl.x) / 2, (tr.y + tl.y) / 2),
            mr  = new fabric.Point((br.x + tr.x) / 2, (br.y + tr.y) / 2),
            mb  = new fabric.Point((br.x + bl.x) / 2, (br.y + bl.y) / 2),
            mtr = new fabric.Point(mt.x + sin * this.rotatingPointOffset, mt.y - cos * this.rotatingPointOffset);
      }

      // if (!absolute) {
      //   var canvas = this.canvas;
      //   setTimeout(function() {
      //     canvas.contextTop.clearRect(0, 0, 700, 700);
      //     canvas.contextTop.fillStyle = 'green';
      //     canvas.contextTop.fillRect(mb.x, mb.y, 3, 3);
      //     canvas.contextTop.fillRect(bl.x, bl.y, 3, 3);
      //     canvas.contextTop.fillRect(br.x, br.y, 3, 3);
      //     canvas.contextTop.fillRect(tl.x, tl.y, 3, 3);
      //     canvas.contextTop.fillRect(tr.x, tr.y, 3, 3);
      //     canvas.contextTop.fillRect(ml.x, ml.y, 3, 3);
      //     canvas.contextTop.fillRect(mr.x, mr.y, 3, 3);
      //     canvas.contextTop.fillRect(mt.x, mt.y, 3, 3);
      //     canvas.contextTop.fillRect(mtr.x, mtr.y, 3, 3);
      //   }, 50);
      // }

      var coords = {
        // corners
        tl: tl, tr: tr, br: br, bl: bl,
      };
      if (!absolute) {
        // middle
        coords.ml = ml;
        coords.mt = mt;
        coords.mr = mr;
        coords.mb = mb;
        // rotating point
        coords.mtr = mtr;
      }
      return coords;
    },

    /**
     * Sets corner position coordinates based on current angle, width and height.
     * See {@link https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords|When-to-call-setCoords}
     * @param {Boolean} [ignoreZoom] set oCoords with or without the viewport transform.
     * @param {Boolean} [skipAbsolute] skip calculation of aCoords, usefull in setViewportTransform
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setCoords: function(ignoreZoom, skipAbsolute) {
      this.oCoords = this.calcCoords(ignoreZoom);
      if (!skipAbsolute) {
        this.aCoords = this.calcCoords(true);
      }

      // set coordinates of the draggable boxes in the corners used to scale/rotate the image
      ignoreZoom || (this._setCornerCoords && this._setCornerCoords());

      return this;
    },

    /**
     * calculate rotation matrix of an object
     * @return {Array} rotation matrix for the object
     */
    _calcRotateMatrix: function() {
      if (this.angle) {
        var theta = degreesToRadians(this.angle), cos = fabric.util.cos(theta), sin = fabric.util.sin(theta);
        return [cos, sin, -sin, cos, 0, 0];
      }
      return fabric.iMatrix.concat();
    },

    /**
     * calculate the translation matrix for an object transform
     * @return {Array} rotation matrix for the object
     */
    _calcTranslateMatrix: function() {
      var center = this.getCenterPoint();
      return [1, 0, 0, 1, center.x, center.y];
    },

    transformMatrixKey: function(skipGroup) {
      var sep = '_', prefix = '';
      if (!skipGroup && this.group) {
        prefix = this.group.transformMatrixKey(skipGroup) + sep;
      };
      return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY +
        sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY +
        sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;
    },

    /**
     * calculate trasform Matrix that represent current transformation from
     * object properties.
     * @param {Boolean} [skipGroup] return transformMatrix for object and not go upward with parents
     * @return {Array} matrix Transform Matrix for the object
     */
    calcTransformMatrix: function(skipGroup) {
      if (skipGroup) {
        return this.calcOwnMatrix();
      }
      var key = this.transformMatrixKey(), cache = this.matrixCache || (this.matrixCache = {});
      if (cache.key === key) {
        return cache.value;
      }
      var matrix = this.calcOwnMatrix();
      if (this.group) {
        matrix = multiplyMatrices(this.group.calcTransformMatrix(), matrix);
      }
      cache.key = key;
      cache.value = matrix;
      return matrix;
    },

    calcOwnMatrix: function() {
      var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});
      if (cache.key === key) {
        return cache.value;
      }
      var matrix = this._calcTranslateMatrix(),
          rotateMatrix,
          dimensionMatrix = this._calcDimensionsTransformMatrix(this.skewX, this.skewY, true);
      if (this.angle) {
        rotateMatrix = this._calcRotateMatrix();
        matrix = multiplyMatrices(matrix, rotateMatrix);
      }
      matrix = multiplyMatrices(matrix, dimensionMatrix);
      cache.key = key;
      cache.value = matrix;
      return matrix;
    },

    _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {
      var skewMatrix,
          scaleX = this.scaleX * (flipping && this.flipX ? -1 : 1),
          scaleY = this.scaleY * (flipping && this.flipY ? -1 : 1),
          scaleMatrix = [scaleX, 0, 0, scaleY, 0, 0];
      if (skewX) {
        skewMatrix = [1, 0, Math.tan(degreesToRadians(skewX)), 1];
        scaleMatrix = multiplyMatrices(scaleMatrix, skewMatrix, true);
      }
      if (skewY) {
        skewMatrix = [1, Math.tan(degreesToRadians(skewY)), 0, 1];
        scaleMatrix = multiplyMatrices(scaleMatrix, skewMatrix, true);
      }
      return scaleMatrix;
    },


    /*
     * Calculate object dimensions from its properties
     * @private
     * @return {Object} .x width dimension
     * @return {Object} .y height dimension
     */
    _getNonTransformedDimensions: function() {
      var strokeWidth = this.strokeWidth,
          w = this.width + strokeWidth,
          h = this.height + strokeWidth;
      return { x: w, y: h };
    },

    /*
     * Calculate object bounding boxdimensions from its properties scale, skew.
     * @private
     * @return {Object} .x width dimension
     * @return {Object} .y height dimension
     */
    _getTransformedDimensions: function(skewX, skewY) {
      if (typeof skewX === 'undefined') {
        skewX = this.skewX;
      }
      if (typeof skewY === 'undefined') {
        skewY = this.skewY;
      }
      var dimensions = this._getNonTransformedDimensions();
      if (skewX === 0 && skewY === 0) {
        return { x: dimensions.x * this.scaleX, y: dimensions.y * this.scaleY };
      }
      var dimX = dimensions.x / 2, dimY = dimensions.y / 2,
          points = [
            {
              x: -dimX,
              y: -dimY
            },
            {
              x: dimX,
              y: -dimY
            },
            {
              x: -dimX,
              y: dimY
            },
            {
              x: dimX,
              y: dimY
            }],
          i, transformMatrix = this._calcDimensionsTransformMatrix(skewX, skewY, false),
          bbox;
      for (i = 0; i < points.length; i++) {
        points[i] = fabric.util.transformPoint(points[i], transformMatrix);
      }
      bbox = fabric.util.makeBoundingBoxFromPoints(points);
      return { x: bbox.width, y: bbox.height };
    },

    /*
     * Calculate object dimensions for controls. include padding and canvas zoom
     * private
     */
    _calculateCurrentDimensions: function()  {
      var vpt = this.getViewportTransform(),
          dim = this._getTransformedDimensions(),
          p = fabric.util.transformPoint(dim, vpt, true);

      return p.scalarAdd(2 * this.padding);
    },
  });
})();


fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

  /**
   * Moves an object to the bottom of the stack of drawn objects
   * @return {fabric.Object} thisArg
   * @chainable
   */
  sendToBack: function() {
    if (this.group) {
      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
    }
    else {
      this.canvas.sendToBack(this);
    }
    return this;
  },

  /**
   * Moves an object to the top of the stack of drawn objects
   * @return {fabric.Object} thisArg
   * @chainable
   */
  bringToFront: function() {
    if (this.group) {
      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
    }
    else {
      this.canvas.bringToFront(this);
    }
    return this;
  },

  /**
   * Moves an object down in stack of drawn objects
   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  sendBackwards: function(intersecting) {
    if (this.group) {
      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
    }
    else {
      this.canvas.sendBackwards(this, intersecting);
    }
    return this;
  },

  /**
   * Moves an object up in stack of drawn objects
   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  bringForward: function(intersecting) {
    if (this.group) {
      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
    }
    else {
      this.canvas.bringForward(this, intersecting);
    }
    return this;
  },

  /**
   * Moves an object to specified level in stack of drawn objects
   * @param {Number} index New position of object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  moveTo: function(index) {
    if (this.group && this.group.type !== 'activeSelection') {
      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
    }
    else {
      this.canvas.moveTo(this, index);
    }
    return this;
  }
});


/* _TO_SVG_START_ */
(function() {
  function getSvgColorString(prop, value) {
    if (!value) {
      return prop + ': none; ';
    }
    else if (value.toLive) {
      return prop + ': url(#SVGID_' + value.id + '); ';
    }
    else {
      var color = new fabric.Color(value),
          str = prop + ': ' + color.toRgb() + '; ',
          opacity = color.getAlpha();
      if (opacity !== 1) {
        //change the color in rgb + opacity
        str += prop + '-opacity: ' + opacity.toString() + '; ';
      }
      return str;
    }
  }

  var toFixed = fabric.util.toFixed;

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
    /**
     * Returns styles-string for svg-export
     * @param {Boolean} skipShadow a boolean to skip shadow filter output
     * @return {String}
     */
    getSvgStyles: function(skipShadow) {

      var fillRule = this.fillRule ? this.fillRule : 'nonzero',
          strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
          strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
          strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : '0',
          strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
          strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
          strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
          opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
          visibility = this.visible ? '' : ' visibility: hidden;',
          filter = skipShadow ? '' : this.getSvgFilter(),
          fill = getSvgColorString('fill', this.fill),
          stroke = getSvgColorString('stroke', this.stroke);

      return [
        stroke,
        'stroke-width: ', strokeWidth, '; ',
        'stroke-dasharray: ', strokeDashArray, '; ',
        'stroke-linecap: ', strokeLineCap, '; ',
        'stroke-dashoffset: ', strokeDashOffset, '; ',
        'stroke-linejoin: ', strokeLineJoin, '; ',
        'stroke-miterlimit: ', strokeMiterLimit, '; ',
        fill,
        'fill-rule: ', fillRule, '; ',
        'opacity: ', opacity, ';',
        filter,
        visibility
      ].join('');
    },

    /**
     * Returns styles-string for svg-export
     * @param {Object} style the object from which to retrieve style properties
     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.
     * @return {String}
     */
    getSvgSpanStyles: function(style, useWhiteSpace) {
      var term = '; ';
      var fontFamily = style.fontFamily ?
        'font-family: ' + (((style.fontFamily.indexOf('\'') === -1 && style.fontFamily.indexOf('"') === -1) ?
          '\'' + style.fontFamily  + '\'' : style.fontFamily)) + term : '';
      var strokeWidth = style.strokeWidth ? 'stroke-width: ' + style.strokeWidth + term : '',
          fontFamily = fontFamily,
          fontSize = style.fontSize ? 'font-size: ' + style.fontSize + 'px' + term : '',
          fontStyle = style.fontStyle ? 'font-style: ' + style.fontStyle + term : '',
          fontWeight = style.fontWeight ? 'font-weight: ' + style.fontWeight + term : '',
          fill = style.fill ? getSvgColorString('fill', style.fill) : '',
          stroke = style.stroke ? getSvgColorString('stroke', style.stroke) : '',
          textDecoration = this.getSvgTextDecoration(style),
          deltaY = style.deltaY ? 'baseline-shift: ' + (-style.deltaY) + '; ' : '';
      if (textDecoration) {
        textDecoration = 'text-decoration: ' + textDecoration + term;
      }

      return [
        stroke,
        strokeWidth,
        fontFamily,
        fontSize,
        fontStyle,
        fontWeight,
        textDecoration,
        fill,
        deltaY,
        useWhiteSpace ? 'white-space: pre; ' : ''
      ].join('');
    },

    /**
     * Returns text-decoration property for svg-export
     * @param {Object} style the object from which to retrieve style properties
     * @return {String}
     */
    getSvgTextDecoration: function(style) {
      if ('overline' in style || 'underline' in style || 'linethrough' in style) {
        return (style.overline ? 'overline ' : '') +
          (style.underline ? 'underline ' : '') + (style.linethrough ? 'line-through ' : '');
      }
      return '';
    },

    /**
     * Returns filter for svg shadow
     * @return {String}
     */
    getSvgFilter: function() {
      return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
    },

    /**
     * Returns id attribute for svg output
     * @return {String}
     */
    getSvgCommons: function() {
      return [
        this.id ? 'id="' + this.id + '" ' : '',
        this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : '',
      ].join('');
    },

    /**
     * Returns transform-string for svg-export
     * @param {Boolean} use the full transform or the single object one.
     * @return {String}
     */
    getSvgTransform: function(full, additionalTransform) {
      var transform = full ? this.calcTransformMatrix() : this.calcOwnMatrix(),
          svgTransform = transform.map(function(value) {
            return toFixed(value, fabric.Object.NUM_FRACTION_DIGITS);
          }).join(' ');
      return 'transform="matrix(' + svgTransform + ')' +
        (additionalTransform || '') + this.getSvgTransformMatrix() + '" ';
    },

    /**
     * Returns transform-string for svg-export from the transform matrix of single elements
     * @return {String}
     */
    getSvgTransformMatrix: function() {
      return this.transformMatrix ? ' matrix(' + this.transformMatrix.join(' ') + ')' : '';
    },

    _setSVGBg: function(textBgRects) {
      if (this.backgroundColor) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
        textBgRects.push(
          '\t\t<rect ',
          this._getFillAttributes(this.backgroundColor),
          ' x="',
          toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
          '" y="',
          toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
          '" width="',
          toFixed(this.width, NUM_FRACTION_DIGITS),
          '" height="',
          toFixed(this.height, NUM_FRACTION_DIGITS),
          '"></rect>\n');
      }
    },

    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      return this._createBaseSVGMarkup(this._toSVG(), { reviver: reviver });
    },

    /**
     * Returns svg clipPath representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toClipPathSVG: function(reviver) {
      return '\t' + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: reviver });
    },

    /**
     * @private
     */
    _createBaseClipPathSVGMarkup: function(objectMarkup, options) {
      options = options || {};
      var reviver = options.reviver,
          additionalTransform = options.additionalTransform || '',
          commonPieces = [
            this.getSvgTransform(true, additionalTransform),
            this.getSvgCommons(),
          ].join(''),
          // insert commons in the markup, style and svgCommons
          index = objectMarkup.indexOf('COMMON_PARTS');
      objectMarkup[index] = commonPieces;
      return reviver ? reviver(objectMarkup.join('')) : objectMarkup.join('');
    },

    /**
     * @private
     */
    _createBaseSVGMarkup: function(objectMarkup, options) {
      options = options || {};
      var noStyle = options.noStyle, withShadow = options.withShadow,
          reviver = options.reviver,
          styleInfo = noStyle ? '' : 'style="' + this.getSvgStyles() + '" ',
          shadowInfo = withShadow ? 'style="' + this.getSvgFilter() + '" ' : '',
          clipPath = this.clipPath,
          absoluteClipPath = this.clipPath && this.clipPath.absolutePositioned,
          commonPieces, markup = [], clipPathMarkup,
          // insert commons in the markup, style and svgCommons
          index = objectMarkup.indexOf('COMMON_PARTS'),
          additionalTransform = options.additionalTransform;
      if (clipPath) {
        clipPath.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
        clipPathMarkup = '<clipPath id="' + clipPath.clipPathId + '" >\n' +
          this.clipPath.toClipPathSVG(reviver) +
          '</clipPath>\n';
      }
      if (absoluteClipPath) {
        markup.push(
          '<g ', shadowInfo, this.getSvgCommons(), ' >\n'
        );
      }
      markup.push(
        '<g ',
        this.getSvgTransform(false),
        !absoluteClipPath ? shadowInfo + this.getSvgCommons() : '',
        ' >\n'
      );
      commonPieces = [
        styleInfo,
        noStyle ? '' : this.addPaintOrder(), ' ',
        additionalTransform ? 'transform="' + additionalTransform + '" ' : '',
      ].join('');
      objectMarkup[index] = commonPieces;
      if (this.fill && this.fill.toLive) {
        markup.push(this.fill.toSVG(this, false));
      }
      if (this.stroke && this.stroke.toLive) {
        markup.push(this.stroke.toSVG(this, false));
      }
      if (this.shadow) {
        markup.push(this.shadow.toSVG(this));
      }
      if (clipPath) {
        markup.push(clipPathMarkup);
      }
      markup.push(objectMarkup.join(''));
      markup.push('</g>\n');
      absoluteClipPath && markup.push('</g>\n');
      return reviver ? reviver(markup.join('')) : markup.join('');
    },

    addPaintOrder: function() {
      return this.paintFirst !== 'fill' ? ' paint-order="' + this.paintFirst + '" ' : '';
    }
  });
})();
/* _TO_SVG_END_ */


(function() {

  var extend = fabric.util.object.extend,
      originalSet = 'stateProperties';

  /*
    Depends on `stateProperties`
  */
  function saveProps(origin, destination, props) {
    var tmpObj = { }, deep = true;
    props.forEach(function(prop) {
      tmpObj[prop] = origin[prop];
    });
    extend(origin[destination], tmpObj, deep);
  }

  function _isEqual(origValue, currentValue, firstPass) {
    if (origValue === currentValue) {
      // if the objects are identical, return
      return true;
    }
    else if (Array.isArray(origValue)) {
      if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {
        return false;
      }
      for (var i = 0, len = origValue.length; i < len; i++) {
        if (!_isEqual(origValue[i], currentValue[i])) {
          return false;
        }
      }
      return true;
    }
    else if (origValue && typeof origValue === 'object') {
      var keys = Object.keys(origValue), key;
      if (!currentValue ||
          typeof currentValue !== 'object' ||
          (!firstPass && keys.length !== Object.keys(currentValue).length)
      ) {
        return false;
      }
      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        // since clipPath is in the statefull cache list and the clipPath objects
        // would be iterated as an object, this would lead to possible infinite recursion
        if (key === 'canvas') {
          continue;
        }
        if (!_isEqual(origValue[key], currentValue[key])) {
          return false;
        }
      }
      return true;
    }
  }


  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Returns true if object state (one of its state properties) was changed
     * @param {String} [propertySet] optional name for the set of property we want to save
     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
     */
    hasStateChanged: function(propertySet) {
      propertySet = propertySet || originalSet;
      var dashedPropertySet = '_' + propertySet;
      if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {
        return true;
      }
      return !_isEqual(this[dashedPropertySet], this, true);
    },

    /**
     * Saves state of an object
     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
     * @return {fabric.Object} thisArg
     */
    saveState: function(options) {
      var propertySet = options && options.propertySet || originalSet,
          destination = '_' + propertySet;
      if (!this[destination]) {
        return this.setupState(options);
      }
      saveProps(this, destination, this[propertySet]);
      if (options && options.stateProperties) {
        saveProps(this, destination, options.stateProperties);
      }
      return this;
    },

    /**
     * Setups state of an object
     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
     * @return {fabric.Object} thisArg
     */
    setupState: function(options) {
      options = options || { };
      var propertySet = options.propertySet || originalSet;
      options.propertySet = propertySet;
      this['_' + propertySet] = { };
      this.saveState(options);
      return this;
    }
  });
})();


(function() {

  var degreesToRadians = fabric.util.degreesToRadians;

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * The object interactivity controls.
     * @private
     */
    _controlsVisibility: null,

    /**
     * Determines which corner has been clicked
     * @private
     * @param {Object} pointer The pointer indicating the mouse position
     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
     */
    _findTargetCorner: function(pointer) {
      // objects in group, anykind, are not self modificable,
      // must not return an hovered corner.
      if (!this.hasControls || this.group || (!this.canvas || this.canvas._activeObject !== this)) {
        return false;
      }

      var ex = pointer.x,
          ey = pointer.y,
          xPoints,
          lines;
      this.__corner = 0;
      for (var i in this.oCoords) {

        if (!this.isControlVisible(i)) {
          continue;
        }

        if (i === 'mtr' && !this.hasRotatingPoint) {
          continue;
        }

        if (this.get('lockUniScaling') &&
           (i === 'mt' || i === 'mr' || i === 'mb' || i === 'ml')) {
          continue;
        }

        lines = this._getImageLines(this.oCoords[i].corner);

        // debugging

        // canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
        // canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);

        // canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
        // canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);

        // canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
        // canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);

        // canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
        // canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);

        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
        if (xPoints !== 0 && xPoints % 2 === 1) {
          this.__corner = i;
          return i;
        }
      }
      return false;
    },

    /**
     * Sets the coordinates of the draggable boxes in the corners of
     * the image used to scale/rotate it.
     * @private
     */
    _setCornerCoords: function() {
      var coords = this.oCoords,
          newTheta = degreesToRadians(45 - this.angle),
          /* Math.sqrt(2 * Math.pow(this.cornerSize, 2)) / 2, */
          /* 0.707106 stands for sqrt(2)/2 */
          cornerHypotenuse = this.cornerSize * 0.707106,
          cosHalfOffset = cornerHypotenuse * fabric.util.cos(newTheta),
          sinHalfOffset = cornerHypotenuse * fabric.util.sin(newTheta),
          x, y;

      for (var point in coords) {
        x = coords[point].x;
        y = coords[point].y;
        coords[point].corner = {
          tl: {
            x: x - sinHalfOffset,
            y: y - cosHalfOffset
          },
          tr: {
            x: x + cosHalfOffset,
            y: y - sinHalfOffset
          },
          bl: {
            x: x - cosHalfOffset,
            y: y + sinHalfOffset
          },
          br: {
            x: x + sinHalfOffset,
            y: y + cosHalfOffset
          }
        };
      }
    },

    /**
     * Draws a colored layer behind the object, inside its selection borders.
     * Requires public options: padding, selectionBackgroundColor
     * this function is called when the context is transformed
     * has checks to be skipped when the object is on a staticCanvas
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawSelectionBackground: function(ctx) {
      if (!this.selectionBackgroundColor ||
        (this.canvas && !this.canvas.interactive) ||
        (this.canvas && this.canvas._activeObject !== this)
      ) {
        return this;
      }
      ctx.save();
      var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),
          vpt = this.canvas.viewportTransform;
      ctx.translate(center.x, center.y);
      ctx.scale(1 / vpt[0], 1 / vpt[3]);
      ctx.rotate(degreesToRadians(this.angle));
      ctx.fillStyle = this.selectionBackgroundColor;
      ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
      ctx.restore();
      return this;
    },

    /**
     * Draws borders of an object's bounding box.
     * Requires public properties: width, height
     * Requires public options: padding, borderColor
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawBorders: function(ctx, styleOverride) {
      styleOverride = styleOverride || {};
      var wh = this._calculateCurrentDimensions(),
          strokeWidth = 1 / this.borderScaleFactor,
          width = wh.x + strokeWidth,
          height = wh.y + strokeWidth,
          drawRotatingPoint = typeof styleOverride.hasRotatingPoint !== 'undefined' ?
            styleOverride.hasRotatingPoint : this.hasRotatingPoint,
          hasControls = typeof styleOverride.hasControls !== 'undefined' ?
            styleOverride.hasControls : this.hasControls,
          rotatingPointOffset = typeof styleOverride.rotatingPointOffset !== 'undefined' ?
            styleOverride.rotatingPointOffset : this.rotatingPointOffset;

      ctx.save();
      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);

      ctx.strokeRect(
        -width / 2,
        -height / 2,
        width,
        height
      );

      if (drawRotatingPoint && this.isControlVisible('mtr') && hasControls) {

        var rotateHeight = -height / 2;

        ctx.beginPath();
        ctx.moveTo(0, rotateHeight);
        ctx.lineTo(0, rotateHeight - rotatingPointOffset);
        ctx.stroke();
      }

      ctx.restore();
      return this;
    },

    /**
     * Draws borders of an object's bounding box when it is inside a group.
     * Requires public properties: width, height
     * Requires public options: padding, borderColor
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {object} options object representing current object parameters
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawBordersInGroup: function(ctx, options, styleOverride) {
      styleOverride = styleOverride || {};
      var p = this._getNonTransformedDimensions(),
          matrix = fabric.util.customTransformMatrix(options.scaleX, options.scaleY, options.skewX),
          wh = fabric.util.transformPoint(p, matrix),
          strokeWidth = 1 / this.borderScaleFactor,
          width = wh.x + strokeWidth,
          height = wh.y + strokeWidth;

      ctx.save();
      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);
      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;

      ctx.strokeRect(
        -width / 2,
        -height / 2,
        width,
        height
      );

      ctx.restore();
      return this;
    },

    /**
     * Draws corners of an object's bounding box.
     * Requires public properties: width, height
     * Requires public options: cornerSize, padding
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawControls: function(ctx, styleOverride) {
      styleOverride = styleOverride || {};
      var wh = this._calculateCurrentDimensions(),
          width = wh.x,
          height = wh.y,
          scaleOffset = styleOverride.cornerSize || this.cornerSize,
          left = -(width + scaleOffset) / 2,
          top = -(height + scaleOffset) / 2,
          transparentCorners = typeof styleOverride.transparentCorners !== 'undefined' ?
            styleOverride.transparentCorners : this.transparentCorners,
          hasRotatingPoint = typeof styleOverride.hasRotatingPoint !== 'undefined' ?
            styleOverride.hasRotatingPoint : this.hasRotatingPoint,
          methodName = transparentCorners ? 'stroke' : 'fill';

      ctx.save();
      ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;
      if (!this.transparentCorners) {
        ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;
      }
      this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray, null);

      // top-left
      this._drawControl('tl', ctx, methodName,
        left,
        top, styleOverride);

      // top-right
      this._drawControl('tr', ctx, methodName,
        left + width,
        top, styleOverride);

      // bottom-left
      this._drawControl('bl', ctx, methodName,
        left,
        top + height, styleOverride);

      // bottom-right
      this._drawControl('br', ctx, methodName,
        left + width,
        top + height, styleOverride);

      if (!this.get('lockUniScaling')) {

        // middle-top
        this._drawControl('mt', ctx, methodName,
          left + width / 2,
          top, styleOverride);

        // middle-bottom
        this._drawControl('mb', ctx, methodName,
          left + width / 2,
          top + height, styleOverride);

        // middle-right
        this._drawControl('mr', ctx, methodName,
          left + width,
          top + height / 2, styleOverride);

        // middle-left
        this._drawControl('ml', ctx, methodName,
          left,
          top + height / 2, styleOverride);
      }

      // middle-top-rotate
      if (hasRotatingPoint) {
        this._drawControl('mtr', ctx, methodName,
          left + width / 2,
          top - this.rotatingPointOffset, styleOverride);
      }

      ctx.restore();

      return this;
    },

    /**
     * @private
     */
    _drawControl: function(control, ctx, methodName, left, top, styleOverride) {
      styleOverride = styleOverride || {};
      if (!this.isControlVisible(control)) {
        return;
      }
      var size = this.cornerSize, stroke = !this.transparentCorners && this.cornerStrokeColor;
      switch (styleOverride.cornerStyle || this.cornerStyle) {
        case 'circle':
          ctx.beginPath();
          ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI, false);
          ctx[methodName]();
          if (stroke) {
            ctx.stroke();
          }
          break;
        default:
          this.transparentCorners || ctx.clearRect(left, top, size, size);
          ctx[methodName + 'Rect'](left, top, size, size);
          if (stroke) {
            ctx.strokeRect(left, top, size, size);
          }
      }
    },

    /**
     * Returns true if the specified control is visible, false otherwise.
     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
     * @returns {Boolean} true if the specified control is visible, false otherwise
     */
    isControlVisible: function(controlName) {
      return this._getControlsVisibility()[controlName];
    },

    /**
     * Sets the visibility of the specified control.
     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
     * @param {Boolean} visible true to set the specified control visible, false otherwise
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setControlVisible: function(controlName, visible) {
      this._getControlsVisibility()[controlName] = visible;
      return this;
    },

    /**
     * Sets the visibility state of object controls.
     * @param {Object} [options] Options object
     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setControlsVisibility: function(options) {
      options || (options = { });

      for (var p in options) {
        this.setControlVisible(p, options[p]);
      }
      return this;
    },

    /**
     * Returns the instance of the control visibility set for this object.
     * @private
     * @returns {Object}
     */
    _getControlsVisibility: function() {
      if (!this._controlsVisibility) {
        this._controlsVisibility = {
          tl: true,
          tr: true,
          br: true,
          bl: true,
          ml: true,
          mt: true,
          mr: true,
          mb: true,
          mtr: true
        };
      }
      return this._controlsVisibility;
    },

    /**
     * This callback function is called every time _discardActiveObject or _setActiveObject
     * try to to deselect this object. If the function returns true, the process is cancelled
     * @param {Object} [options] options sent from the upper functions
     * @param {Event} [options.e] event if the process is generated by an event
     */
    onDeselect: function() {
      // implemented by sub-classes, as needed.
    },


    /**
     * This callback function is called every time _discardActiveObject or _setActiveObject
     * try to to select this object. If the function returns true, the process is cancelled
     * @param {Object} [options] options sent from the upper functions
     * @param {Event} [options.e] event if the process is generated by an event
     */
    onSelect: function() {
      // implemented by sub-classes, as needed.
    }
  });
})();


fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

  /**
   * Animation duration (in ms) for fx* methods
   * @type Number
   * @default
   */
  FX_DURATION: 500,

  /**
   * Centers object horizontally with animation.
   * @param {fabric.Object} object Object to center
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxCenterObjectH: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: object.left,
      endValue: this.getCenter().left,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('left', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function() {
        object.setCoords();
        onComplete();
      }
    });

    return this;
  },

  /**
   * Centers object vertically with animation.
   * @param {fabric.Object} object Object to center
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxCenterObjectV: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: object.top,
      endValue: this.getCenter().top,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('top', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function() {
        object.setCoords();
        onComplete();
      }
    });

    return this;
  },

  /**
   * Same as `fabric.Canvas#remove` but animated
   * @param {fabric.Object} object Object to remove
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxRemove: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: object.opacity,
      endValue: 0,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('opacity', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function () {
        _this.remove(object);
        onComplete();
      }
    });

    return this;
  }
});

fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
  /**
   * Animates object's properties
   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
   * @param {Number|Object} value Value to animate property to (if string was given first) or options object
   * @return {fabric.Object} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
   * @chainable
   *
   * As object  multiple properties
   *
   * object.animate({ left: ..., top: ... });
   * object.animate({ left: ..., top: ... }, { duration: ... });
   *
   * As string  one property
   *
   * object.animate('left', ...);
   * object.animate('left', { duration: ... });
   *
   */
  animate: function() {
    if (arguments[0] && typeof arguments[0] === 'object') {
      var propsToAnimate = [], prop, skipCallbacks;
      for (prop in arguments[0]) {
        propsToAnimate.push(prop);
      }
      for (var i = 0, len = propsToAnimate.length; i < len; i++) {
        prop = propsToAnimate[i];
        skipCallbacks = i !== len - 1;
        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
      }
    }
    else {
      this._animate.apply(this, arguments);
    }
    return this;
  },

  /**
   * @private
   * @param {String} property Property to animate
   * @param {String} to Value to animate to
   * @param {Object} [options] Options object
   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
   */
  _animate: function(property, to, options, skipCallbacks) {
    var _this = this, propPair;

    to = to.toString();

    if (!options) {
      options = { };
    }
    else {
      options = fabric.util.object.clone(options);
    }

    if (~property.indexOf('.')) {
      propPair = property.split('.');
    }

    var currentValue = propPair
      ? this.get(propPair[0])[propPair[1]]
      : this.get(property);

    if (!('from' in options)) {
      options.from = currentValue;
    }

    if (~to.indexOf('=')) {
      to = currentValue + parseFloat(to.replace('=', ''));
    }
    else {
      to = parseFloat(to);
    }

    fabric.util.animate({
      startValue: options.from,
      endValue: to,
      byValue: options.by,
      easing: options.easing,
      duration: options.duration,
      abort: options.abort && function() {
        return options.abort.call(_this);
      },
      onChange: function(value, valueProgress, timeProgress) {
        if (propPair) {
          _this[propPair[0]][propPair[1]] = value;
        }
        else {
          _this.set(property, value);
        }
        if (skipCallbacks) {
          return;
        }
        options.onChange && options.onChange(value, valueProgress, timeProgress);
      },
      onComplete: function(value, valueProgress, timeProgress) {
        if (skipCallbacks) {
          return;
        }

        _this.setCoords();
        options.onComplete && options.onComplete(value, valueProgress, timeProgress);
      }
    });
  }
});


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },
      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');

  if (fabric.Line) {
    fabric.warn('fabric.Line is already defined');
    return;
  }

  /**
   * Line class
   * @class fabric.Line
   * @extends fabric.Object
   * @see {@link fabric.Line#initialize} for constructor definition
   */
  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'line',

    /**
     * x value or first line edge
     * @type Number
     * @default
     */
    x1: 0,

    /**
     * y value or first line edge
     * @type Number
     * @default
     */
    y1: 0,

    /**
     * x value or second line edge
     * @type Number
     * @default
     */
    x2: 0,

    /**
     * y value or second line edge
     * @type Number
     * @default
     */
    y2: 0,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('x1', 'x2', 'y1', 'y2'),

    /**
     * Constructor
     * @param {Array} [points] Array of points
     * @param {Object} [options] Options object
     * @return {fabric.Line} thisArg
     */
    initialize: function(points, options) {
      if (!points) {
        points = [0, 0, 0, 0];
      }

      this.callSuper('initialize', options);

      this.set('x1', points[0]);
      this.set('y1', points[1]);
      this.set('x2', points[2]);
      this.set('y2', points[3]);

      this._setWidthHeight(options);
    },

    /**
     * @private
     * @param {Object} [options] Options
     */
    _setWidthHeight: function(options) {
      options || (options = { });

      this.width = Math.abs(this.x2 - this.x1);
      this.height = Math.abs(this.y2 - this.y1);

      this.left = 'left' in options
        ? options.left
        : this._getLeftToOriginX();

      this.top = 'top' in options
        ? options.top
        : this._getTopToOriginY();
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);
      if (typeof coordProps[key] !== 'undefined') {
        this._setWidthHeight();
      }
      return this;
    },

    /**
     * @private
     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
     */
    _getLeftToOriginX: makeEdgeToOriginGetter(
      { // property names
        origin: 'originX',
        axis1: 'x1',
        axis2: 'x2',
        dimension: 'width'
      },
      { // possible values of origin
        nearest: 'left',
        center: 'center',
        farthest: 'right'
      }
    ),

    /**
     * @private
     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
     */
    _getTopToOriginY: makeEdgeToOriginGetter(
      { // property names
        origin: 'originY',
        axis1: 'y1',
        axis2: 'y2',
        dimension: 'height'
      },
      { // possible values of origin
        nearest: 'top',
        center: 'center',
        farthest: 'bottom'
      }
    ),

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();

      if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {
        // move from center (of virtual box) to its left/top corner
        // we can't assume x1, y1 is top left and x2, y2 is bottom right
        var p = this.calcLinePoints();
        ctx.moveTo(p.x1, p.y1);
        ctx.lineTo(p.x2, p.y2);
      }

      ctx.lineWidth = this.strokeWidth;

      // TODO: test this
      // make sure setting "fill" changes color of a line
      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
      var origStrokeStyle = ctx.strokeStyle;
      ctx.strokeStyle = this.stroke || ctx.fillStyle;
      this.stroke && this._renderStroke(ctx);
      ctx.strokeStyle = origStrokeStyle;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var p = this.calcLinePoints();

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);
      ctx.closePath();
    },

    /**
     * This function is an helper for svg import. it returns the center of the object in the svg
     * untransformed coordinates
     * @private
     * @return {Object} center point from element coordinates
     */
    _findCenterFromElement: function() {
      return {
        x: (this.x1 + this.x2) / 2,
        y: (this.y1 + this.y2) / 2,
      };
    },

    /**
     * Returns object representation of an instance
     * @methd toObject
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
    },

    /*
     * Calculate object dimensions from its properties
     * @private
     */
    _getNonTransformedDimensions: function() {
      var dim = this.callSuper('_getNonTransformedDimensions');
      if (this.strokeLineCap === 'butt') {
        if (this.width === 0) {
          dim.y -= this.strokeWidth;
        }
        if (this.height === 0) {
          dim.x -= this.strokeWidth;
        }
      }
      return dim;
    },

    /**
     * Recalculates line points given width and height
     * @private
     */
    calcLinePoints: function() {
      var xMult = this.x1 <= this.x2 ? -1 : 1,
          yMult = this.y1 <= this.y2 ? -1 : 1,
          x1 = (xMult * this.width * 0.5),
          y1 = (yMult * this.height * 0.5),
          x2 = (xMult * this.width * -0.5),
          y2 = (yMult * this.height * -0.5);

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2
      };
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var p = this.calcLinePoints();
      return [
        '<line ', 'COMMON_PARTS',
        'x1="', p.x1,
        '" y1="', p.y1,
        '" x2="', p.x2,
        '" y2="', p.y2,
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
   * @static
   * @memberOf fabric.Line
   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
   */
  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));

  /**
   * Returns fabric.Line instance from an SVG element
   * @static
   * @memberOf fabric.Line
   * @param {SVGElement} element Element to parse
   * @param {Object} [options] Options object
   * @param {Function} [callback] callback function invoked after parsing
   */
  fabric.Line.fromElement = function(element, callback, options) {
    options = options || { };
    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
        points = [
          parsedAttributes.x1 || 0,
          parsedAttributes.y1 || 0,
          parsedAttributes.x2 || 0,
          parsedAttributes.y2 || 0
        ];
    callback(new fabric.Line(points, extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Line instance from an object representation
   * @static
   * @memberOf fabric.Line
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   */
  fabric.Line.fromObject = function(object, callback) {
    function _callback(instance) {
      delete instance.points;
      callback && callback(instance);
    };
    var options = clone(object, true);
    options.points = [object.x1, object.y1, object.x2, object.y2];
    fabric.Object._fromObject('Line', options, _callback, 'points');
  };

  /**
   * Produces a function that calculates distance from canvas edge to Line origin.
   */
  function makeEdgeToOriginGetter(propertyNames, originValues) {
    var origin = propertyNames.origin,
        axis1 = propertyNames.axis1,
        axis2 = propertyNames.axis2,
        dimension = propertyNames.dimension,
        nearest = originValues.nearest,
        center = originValues.center,
        farthest = originValues.farthest;

    return function() {
      switch (this.get(origin)) {
        case nearest:
          return Math.min(this.get(axis1), this.get(axis2));
        case center:
          return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
        case farthest:
          return Math.max(this.get(axis1), this.get(axis2));
      }
    };

  }

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      pi = Math.PI;

  if (fabric.Circle) {
    fabric.warn('fabric.Circle is already defined.');
    return;
  }

  /**
   * Circle class
   * @class fabric.Circle
   * @extends fabric.Object
   * @see {@link fabric.Circle#initialize} for constructor definition
   */
  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'circle',

    /**
     * Radius of this circle
     * @type Number
     * @default
     */
    radius: 0,

    /**
     * Start angle of the circle, moving clockwise
     * deprectated type, this should be in degree, this was an oversight.
     * probably will change to degrees in next major version
     * @type Number
     * @default 0
     */
    startAngle: 0,

    /**
     * End angle of the circle
     * deprectated type, this should be in degree, this was an oversight.
     * probably will change to degrees in next major version
     * @type Number
     * @default 2Pi
     */
    endAngle: pi * 2,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('radius', 'startAngle', 'endAngle'),

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Circle} thisArg
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);

      if (key === 'radius') {
        this.setRadius(value);
      }

      return this;
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */

    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var svgString, x = 0, y = 0,
          angle = (this.endAngle - this.startAngle) % ( 2 * pi);

      if (angle === 0) {
        svgString = [
          '<circle ', 'COMMON_PARTS',
          'cx="' + x + '" cy="' + y + '" ',
          'r="', this.radius,
          '" />\n'
        ];
      }
      else {
        var startX = fabric.util.cos(this.startAngle) * this.radius,
            startY = fabric.util.sin(this.startAngle) * this.radius,
            endX = fabric.util.cos(this.endAngle) * this.radius,
            endY = fabric.util.sin(this.endAngle) * this.radius,
            largeFlag = angle > pi ? '1' : '0';
        svgString = [
          '<path d="M ' + startX + ' ' + startY,
          ' A ' + this.radius + ' ' + this.radius,
          ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,
          '"', 'COMMON_PARTS', ' />\n'
        ];
      }
      return svgString;
    },
    /* _TO_SVG_END_ */

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();
      ctx.arc(
        0,
        0,
        this.radius,
        this.startAngle,
        this.endAngle, false);
      this._renderPaintInOrder(ctx);
    },

    /**
     * Returns horizontal radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRadiusX: function() {
      return this.get('radius') * this.get('scaleX');
    },

    /**
     * Returns vertical radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRadiusY: function() {
      return this.get('radius') * this.get('scaleY');
    },

    /**
     * Sets radius of an object (and updates width accordingly)
     * @return {fabric.Circle} thisArg
     */
    setRadius: function(value) {
      this.radius = value;
      return this.set('width', value * 2).set('height', value * 2);
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
   * @static
   * @memberOf fabric.Circle
   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
   */
  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));

  /**
   * Returns {@link fabric.Circle} instance from an SVG element
   * @static
   * @memberOf fabric.Circle
   * @param {SVGElement} element Element to parse
   * @param {Function} [callback] Options callback invoked after parsing is finished
   * @param {Object} [options] Options object
   * @throws {Error} If value of `r` attribute is missing or invalid
   */
  fabric.Circle.fromElement = function(element, callback) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);

    if (!isValidRadius(parsedAttributes)) {
      throw new Error('value of `r` attribute is required and can not be negative');
    }

    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;
    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;
    callback(new fabric.Circle(parsedAttributes));
  };

  /**
   * @private
   */
  function isValidRadius(attributes) {
    return (('radius' in attributes) && (attributes.radius >= 0));
  }
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Circle} instance from an object representation
   * @static
   * @memberOf fabric.Circle
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   * @return {Object} Instance of fabric.Circle
   */
  fabric.Circle.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Circle', object, callback);
  };

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Triangle) {
    fabric.warn('fabric.Triangle is already defined');
    return;
  }

  /**
   * Triangle class
   * @class fabric.Triangle
   * @extends fabric.Object
   * @return {fabric.Triangle} thisArg
   * @see {@link fabric.Triangle#initialize} for constructor definition
   */
  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'triangle',

    /**
     * Width is set to 100 to compensate the old initialize code that was setting it to 100
     * @type Number
     * @default
     */
    width: 100,

    /**
     * Height is set to 100 to compensate the old initialize code that was setting it to 100
     * @type Number
     * @default
     */
    height: 100,

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2;

      ctx.beginPath();
      ctx.moveTo(-widthBy2, heightBy2);
      ctx.lineTo(0, -heightBy2);
      ctx.lineTo(widthBy2, heightBy2);
      ctx.closePath();

      this._renderPaintInOrder(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2;

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);
      ctx.closePath();
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2,
          points = [
            -widthBy2 + ' ' + heightBy2,
            '0 ' + -heightBy2,
            widthBy2 + ' ' + heightBy2
          ].join(',');
      return [
        '<polygon ', 'COMMON_PARTS',
        'points="', points,
        '" />'
      ];
    },
    /* _TO_SVG_END_ */
  });

  /**
   * Returns {@link fabric.Triangle} instance from an object representation
   * @static
   * @memberOf fabric.Triangle
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   */
  fabric.Triangle.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Triangle', object, callback);
  };

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      piBy2   = Math.PI * 2;

  if (fabric.Ellipse) {
    fabric.warn('fabric.Ellipse is already defined.');
    return;
  }

  /**
   * Ellipse class
   * @class fabric.Ellipse
   * @extends fabric.Object
   * @return {fabric.Ellipse} thisArg
   * @see {@link fabric.Ellipse#initialize} for constructor definition
   */
  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'ellipse',

    /**
     * Horizontal radius
     * @type Number
     * @default
     */
    rx:   0,

    /**
     * Vertical radius
     * @type Number
     * @default
     */
    ry:   0,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @return {fabric.Ellipse} thisArg
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      this.set('rx', options && options.rx || 0);
      this.set('ry', options && options.ry || 0);
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Ellipse} thisArg
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);
      switch (key) {

        case 'rx':
          this.rx = value;
          this.set('width', value * 2);
          break;

        case 'ry':
          this.ry = value;
          this.set('height', value * 2);
          break;

      }
      return this;
    },

    /**
     * Returns horizontal radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRx: function() {
      return this.get('rx') * this.get('scaleX');
    },

    /**
     * Returns Vertical radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRy: function() {
      return this.get('ry') * this.get('scaleY');
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      return [
        '<ellipse ', 'COMMON_PARTS',
        'cx="0" cy="0" ',
        'rx="', this.rx,
        '" ry="', this.ry,
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();
      ctx.save();
      ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
      ctx.arc(
        0,
        0,
        this.rx,
        0,
        piBy2,
        false);
      ctx.restore();
      this._renderPaintInOrder(ctx);
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
   * @static
   * @memberOf fabric.Ellipse
   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
   */
  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));

  /**
   * Returns {@link fabric.Ellipse} instance from an SVG element
   * @static
   * @memberOf fabric.Ellipse
   * @param {SVGElement} element Element to parse
   * @param {Function} [callback] Options callback invoked after parsing is finished
   * @return {fabric.Ellipse}
   */
  fabric.Ellipse.fromElement = function(element, callback) {

    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);

    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;
    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;
    callback(new fabric.Ellipse(parsedAttributes));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Ellipse} instance from an object representation
   * @static
   * @memberOf fabric.Ellipse
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   * @return {fabric.Ellipse}
   */
  fabric.Ellipse.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Ellipse', object, callback);
  };

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend;

  if (fabric.Rect) {
    fabric.warn('fabric.Rect is already defined');
    return;
  }

  /**
   * Rectangle class
   * @class fabric.Rect
   * @extends fabric.Object
   * @return {fabric.Rect} thisArg
   * @see {@link fabric.Rect#initialize} for constructor definition
   */
  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {

    /**
     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: fabric.Object.prototype.stateProperties.concat('rx', 'ry'),

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'rect',

    /**
     * Horizontal border radius
     * @type Number
     * @default
     */
    rx:   0,

    /**
     * Vertical border radius
     * @type Number
     * @default
     */
    ry:   0,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      this._initRxRy();
    },

    /**
     * Initializes rx/ry attributes
     * @private
     */
    _initRxRy: function() {
      if (this.rx && !this.ry) {
        this.ry = this.rx;
      }
      else if (this.ry && !this.rx) {
        this.rx = this.ry;
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {

      // 1x1 case (used in spray brush) optimization was removed because
      // with caching and higher zoom level this makes more damage than help

      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
          w = this.width,
          h = this.height,
          x = -this.width / 2,
          y = -this.height / 2,
          isRounded = rx !== 0 || ry !== 0,
          /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
          k = 1 - 0.5522847498;
      ctx.beginPath();

      ctx.moveTo(x + rx, y);

      ctx.lineTo(x + w - rx, y);
      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);

      ctx.lineTo(x + w, y + h - ry);
      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);

      ctx.lineTo(x + rx, y + h);
      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);

      ctx.lineTo(x, y + ry);
      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);

      ctx.closePath();

      this._renderPaintInOrder(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var x = -this.width / 2,
          y = -this.height / 2,
          w = this.width,
          h = this.height;

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
      ctx.closePath();
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var x = -this.width / 2, y = -this.height / 2;
      return [
        '<rect ', 'COMMON_PARTS',
        'x="', x, '" y="', y,
        '" rx="', this.rx, '" ry="', this.ry,
        '" width="', this.width, '" height="', this.height,
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
   * @static
   * @memberOf fabric.Rect
   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
   */
  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));

  /**
   * Returns {@link fabric.Rect} instance from an SVG element
   * @static
   * @memberOf fabric.Rect
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Rect.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }
    options = options || { };

    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);

    parsedAttributes.left = parsedAttributes.left || 0;
    parsedAttributes.top  = parsedAttributes.top  || 0;
    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
    rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
    callback(rect);
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Rect} instance from an object representation
   * @static
   * @memberOf fabric.Rect
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created
   */
  fabric.Rect.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Rect', object, callback);
  };

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      min = fabric.util.array.min,
      max = fabric.util.array.max,
      toFixed = fabric.util.toFixed;

  if (fabric.Polyline) {
    fabric.warn('fabric.Polyline is already defined');
    return;
  }

  /**
   * Polyline class
   * @class fabric.Polyline
   * @extends fabric.Object
   * @see {@link fabric.Polyline#initialize} for constructor definition
   */
  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'polyline',

    /**
     * Points array
     * @type Array
     * @default
     */
    points: null,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('points'),

    /**
     * Constructor
     * @param {Array} points Array of points (where each point is an object with x and y)
     * @param {Object} [options] Options object
     * @return {fabric.Polyline} thisArg
     * @example
     * var poly = new fabric.Polyline([
     *     { x: 10, y: 10 },
     *     { x: 50, y: 30 },
     *     { x: 40, y: 70 },
     *     { x: 60, y: 50 },
     *     { x: 100, y: 150 },
     *     { x: 40, y: 100 }
     *   ], {
     *   stroke: 'red',
     *   left: 100,
     *   top: 100
     * });
     */
    initialize: function(points, options) {
      options = options || {};
      this.points = points || [];
      this.callSuper('initialize', options);
      var calcDim = this._calcDimensions();
      if (typeof options.left === 'undefined') {
        this.left = calcDim.left;
      }
      if (typeof options.top === 'undefined') {
        this.top = calcDim.top;
      }
      this.width = calcDim.width;
      this.height = calcDim.height;
      this.pathOffset = {
        x: calcDim.left + this.width / 2,
        y: calcDim.top + this.height / 2
      };
    },

    /**
     * Calculate the polygon min and max point from points array,
     * returning an object with left, top, widht, height to measure the
     * polygon size
     * @return {Object} object.left X coordinate of the polygon leftmost point
     * @return {Object} object.top Y coordinate of the polygon topmost point
     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point
     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point
     * @private
     */
    _calcDimensions: function() {

      var points = this.points,
          minX = min(points, 'x') || 0,
          minY = min(points, 'y') || 0,
          maxX = max(points, 'x') || 0,
          maxY = max(points, 'y') || 0,
          width = (maxX - minX),
          height = (maxY - minY);

      return {
        left: minX,
        top: minY,
        width: width,
        height: height
      };
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), {
        points: this.points.concat()
      });
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y,
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

      for (var i = 0, len = this.points.length; i < len; i++) {
        points.push(
          toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), ',',
          toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), ' '
        );
      }
      return [
        '<' + this.type + ' ', 'COMMON_PARTS',
        'points="', points.join(''),
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */


    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    commonRender: function(ctx) {
      var point, len = this.points.length,
          x = this.pathOffset.x,
          y = this.pathOffset.y;

      if (!len || isNaN(this.points[len - 1].y)) {
        // do not draw if no points or odd points
        // NaN comes from parseFloat of a empty string in parser
        return false;
      }
      ctx.beginPath();
      ctx.moveTo(this.points[0].x - x, this.points[0].y - y);
      for (var i = 0; i < len; i++) {
        point = this.points[i];
        ctx.lineTo(point.x - x, point.y - y);
      }
      return true;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      if (!this.commonRender(ctx)) {
        return;
      }
      this._renderPaintInOrder(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var p1, p2;

      ctx.beginPath();
      for (var i = 0, len = this.points.length; i < len; i++) {
        p1 = this.points[i];
        p2 = this.points[i + 1] || p1;
        fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);
      }
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity of this instance
     */
    complexity: function() {
      return this.get('points').length;
    }
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
   * @static
   * @memberOf fabric.Polyline
   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
   */
  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

  /**
   * Returns fabric.Polyline instance from an SVG element
   * @static
   * @memberOf fabric.Polyline
   * @param {SVGElement} element Element to parser
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Polyline.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }
    options || (options = { });

    var points = fabric.parsePointsAttribute(element.getAttribute('points')),
        parsedAttributes = fabric.parseAttributes(element, fabric.Polyline.ATTRIBUTE_NAMES);

    callback(new fabric.Polyline(points, fabric.util.object.extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Polyline instance from an object representation
   * @static
   * @memberOf fabric.Polyline
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Polyline.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Polyline', object, callback, 'points');
  };

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend;

  if (fabric.Polygon) {
    fabric.warn('fabric.Polygon is already defined');
    return;
  }

  /**
   * Polygon class
   * @class fabric.Polygon
   * @extends fabric.Polyline
   * @see {@link fabric.Polygon#initialize} for constructor definition
   */
  fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'polygon',

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      if (!this.commonRender(ctx)) {
        return;
      }
      ctx.closePath();
      this._renderPaintInOrder(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      this.callSuper('_renderDashedStroke', ctx);
      ctx.closePath();
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
   * @static
   * @memberOf fabric.Polygon
   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
   */
  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

  /**
   * Returns {@link fabric.Polygon} instance from an SVG element
   * @static
   * @memberOf fabric.Polygon
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Polygon.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }

    options || (options = { });

    var points = fabric.parsePointsAttribute(element.getAttribute('points')),
        parsedAttributes = fabric.parseAttributes(element, fabric.Polygon.ATTRIBUTE_NAMES);

    callback(new fabric.Polygon(points, extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Polygon instance from an object representation
   * @static
   * @memberOf fabric.Polygon
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Polygon.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Polygon', object, callback, 'points');
  };

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      min = fabric.util.array.min,
      max = fabric.util.array.max,
      extend = fabric.util.object.extend,
      _toString = Object.prototype.toString,
      drawArc = fabric.util.drawArc,
      toFixed = fabric.util.toFixed,
      commandLengths = {
        m: 2,
        l: 2,
        h: 1,
        v: 1,
        c: 6,
        s: 4,
        q: 4,
        t: 2,
        a: 7
      },
      repeatedCommands = {
        m: 'l',
        M: 'L'
      };

  if (fabric.Path) {
    fabric.warn('fabric.Path is already defined');
    return;
  }

  /**
   * Path class
   * @class fabric.Path
   * @extends fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
   * @see {@link fabric.Path#initialize} for constructor definition
   */
  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'path',

    /**
     * Array of path points
     * @type Array
     * @default
     */
    path: null,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('path', 'fillRule'),

    stateProperties: fabric.Object.prototype.stateProperties.concat('path'),

    /**
     * Constructor
     * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
     * @param {Object} [options] Options object
     * @return {fabric.Path} thisArg
     */
    initialize: function(path, options) {
      options = options || { };
      this.callSuper('initialize', options);

      if (!path) {
        path = [];
      }

      var fromArray = _toString.call(path) === '[object Array]';

      this.path = fromArray
        ? path
        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
        : path.match && path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);

      if (!this.path) {
        return;
      }

      if (!fromArray) {
        this.path = this._parsePath();
      }

      this._setPositionDimensions(options);
    },

    /**
     * @private
     * @param {Object} options Options object
     */
    _setPositionDimensions: function(options) {
      var calcDim = this._parseDimensions();

      this.width = calcDim.width;
      this.height = calcDim.height;

      if (typeof options.left === 'undefined') {
        this.left = calcDim.left;
      }

      if (typeof options.top === 'undefined') {
        this.top = calcDim.top;
      }

      this.pathOffset = this.pathOffset || {
        x: calcDim.left + this.width / 2,
        y: calcDim.top + this.height / 2
      };
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render path on
     */
    _renderPathCommands: function(ctx) {
      var current, // current instruction
          previous = null,
          subpathStartX = 0,
          subpathStartY = 0,
          x = 0, // current x
          y = 0, // current y
          controlX = 0, // current control point x
          controlY = 0, // current control point y
          tempX,
          tempY,
          l = -this.pathOffset.x,
          t = -this.pathOffset.y;

      ctx.beginPath();

      for (var i = 0, len = this.path.length; i < len; ++i) {

        current = this.path[i];

        switch (current[0]) { // first letter

          case 'l': // lineto, relative
            x += current[1];
            y += current[2];
            ctx.lineTo(x + l, y + t);
            break;

          case 'L': // lineto, absolute
            x = current[1];
            y = current[2];
            ctx.lineTo(x + l, y + t);
            break;

          case 'h': // horizontal lineto, relative
            x += current[1];
            ctx.lineTo(x + l, y + t);
            break;

          case 'H': // horizontal lineto, absolute
            x = current[1];
            ctx.lineTo(x + l, y + t);
            break;

          case 'v': // vertical lineto, relative
            y += current[1];
            ctx.lineTo(x + l, y + t);
            break;

          case 'V': // verical lineto, absolute
            y = current[1];
            ctx.lineTo(x + l, y + t);
            break;

          case 'm': // moveTo, relative
            x += current[1];
            y += current[2];
            subpathStartX = x;
            subpathStartY = y;
            ctx.moveTo(x + l, y + t);
            break;

          case 'M': // moveTo, absolute
            x = current[1];
            y = current[2];
            subpathStartX = x;
            subpathStartY = y;
            ctx.moveTo(x + l, y + t);
            break;

          case 'c': // bezierCurveTo, relative
            tempX = x + current[5];
            tempY = y + current[6];
            controlX = x + current[3];
            controlY = y + current[4];
            ctx.bezierCurveTo(
              x + current[1] + l, // x1
              y + current[2] + t, // y1
              controlX + l, // x2
              controlY + t, // y2
              tempX + l,
              tempY + t
            );
            x = tempX;
            y = tempY;
            break;

          case 'C': // bezierCurveTo, absolute
            x = current[5];
            y = current[6];
            controlX = current[3];
            controlY = current[4];
            ctx.bezierCurveTo(
              current[1] + l,
              current[2] + t,
              controlX + l,
              controlY + t,
              x + l,
              y + t
            );
            break;

          case 's': // shorthand cubic bezierCurveTo, relative

            // transform to absolute x,y
            tempX = x + current[3];
            tempY = y + current[4];

            if (previous[0].match(/[CcSs]/) === null) {
              // If there is no previous command or if the previous command was not a C, c, S, or s,
              // the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control points
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }

            ctx.bezierCurveTo(
              controlX + l,
              controlY + t,
              x + current[1] + l,
              y + current[2] + t,
              tempX + l,
              tempY + t
            );
            // set control point to 2nd one of this command
            // "... the first control point is assumed to be
            // the reflection of the second control point on
            // the previous command relative to the current point."
            controlX = x + current[1];
            controlY = y + current[2];

            x = tempX;
            y = tempY;
            break;

          case 'S': // shorthand cubic bezierCurveTo, absolute
            tempX = current[3];
            tempY = current[4];
            if (previous[0].match(/[CcSs]/) === null) {
              // If there is no previous command or if the previous command was not a C, c, S, or s,
              // the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control points
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }
            ctx.bezierCurveTo(
              controlX + l,
              controlY + t,
              current[1] + l,
              current[2] + t,
              tempX + l,
              tempY + t
            );
            x = tempX;
            y = tempY;

            // set control point to 2nd one of this command
            // "... the first control point is assumed to be
            // the reflection of the second control point on
            // the previous command relative to the current point."
            controlX = current[1];
            controlY = current[2];

            break;

          case 'q': // quadraticCurveTo, relative
            // transform to absolute x,y
            tempX = x + current[3];
            tempY = y + current[4];

            controlX = x + current[1];
            controlY = y + current[2];

            ctx.quadraticCurveTo(
              controlX + l,
              controlY + t,
              tempX + l,
              tempY + t
            );
            x = tempX;
            y = tempY;
            break;

          case 'Q': // quadraticCurveTo, absolute
            tempX = current[3];
            tempY = current[4];

            ctx.quadraticCurveTo(
              current[1] + l,
              current[2] + t,
              tempX + l,
              tempY + t
            );
            x = tempX;
            y = tempY;
            controlX = current[1];
            controlY = current[2];
            break;

          case 't': // shorthand quadraticCurveTo, relative

            // transform to absolute x,y
            tempX = x + current[1];
            tempY = y + current[2];

            if (previous[0].match(/[QqTt]/) === null) {
              // If there is no previous command or if the previous command was not a Q, q, T or t,
              // assume the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control point
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }

            ctx.quadraticCurveTo(
              controlX + l,
              controlY + t,
              tempX + l,
              tempY + t
            );
            x = tempX;
            y = tempY;

            break;

          case 'T':
            tempX = current[1];
            tempY = current[2];

            if (previous[0].match(/[QqTt]/) === null) {
              // If there is no previous command or if the previous command was not a Q, q, T or t,
              // assume the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control point
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }
            ctx.quadraticCurveTo(
              controlX + l,
              controlY + t,
              tempX + l,
              tempY + t
            );
            x = tempX;
            y = tempY;
            break;

          case 'a':
            // TODO: optimize this
            drawArc(ctx, x + l, y + t, [
              current[1],
              current[2],
              current[3],
              current[4],
              current[5],
              current[6] + x + l,
              current[7] + y + t
            ]);
            x += current[6];
            y += current[7];
            break;

          case 'A':
            // TODO: optimize this
            drawArc(ctx, x + l, y + t, [
              current[1],
              current[2],
              current[3],
              current[4],
              current[5],
              current[6] + l,
              current[7] + t
            ]);
            x = current[6];
            y = current[7];
            break;

          case 'z':
          case 'Z':
            x = subpathStartX;
            y = subpathStartY;
            ctx.closePath();
            break;
        }
        previous = current;
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render path on
     */
    _render: function(ctx) {
      this._renderPathCommands(ctx);
      this._renderPaintInOrder(ctx);
    },

    /**
     * Returns string representation of an instance
     * @return {String} string representation of an instance
     */
    toString: function() {
      return '#<fabric.Path (' + this.complexity() +
        '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var o = extend(this.callSuper('toObject', propertiesToInclude), {
        path: this.path.map(function(item) { return item.slice(); }),
        top: this.top,
        left: this.left,
      });
      return o;
    },

    /**
     * Returns dataless object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      var o = this.toObject(['sourcePath'].concat(propertiesToInclude));
      if (o.sourcePath) {
        delete o.path;
      }
      return o;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var path = this.path.map(function(path) {
        return path.join(' ');
      }).join(' ');
      return [
        '<path ', 'COMMON_PARTS',
        'd="', path,
        '" stroke-linecap="round" ',
        '/>\n'
      ];
    },

    _getOffsetTransform: function() {
      var digits = fabric.Object.NUM_FRACTION_DIGITS;
      return ' translate(' + toFixed(-this.pathOffset.x, digits) + ', ' +
          toFixed(-this.pathOffset.y, digits) + ')';
    },

    /**
     * Returns svg clipPath representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toClipPathSVG: function(reviver) {
      var additionalTransform = this._getOffsetTransform();
      return '\t' + this._createBaseClipPathSVGMarkup(
        this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform }
      );
    },

    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var additionalTransform = this._getOffsetTransform();
      return this._createBaseSVGMarkup(this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform  });
    },
    /* _TO_SVG_END_ */

    /**
     * Returns number representation of an instance complexity
     * @return {Number} complexity of this instance
     */
    complexity: function() {
      return this.path.length;
    },

    /**
     * @private
     */
    _parsePath: function() {
      var result = [],
          coords = [],
          currentPath,
          parsed,
          re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/ig,
          match,
          coordsStr;

      for (var i = 0, coordsParsed, len = this.path.length; i < len; i++) {
        currentPath = this.path[i];

        coordsStr = currentPath.slice(1).trim();
        coords.length = 0;

        while ((match = re.exec(coordsStr))) {
          coords.push(match[0]);
        }

        coordsParsed = [currentPath.charAt(0)];

        for (var j = 0, jlen = coords.length; j < jlen; j++) {
          parsed = parseFloat(coords[j]);
          if (!isNaN(parsed)) {
            coordsParsed.push(parsed);
          }
        }

        var command = coordsParsed[0],
            commandLength = commandLengths[command.toLowerCase()],
            repeatedCommand = repeatedCommands[command] || command;

        if (coordsParsed.length - 1 > commandLength) {
          for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
            result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
            command = repeatedCommand;
          }
        }
        else {
          result.push(coordsParsed);
        }
      }

      return result;
    },

    /**
     * @private
     */
    _parseDimensions: function() {

      var aX = [],
          aY = [],
          current, // current instruction
          previous = null,
          subpathStartX = 0,
          subpathStartY = 0,
          x = 0, // current x
          y = 0, // current y
          controlX = 0, // current control point x
          controlY = 0, // current control point y
          tempX,
          tempY,
          bounds;

      for (var i = 0, len = this.path.length; i < len; ++i) {

        current = this.path[i];

        switch (current[0]) { // first letter

          case 'l': // lineto, relative
            x += current[1];
            y += current[2];
            bounds = [];
            break;

          case 'L': // lineto, absolute
            x = current[1];
            y = current[2];
            bounds = [];
            break;

          case 'h': // horizontal lineto, relative
            x += current[1];
            bounds = [];
            break;

          case 'H': // horizontal lineto, absolute
            x = current[1];
            bounds = [];
            break;

          case 'v': // vertical lineto, relative
            y += current[1];
            bounds = [];
            break;

          case 'V': // verical lineto, absolute
            y = current[1];
            bounds = [];
            break;

          case 'm': // moveTo, relative
            x += current[1];
            y += current[2];
            subpathStartX = x;
            subpathStartY = y;
            bounds = [];
            break;

          case 'M': // moveTo, absolute
            x = current[1];
            y = current[2];
            subpathStartX = x;
            subpathStartY = y;
            bounds = [];
            break;

          case 'c': // bezierCurveTo, relative
            tempX = x + current[5];
            tempY = y + current[6];
            controlX = x + current[3];
            controlY = y + current[4];
            bounds = fabric.util.getBoundsOfCurve(x, y,
              x + current[1], // x1
              y + current[2], // y1
              controlX, // x2
              controlY, // y2
              tempX,
              tempY
            );
            x = tempX;
            y = tempY;
            break;

          case 'C': // bezierCurveTo, absolute
            controlX = current[3];
            controlY = current[4];
            bounds = fabric.util.getBoundsOfCurve(x, y,
              current[1],
              current[2],
              controlX,
              controlY,
              current[5],
              current[6]
            );
            x = current[5];
            y = current[6];
            break;

          case 's': // shorthand cubic bezierCurveTo, relative

            // transform to absolute x,y
            tempX = x + current[3];
            tempY = y + current[4];

            if (previous[0].match(/[CcSs]/) === null) {
              // If there is no previous command or if the previous command was not a C, c, S, or s,
              // the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control points
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }

            bounds = fabric.util.getBoundsOfCurve(x, y,
              controlX,
              controlY,
              x + current[1],
              y + current[2],
              tempX,
              tempY
            );
            // set control point to 2nd one of this command
            // "... the first control point is assumed to be
            // the reflection of the second control point on
            // the previous command relative to the current point."
            controlX = x + current[1];
            controlY = y + current[2];
            x = tempX;
            y = tempY;
            break;

          case 'S': // shorthand cubic bezierCurveTo, absolute
            tempX = current[3];
            tempY = current[4];
            if (previous[0].match(/[CcSs]/) === null) {
              // If there is no previous command or if the previous command was not a C, c, S, or s,
              // the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control points
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }
            bounds = fabric.util.getBoundsOfCurve(x, y,
              controlX,
              controlY,
              current[1],
              current[2],
              tempX,
              tempY
            );
            x = tempX;
            y = tempY;
            // set control point to 2nd one of this command
            // "... the first control point is assumed to be
            // the reflection of the second control point on
            // the previous command relative to the current point."
            controlX = current[1];
            controlY = current[2];
            break;

          case 'q': // quadraticCurveTo, relative
            // transform to absolute x,y
            tempX = x + current[3];
            tempY = y + current[4];
            controlX = x + current[1];
            controlY = y + current[2];
            bounds = fabric.util.getBoundsOfCurve(x, y,
              controlX,
              controlY,
              controlX,
              controlY,
              tempX,
              tempY
            );
            x = tempX;
            y = tempY;
            break;

          case 'Q': // quadraticCurveTo, absolute
            controlX = current[1];
            controlY = current[2];
            bounds = fabric.util.getBoundsOfCurve(x, y,
              controlX,
              controlY,
              controlX,
              controlY,
              current[3],
              current[4]
            );
            x = current[3];
            y = current[4];
            break;

          case 't': // shorthand quadraticCurveTo, relative
            // transform to absolute x,y
            tempX = x + current[1];
            tempY = y + current[2];
            if (previous[0].match(/[QqTt]/) === null) {
              // If there is no previous command or if the previous command was not a Q, q, T or t,
              // assume the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control point
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }

            bounds = fabric.util.getBoundsOfCurve(x, y,
              controlX,
              controlY,
              controlX,
              controlY,
              tempX,
              tempY
            );
            x = tempX;
            y = tempY;

            break;

          case 'T':
            tempX = current[1];
            tempY = current[2];

            if (previous[0].match(/[QqTt]/) === null) {
              // If there is no previous command or if the previous command was not a Q, q, T or t,
              // assume the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control point
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }
            bounds = fabric.util.getBoundsOfCurve(x, y,
              controlX,
              controlY,
              controlX,
              controlY,
              tempX,
              tempY
            );
            x = tempX;
            y = tempY;
            break;

          case 'a':
            // TODO: optimize this
            bounds = fabric.util.getBoundsOfArc(x, y,
              current[1],
              current[2],
              current[3],
              current[4],
              current[5],
              current[6] + x,
              current[7] + y
            );
            x += current[6];
            y += current[7];
            break;

          case 'A':
            // TODO: optimize this
            bounds = fabric.util.getBoundsOfArc(x, y,
              current[1],
              current[2],
              current[3],
              current[4],
              current[5],
              current[6],
              current[7]
            );
            x = current[6];
            y = current[7];
            break;

          case 'z':
          case 'Z':
            x = subpathStartX;
            y = subpathStartY;
            break;
        }
        previous = current;
        bounds.forEach(function (point) {
          aX.push(point.x);
          aY.push(point.y);
        });
        aX.push(x);
        aY.push(y);
      }

      var minX = min(aX) || 0,
          minY = min(aY) || 0,
          maxX = max(aX) || 0,
          maxY = max(aY) || 0,
          deltaX = maxX - minX,
          deltaY = maxY - minY,

          o = {
            left: minX,
            top: minY,
            width: deltaX,
            height: deltaY
          };

      return o;
    }
  });

  /**
   * Creates an instance of fabric.Path from an object
   * @static
   * @memberOf fabric.Path
   * @param {Object} object
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Path.fromObject = function(object, callback) {
    if (typeof object.sourcePath === 'string') {
      var pathUrl = object.sourcePath;
      fabric.loadSVGFromURL(pathUrl, function (elements) {
        var path = elements[0];
        path.setOptions(object);
        callback && callback(path);
      });
    }
    else {
      fabric.Object._fromObject('Path', object, callback, 'path');
    }
  };

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
   * @static
   * @memberOf fabric.Path
   * @see http://www.w3.org/TR/SVG/paths.html#PathElement
   */
  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);

  /**
   * Creates an instance of fabric.Path from an SVG <path> element
   * @static
   * @memberOf fabric.Path
   * @param {SVGElement} element to parse
   * @param {Function} callback Callback to invoke when an fabric.Path instance is created
   * @param {Object} [options] Options object
   * @param {Function} [callback] Options callback invoked after parsing is finished
   */
  fabric.Path.fromElement = function(element, callback, options) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
    callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      min = fabric.util.array.min,
      max = fabric.util.array.max;

  if (fabric.Group) {
    return;
  }

  /**
   * Group class
   * @class fabric.Group
   * @extends fabric.Object
   * @mixes fabric.Collection
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
   * @see {@link fabric.Group#initialize} for constructor definition
   */
  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'group',

    /**
     * Width of stroke
     * @type Number
     * @default
     */
    strokeWidth: 0,

    /**
     * Indicates if click events should also check for subtargets
     * @type Boolean
     * @default
     */
    subTargetCheck: false,

    /**
     * Groups are container, do not render anything on theyr own, ence no cache properties
     * @type Array
     * @default
     */
    cacheProperties: [],

    /**
     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still
     * available setting this boolean to true.
     * @type Boolean
     * @since 2.0.0
     * @default
     */
    useSetOnGroup: false,

    /**
     * Constructor
     * @param {Object} objects Group objects
     * @param {Object} [options] Options object
     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
     * @return {Object} thisArg
     */
    initialize: function(objects, options, isAlreadyGrouped) {
      options = options || {};
      this._objects = [];
      // if objects enclosed in a group have been grouped already,
      // we cannot change properties of objects.
      // Thus we need to set options to group without objects,
      isAlreadyGrouped && this.callSuper('initialize', options);
      this._objects = objects || [];
      for (var i = this._objects.length; i--; ) {
        this._objects[i].group = this;
      }

      if (!isAlreadyGrouped) {
        var center = options && options.centerPoint;
        // we want to set origins before calculating the bounding box.
        // so that the topleft can be set with that in mind.
        // if specific top and left are passed, are overwritten later
        // with the callSuper('initialize', options)
        if (options.originX !== undefined) {
          this.originX = options.originX;
        }
        if (options.originY !== undefined) {
          this.originY = options.originY;
        }
        // if coming from svg i do not want to calc bounds.
        // i assume width and height are passed along options
        center || this._calcBounds();
        this._updateObjectsCoords(center);
        delete options.centerPoint;
        this.callSuper('initialize', options);
      }
      else {
        this._updateObjectsACoords();
      }

      this.setCoords();
    },

    /**
     * @private
     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
     */
    _updateObjectsACoords: function() {
      var ignoreZoom = true, skipAbsolute = true;
      for (var i = this._objects.length; i--; ){
        this._objects[i].setCoords(ignoreZoom, skipAbsolute);
      }
    },

    /**
     * @private
     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
     */
    _updateObjectsCoords: function(center) {
      var center = center || this.getCenterPoint();
      for (var i = this._objects.length; i--; ){
        this._updateObjectCoords(this._objects[i], center);
      }
    },

    /**
     * @private
     * @param {Object} object
     * @param {fabric.Point} center, current center of group.
     */
    _updateObjectCoords: function(object, center) {
      var objectLeft = object.left,
          objectTop = object.top,
          ignoreZoom = true, skipAbsolute = true;

      object.set({
        left: objectLeft - center.x,
        top: objectTop - center.y
      });
      object.group = this;
      object.setCoords(ignoreZoom, skipAbsolute);
    },

    /**
     * Returns string represenation of a group
     * @return {String}
     */
    toString: function() {
      return '#<fabric.Group: (' + this.complexity() + ')>';
    },

    /**
     * Adds an object to a group; Then recalculates group's dimension, position.
     * @param {Object} object
     * @return {fabric.Group} thisArg
     * @chainable
     */
    addWithUpdate: function(object) {
      this._restoreObjectsState();
      fabric.util.resetObjectTransform(this);
      if (object) {
        this._objects.push(object);
        object.group = this;
        object._set('canvas', this.canvas);
      }
      this._calcBounds();
      this._updateObjectsCoords();
      this.setCoords();
      this.dirty = true;
      return this;
    },

    /**
     * Removes an object from a group; Then recalculates group's dimension, position.
     * @param {Object} object
     * @return {fabric.Group} thisArg
     * @chainable
     */
    removeWithUpdate: function(object) {
      this._restoreObjectsState();
      fabric.util.resetObjectTransform(this);

      this.remove(object);
      this._calcBounds();
      this._updateObjectsCoords();
      this.setCoords();
      this.dirty = true;
      return this;
    },

    /**
     * @private
     */
    _onObjectAdded: function(object) {
      this.dirty = true;
      object.group = this;
      object._set('canvas', this.canvas);
    },

    /**
     * @private
     */
    _onObjectRemoved: function(object) {
      this.dirty = true;
      delete object.group;
    },

    /**
     * @private
     */
    _set: function(key, value) {
      var i = this._objects.length;
      if (this.useSetOnGroup) {
        while (i--) {
          this._objects[i].setOnGroup(key, value);
        }
      }
      if (key === 'canvas') {
        while (i--) {
          this._objects[i]._set(key, value);
        }
      }
      fabric.Object.prototype._set.call(this, key, value);
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var _includeDefaultValues = this.includeDefaultValues;
      var objsToObject = this._objects.map(function(obj) {
        var originalDefaults = obj.includeDefaultValues;
        obj.includeDefaultValues = _includeDefaultValues;
        var _obj = obj.toObject(propertiesToInclude);
        obj.includeDefaultValues = originalDefaults;
        return _obj;
      });
      var obj = fabric.Object.prototype.toObject.call(this, propertiesToInclude);
      obj.objects = objsToObject;
      return obj;
    },

    /**
     * Returns object representation of an instance, in dataless mode.
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      var objsToObject, sourcePath = this.sourcePath;
      if (sourcePath) {
        objsToObject = sourcePath;
      }
      else {
        var _includeDefaultValues = this.includeDefaultValues;
        objsToObject = this._objects.map(function(obj) {
          var originalDefaults = obj.includeDefaultValues;
          obj.includeDefaultValues = _includeDefaultValues;
          var _obj = obj.toDatalessObject(propertiesToInclude);
          obj.includeDefaultValues = originalDefaults;
          return _obj;
        });
      }
      var obj = fabric.Object.prototype.toDatalessObject.call(this, propertiesToInclude);
      obj.objects = objsToObject;
      return obj;
    },

    /**
     * Renders instance on a given context
     * @param {CanvasRenderingContext2D} ctx context to render instance on
     */
    render: function(ctx) {
      this._transformDone = true;
      this.callSuper('render', ctx);
      this._transformDone = false;
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * @return {Boolean}
     */
    shouldCache: function() {
      var ownCache = this.objectCaching && (!this.group || this.needsItsOwnCache() || !this.group.isOnACache());
      this.ownCaching = ownCache;
      if (ownCache) {
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].willDrawShadow()) {
            this.ownCaching = false;
            return false;
          }
        }
      }
      return ownCache;
    },

    /**
     * Check if this object or a child object will cast a shadow
     * @return {Boolean}
     */
    willDrawShadow: function() {
      if (this.shadow) {
        return fabric.Object.prototype.willDrawShadow.call(this);
      }
      for (var i = 0, len = this._objects.length; i < len; i++) {
        if (this._objects[i].willDrawShadow()) {
          return true;
        }
      }
      return false;
    },

    /**
     * Check if this group or its parent group are caching, recursively up
     * @return {Boolean}
     */
    isOnACache: function() {
      return this.ownCaching || (this.group && this.group.isOnACache());
    },

    /**
     * Execute the drawing operation for an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawObject: function(ctx) {
      for (var i = 0, len = this._objects.length; i < len; i++) {
        this._objects[i].render(ctx);
      }
      this._drawClipPath(ctx);
    },

    /**
     * Check if cache is dirty
     */
    isCacheDirty: function(skipCanvas) {
      if (this.callSuper('isCacheDirty', skipCanvas)) {
        return true;
      }
      if (!this.statefullCache) {
        return false;
      }
      for (var i = 0, len = this._objects.length; i < len; i++) {
        if (this._objects[i].isCacheDirty(true)) {
          if (this._cacheCanvas) {
            // if this group has not a cache canvas there is nothing to clean
            var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;
            this._cacheContext.clearRect(-x / 2, -y / 2, x, y);
          }
          return true;
        }
      }
      return false;
    },

    /**
     * Retores original state of each of group objects (original state is that which was before group was created).
     * @private
     * @return {fabric.Group} thisArg
     * @chainable
     */
    _restoreObjectsState: function() {
      this._objects.forEach(this._restoreObjectState, this);
      return this;
    },

    /**
     * Realises the transform from this group onto the supplied object
     * i.e. it tells you what would happen if the supplied object was in
     * the group, and then the group was destroyed. It mutates the supplied
     * object.
     * @param {fabric.Object} object
     * @return {fabric.Object} transformedObject
     */
    realizeTransform: function(object) {
      var matrix = object.calcTransformMatrix(),
          options = fabric.util.qrDecompose(matrix),
          center = new fabric.Point(options.translateX, options.translateY);
      object.flipX = false;
      object.flipY = false;
      object.set('scaleX', options.scaleX);
      object.set('scaleY', options.scaleY);
      object.skewX = options.skewX;
      object.skewY = options.skewY;
      object.angle = options.angle;
      object.setPositionByOrigin(center, 'center', 'center');
      return object;
    },

    /**
     * Restores original state of a specified object in group
     * @private
     * @param {fabric.Object} object
     * @return {fabric.Group} thisArg
     */
    _restoreObjectState: function(object) {
      this.realizeTransform(object);
      object.setCoords();
      delete object.group;
      return this;
    },

    /**
     * Destroys a group (restoring state of its objects)
     * @return {fabric.Group} thisArg
     * @chainable
     */
    destroy: function() {
      // when group is destroyed objects needs to get a repaint to be eventually
      // displayed on canvas.
      this._objects.forEach(function(object) {
        object.set('dirty', true);
      });
      return this._restoreObjectsState();
    },

    /**
     * make a group an active selection, remove the group from canvas
     * the group has to be on canvas for this to work.
     * @return {fabric.ActiveSelection} thisArg
     * @chainable
     */
    toActiveSelection: function() {
      if (!this.canvas) {
        return;
      }
      var objects = this._objects, canvas = this.canvas;
      this._objects = [];
      var options = this.toObject();
      delete options.objects;
      var activeSelection = new fabric.ActiveSelection([]);
      activeSelection.set(options);
      activeSelection.type = 'activeSelection';
      canvas.remove(this);
      objects.forEach(function(object) {
        object.group = activeSelection;
        object.dirty = true;
        canvas.add(object);
      });
      activeSelection.canvas = canvas;
      activeSelection._objects = objects;
      canvas._activeObject = activeSelection;
      activeSelection.setCoords();
      return activeSelection;
    },

    /**
     * Destroys a group (restoring state of its objects)
     * @return {fabric.Group} thisArg
     * @chainable
     */
    ungroupOnCanvas: function() {
      return this._restoreObjectsState();
    },

    /**
     * Sets coordinates of all objects inside group
     * @return {fabric.Group} thisArg
     * @chainable
     */
    setObjectsCoords: function() {
      var ignoreZoom = true, skipAbsolute = true;
      this.forEachObject(function(object) {
        object.setCoords(ignoreZoom, skipAbsolute);
      });
      return this;
    },

    /**
     * @private
     */
    _calcBounds: function(onlyWidthHeight) {
      var aX = [],
          aY = [],
          o, prop,
          props = ['tr', 'br', 'bl', 'tl'],
          i = 0, iLen = this._objects.length,
          j, jLen = props.length,
          ignoreZoom = true;

      for ( ; i < iLen; ++i) {
        o = this._objects[i];
        o.setCoords(ignoreZoom);
        for (j = 0; j < jLen; j++) {
          prop = props[j];
          aX.push(o.oCoords[prop].x);
          aY.push(o.oCoords[prop].y);
        }
      }

      this._getBounds(aX, aY, onlyWidthHeight);
    },

    /**
     * @private
     */
    _getBounds: function(aX, aY, onlyWidthHeight) {
      var minXY = new fabric.Point(min(aX), min(aY)),
          maxXY = new fabric.Point(max(aX), max(aY)),
          top = minXY.y || 0, left = minXY.x || 0,
          width = (maxXY.x - minXY.x) || 0,
          height = (maxXY.y - minXY.y) || 0;
      this.width = width;
      this.height = height;
      if (!onlyWidthHeight) {
        // the bounding box always finds the topleft most corner.
        // whatever is the group origin, we set up here the left/top position.
        this.setPositionByOrigin({ x: left, y: top }, 'left', 'top');
      }
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var svgString = [];

      for (var i = 0, len = this._objects.length; i < len; i++) {
        svgString.push('\t', this._objects[i].toSVG(reviver));
      }

      return this._createBaseSVGMarkup(
        svgString,
        { reviver: reviver, noStyle: true, withShadow: true });
    },

    /**
     * Returns svg clipPath representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toClipPathSVG: function(reviver) {
      var svgString = [];

      for (var i = 0, len = this._objects.length; i < len; i++) {
        svgString.push('\t', this._objects[i].toClipPathSVG(reviver));
      }

      return this._createBaseClipPathSVGMarkup(svgString, { reviver: reviver });
    },
    /* _TO_SVG_END_ */
  });

  /**
   * Returns {@link fabric.Group} instance from an object representation
   * @static
   * @memberOf fabric.Group
   * @param {Object} object Object to create a group from
   * @param {Function} [callback] Callback to invoke when an group instance is created
   */
  fabric.Group.fromObject = function(object, callback) {
    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
      fabric.util.enlivenObjects([object.clipPath], function(enlivedClipPath) {
        var options = fabric.util.object.clone(object, true);
        options.clipPath = enlivedClipPath[0];
        delete options.objects;
        callback && callback(new fabric.Group(enlivenedObjects, options, true));
      });
    });
  };

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.ActiveSelection) {
    return;
  }

  /**
   * Group class
   * @class fabric.ActiveSelection
   * @extends fabric.Group
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
   * @see {@link fabric.ActiveSelection#initialize} for constructor definition
   */
  fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'activeSelection',

    /**
     * Constructor
     * @param {Object} objects ActiveSelection objects
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(objects, options) {
      options = options || {};
      this._objects = objects || [];
      for (var i = this._objects.length; i--; ) {
        this._objects[i].group = this;
      }

      if (options.originX) {
        this.originX = options.originX;
      }
      if (options.originY) {
        this.originY = options.originY;
      }
      this._calcBounds();
      this._updateObjectsCoords();
      fabric.Object.prototype.initialize.call(this, options);
      this.setCoords();
    },

    /**
     * Change te activeSelection to a normal group,
     * High level function that automatically adds it to canvas as
     * active object. no events fired.
     * @since 2.0.0
     * @return {fabric.Group}
     */
    toGroup: function() {
      var objects = this._objects.concat();
      this._objects = [];
      var options = fabric.Object.prototype.toObject.call(this);
      var newGroup = new fabric.Group([]);
      delete options.type;
      newGroup.set(options);
      objects.forEach(function(object) {
        object.canvas.remove(object);
        object.group = newGroup;
      });
      newGroup._objects = objects;
      if (!this.canvas) {
        return newGroup;
      }
      var canvas = this.canvas;
      canvas.add(newGroup);
      canvas._activeObject = newGroup;
      newGroup.setCoords();
      return newGroup;
    },

    /**
     * If returns true, deselection is cancelled.
     * @since 2.0.0
     * @return {Boolean} [cancel]
     */
    onDeselect: function() {
      this.destroy();
      return false;
    },

    /**
     * Returns string representation of a group
     * @return {String}
     */
    toString: function() {
      return '#<fabric.ActiveSelection: (' + this.complexity() + ')>';
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * @return {Boolean}
     */
    shouldCache: function() {
      return false;
    },

    /**
     * Check if this group or its parent group are caching, recursively up
     * @return {Boolean}
     */
    isOnACache: function() {
      return false;
    },

    /**
     * Renders controls and borders for the object
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [styleOverride] properties to override the object style
     * @param {Object} [childrenOverride] properties to override the children overrides
     */
    _renderControls: function(ctx, styleOverride, childrenOverride) {
      ctx.save();
      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
      this.callSuper('_renderControls', ctx, styleOverride);
      childrenOverride = childrenOverride || { };
      if (typeof childrenOverride.hasControls === 'undefined') {
        childrenOverride.hasControls = false;
      }
      if (typeof childrenOverride.hasRotatingPoint === 'undefined') {
        childrenOverride.hasRotatingPoint = false;
      }
      childrenOverride.forActiveSelection = true;
      for (var i = 0, len = this._objects.length; i < len; i++) {
        this._objects[i]._renderControls(ctx, childrenOverride);
      }
      ctx.restore();
    },
  });

  /**
   * Returns {@link fabric.ActiveSelection} instance from an object representation
   * @static
   * @memberOf fabric.ActiveSelection
   * @param {Object} object Object to create a group from
   * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created
   */
  fabric.ActiveSelection.fromObject = function(object, callback) {
    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
      delete object.objects;
      callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));
    });
  };

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var extend = fabric.util.object.extend;

  if (!global.fabric) {
    global.fabric = { };
  }

  if (global.fabric.Image) {
    fabric.warn('fabric.Image is already defined.');
    return;
  }

  /**
   * Image class
   * @class fabric.Image
   * @extends fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}
   * @see {@link fabric.Image#initialize} for constructor definition
   */
  fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'image',

    /**
     * crossOrigin value (one of "", "anonymous", "use-credentials")
     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
     * @type String
     * @default
     */
    crossOrigin: '',

    /**
     * Width of a stroke.
     * For image quality a stroke multiple of 2 gives better results.
     * @type Number
     * @default
     */
    strokeWidth: 0,

    /**
     * private
     * contains last value of scaleX to detect
     * if the Image got resized after the last Render
     * @type Number
     */
    _lastScaleX: 1,

    /**
     * private
     * contains last value of scaleY to detect
     * if the Image got resized after the last Render
     * @type Number
     */
    _lastScaleY: 1,

    /**
     * private
     * contains last value of scaling applied by the apply filter chain
     * @type Number
     */
    _filterScalingX: 1,

    /**
     * private
     * contains last value of scaling applied by the apply filter chain
     * @type Number
     */
    _filterScalingY: 1,

    /**
     * minimum scale factor under which any resizeFilter is triggered to resize the image
     * 0 will disable the automatic resize. 1 will trigger automatically always.
     * number bigger than 1 are not implemented yet.
     * @type Number
     */
    minimumScaleTrigger: 0.5,

    /**
     * List of properties to consider when checking if
     * state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: fabric.Object.prototype.stateProperties.concat('cropX', 'cropY'),

    /**
     * key used to retrieve the texture representing this image
     * since 2.0.0
     * @type String
     * @default
     */
    cacheKey: '',

    /**
     * Image crop in pixels from original image size.
     * since 2.0.0
     * @type Number
     * @default
     */
    cropX: 0,

    /**
     * Image crop in pixels from original image size.
     * since 2.0.0
     * @type Number
     * @default
     */
    cropY: 0,

    /**
     * Constructor
     * @param {HTMLImageElement | String} element Image element
     * @param {Object} [options] Options object
     * @param {function} [callback] callback function to call after eventual filters applied.
     * @return {fabric.Image} thisArg
     */
    initialize: function(element, options) {
      options || (options = { });
      this.filters = [];
      this.cacheKey = 'texture' + fabric.Object.__uid++;
      this.callSuper('initialize', options);
      this._initElement(element, options);
    },

    /**
     * Returns image element which this instance if based on
     * @return {HTMLImageElement} Image element
     */
    getElement: function() {
      return this._element || {};
    },

    /**
     * Sets image element for this instance to a specified one.
     * If filters defined they are applied to new image.
     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
     * @param {HTMLImageElement} element
     * @param {Object} [options] Options object
     * @return {fabric.Image} thisArg
     * @chainable
     */
    setElement: function(element, options) {
      this.removeTexture(this.cacheKey);
      this.removeTexture(this.cacheKey + '_filtered');
      this._element = element;
      this._originalElement = element;
      this._initConfig(options);
      if (this.filters.length !== 0) {
        this.applyFilters();
      }
      // resizeFilters work on the already filtered copy.
      // we need to apply resizeFilters AFTER normal filters.
      // applyResizeFilters is run more often than normal fiters
      // and is triggered by user interactions rather than dev code
      if (this.resizeFilter) {
        this.applyResizeFilters();
      }
      return this;
    },

    /**
     * Delete a single texture if in webgl mode
     */
    removeTexture: function(key) {
      var backend = fabric.filterBackend;
      if (backend && backend.evictCachesForKey) {
        backend.evictCachesForKey(key);
      }
    },

    /**
     * Delete textures, reference to elements and eventually JSDOM cleanup
     */
    dispose: function() {
      this.removeTexture(this.cacheKey);
      this.removeTexture(this.cacheKey + '_filtered');
      this._cacheContext = undefined;
      ['_originalElement', '_element', '_filteredEl', '_cacheCanvas'].forEach((function(element) {
        fabric.util.cleanUpJsdomNode(this[element]);
        this[element] = undefined;
      }).bind(this));
    },

    /**
     * Sets crossOrigin value (on an instance and corresponding image element)
     * @return {fabric.Image} thisArg
     * @chainable
     */
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
      this._element.crossOrigin = value;

      return this;
    },

    /**
     * Returns original size of an image
     * @return {Object} Object with "width" and "height" properties
     */
    getOriginalSize: function() {
      var element = this.getElement();
      return {
        width: element.naturalWidth || element.width,
        height: element.naturalHeight || element.height
      };
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _stroke: function(ctx) {
      if (!this.stroke || this.strokeWidth === 0) {
        return;
      }
      var w = this.width / 2, h = this.height / 2;
      ctx.beginPath();
      ctx.moveTo(-w, -h);
      ctx.lineTo(w, -h);
      ctx.lineTo(w, h);
      ctx.lineTo(-w, h);
      ctx.lineTo(-w, -h);
      ctx.closePath();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var x = -this.width / 2,
          y = -this.height / 2,
          w = this.width,
          h = this.height;

      ctx.save();
      this._setStrokeStyles(ctx, this);

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
      ctx.closePath();
      ctx.restore();
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var filters = [];

      this.filters.forEach(function(filterObj) {
        if (filterObj) {
          filters.push(filterObj.toObject());
        }
      });
      var object = extend(
        this.callSuper(
          'toObject',
          ['crossOrigin', 'cropX', 'cropY'].concat(propertiesToInclude)
        ), {
          src: this.getSrc(),
          filters: filters,
        });
      if (this.resizeFilter) {
        object.resizeFilter = this.resizeFilter.toObject();
      }
      return object;
    },

    /**
     * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,hight.
     * @return {Boolean}
     */
    hasCrop: function() {
      return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var svgString = [], imageMarkup = [], strokeSvg,
          x = -this.width / 2, y = -this.height / 2, clipPath = '';
      if (this.hasCrop()) {
        var clipPathId = fabric.Object.__uid++;
        svgString.push(
          '<clipPath id="imageCrop_' + clipPathId + '">\n',
          '\t<rect x="' + x + '" y="' + y + '" width="' + this.width + '" height="' + this.height + '" />\n',
          '</clipPath>\n'
        );
        clipPath = ' clip-path="url(#imageCrop_' + clipPathId + ')" ';
      }
      imageMarkup.push('\t<image ', 'COMMON_PARTS', 'xlink:href="', this.getSvgSrc(true),
        '" x="', x - this.cropX, '" y="', y - this.cropY,
        // we're essentially moving origin of transformation from top/left corner to the center of the shape
        // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
        // so that object's center aligns with container's left/top
        '" width="', this._element.width || this._element.naturalWidth,
        '" height="', this._element.height || this._element.height,
        '"', clipPath,
        '></image>\n');

      if (this.stroke || this.strokeDashArray) {
        var origFill = this.fill;
        this.fill = null;
        strokeSvg = [
          '\t<rect ',
          'x="', x, '" y="', y,
          '" width="', this.width, '" height="', this.height,
          '" style="', this.getSvgStyles(),
          '"/>\n'
        ];
        this.fill = origFill;
      }
      if (this.paintFirst !== 'fill') {
        svgString = svgString.concat(strokeSvg, imageMarkup);
      }
      else {
        svgString = svgString.concat(imageMarkup, strokeSvg);
      }
      return svgString;
    },
    /* _TO_SVG_END_ */

    /**
     * Returns source of an image
     * @param {Boolean} filtered indicates if the src is needed for svg
     * @return {String} Source of an image
     */
    getSrc: function(filtered) {
      var element = filtered ? this._element : this._originalElement;
      if (element) {
        if (element.toDataURL) {
          return element.toDataURL();
        }
        return element.src;
      }
      else {
        return this.src || '';
      }
    },

    /**
     * Sets source of an image
     * @param {String} src Source string (URL)
     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
     * @param {Object} [options] Options object
     * @return {fabric.Image} thisArg
     * @chainable
     */
    setSrc: function(src, callback, options) {
      fabric.util.loadImage(src, function(img) {
        this.setElement(img, options);
        this._setWidthHeight();
        callback(this);
      }, this, options && options.crossOrigin);
      return this;
    },

    /**
     * Returns string representation of an instance
     * @return {String} String representation of an instance
     */
    toString: function() {
      return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
    },

    applyResizeFilters: function() {
      var filter = this.resizeFilter,
          minimumScale = this.minimumScaleTrigger,
          objectScale = this.getTotalObjectScaling(),
          scaleX = objectScale.scaleX,
          scaleY = objectScale.scaleY,
          elementToFilter = this._filteredEl || this._originalElement;
      if (this.group) {
        this.set('dirty', true);
      }
      if (!filter || (scaleX > minimumScale && scaleY > minimumScale)) {
        this._element = elementToFilter;
        this._filterScalingX = 1;
        this._filterScalingY = 1;
        this._lastScaleX = scaleX;
        this._lastScaleY = scaleY;
        return;
      }
      if (!fabric.filterBackend) {
        fabric.filterBackend = fabric.initFilterBackend();
      }
      var canvasEl = fabric.util.createCanvasElement(),
          cacheKey = this._filteredEl ? (this.cacheKey + '_filtered') : this.cacheKey,
          sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;
      canvasEl.width = sourceWidth;
      canvasEl.height = sourceHeight;
      this._element = canvasEl;
      this._lastScaleX = filter.scaleX = scaleX;
      this._lastScaleY = filter.scaleY = scaleY;
      fabric.filterBackend.applyFilters(
        [filter], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);
      this._filterScalingX = canvasEl.width / this._originalElement.width;
      this._filterScalingY = canvasEl.height / this._originalElement.height;
    },

    /**
     * Applies filters assigned to this image (from "filters" array) or from filter param
     * @method applyFilters
     * @param {Array} filters to be applied
     * @param {Boolean} forResizing specify if the filter operation is a resize operation
     * @return {thisArg} return the fabric.Image object
     * @chainable
     */
    applyFilters: function(filters) {

      filters = filters || this.filters || [];
      filters = filters.filter(function(filter) { return filter && !filter.isNeutralState(); });
      this.set('dirty', true);

      // needs to clear out or WEBGL will not resize correctly
      this.removeTexture(this.cacheKey + '_filtered');

      if (filters.length === 0) {
        this._element = this._originalElement;
        this._filteredEl = null;
        this._filterScalingX = 1;
        this._filterScalingY = 1;
        return this;
      }

      var imgElement = this._originalElement,
          sourceWidth = imgElement.naturalWidth || imgElement.width,
          sourceHeight = imgElement.naturalHeight || imgElement.height;

      if (this._element === this._originalElement) {
        // if the element is the same we need to create a new element
        var canvasEl = fabric.util.createCanvasElement();
        canvasEl.width = sourceWidth;
        canvasEl.height = sourceHeight;
        this._element = canvasEl;
        this._filteredEl = canvasEl;
      }
      else {
        // clear the existing element to get new filter data
        // also dereference the eventual resized _element
        this._element = this._filteredEl;
        this._filteredEl.getContext('2d').clearRect(0, 0, sourceWidth, sourceHeight);
        // we also need to resize again at next renderAll, so remove saved _lastScaleX/Y
        this._lastScaleX = 1;
        this._lastScaleY = 1;
      }
      if (!fabric.filterBackend) {
        fabric.filterBackend = fabric.initFilterBackend();
      }
      fabric.filterBackend.applyFilters(
        filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);
      if (this._originalElement.width !== this._element.width ||
        this._originalElement.height !== this._element.height) {
        this._filterScalingX = this._element.width / this._originalElement.width;
        this._filterScalingY = this._element.height / this._originalElement.height;
      }
      return this;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {
        this.applyResizeFilters();
      }
      this._stroke(ctx);
      this._renderPaintInOrder(ctx);
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * This is the special image version where we would like to avoid caching where possible.
     * Essentially images do not benefit from caching. They may require caching, and in that
     * case we do it. Also caching an image usually ends in a loss of details.
     * A full performance audit should be done.
     * @return {Boolean}
     */
    shouldCache: function() {
      this.ownCaching = this.objectCaching && this.needsItsOwnCache();
      return this.ownCaching;
    },

    _renderFill: function(ctx) {
      var elementToDraw = this._element,
          w = this.width, h = this.height,
          sW = Math.min(elementToDraw.naturalWidth || elementToDraw.width, w * this._filterScalingX),
          sH = Math.min(elementToDraw.naturalHeight || elementToDraw.height, h * this._filterScalingY),
          x = -w / 2, y = -h / 2,
          sX = Math.max(0, this.cropX * this._filterScalingX),
          sY = Math.max(0, this.cropY * this._filterScalingY);

      elementToDraw && ctx.drawImage(elementToDraw, sX, sY, sW, sH, x, y, w, h);
    },

    /**
     * @private, needed to check if image needs resize
     */
    _needsResize: function() {
      var scale = this.getTotalObjectScaling();
      return (scale.scaleX !== this._lastScaleX || scale.scaleY !== this._lastScaleY);
    },

    /**
     * @private
     */
    _resetWidthHeight: function() {
      this.set(this.getOriginalSize());
    },

    /**
     * The Image class's initialization method. This method is automatically
     * called by the constructor.
     * @private
     * @param {HTMLImageElement|String} element The element representing the image
     * @param {Object} [options] Options object
     */
    _initElement: function(element, options) {
      this.setElement(fabric.util.getById(element), options);
      fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initConfig: function(options) {
      options || (options = { });
      this.setOptions(options);
      this._setWidthHeight(options);
      if (this._element && this.crossOrigin) {
        this._element.crossOrigin = this.crossOrigin;
      }
    },

    /**
     * @private
     * @param {Array} filters to be initialized
     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
     */
    _initFilters: function(filters, callback) {
      if (filters && filters.length) {
        fabric.util.enlivenObjects(filters, function(enlivenedObjects) {
          callback && callback(enlivenedObjects);
        }, 'fabric.Image.filters');
      }
      else {
        callback && callback();
      }
    },

    /**
     * @private
     * Set the width and the height of the image object, using the element or the
     * options.
     * @param {Object} [options] Object with width/height properties
     */
    _setWidthHeight: function(options) {
      options || (options = { });
      var el = this.getElement();
      this.width = options.width || el.naturalWidth || el.width || 0;
      this.height = options.height || el.naturalHeight || el.height || 0;
    },

    /**
     * Calculate offset for center and scale factor for the image in order to respect
     * the preserveAspectRatio attribute
     * @private
     * @return {Object}
     */
    parsePreserveAspectRatioAttribute: function() {
      var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ''),
          rWidth = this._element.width, rHeight = this._element.height,
          scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0,
          offset, pWidth = this.width, pHeight = this.height, parsedAttributes = { width: pWidth, height: pHeight };
      if (pAR && (pAR.alignX !== 'none' || pAR.alignY !== 'none')) {
        if (pAR.meetOrSlice === 'meet') {
          scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);
          offset = (pWidth - rWidth * scaleX) / 2;
          if (pAR.alignX === 'Min') {
            offsetLeft = -offset;
          }
          if (pAR.alignX === 'Max') {
            offsetLeft = offset;
          }
          offset = (pHeight - rHeight * scaleY) / 2;
          if (pAR.alignY === 'Min') {
            offsetTop = -offset;
          }
          if (pAR.alignY === 'Max') {
            offsetTop = offset;
          }
        }
        if (pAR.meetOrSlice === 'slice') {
          scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);
          offset = rWidth - pWidth / scaleX;
          if (pAR.alignX === 'Mid') {
            cropX = offset / 2;
          }
          if (pAR.alignX === 'Max') {
            cropX = offset;
          }
          offset = rHeight - pHeight / scaleY;
          if (pAR.alignY === 'Mid') {
            cropY = offset / 2;
          }
          if (pAR.alignY === 'Max') {
            cropY = offset;
          }
          rWidth = pWidth / scaleX;
          rHeight = pHeight / scaleY;
        }
      }
      else {
        scaleX = pWidth / rWidth;
        scaleY = pHeight / rHeight;
      }
      return {
        width: rWidth,
        height: rHeight,
        scaleX: scaleX,
        scaleY: scaleY,
        offsetLeft: offsetLeft,
        offsetTop: offsetTop,
        cropX: cropX,
        cropY: cropY
      };
    }
  });

  /**
   * Default CSS class name for canvas
   * @static
   * @type String
   * @default
   */
  fabric.Image.CSS_CANVAS = 'canvas-img';

  /**
   * Alias for getSrc
   * @static
   */
  fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;

  /**
   * Creates an instance of fabric.Image from its object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} callback Callback to invoke when an image instance is created
   */
  fabric.Image.fromObject = function(_object, callback) {
    var object = fabric.util.object.clone(_object);
    fabric.util.loadImage(object.src, function(img, error) {
      if (error) {
        callback && callback(null, error);
        return;
      }
      fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {
        object.filters = filters || [];
        fabric.Image.prototype._initFilters.call(object, [object.resizeFilter], function(resizeFilters) {
          object.resizeFilter = resizeFilters[0];
          fabric.util.enlivenObjects([object.clipPath], function(enlivedProps) {
            object.clipPath = enlivedProps[0];
            var image = new fabric.Image(img, object);
            callback(image);
          });
        });
      });
    }, null, object.crossOrigin);
  };

  /**
   * Creates an instance of fabric.Image from an URL string
   * @static
   * @param {String} url URL to create an image from
   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument)
   * @param {Object} [imgOptions] Options object
   */
  fabric.Image.fromURL = function(url, callback, imgOptions) {
    fabric.util.loadImage(url, function(img) {
      callback && callback(new fabric.Image(img, imgOptions));
    }, null, imgOptions && imgOptions.crossOrigin);
  };

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})
   * @static
   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}
   */
  fabric.Image.ATTRIBUTE_NAMES =
    fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href crossOrigin'.split(' '));

  /**
   * Returns {@link fabric.Image} instance from an SVG element
   * @static
   * @param {SVGElement} element Element to parse
   * @param {Object} [options] Options object
   * @param {Function} callback Callback to execute when fabric.Image object is created
   * @return {fabric.Image} Instance of fabric.Image
   */
  fabric.Image.fromElement = function(element, callback, options) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);
    fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,
      extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
  };
  /* _FROM_SVG_END_ */

})( true ? exports : undefined);


fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

  /**
   * @private
   * @return {Number} angle value
   */
  _getAngleValueForStraighten: function() {
    var angle = this.angle % 360;
    if (angle > 0) {
      return Math.round((angle - 1) / 90) * 90;
    }
    return Math.round(angle / 90) * 90;
  },

  /**
   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
   * @return {fabric.Object} thisArg
   * @chainable
   */
  straighten: function() {
    this.rotate(this._getAngleValueForStraighten());
    return this;
  },

  /**
   * Same as {@link fabric.Object.prototype.straighten} but with animation
   * @param {Object} callbacks Object with callback functions
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Object} thisArg
   * @chainable
   */
  fxStraighten: function(callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: this.get('angle'),
      endValue: this._getAngleValueForStraighten(),
      duration: this.FX_DURATION,
      onChange: function(value) {
        _this.rotate(value);
        onChange();
      },
      onComplete: function() {
        _this.setCoords();
        onComplete();
      },
    });

    return this;
  }
});

fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

  /**
   * Straightens object, then rerenders canvas
   * @param {fabric.Object} object Object to straighten
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  straightenObject: function (object) {
    object.straighten();
    this.requestRenderAll();
    return this;
  },

  /**
   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
   * @param {fabric.Object} object Object to straighten
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxStraightenObject: function (object) {
    object.fxStraighten({
      onChange: this.requestRenderAllBound
    });
    return this;
  }
});


(function() {

  'use strict';

  /**
   * Tests if webgl supports certain precision
   * @param {WebGL} Canvas WebGL context to test on
   * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'
   * @returns {Boolean} Whether the user's browser WebGL supports given precision.
   */
  function testPrecision(gl, precision){
    var fragmentSource = 'precision ' + precision + ' float;\nvoid main(){}';
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      return false;
    }
    return true;
  }

  /**
   * Indicate whether this filtering backend is supported by the user's browser.
   * @param {Number} tileSize check if the tileSize is supported
   * @returns {Boolean} Whether the user's browser supports WebGL.
   */
  fabric.isWebglSupported = function(tileSize) {
    if (fabric.isLikelyNode) {
      return false;
    }
    tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;
    var canvas = document.createElement('canvas');
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    var isSupported = false;
    // eslint-disable-next-line
    if (gl) {
      fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      isSupported = fabric.maxTextureSize >= tileSize;
      var precisions = ['highp', 'mediump', 'lowp'];
      for (var i = 0; i < 3; i++){
        if (testPrecision(gl, precisions[i])){
          fabric.webGlPrecision = precisions[i];
          break;
        };
      }
    }
    this.isSupported = isSupported;
    return isSupported;
  };

  fabric.WebglFilterBackend = WebglFilterBackend;

  /**
   * WebGL filter backend.
   */
  function WebglFilterBackend(options) {
    if (options && options.tileSize) {
      this.tileSize = options.tileSize;
    }
    this.setupGLContext(this.tileSize, this.tileSize);
    this.captureGPUInfo();
  };

  WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {

    tileSize: 2048,

    /**
     * Experimental. This object is a sort of repository of help layers used to avoid
     * of recreating them during frequent filtering. If you are previewing a filter with
     * a slider you problably do not want to create help layers every filter step.
     * in this object there will be appended some canvases, created once, resized sometimes
     * cleared never. Clearing is left to the developer.
     **/
    resources: {

    },

    /**
     * Setup a WebGL context suitable for filtering, and bind any needed event handlers.
     */
    setupGLContext: function(width, height) {
      this.dispose();
      this.createWebGLCanvas(width, height);
      // eslint-disable-next-line
      this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]);
      this.chooseFastestCopyGLTo2DMethod(width, height);
    },

    /**
     * Pick a method to copy data from GL context to 2d canvas.  In some browsers using
     * putImageData is faster than drawImage for that specific operation.
     */
    chooseFastestCopyGLTo2DMethod: function(width, height) {
      var canMeasurePerf = typeof window.performance !== 'undefined';
      var canUseImageData;
      try {
        new ImageData(1, 1);
        canUseImageData = true;
      }
      catch (e) {
        canUseImageData = false;
      }
      // eslint-disable-next-line no-undef
      var canUseArrayBuffer = typeof ArrayBuffer !== 'undefined';
      // eslint-disable-next-line no-undef
      var canUseUint8Clamped = typeof Uint8ClampedArray !== 'undefined';

      if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {
        return;
      }

      var targetCanvas = fabric.util.createCanvasElement();
      // eslint-disable-next-line no-undef
      var imageBuffer = new ArrayBuffer(width * height * 4);
      var testContext = {
        imageBuffer: imageBuffer,
        destinationWidth: width,
        destinationHeight: height,
        targetCanvas: targetCanvas
      };
      var startTime, drawImageTime, putImageDataTime;
      targetCanvas.width = width;
      targetCanvas.height = height;

      startTime = window.performance.now();
      copyGLTo2DDrawImage.call(testContext, this.gl, testContext);
      drawImageTime = window.performance.now() - startTime;

      startTime = window.performance.now();
      copyGLTo2DPutImageData.call(testContext, this.gl, testContext);
      putImageDataTime = window.performance.now() - startTime;

      if (drawImageTime > putImageDataTime) {
        this.imageBuffer = imageBuffer;
        this.copyGLTo2D = copyGLTo2DPutImageData;
      }
      else {
        this.copyGLTo2D = copyGLTo2DDrawImage;
      }
    },

    /**
     * Create a canvas element and associated WebGL context and attaches them as
     * class properties to the GLFilterBackend class.
     */
    createWebGLCanvas: function(width, height) {
      var canvas = fabric.util.createCanvasElement();
      canvas.width = width;
      canvas.height = height;
      var glOptions = {
            alpha: true,
            premultipliedAlpha: false,
            depth: false,
            stencil: false,
            antialias: false
          },
          gl = canvas.getContext('webgl', glOptions);
      if (!gl) {
        gl = canvas.getContext('experimental-webgl', glOptions);
      }
      if (!gl) {
        return;
      }
      gl.clearColor(0, 0, 0, 0);
      // this canvas can fire webglcontextlost and webglcontextrestored
      this.canvas = canvas;
      this.gl = gl;
    },

    /**
     * Attempts to apply the requested filters to the source provided, drawing the filtered output
     * to the provided target canvas.
     *
     * @param {Array} filters The filters to apply.
     * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.
     * @param {Number} width The width of the source input.
     * @param {Number} height The height of the source input.
     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
     * @param {String|undefined} cacheKey A key used to cache resources related to the source. If
     * omitted, caching will be skipped.
     */
    applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {
      var gl = this.gl;
      var cachedTexture;
      if (cacheKey) {
        cachedTexture = this.getCachedTexture(cacheKey, source);
      }
      var pipelineState = {
        originalWidth: source.width || source.originalWidth,
        originalHeight: source.height || source.originalHeight,
        sourceWidth: width,
        sourceHeight: height,
        destinationWidth: width,
        destinationHeight: height,
        context: gl,
        sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),
        targetTexture: this.createTexture(gl, width, height),
        originalTexture: cachedTexture ||
          this.createTexture(gl, width, height, !cachedTexture && source),
        passes: filters.length,
        webgl: true,
        aPosition: this.aPosition,
        programCache: this.programCache,
        pass: 0,
        filterBackend: this,
        targetCanvas: targetCanvas
      };
      var tempFbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);
      filters.forEach(function(filter) { filter && filter.applyTo(pipelineState); });
      resizeCanvasIfNeeded(pipelineState);
      this.copyGLTo2D(gl, pipelineState);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.deleteTexture(pipelineState.sourceTexture);
      gl.deleteTexture(pipelineState.targetTexture);
      gl.deleteFramebuffer(tempFbo);
      targetCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
      return pipelineState;
    },

    /**
     * Detach event listeners, remove references, and clean up caches.
     */
    dispose: function() {
      if (this.canvas) {
        this.canvas = null;
        this.gl = null;
      }
      this.clearWebGLCaches();
    },

    /**
     * Wipe out WebGL-related caches.
     */
    clearWebGLCaches: function() {
      this.programCache = {};
      this.textureCache = {};
    },

    /**
     * Create a WebGL texture object.
     *
     * Accepts specific dimensions to initialize the textuer to or a source image.
     *
     * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.
     * @param {Number} width The width to initialize the texture at.
     * @param {Number} height The height to initialize the texture.
     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.
     * @returns {WebGLTexture}
     */
    createTexture: function(gl, width, height, textureImageSource) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      if (textureImageSource) {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);
      }
      else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      return texture;
    },

    /**
     * Can be optionally used to get a texture from the cache array
     *
     * If an existing texture is not found, a new texture is created and cached.
     *
     * @param {String} uniqueId A cache key to use to find an existing texture.
     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the
     * texture cache entry if one does not already exist.
     */
    getCachedTexture: function(uniqueId, textureImageSource) {
      if (this.textureCache[uniqueId]) {
        return this.textureCache[uniqueId];
      }
      else {
        var texture = this.createTexture(
          this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);
        this.textureCache[uniqueId] = texture;
        return texture;
      }
    },

    /**
     * Clear out cached resources related to a source image that has been
     * filtered previously.
     *
     * @param {String} cacheKey The cache key provided when the source image was filtered.
     */
    evictCachesForKey: function(cacheKey) {
      if (this.textureCache[cacheKey]) {
        this.gl.deleteTexture(this.textureCache[cacheKey]);
        delete this.textureCache[cacheKey];
      }
    },

    copyGLTo2D: copyGLTo2DDrawImage,

    /**
     * Attempt to extract GPU information strings from a WebGL context.
     *
     * Useful information when debugging or blacklisting specific GPUs.
     *
     * @returns {Object} A GPU info object with renderer and vendor strings.
     */
    captureGPUInfo: function() {
      if (this.gpuInfo) {
        return this.gpuInfo;
      }
      var gl = this.gl, gpuInfo = { renderer: '', vendor: '' };
      if (!gl) {
        return gpuInfo;
      }
      var ext = gl.getExtension('WEBGL_debug_renderer_info');
      if (ext) {
        var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
        var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
        if (renderer) {
          gpuInfo.renderer = renderer.toLowerCase();
        }
        if (vendor) {
          gpuInfo.vendor = vendor.toLowerCase();
        }
      }
      this.gpuInfo = gpuInfo;
      return gpuInfo;
    },
  };
})();

function resizeCanvasIfNeeded(pipelineState) {
  var targetCanvas = pipelineState.targetCanvas,
      width = targetCanvas.width, height = targetCanvas.height,
      dWidth = pipelineState.destinationWidth,
      dHeight = pipelineState.destinationHeight;

  if (width !== dWidth || height !== dHeight) {
    targetCanvas.width = dWidth;
    targetCanvas.height = dHeight;
  }
}

/**
 * Copy an input WebGL canvas on to an output 2D canvas.
 *
 * The WebGL canvas is assumed to be upside down, with the top-left pixel of the
 * desired output image appearing in the bottom-left corner of the WebGL canvas.
 *
 * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
 * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
 * @param {Object} pipelineState The 2D target canvas to copy on to.
 */
function copyGLTo2DDrawImage(gl, pipelineState) {
  var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas,
      ctx = targetCanvas.getContext('2d');
  ctx.translate(0, targetCanvas.height); // move it down again
  ctx.scale(1, -1); // vertical flip
  // where is my image on the big glcanvas?
  var sourceY = glCanvas.height - targetCanvas.height;
  ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0,
    targetCanvas.width, targetCanvas.height);
}

/**
 * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData
 * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).
 *
 * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
 * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
 * @param {Object} pipelineState The 2D target canvas to copy on to.
 */
function copyGLTo2DPutImageData(gl, pipelineState) {
  var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext('2d'),
      dWidth = pipelineState.destinationWidth,
      dHeight = pipelineState.destinationHeight,
      numBytes = dWidth * dHeight * 4;

  // eslint-disable-next-line no-undef
  var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);
  // eslint-disable-next-line no-undef
  var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);

  gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);
  var imgData = new ImageData(u8Clamped, dWidth, dHeight);
  ctx.putImageData(imgData, 0, 0);
}


(function() {

  'use strict';

  var noop = function() {};

  fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;

  /**
   * Canvas 2D filter backend.
   */
  function Canvas2dFilterBackend() {};

  Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {
    evictCachesForKey: noop,
    dispose: noop,
    clearWebGLCaches: noop,

    /**
     * Experimental. This object is a sort of repository of help layers used to avoid
     * of recreating them during frequent filtering. If you are previewing a filter with
     * a slider you probably do not want to create help layers every filter step.
     * in this object there will be appended some canvases, created once, resized sometimes
     * cleared never. Clearing is left to the developer.
     **/
    resources: {

    },

    /**
     * Apply a set of filters against a source image and draw the filtered output
     * to the provided destination canvas.
     *
     * @param {EnhancedFilter} filters The filter to apply.
     * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.
     * @param {Number} sourceWidth The width of the source input.
     * @param {Number} sourceHeight The height of the source input.
     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
     */
    applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {
      var ctx = targetCanvas.getContext('2d');
      ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
      var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
      var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
      var pipelineState = {
        sourceWidth: sourceWidth,
        sourceHeight: sourceHeight,
        imageData: imageData,
        originalEl: sourceElement,
        originalImageData: originalImageData,
        canvasEl: targetCanvas,
        ctx: ctx,
        filterBackend: this,
      };
      filters.forEach(function(filter) { filter.applyTo(pipelineState); });
      if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
        targetCanvas.width = pipelineState.imageData.width;
        targetCanvas.height = pipelineState.imageData.height;
      }
      ctx.putImageData(pipelineState.imageData, 0, 0);
      return pipelineState;
    },

  };
})();


/**
 * @namespace fabric.Image.filters
 * @memberOf fabric.Image
 * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}
 * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
 */
fabric.Image = fabric.Image || { };
fabric.Image.filters = fabric.Image.filters || { };

/**
 * Root filter class from which all filter classes inherit from
 * @class fabric.Image.filters.BaseFilter
 * @memberOf fabric.Image.filters
 */
fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {

  /**
   * Filter type
   * @param {String} type
   * @default
   */
  type: 'BaseFilter',

  /**
   * Array of attributes to send with buffers. do not modify
   * @private
   */

  vertexSource: 'attribute vec2 aPosition;\n' +
    'varying vec2 vTexCoord;\n' +
    'void main() {\n' +
      'vTexCoord = aPosition;\n' +
      'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
    '}',

  fragmentSource: 'precision highp float;\n' +
    'varying vec2 vTexCoord;\n' +
    'uniform sampler2D uTexture;\n' +
    'void main() {\n' +
      'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
    '}',

  /**
   * Constructor
   * @param {Object} [options] Options object
   */
  initialize: function(options) {
    if (options) {
      this.setOptions(options);
    }
  },

  /**
   * Sets filter's properties from options
   * @param {Object} [options] Options object
   */
  setOptions: function(options) {
    for (var prop in options) {
      this[prop] = options[prop];
    }
  },

  /**
   * Compile this filter's shader program.
   *
   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.
   * @param {String} fragmentSource fragmentShader source for compilation
   * @param {String} vertexSource vertexShader source for compilation
   */
  createProgram: function(gl, fragmentSource, vertexSource) {
    fragmentSource = fragmentSource || this.fragmentSource;
    vertexSource = vertexSource || this.vertexSource;
    if (fabric.webGlPrecision !== 'highp'){
      fragmentSource = fragmentSource.replace(
        /precision highp float/g,
        'precision ' + fabric.webGlPrecision + ' float'
      );
    }
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexSource);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Vertex shader compile error for ' + this.type + ': ' +
        gl.getShaderInfoLog(vertexShader)
      );
    }

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Fragment shader compile error for ' + this.type + ': ' +
        gl.getShaderInfoLog(fragmentShader)
      );
    }

    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Shader link error for "${this.type}" ' +
        gl.getProgramInfoLog(program)
      );
    }

    var attributeLocations = this.getAttributeLocations(gl, program);
    var uniformLocations = this.getUniformLocations(gl, program) || { };
    uniformLocations.uStepW = gl.getUniformLocation(program, 'uStepW');
    uniformLocations.uStepH = gl.getUniformLocation(program, 'uStepH');
    return {
      program: program,
      attributeLocations: attributeLocations,
      uniformLocations: uniformLocations
    };
  },

  /**
   * Return a map of attribute names to WebGLAttributeLocation objects.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.
   * @returns {Object} A map of attribute names to attribute locations.
   */
  getAttributeLocations: function(gl, program) {
    return {
      aPosition: gl.getAttribLocation(program, 'aPosition'),
    };
  },

  /**
   * Return a map of uniform names to WebGLUniformLocation objects.
   *
   * Intended to be overridden by subclasses.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.
   * @returns {Object} A map of uniform names to uniform locations.
   */
  getUniformLocations: function (/* gl, program */) {
    // in case i do not need any special uniform i need to return an empty object
    return { };
  },

  /**
   * Send attribute data from this filter to its shader program on the GPU.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {Object} attributeLocations A map of shader attribute names to their locations.
   */
  sendAttributeData: function(gl, attributeLocations, aPositionData) {
    var attributeLocation = attributeLocations.aPosition;
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(attributeLocation);
    gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);
    gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);
  },

  _setupFrameBuffer: function(options) {
    var gl = options.context, width, height;
    if (options.passes > 1) {
      width = options.destinationWidth;
      height = options.destinationHeight;
      if (options.sourceWidth !== width || options.sourceHeight !== height) {
        gl.deleteTexture(options.targetTexture);
        options.targetTexture = options.filterBackend.createTexture(gl, width, height);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
        options.targetTexture, 0);
    }
    else {
      // draw last filter on canvas and not to framebuffer.
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.finish();
    }
  },

  _swapTextures: function(options) {
    options.passes--;
    options.pass++;
    var temp = options.targetTexture;
    options.targetTexture = options.sourceTexture;
    options.sourceTexture = temp;
  },

  /**
   * Generic isNeutral implementation for one parameter based filters.
   * Used only in image applyFilters to discard filters that will not have an effect
   * on the image
   * Other filters may need their own verison ( ColorMatrix, HueRotation, gamma, ComposedFilter )
   * @param {Object} options
   **/
  isNeutralState: function(/* options */) {
    var main = this.mainParameter,
        _class = fabric.Image.filters[this.type].prototype;
    if (main) {
      if (Array.isArray(_class[main])) {
        for (var i = _class[main].length; i--;) {
          if (this[main][i] !== _class[main][i]) {
            return false;
          }
        }
        return true;
      }
      else {
        return _class[main] === this[main];
      }
    }
    else {
      return false;
    }
  },

  /**
   * Apply this filter to the input image data provided.
   *
   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
   *
   * @param {Object} options
   * @param {Number} options.passes The number of filters remaining to be executed
   * @param {Boolean} options.webgl Whether to use webgl to render the filter.
   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  applyTo: function(options) {
    if (options.webgl) {
      this._setupFrameBuffer(options);
      this.applyToWebGL(options);
      this._swapTextures(options);
    }
    else {
      this.applyTo2d(options);
    }
  },

  /**
   * Retrieves the cached shader.
   * @param {Object} options
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  retrieveShader: function(options) {
    if (!options.programCache.hasOwnProperty(this.type)) {
      options.programCache[this.type] = this.createProgram(options.context);
    }
    return options.programCache[this.type];
  },

  /**
   * Apply this filter using webgl.
   *
   * @param {Object} options
   * @param {Number} options.passes The number of filters remaining to be executed
   * @param {Boolean} options.webgl Whether to use webgl to render the filter.
   * @param {WebGLTexture} options.originalTexture The texture of the original input image.
   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  applyToWebGL: function(options) {
    var gl = options.context;
    var shader = this.retrieveShader(options);
    if (options.pass === 0 && options.originalTexture) {
      gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);
    }
    else {
      gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);
    }
    gl.useProgram(shader.program);
    this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);

    gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);
    gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);

    this.sendUniformData(gl, shader.uniformLocations);
    gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  },

  bindAdditionalTexture: function(gl, texture, textureUnit) {
    gl.activeTexture(textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // reset active texture to 0 as usual
    gl.activeTexture(gl.TEXTURE0);
  },

  unbindAdditionalTexture: function(gl, textureUnit) {
    gl.activeTexture(textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.activeTexture(gl.TEXTURE0);
  },

  getMainParameter: function() {
    return this[this.mainParameter];
  },

  setMainParameter: function(value) {
    this[this.mainParameter] = value;
  },

  /**
   * Send uniform data from this filter to its shader program on the GPU.
   *
   * Intended to be overridden by subclasses.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {Object} uniformLocations A map of shader uniform names to their locations.
   */
  sendUniformData: function(/* gl, uniformLocations */) {
    // Intentionally left blank.  Override me in subclasses.
  },

  /**
   * If needed by a 2d filter, this functions can create an helper canvas to be used
   * remember that options.targetCanvas is available for use till end of chain.
   */
  createHelpLayer: function(options) {
    if (!options.helpLayer) {
      var helpLayer = document.createElement('canvas');
      helpLayer.width = options.sourceWidth;
      helpLayer.height = options.sourceHeight;
      options.helpLayer = helpLayer;
    }
  },

  /**
   * Returns object representation of an instance
   * @return {Object} Object representation of an instance
   */
  toObject: function() {
    var object = { type: this.type }, mainP = this.mainParameter;
    if (mainP) {
      object[mainP] = this[mainP];
    }
    return object;
  },

  /**
   * Returns a JSON representation of an instance
   * @return {Object} JSON
   */
  toJSON: function() {
    // delegate, not alias
    return this.toObject();
  }
});

fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
  var filter = new fabric.Image.filters[object.type](object);
  callback && callback(filter);
  return filter;
};


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Color Matrix filter class
   * @class fabric.Image.filters.ColorMatrix
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}
   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}
   * @example <caption>Kodachrome filter</caption>
   * var filter = new fabric.Image.filters.ColorMatrix({
   *  matrix: [
       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
       0, 0, 0, 1, 0
      ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'ColorMatrix',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'varying vec2 vTexCoord;\n' +
      'uniform mat4 uColorMatrix;\n' +
      'uniform vec4 uConstants;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color *= uColorMatrix;\n' +
        'color += uConstants;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Colormatrix for pixels.
     * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
     * outside the -1, 1 range.
     * 0.0039215686 is the part of 1 that get translated to 1 in 2d
     * @param {Array} matrix array of 20 numbers.
     * @default
     */
    matrix: [
      1, 0, 0, 0, 0,
      0, 1, 0, 0, 0,
      0, 0, 1, 0, 0,
      0, 0, 0, 1, 0
    ],

    mainParameter: 'matrix',

    /**
     * Lock the colormatrix on the color part, skipping alpha, manly for non webgl scenario
     * to save some calculation
     */
    colorsOnly: true,

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      // create a new array instead mutating the prototype with push
      this.matrix = this.matrix.slice(0);
    },

    /**
     * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          iLen = data.length,
          m = this.matrix,
          r, g, b, a, i, colorsOnly = this.colorsOnly;

      for (i = 0; i < iLen; i += 4) {
        r = data[i];
        g = data[i + 1];
        b = data[i + 2];
        if (colorsOnly) {
          data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;
          data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;
          data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;
        }
        else {
          a = data[i + 3];
          data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;
          data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;
          data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;
          data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uColorMatrix: gl.getUniformLocation(program, 'uColorMatrix'),
        uConstants: gl.getUniformLocation(program, 'uConstants'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var m = this.matrix,
          matrix = [
            m[0], m[1], m[2], m[3],
            m[5], m[6], m[7], m[8],
            m[10], m[11], m[12], m[13],
            m[15], m[16], m[17], m[18]
          ],
          constants = [m[4], m[9], m[14], m[19]];
      gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);
      gl.uniform4fv(uniformLocations.uConstants, constants);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] function to invoke after filter creation
   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix
   */
  fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;
})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Brightness filter class
   * @class fabric.Image.filters.Brightness
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Brightness({
   *   brightness: 0.05
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Brightness',

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uBrightness;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color.rgb += uBrightness;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Brightness value, from -1 to 1.
     * translated to -255 to 255 for 2d
     * 0.0039215686 is the part of 1 that get translated to 1 in 2d
     * @param {Number} brightness
     * @default
     */
    brightness: 0,

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'brightness',

    /**
    * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
    *
    * @param {Object} options
    * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
    */
    applyTo2d: function(options) {
      if (this.brightness === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, i, len = data.length,
          brightness = Math.round(this.brightness * 255);
      for (i = 0; i < len; i += 4) {
        data[i] = data[i] + brightness;
        data[i + 1] = data[i + 1] + brightness;
        data[i + 2] = data[i + 2] + brightness;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uBrightness: gl.getUniformLocation(program, 'uBrightness'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uBrightness, this.brightness);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness
   */
  fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Adapted from <a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">html5rocks article</a>
   * @class fabric.Image.filters.Convolute
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example <caption>Sharpen filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 0, -1,  0,
   *            -1,  5, -1,
   *             0, -1,  0 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Blur filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 1/9, 1/9, 1/9,
   *             1/9, 1/9, 1/9,
   *             1/9, 1/9, 1/9 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Emboss filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 1,   1,  1,
   *             1, 0.7, -1,
   *            -1,  -1, -1 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Emboss filter with opaqueness</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   opaque: true,
   *   matrix: [ 1,   1,  1,
   *             1, 0.7, -1,
   *            -1,  -1, -1 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Convolute',

    /*
     * Opaque value (true/false)
     */
    opaque: false,

    /*
     * matrix for the filter, max 9x9
     */
    matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: {
      Convolute_3_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[9];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_3_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[9];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_5_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[25];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_5_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[25];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_7_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[49];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_7_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[49];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_9_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[81];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_9_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[81];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
    },

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Convolute.prototype
     * @param {Object} [options] Options object
     * @param {Boolean} [options.opaque=false] Opaque value (true/false)
     * @param {Array} [options.matrix] Filter matrix
     */


    /**
    * Retrieves the cached shader.
    * @param {Object} options
    * @param {WebGLRenderingContext} options.context The GL context used for rendering.
    * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
    */
    retrieveShader: function(options) {
      var size = Math.sqrt(this.matrix.length);
      var cacheKey = this.type + '_' + size + '_' + (this.opaque ? 1 : 0);
      var shaderSource = this.fragmentSource[cacheKey];
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          weights = this.matrix,
          side = Math.round(Math.sqrt(weights.length)),
          halfSide = Math.floor(side / 2),
          sw = imageData.width,
          sh = imageData.height,
          output = options.ctx.createImageData(sw, sh),
          dst = output.data,
          // go through the destination image pixels
          alphaFac = this.opaque ? 1 : 0,
          r, g, b, a, dstOff,
          scx, scy, srcOff, wt,
          x, y, cx, cy;

      for (y = 0; y < sh; y++) {
        for (x = 0; x < sw; x++) {
          dstOff = (y * sw + x) * 4;
          // calculate the weighed sum of the source image pixels that
          // fall under the convolution matrix
          r = 0; g = 0; b = 0; a = 0;

          for (cy = 0; cy < side; cy++) {
            for (cx = 0; cx < side; cx++) {
              scy = y + cy - halfSide;
              scx = x + cx - halfSide;

              // eslint-disable-next-line max-depth
              if (scy < 0 || scy > sh || scx < 0 || scx > sw) {
                continue;
              }

              srcOff = (scy * sw + scx) * 4;
              wt = weights[cy * side + cx];

              r += data[srcOff] * wt;
              g += data[srcOff + 1] * wt;
              b += data[srcOff + 2] * wt;
              // eslint-disable-next-line max-depth
              if (!alphaFac) {
                a += data[srcOff + 3] * wt;
              }
            }
          }
          dst[dstOff] = r;
          dst[dstOff + 1] = g;
          dst[dstOff + 2] = b;
          if (!alphaFac) {
            dst[dstOff + 3] = a;
          }
          else {
            dst[dstOff + 3] = data[dstOff + 3];
          }
        }
      }
      options.imageData = output;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uMatrix: gl.getUniformLocation(program, 'uMatrix'),
        uOpaque: gl.getUniformLocation(program, 'uOpaque'),
        uHalfSize: gl.getUniformLocation(program, 'uHalfSize'),
        uSize: gl.getUniformLocation(program, 'uSize'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1fv(uniformLocations.uMatrix, this.matrix);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        opaque: this.opaque,
        matrix: this.matrix
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute
   */
  fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Grayscale image filter class
   * @class fabric.Image.filters.Grayscale
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Grayscale();
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Grayscale',

    fragmentSource: {
      average: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'float average = (color.r + color.b + color.g) / 3.0;\n' +
          'gl_FragColor = vec4(average, average, average, color.a);\n' +
        '}',
      lightness: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uMode;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 col = texture2D(uTexture, vTexCoord);\n' +
          'float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n' +
          'gl_FragColor = vec4(average, average, average, col.a);\n' +
        '}',
      luminosity: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uMode;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 col = texture2D(uTexture, vTexCoord);\n' +
          'float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n' +
          'gl_FragColor = vec4(average, average, average, col.a);\n' +
        '}',
    },


    /**
     * Grayscale mode, between 'average', 'lightness', 'luminosity'
     * @param {String} type
     * @default
     */
    mode: 'average',

    mainParameter: 'mode',

    /**
     * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          len = data.length, value,
          mode = this.mode;
      for (i = 0; i < len; i += 4) {
        if (mode === 'average') {
          value = (data[i] + data[i + 1] + data[i + 2]) / 3;
        }
        else if (mode === 'lightness') {
          value = (Math.min(data[i], data[i + 1], data[i + 2]) +
            Math.max(data[i], data[i + 1], data[i + 2])) / 2;
        }
        else if (mode === 'luminosity') {
          value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];
        }
        data[i] = value;
        data[i + 1] = value;
        data[i + 2] = value;
      }
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode;
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        var shaderSource = this.fragmentSource[this.mode];
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uMode: gl.getUniformLocation(program, 'uMode'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      // default average mode.
      var mode = 1;
      gl.uniform1i(uniformLocations.uMode, mode);
    },

    /**
     * Grayscale filter isNeutralState implementation
     * The filter is never neutral
     * on the image
     **/
    isNeutralState: function() {
      return false;
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale
   */
  fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Invert filter class
   * @class fabric.Image.filters.Invert
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Invert();
   * object.filters.push(filter);
   * object.applyFilters(canvas.renderAll.bind(canvas));
   */
  filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Invert',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform int uInvert;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'if (uInvert == 1) {\n' +
          'gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n' +
        '} else {\n' +
          'gl_FragColor = color;\n' +
        '}\n' +
      '}',

    /**
     * Filter invert. if false, does nothing
     * @param {Boolean} invert
     * @default
     */
    invert: true,

    mainParameter: 'invert',

    /**
     * Apply the Invert operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          len = data.length;
      for (i = 0; i < len; i += 4) {
        data[i] = 255 - data[i];
        data[i + 1] = 255 - data[i + 1];
        data[i + 2] = 255 - data[i + 2];
      }
    },

    /**
     * Invert filter isNeutralState implementation
     * Used only in image applyFilters to discard filters that will not have an effect
     * on the image
     * @param {Object} options
     **/
    isNeutralState: function() {
      return !this.invert;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uInvert: gl.getUniformLocation(program, 'uInvert'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1i(uniformLocations.uInvert, this.invert);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert
   */
  fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;


})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Noise filter class
   * @class fabric.Image.filters.Noise
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Noise({
   *   noise: 700
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Noise',

    /**
     * Fragment source for the noise program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uStepH;\n' +
      'uniform float uNoise;\n' +
      'uniform float uSeed;\n' +
      'varying vec2 vTexCoord;\n' +
      'float rand(vec2 co, float seed, float vScale) {\n' +
        'return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n' +
      '}\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'noise',

    /**
     * Noise value, from
     * @param {Number} noise
     * @default
     */
    noise: 0,

    /**
     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      if (this.noise === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, i, len = data.length,
          noise = this.noise, rand;

      for (i = 0, len = data.length; i < len; i += 4) {

        rand = (0.5 - Math.random()) * noise;

        data[i] += rand;
        data[i + 1] += rand;
        data[i + 2] += rand;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uNoise: gl.getUniformLocation(program, 'uNoise'),
        uSeed: gl.getUniformLocation(program, 'uSeed'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uNoise, this.noise / 255);
      gl.uniform1f(uniformLocations.uSeed, Math.random());
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        noise: this.noise
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise
   */
  fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Pixelate filter class
   * @class fabric.Image.filters.Pixelate
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Pixelate({
   *   blocksize: 8
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Pixelate',

    blocksize: 4,

    mainParameter: 'blocksize',

    /**
     * Fragment source for the Pixelate program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uBlocksize;\n' +
      'uniform float uStepW;\n' +
      'uniform float uStepH;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'float blockW = uBlocksize * uStepW;\n' +
        'float blockH = uBlocksize * uStepW;\n' +
        'int posX = int(vTexCoord.x / blockW);\n' +
        'int posY = int(vTexCoord.y / blockH);\n' +
        'float fposX = float(posX);\n' +
        'float fposY = float(posY);\n' +
        'vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n' +
        'vec4 color = texture2D(uTexture, squareCoords);\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          iLen = imageData.height,
          jLen = imageData.width,
          index, i, j, r, g, b, a,
          _i, _j, _iLen, _jLen;

      for (i = 0; i < iLen; i += this.blocksize) {
        for (j = 0; j < jLen; j += this.blocksize) {

          index = (i * 4) * jLen + (j * 4);

          r = data[index];
          g = data[index + 1];
          b = data[index + 2];
          a = data[index + 3];

          _iLen = Math.min(i + this.blocksize, iLen);
          _jLen = Math.min(j + this.blocksize, jLen);
          for (_i = i; _i < _iLen; _i++) {
            for (_j = j; _j < _jLen; _j++) {
              index = (_i * 4) * jLen + (_j * 4);
              data[index] = r;
              data[index + 1] = g;
              data[index + 2] = b;
              data[index + 3] = a;
            }
          }
        }
      }
    },

    /**
     * Indicate when the filter is not gonna apply changes to the image
     **/
    isNeutralState: function() {
      return this.blocksize === 1;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uBlocksize: gl.getUniformLocation(program, 'uBlocksize'),
        uStepW: gl.getUniformLocation(program, 'uStepW'),
        uStepH: gl.getUniformLocation(program, 'uStepH'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate
   */
  fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Remove white filter class
   * @class fabric.Image.filters.RemoveColor
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.RemoveColor({
   *   threshold: 0.2,
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'RemoveColor',

    /**
     * Color to remove, in any format understood by fabric.Color.
     * @param {String} type
     * @default
     */
    color: '#FFFFFF',

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec4 uLow;\n' +
      'uniform vec4 uHigh;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
        'if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n' +
          'gl_FragColor.a = 0.0;\n' +
        '}\n' +
      '}',

    /**
     * distance to actual color, as value up or down from each r,g,b
     * between 0 and 1
     **/
    distance: 0.02,

    /**
     * For color to remove inside distance, use alpha channel for a smoother deletion
     * NOT IMPLEMENTED YET
     **/
    useAlpha: false,

    /**
     * Constructor
     * @memberOf fabric.Image.filters.RemoveWhite.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.color=#RRGGBB] Threshold value
     * @param {Number} [options.distance=10] Distance value
     */

    /**
     * Applies filter to canvas element
     * @param {Object} canvasEl Canvas element to apply filter to
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          distance = this.distance * 255,
          r, g, b,
          source = new fabric.Color(this.color).getSource(),
          lowC = [
            source[0] - distance,
            source[1] - distance,
            source[2] - distance,
          ],
          highC = [
            source[0] + distance,
            source[1] + distance,
            source[2] + distance,
          ];


      for (i = 0; i < data.length; i += 4) {
        r = data[i];
        g = data[i + 1];
        b = data[i + 2];

        if (r > lowC[0] &&
            g > lowC[1] &&
            b > lowC[2] &&
            r < highC[0] &&
            g < highC[1] &&
            b < highC[2]) {
          data[i + 3] = 0;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uLow: gl.getUniformLocation(program, 'uLow'),
        uHigh: gl.getUniformLocation(program, 'uHigh'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var source = new fabric.Color(this.color).getSource(),
          distance = parseFloat(this.distance),
          lowC = [
            0 + source[0] / 255 - distance,
            0 + source[1] / 255 - distance,
            0 + source[2] / 255 - distance,
            1
          ],
          highC = [
            source[0] / 255 + distance,
            source[1] / 255 + distance,
            source[2] / 255 + distance,
            1
          ];
      gl.uniform4fv(uniformLocations.uLow, lowC);
      gl.uniform4fv(uniformLocations.uHigh, highC);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        color: this.color,
        distance: this.distance
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite
   */
  fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  var matrices = {
    Brownie: [
      0.59970,0.34553,-0.27082,0,0.186,
      -0.03770,0.86095,0.15059,0,-0.1449,
      0.24113,-0.07441,0.44972,0,-0.02965,
      0,0,0,1,0
    ],
    Vintage: [
      0.62793,0.32021,-0.03965,0,0.03784,
      0.02578,0.64411,0.03259,0,0.02926,
      0.04660,-0.08512,0.52416,0,0.02023,
      0,0,0,1,0
    ],
    Kodachrome: [
      1.12855,-0.39673,-0.03992,0,0.24991,
      -0.16404,1.08352,-0.05498,0,0.09698,
      -0.16786,-0.56034,1.60148,0,0.13972,
      0,0,0,1,0
    ],
    Technicolor: [
      1.91252,-0.85453,-0.09155,0,0.04624,
      -0.30878,1.76589,-0.10601,0,-0.27589,
      -0.23110,-0.75018,1.84759,0,0.12137,
      0,0,0,1,0
    ],
    Polaroid: [
      1.438,-0.062,-0.062,0,0,
      -0.122,1.378,-0.122,0,0,
      -0.016,-0.016,1.483,0,0,
      0,0,0,1,0
    ],
    Sepia: [
      0.393, 0.769, 0.189, 0, 0,
      0.349, 0.686, 0.168, 0, 0,
      0.272, 0.534, 0.131, 0, 0,
      0, 0, 0, 1, 0
    ],
    BlackWhite: [
      1.5, 1.5, 1.5, 0, -1,
      1.5, 1.5, 1.5, 0, -1,
      1.5, 1.5, 1.5, 0, -1,
      0, 0, 0, 1, 0,
    ]
  };

  for (var key in matrices) {
    filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: key,

      /**
       * Colormatrix for the effect
       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
       * outside the -1, 1 range.
       * @param {Array} matrix array of 20 numbers.
       * @default
       */
      matrix: matrices[key],

      /**
       * Lock the matrix export for this kind of static, parameter less filters.
       */
      mainParameter: false,
      /**
       * Lock the colormatrix on the color part, skipping alpha
       */
      colorsOnly: true,

    });
    fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;
  }
})( true ? exports : undefined);


(function(global) {
  'use strict';

  var fabric = global.fabric,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Color Blend filter class
   * @class fabric.Image.filter.BlendColor
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @example
   * var filter = new fabric.Image.filters.BlendColor({
   *  color: '#000',
   *  mode: 'multiply'
   * });
   *
   * var filter = new fabric.Image.filters.BlendImage({
   *  image: fabricImageObject,
   *  mode: 'multiply',
   *  alpha: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */

  filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {
    type: 'BlendColor',

    /**
     * Color to make the blend operation with. default to a reddish color since black or white
     * gives always strong result.
     **/
    color: '#F95C63',

    /**
     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
     * darken, lighten, overlay, exclusion, tint.
     **/
    mode: 'multiply',

    /**
     * alpha value. represent the strength of the blend color operation.
     **/
    alpha: 1,

    /**
     * Fragment source for the Multiply program
     */
    fragmentSource: {
      multiply: 'gl_FragColor.rgb *= uColor.rgb;\n',
      screen: 'gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n',
      add: 'gl_FragColor.rgb += uColor.rgb;\n',
      diff: 'gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n',
      subtract: 'gl_FragColor.rgb -= uColor.rgb;\n',
      lighten: 'gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n',
      darken: 'gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n',
      exclusion: 'gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n',
      overlay: 'if (uColor.r < 0.5) {\n' +
          'gl_FragColor.r *= 2.0 * uColor.r;\n' +
        '} else {\n' +
          'gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n' +
        '}\n' +
        'if (uColor.g < 0.5) {\n' +
          'gl_FragColor.g *= 2.0 * uColor.g;\n' +
        '} else {\n' +
          'gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n' +
        '}\n' +
        'if (uColor.b < 0.5) {\n' +
          'gl_FragColor.b *= 2.0 * uColor.b;\n' +
        '} else {\n' +
          'gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n' +
        '}\n',
      tint: 'gl_FragColor.rgb *= (1.0 - uColor.a);\n' +
        'gl_FragColor.rgb += uColor.rgb;\n',
    },

    /**
     * build the fragment source for the filters, joining the common part with
     * the specific one.
     * @param {String} mode the mode of the filter, a key of this.fragmentSource
     * @return {String} the source to be compiled
     * @private
     */
    buildSource: function(mode) {
      return 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'gl_FragColor = color;\n' +
          'if (color.a > 0.0) {\n' +
            this.fragmentSource[mode] +
          '}\n' +
        '}';
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode, shaderSource;
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        shaderSource = this.buildSource(this.mode);
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, iLen = data.length,
          tr, tg, tb,
          r, g, b,
          source, alpha1 = 1 - this.alpha;

      source = new fabric.Color(this.color).getSource();
      tr = source[0] * this.alpha;
      tg = source[1] * this.alpha;
      tb = source[2] * this.alpha;

      for (var i = 0; i < iLen; i += 4) {

        r = data[i];
        g = data[i + 1];
        b = data[i + 2];

        switch (this.mode) {
          case 'multiply':
            data[i] = r * tr / 255;
            data[i + 1] = g * tg / 255;
            data[i + 2] = b * tb / 255;
            break;
          case 'screen':
            data[i] = 255 - (255 - r) * (255 - tr) / 255;
            data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;
            data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;
            break;
          case 'add':
            data[i] = r + tr;
            data[i + 1] = g + tg;
            data[i + 2] = b + tb;
            break;
          case 'diff':
          case 'difference':
            data[i] = Math.abs(r - tr);
            data[i + 1] = Math.abs(g - tg);
            data[i + 2] = Math.abs(b - tb);
            break;
          case 'subtract':
            data[i] = r - tr;
            data[i + 1] = g - tg;
            data[i + 2] = b - tb;
            break;
          case 'darken':
            data[i] = Math.min(r, tr);
            data[i + 1] = Math.min(g, tg);
            data[i + 2] = Math.min(b, tb);
            break;
          case 'lighten':
            data[i] = Math.max(r, tr);
            data[i + 1] = Math.max(g, tg);
            data[i + 2] = Math.max(b, tb);
            break;
          case 'overlay':
            data[i] = tr < 128 ? (2 * r * tr / 255) : (255 - 2 * (255 - r) * (255 - tr) / 255);
            data[i + 1] = tg < 128 ? (2 * g * tg / 255) : (255 - 2 * (255 - g) * (255 - tg) / 255);
            data[i + 2] = tb < 128 ? (2 * b * tb / 255) : (255 - 2 * (255 - b) * (255 - tb) / 255);
            break;
          case 'exclusion':
            data[i] = tr + r - ((2 * tr * r) / 255);
            data[i + 1] = tg + g - ((2 * tg * g) / 255);
            data[i + 2] = tb + b - ((2 * tb * b) / 255);
            break;
          case 'tint':
            data[i] = tr + r * alpha1;
            data[i + 1] = tg + g * alpha1;
            data[i + 2] = tb + b * alpha1;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uColor: gl.getUniformLocation(program, 'uColor'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var source = new fabric.Color(this.color).getSource();
      source[0] = this.alpha * source[0] / 255;
      source[1] = this.alpha * source[1] / 255;
      source[2] = this.alpha * source[2] / 255;
      source[3] = this.alpha;
      gl.uniform4fv(uniformLocations.uColor, source);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        color: this.color,
        mode: this.mode,
        alpha: this.alpha
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor
   */
  fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {
  'use strict';

  var fabric = global.fabric,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Image Blend filter class
   * @class fabric.Image.filter.BlendImage
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @example
   * var filter = new fabric.Image.filters.BlendColor({
   *  color: '#000',
   *  mode: 'multiply'
   * });
   *
   * var filter = new fabric.Image.filters.BlendImage({
   *  image: fabricImageObject,
   *  mode: 'multiply',
   *  alpha: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */

  filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {
    type: 'BlendImage',

    /**
     * Color to make the blend operation with. default to a reddish color since black or white
     * gives always strong result.
     **/
    image: null,

    /**
     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
     * darken, lighten, overlay, exclusion, tint.
     **/
    mode: 'multiply',

    /**
     * alpha value. represent the strength of the blend image operation.
     * not implemented.
     **/
    alpha: 1,

    vertexSource: 'attribute vec2 aPosition;\n' +
      'varying vec2 vTexCoord;\n' +
      'varying vec2 vTexCoord2;\n' +
      'uniform mat3 uTransformMatrix;\n' +
      'void main() {\n' +
        'vTexCoord = aPosition;\n' +
        'vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n' +
        'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
      '}',

    /**
     * Fragment source for the Multiply program
     */
    fragmentSource: {
      multiply: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform sampler2D uImage;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
          'color.rgba *= color2.rgba;\n' +
          'gl_FragColor = color;\n' +
        '}',
      mask: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform sampler2D uImage;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
          'color.a = color2.a;\n' +
          'gl_FragColor = color;\n' +
        '}',
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode;
      var shaderSource = this.fragmentSource[this.mode];
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    applyToWebGL: function(options) {
      // load texture to blend.
      var gl = options.context,
          texture = this.createTexture(options.filterBackend, this.image);
      this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);
      this.callSuper('applyToWebGL', options);
      this.unbindAdditionalTexture(gl, gl.TEXTURE1);
    },

    createTexture: function(backend, image) {
      return backend.getCachedTexture(image.cacheKey, image._element);
    },

    /**
     * Calculate a transformMatrix to adapt the image to blend over
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    calculateMatrix: function() {
      var image = this.image,
          width = image._element.width,
          height = image._element.height;
      return [
        1 / image.scaleX, 0, 0,
        0, 1 / image.scaleY, 0,
        -image.left / width, -image.top / height, 1
      ];
    },

    /**
     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          resources = options.filterBackend.resources,
          data = imageData.data, iLen = data.length,
          width = imageData.width,
          height = imageData.height,
          tr, tg, tb, ta,
          r, g, b, a,
          canvas1, context, image = this.image, blendData;

      if (!resources.blendImage) {
        resources.blendImage = fabric.util.createCanvasElement();
      }
      canvas1 = resources.blendImage;
      context = canvas1.getContext('2d');
      if (canvas1.width !== width || canvas1.height !== height) {
        canvas1.width = width;
        canvas1.height = height;
      }
      else {
        context.clearRect(0, 0, width, height);
      }
      context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);
      context.drawImage(image._element, 0, 0, width, height);
      blendData = context.getImageData(0, 0, width, height).data;
      for (var i = 0; i < iLen; i += 4) {

        r = data[i];
        g = data[i + 1];
        b = data[i + 2];
        a = data[i + 3];

        tr = blendData[i];
        tg = blendData[i + 1];
        tb = blendData[i + 2];
        ta = blendData[i + 3];

        switch (this.mode) {
          case 'multiply':
            data[i] = r * tr / 255;
            data[i + 1] = g * tg / 255;
            data[i + 2] = b * tb / 255;
            data[i + 3] = a * ta / 255;
            break;
          case 'mask':
            data[i + 3] = ta;
            break;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uTransformMatrix: gl.getUniformLocation(program, 'uTransformMatrix'),
        uImage: gl.getUniformLocation(program, 'uImage'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var matrix = this.calculateMatrix();
      gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.
      gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        image: this.image && this.image.toObject(),
        mode: this.mode,
        alpha: this.alpha
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} callback to be invoked after filter creation
   * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage
   */
  fabric.Image.filters.BlendImage.fromObject = function(object, callback) {
    fabric.Image.fromObject(object.image, function(image) {
      var options = fabric.util.object.clone(object);
      options.image = image;
      callback(new fabric.Image.filters.BlendImage(options));
    });
  };

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,
      sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin,
      ceil = Math.ceil,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Resize image filter class
   * @class fabric.Image.filters.Resize
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Resize();
   * object.filters.push(filter);
   * object.applyFilters(canvas.renderAll.bind(canvas));
   */
  filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Resize',

    /**
     * Resize type
     * for webgl resizeType is just lanczos, for canvas2d can be:
     * bilinear, hermite, sliceHack, lanczos.
     * @param {String} resizeType
     * @default
     */
    resizeType: 'hermite',

    /**
     * Scale factor for resizing, x axis
     * @param {Number} scaleX
     * @default
     */
    scaleX: 1,

    /**
     * Scale factor for resizing, y axis
     * @param {Number} scaleY
     * @default
     */
    scaleY: 1,

    /**
     * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos
     * @param {Number} lanczosLobes
     * @default
     */
    lanczosLobes: 3,


    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uDelta: gl.getUniformLocation(program, 'uDelta'),
        uTaps: gl.getUniformLocation(program, 'uTaps'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]);
      gl.uniform1fv(uniformLocations.uTaps, this.taps);
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var filterWindow = this.getFilterWindow(), cacheKey = this.type + '_' + filterWindow;
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        var fragmentShader = this.generateShader(filterWindow);
        options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);
      }
      return options.programCache[cacheKey];
    },

    getFilterWindow: function() {
      var scale = this.tempScale;
      return Math.ceil(this.lanczosLobes / scale);
    },

    getTaps: function() {
      var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale,
          filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);
      for (var i = 1; i <= filterWindow; i++) {
        taps[i - 1] = lobeFunction(i * scale);
      }
      return taps;
    },

    /**
     * Generate vertex and shader sources from the necessary steps numbers
     * @param {Number} filterWindow
     */
    generateShader: function(filterWindow) {
      var offsets = new Array(filterWindow),
          fragmentShader = this.fragmentSourceTOP, filterWindow;

      for (var i = 1; i <= filterWindow; i++) {
        offsets[i - 1] = i + '.0 * uDelta';
      }

      fragmentShader += 'uniform float uTaps[' + filterWindow + '];\n';
      fragmentShader += 'void main() {\n';
      fragmentShader += '  vec4 color = texture2D(uTexture, vTexCoord);\n';
      fragmentShader += '  float sum = 1.0;\n';

      offsets.forEach(function(offset, i) {
        fragmentShader += '  color += texture2D(uTexture, vTexCoord + ' + offset + ') * uTaps[' + i + '];\n';
        fragmentShader += '  color += texture2D(uTexture, vTexCoord - ' + offset + ') * uTaps[' + i + '];\n';
        fragmentShader += '  sum += 2.0 * uTaps[' + i + '];\n';
      });
      fragmentShader += '  gl_FragColor = color / sum;\n';
      fragmentShader += '}';
      return fragmentShader;
    },

    fragmentSourceTOP: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec2 uDelta;\n' +
      'varying vec2 vTexCoord;\n',

    /**
     * Apply the resize filter to the image
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyTo: function(options) {
      if (options.webgl) {
        options.passes++;
        this.width = options.sourceWidth;
        this.horizontal = true;
        this.dW = Math.round(this.width * this.scaleX);
        this.dH = options.sourceHeight;
        this.tempScale = this.dW / this.width;
        this.taps = this.getTaps();
        options.destinationWidth = this.dW;
        this._setupFrameBuffer(options);
        this.applyToWebGL(options);
        this._swapTextures(options);
        options.sourceWidth = options.destinationWidth;

        this.height = options.sourceHeight;
        this.horizontal = false;
        this.dH = Math.round(this.height * this.scaleY);
        this.tempScale = this.dH / this.height;
        this.taps = this.getTaps();
        options.destinationHeight = this.dH;
        this._setupFrameBuffer(options);
        this.applyToWebGL(options);
        this._swapTextures(options);
        options.sourceHeight = options.destinationHeight;
      }
      else {
        this.applyTo2d(options);
      }
    },

    isNeutralState: function() {
      return this.scaleX === 1 && this.scaleY === 1;
    },

    lanczosCreate: function(lobes) {
      return function(x) {
        if (x >= lobes || x <= -lobes) {
          return 0.0;
        }
        if (x < 1.19209290E-07 && x > -1.19209290E-07) {
          return 1.0;
        }
        x *= Math.PI;
        var xx = x / lobes;
        return (sin(x) / x) * sin(xx) / xx;
      };
    },

    /**
     * Applies filter to canvas element
     * @memberOf fabric.Image.filters.Resize.prototype
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} scaleX
     * @param {Number} scaleY
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          scaleX = this.scaleX,
          scaleY = this.scaleY;

      this.rcpScaleX = 1 / scaleX;
      this.rcpScaleY = 1 / scaleY;

      var oW = imageData.width, oH = imageData.height,
          dW = round(oW * scaleX), dH = round(oH * scaleY),
          newData;

      if (this.resizeType === 'sliceHack') {
        newData = this.sliceByTwo(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'hermite') {
        newData = this.hermiteFastResize(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'bilinear') {
        newData = this.bilinearFiltering(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'lanczos') {
        newData = this.lanczosResize(options, oW, oH, dW, dH);
      }
      options.imageData = newData;
    },

    /**
     * Filter sliceByTwo
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    sliceByTwo: function(options, oW, oH, dW, dH) {
      var imageData = options.imageData,
          mult = 0.5, doneW = false, doneH = false, stepW = oW * mult,
          stepH = oH * mult, resources = fabric.filterBackend.resources,
          tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;
      if (!resources.sliceByTwo) {
        resources.sliceByTwo = document.createElement('canvas');
      }
      tmpCanvas = resources.sliceByTwo;
      if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {
        tmpCanvas.width = oW * 1.5;
        tmpCanvas.height = oH;
      }
      ctx = tmpCanvas.getContext('2d');
      ctx.clearRect(0, 0, oW * 1.5, oH);
      ctx.putImageData(imageData, 0, 0);

      dW = floor(dW);
      dH = floor(dH);

      while (!doneW || !doneH) {
        oW = stepW;
        oH = stepH;
        if (dW < floor(stepW * mult)) {
          stepW = floor(stepW * mult);
        }
        else {
          stepW = dW;
          doneW = true;
        }
        if (dH < floor(stepH * mult)) {
          stepH = floor(stepH * mult);
        }
        else {
          stepH = dH;
          doneH = true;
        }
        ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);
        sX = dX;
        sY = dY;
        dY += stepH;
      }
      return ctx.getImageData(sX, sY, dW, dH);
    },

    /**
     * Filter lanczosResize
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    lanczosResize: function(options, oW, oH, dW, dH) {

      function process(u) {
        var v, i, weight, idx, a, red, green,
            blue, alpha, fX, fY;
        center.x = (u + 0.5) * ratioX;
        icenter.x = floor(center.x);
        for (v = 0; v < dH; v++) {
          center.y = (v + 0.5) * ratioY;
          icenter.y = floor(center.y);
          a = 0; red = 0; green = 0; blue = 0; alpha = 0;
          for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {
            if (i < 0 || i >= oW) {
              continue;
            }
            fX = floor(1000 * abs(i - center.x));
            if (!cacheLanc[fX]) {
              cacheLanc[fX] = { };
            }
            for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {
              if (j < 0 || j >= oH) {
                continue;
              }
              fY = floor(1000 * abs(j - center.y));
              if (!cacheLanc[fX][fY]) {
                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);
              }
              weight = cacheLanc[fX][fY];
              if (weight > 0) {
                idx = (j * oW + i) * 4;
                a += weight;
                red += weight * srcData[idx];
                green += weight * srcData[idx + 1];
                blue += weight * srcData[idx + 2];
                alpha += weight * srcData[idx + 3];
              }
            }
          }
          idx = (v * dW + u) * 4;
          destData[idx] = red / a;
          destData[idx + 1] = green / a;
          destData[idx + 2] = blue / a;
          destData[idx + 3] = alpha / a;
        }

        if (++u < dW) {
          return process(u);
        }
        else {
          return destImg;
        }
      }

      var srcData = options.imageData.data,
          destImg = options.ctx.createImageData(dW, dH),
          destData = destImg.data,
          lanczos = this.lanczosCreate(this.lanczosLobes),
          ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,
          rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,
          range2X = ceil(ratioX * this.lanczosLobes / 2),
          range2Y = ceil(ratioY * this.lanczosLobes / 2),
          cacheLanc = { }, center = { }, icenter = { };

      return process(0);
    },

    /**
     * bilinearFiltering
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    bilinearFiltering: function(options, oW, oH, dW, dH) {
      var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,
          color, offset = 0, origPix, ratioX = this.rcpScaleX,
          ratioY = this.rcpScaleY,
          w4 = 4 * (oW - 1), img = options.imageData,
          pixels = img.data, destImage = options.ctx.createImageData(dW, dH),
          destPixels = destImage.data;
      for (i = 0; i < dH; i++) {
        for (j = 0; j < dW; j++) {
          x = floor(ratioX * j);
          y = floor(ratioY * i);
          xDiff = ratioX * j - x;
          yDiff = ratioY * i - y;
          origPix = 4 * (y * oW + x);

          for (chnl = 0; chnl < 4; chnl++) {
            a = pixels[origPix + chnl];
            b = pixels[origPix + 4 + chnl];
            c = pixels[origPix + w4 + chnl];
            d = pixels[origPix + w4 + 4 + chnl];
            color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +
                    c * yDiff * (1 - xDiff) + d * xDiff * yDiff;
            destPixels[offset++] = color;
          }
        }
      }
      return destImage;
    },

    /**
     * hermiteFastResize
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    hermiteFastResize: function(options, oW, oH, dW, dH) {
      var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,
          ratioWHalf = ceil(ratioW / 2),
          ratioHHalf = ceil(ratioH / 2),
          img = options.imageData, data = img.data,
          img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;
      for (var j = 0; j < dH; j++) {
        for (var i = 0; i < dW; i++) {
          var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,
              gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;
          for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {
            var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,
                centerX = (i + 0.5) * ratioW, w0 = dy * dy;
            for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {
              var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,
                  w = sqrt(w0 + dx * dx);
              /* eslint-disable max-depth */
              if (w > 1 && w < -1) {
                continue;
              }
              //hermite filter
              weight = 2 * w * w * w - 3 * w * w + 1;
              if (weight > 0) {
                dx = 4 * (xx + yy * oW);
                //alpha
                gxA += weight * data[dx + 3];
                weightsAlpha += weight;
                //colors
                if (data[dx + 3] < 255) {
                  weight = weight * data[dx + 3] / 250;
                }
                gxR += weight * data[dx];
                gxG += weight * data[dx + 1];
                gxB += weight * data[dx + 2];
                weights += weight;
              }
              /* eslint-enable max-depth */
            }
          }
          data2[x2] = gxR / weights;
          data2[x2 + 1] = gxG / weights;
          data2[x2 + 2] = gxB / weights;
          data2[x2 + 3] = gxA / weightsAlpha;
        }
      }
      return img2;
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        resizeType: this.resizeType,
        lanczosLobes: this.lanczosLobes
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize
   */
  fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Contrast filter class
   * @class fabric.Image.filters.Contrast
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Contrast({
   *   contrast: 40
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Contrast',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uContrast;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n' +
        'color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n' +
        'gl_FragColor = color;\n' +
      '}',

    contrast: 0,

    mainParameter: 'contrast',

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Contrast.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)
     */

    /**
      * Apply the Contrast operation to a Uint8Array representing the pixels of an image.
      *
      * @param {Object} options
      * @param {ImageData} options.imageData The Uint8Array to be filtered.
      */
    applyTo2d: function(options) {
      if (this.contrast === 0) {
        return;
      }
      var imageData = options.imageData, i, len,
          data = imageData.data, len = data.length,
          contrast = Math.floor(this.contrast * 255),
          contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));

      for (i = 0; i < len; i += 4) {
        data[i] = contrastF * (data[i] - 128) + 128;
        data[i + 1] = contrastF * (data[i + 1] - 128) + 128;
        data[i + 2] = contrastF * (data[i + 2] - 128) + 128;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uContrast: gl.getUniformLocation(program, 'uContrast'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uContrast, this.contrast);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast
   */
  fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Saturate filter class
   * @class fabric.Image.filters.Saturation
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Saturation({
   *   saturation: 100
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Saturation',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uSaturation;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'float rgMax = max(color.r, color.g);\n' +
        'float rgbMax = max(rgMax, color.b);\n' +
        'color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n' +
        'color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n' +
        'color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n' +
        'gl_FragColor = color;\n' +
      '}',

    saturation: 0,

    mainParameter: 'saturation',

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Saturate.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)
     */

    /**
     * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      if (this.saturation === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, len = data.length,
          adjust = -this.saturation, i, max;

      for (i = 0; i < len; i += 4) {
        max = Math.max(data[i], data[i + 1], data[i + 2]);
        data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;
        data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;
        data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uSaturation: gl.getUniformLocation(program, 'uSaturation'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uSaturation, -this.saturation);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate
   */
  fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Blur filter class
   * @class fabric.Image.filters.Blur
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Blur({
   *   blur: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {

    type: 'Blur',

    /*
'gl_FragColor = vec4(0.0);',
'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',
'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',
'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',
'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',
'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',
'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',
'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',
'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',
'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',
'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',
'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',
'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',
'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',
'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',
'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',
*/

    /* eslint-disable max-len */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec2 uDelta;\n' +
      'varying vec2 vTexCoord;\n' +
      'const float nSamples = 15.0;\n' +
      'vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n' +
      'float random(vec3 scale) {\n' +
        /* use the fragment position for a different seed per-pixel */
        'return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n' +
      '}\n' +
      'void main() {\n' +
        'vec4 color = vec4(0.0);\n' +
        'float total = 0.0;\n' +
        'float offset = random(v3offset);\n' +
        'for (float t = -nSamples; t <= nSamples; t++) {\n' +
          'float percent = (t + offset - 0.5) / nSamples;\n' +
          'float weight = 1.0 - abs(percent);\n' +
          'color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\n' +
          'total += weight;\n' +
        '}\n' +
        'gl_FragColor = color / total;\n' +
      '}',
    /* eslint-enable max-len */

    /**
     * blur value, in percentage of image dimensions.
     * specific to keep the image blur constant at different resolutions
     * range bewteen 0 and 1.
     */
    blur: 0,

    mainParameter: 'blur',

    applyTo: function(options) {
      if (options.webgl) {
        // this aspectRatio is used to give the same blur to vertical and horizontal
        this.aspectRatio = options.sourceWidth / options.sourceHeight;
        options.passes++;
        this._setupFrameBuffer(options);
        this.horizontal = true;
        this.applyToWebGL(options);
        this._swapTextures(options);
        this._setupFrameBuffer(options);
        this.horizontal = false;
        this.applyToWebGL(options);
        this._swapTextures(options);
      }
      else {
        this.applyTo2d(options);
      }
    },

    applyTo2d: function(options) {
      // paint canvasEl with current image data.
      //options.ctx.putImageData(options.imageData, 0, 0);
      options.imageData = this.simpleBlur(options);
    },

    simpleBlur: function(options) {
      var resources = options.filterBackend.resources, canvas1, canvas2,
          width = options.imageData.width,
          height = options.imageData.height;

      if (!resources.blurLayer1) {
        resources.blurLayer1 = fabric.util.createCanvasElement();
        resources.blurLayer2 = fabric.util.createCanvasElement();
      }
      canvas1 = resources.blurLayer1;
      canvas2 = resources.blurLayer2;
      if (canvas1.width !== width || canvas1.height !== height) {
        canvas2.width = canvas1.width = width;
        canvas2.height = canvas1.height = height;
      }
      var ctx1 = canvas1.getContext('2d'),
          ctx2 = canvas2.getContext('2d'),
          nSamples = 15,
          random, percent, j, i,
          blur = this.blur * 0.06 * 0.5;

      // load first canvas
      ctx1.putImageData(options.imageData, 0, 0);
      ctx2.clearRect(0, 0, width, height);

      for (i = -nSamples; i <= nSamples; i++) {
        random = (Math.random() - 0.5) / 4;
        percent = i / nSamples;
        j = blur * percent * width + random;
        ctx2.globalAlpha = 1 - Math.abs(percent);
        ctx2.drawImage(canvas1, j, random);
        ctx1.drawImage(canvas2, 0, 0);
        ctx2.globalAlpha = 1;
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
      }
      for (i = -nSamples; i <= nSamples; i++) {
        random = (Math.random() - 0.5) / 4;
        percent = i / nSamples;
        j = blur * percent * height + random;
        ctx2.globalAlpha = 1 - Math.abs(percent);
        ctx2.drawImage(canvas1, random, j);
        ctx1.drawImage(canvas2, 0, 0);
        ctx2.globalAlpha = 1;
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
      }
      options.ctx.drawImage(canvas1, 0, 0);
      var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);
      ctx1.globalAlpha = 1;
      ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
      return newImageData;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        delta: gl.getUniformLocation(program, 'uDelta'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var delta = this.chooseRightDelta();
      gl.uniform2fv(uniformLocations.delta, delta);
    },

    /**
     * choose right value of image percentage to blur with
     * @returns {Array} a numeric array with delta values
     */
    chooseRightDelta: function() {
      var blurScale = 1, delta = [0, 0], blur;
      if (this.horizontal) {
        if (this.aspectRatio > 1) {
          // image is wide, i want to shrink radius horizontal
          blurScale = 1 / this.aspectRatio;
        }
      }
      else {
        if (this.aspectRatio < 1) {
          // image is tall, i want to shrink radius vertical
          blurScale = this.aspectRatio;
        }
      }
      blur = blurScale * this.blur * 0.12;
      if (this.horizontal) {
        delta[0] = blur;
      }
      else {
        delta[1] = blur;
      }
      return delta;
    },
  });

  /**
   * Deserialize a JSON definition of a BlurFilter into a concrete instance.
   */
  filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Gamma filter class
   * @class fabric.Image.filters.Gamma
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Gamma({
   *   brightness: 200
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Gamma',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec3 uGamma;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'vec3 correction = (1.0 / uGamma);\n' +
        'color.r = pow(color.r, correction.r);\n' +
        'color.g = pow(color.g, correction.g);\n' +
        'color.b = pow(color.b, correction.b);\n' +
        'gl_FragColor = color;\n' +
        'gl_FragColor.rgb *= color.a;\n' +
      '}',

    /**
     * Gamma array value, from 0.01 to 2.2.
     * @param {Array} gamma
     * @default
     */
    gamma: [1, 1, 1],

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'gamma',

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.gamma = [1, 1, 1];
      filters.BaseFilter.prototype.initialize.call(this, options);
    },

    /**
     * Apply the Gamma operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData, data = imageData.data,
          gamma = this.gamma, len = data.length,
          rInv = 1 / gamma[0], gInv = 1 / gamma[1],
          bInv = 1 / gamma[2], i;

      if (!this.rVals) {
        // eslint-disable-next-line
        this.rVals = new Uint8Array(256);
        // eslint-disable-next-line
        this.gVals = new Uint8Array(256);
        // eslint-disable-next-line
        this.bVals = new Uint8Array(256);
      }

      // This is an optimization - pre-compute a look-up table for each color channel
      // instead of performing these pow calls for each pixel in the image.
      for (i = 0, len = 256; i < len; i++) {
        this.rVals[i] = Math.pow(i / 255, rInv) * 255;
        this.gVals[i] = Math.pow(i / 255, gInv) * 255;
        this.bVals[i] = Math.pow(i / 255, bInv) * 255;
      }
      for (i = 0, len = data.length; i < len; i += 4) {
        data[i] = this.rVals[data[i]];
        data[i + 1] = this.gVals[data[i + 1]];
        data[i + 2] = this.bVals[data[i + 2]];
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uGamma: gl.getUniformLocation(program, 'uGamma'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform3fv(uniformLocations.uGamma, this.gamma);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma
   */
  fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * A container class that knows how to apply a sequence of filters to an input image.
   */
  filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {

    type: 'Composed',

    /**
     * A non sparse array of filters to apply
     */
    subFilters: [],

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      // create a new array instead mutating the prototype with push
      this.subFilters = this.subFilters.slice(0);
    },

    /**
     * Apply this container's filters to the input image provided.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be applied.
     */
    applyTo: function(options) {
      options.passes += this.subFilters.length - 1;
      this.subFilters.forEach(function(filter) {
        filter.applyTo(options);
      });
    },

    /**
     * Serialize this filter into JSON.
     *
     * @returns {Object} A JSON representation of this filter.
     */
    toObject: function() {
      return fabric.util.object.extend(this.callSuper('toObject'), {
        subFilters: this.subFilters.map(function(filter) { return filter.toObject(); }),
      });
    },

    isNeutralState: function() {
      return !this.subFilters.some(function(filter) { return !filter.isNeutralState(); });
    }
  });

  /**
   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.
   */
  fabric.Image.filters.Composed.fromObject = function(object, callback) {
    var filters = object.subFilters || [],
        subFilters = filters.map(function(filter) {
          return new fabric.Image.filters[filter.type](filter);
        }),
        instance = new fabric.Image.filters.Composed({ subFilters: subFilters });
    callback && callback(instance);
    return instance;
  };
})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * HueRotation filter class
   * @class fabric.Image.filters.HueRotation
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.HueRotation({
   *   rotation: -0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'HueRotation',

    /**
     * HueRotation value, from -1 to 1.
     * the unit is radians
     * @param {Number} myParameter
     * @default
     */
    rotation: 0,

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'rotation',

    calculateMatrix: function() {
      var rad = this.rotation * Math.PI, cos = fabric.util.cos(rad), sin = fabric.util.sin(rad),
          aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;
      this.matrix = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0
      ];
      this.matrix[0] = cos + OneMinusCos / 3;
      this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[6] = cos + aThird * OneMinusCos;
      this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[12] = cos + aThird * OneMinusCos;
    },

    /**
     * HueRotation isNeutralState implementation
     * Used only in image applyFilters to discard filters that will not have an effect
     * on the image
     * @param {Object} options
     **/
    isNeutralState: function(options) {
      this.calculateMatrix();
      return filters.BaseFilter.prototype.isNeutralState.call(this, options);
    },

    /**
     * Apply this filter to the input image data provided.
     *
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyTo: function(options) {
      this.calculateMatrix();
      filters.BaseFilter.prototype.applyTo.call(this, options);
    },

  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation
   */
  fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : undefined);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      clone = fabric.util.object.clone;

  if (fabric.Text) {
    fabric.warn('fabric.Text is already defined');
    return;
  }

  /**
   * Text class
   * @class fabric.Text
   * @extends fabric.Object
   * @return {fabric.Text} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}
   * @see {@link fabric.Text#initialize} for constructor definition
   */
  fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {

    /**
     * Properties which when set cause object to change dimensions
     * @type Array
     * @private
     */
    _dimensionAffectingProps: [
      'fontSize',
      'fontWeight',
      'fontFamily',
      'fontStyle',
      'lineHeight',
      'text',
      'charSpacing',
      'textAlign',
      'styles',
    ],

    /**
     * @private
     */
    _reNewline: /\r?\n/,

    /**
     * Use this regular expression to filter for whitespaces that is not a new line.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reSpacesAndTabs: /[ \t\r]/g,

    /**
     * Use this regular expression to filter for whitespace that is not a new line.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reSpaceAndTab: /[ \t\r]/,

    /**
     * Use this regular expression to filter consecutive groups of non spaces.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reWords: /\S+/g,

    /**
     * Type of an object
     * @type String
     * @default
     */
    type:                 'text',

    /**
     * Font size (in pixels)
     * @type Number
     * @default
     */
    fontSize:             40,

    /**
     * Font weight (e.g. bold, normal, 400, 600, 800)
     * @type {(Number|String)}
     * @default
     */
    fontWeight:           'normal',

    /**
     * Font family
     * @type String
     * @default
     */
    fontFamily:           'Times New Roman',

    /**
     * Text decoration underline.
     * @type Boolean
     * @default
     */
    underline:       false,

    /**
     * Text decoration overline.
     * @type Boolean
     * @default
     */
    overline:       false,

    /**
     * Text decoration linethrough.
     * @type Boolean
     * @default
     */
    linethrough:       false,

    /**
     * Text alignment. Possible values: "left", "center", "right", "justify",
     * "justify-left", "justify-center" or "justify-right".
     * @type String
     * @default
     */
    textAlign:            'left',

    /**
     * Font style . Possible values: "", "normal", "italic" or "oblique".
     * @type String
     * @default
     */
    fontStyle:            'normal',

    /**
     * Line height
     * @type Number
     * @default
     */
    lineHeight:           1.16,

    /**
     * Superscript schema object (minimum overlap)
     * @type {Object}
     * @default
     */
    superscript: {
      size:      0.60, // fontSize factor
      baseline: -0.35  // baseline-shift factor (upwards)
    },

    /**
     * Subscript schema object (minimum overlap)
     * @type {Object}
     * @default
     */
    subscript: {
      size:      0.60, // fontSize factor
      baseline:  0.11  // baseline-shift factor (downwards)
    },

    /**
     * Background color of text lines
     * @type String
     * @default
     */
    textBackgroundColor:  '',

    /**
     * List of properties to consider when checking if
     * state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: fabric.Object.prototype.stateProperties.concat('fontFamily',
      'fontWeight',
      'fontSize',
      'text',
      'underline',
      'overline',
      'linethrough',
      'textAlign',
      'fontStyle',
      'lineHeight',
      'textBackgroundColor',
      'charSpacing',
      'styles'),

    /**
     * List of properties to consider when checking if cache needs refresh
     * @type Array
     */
    cacheProperties: fabric.Object.prototype.cacheProperties.concat('fontFamily',
      'fontWeight',
      'fontSize',
      'text',
      'underline',
      'overline',
      'linethrough',
      'textAlign',
      'fontStyle',
      'lineHeight',
      'textBackgroundColor',
      'charSpacing',
      'styles'),

    /**
     * When defined, an object is rendered via stroke and this property specifies its color.
     * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
     * @type String
     * @default
     */
    stroke:               null,

    /**
     * Shadow object representing shadow of this shape.
     * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
     * @type fabric.Shadow
     * @default
     */
    shadow:               null,

    /**
     * @private
     */
    _fontSizeFraction: 0.222,

    /**
     * @private
     */
    offsets: {
      underline: 0.10,
      linethrough: -0.315,
      overline: -0.88
    },

    /**
     * Text Line proportion to font Size (in pixels)
     * @type Number
     * @default
     */
    _fontSizeMult:             1.13,

    /**
     * additional space between characters
     * expressed in thousands of em unit
     * @type Number
     * @default
     */
    charSpacing:             0,

    /**
     * Object containing character styles - top-level properties -> line numbers,
     * 2nd-level properties - charater numbers
     * @type Object
     * @default
     */
    styles: null,

    /**
     * Reference to a context to measure text char or couple of chars
     * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas
     * once created it will be referenced on fabric._measuringContext to avoide creating a canvas for every
     * text object created.
     * @type {CanvasRenderingContext2D}
     * @default
     */
    _measuringContext: null,

    /**
     * Baseline shift, stlyes only, keep at 0 for the main text object
     * @type {Number}
     * @default
     */
    deltaY: 0,

    /**
     * Array of properties that define a style unit (of 'styles').
     * @type {Array}
     * @default
     */
    _styleProperties: [
      'stroke',
      'strokeWidth',
      'fill',
      'fontFamily',
      'fontSize',
      'fontWeight',
      'fontStyle',
      'underline',
      'overline',
      'linethrough',
      'deltaY',
      'textBackgroundColor',
    ],

    /**
     * contains characters bounding boxes
     */
    __charBounds: [],

    /**
     * use this size when measuring text. To avoid IE11 rounding errors
     * @type {Number}
     * @default
     * @readonly
     * @private
     */
    CACHE_FONT_SIZE: 400,

    /**
     * contains the min text width to avoid getting 0
     * @type {Number}
     * @default
     */
    MIN_TEXT_WIDTH: 2,

    /**
     * Constructor
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.Text} thisArg
     */
    initialize: function(text, options) {
      this.styles = options ? (options.styles || { }) : { };
      this.text = text;
      this.__skipDimension = true;
      this.callSuper('initialize', options);
      this.__skipDimension = false;
      this.initDimensions();
      this.setCoords();
      this.setupState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * Return a contex for measurement of text string.
     * if created it gets stored for reuse
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.Text} thisArg
     */
    getMeasuringContext: function() {
      // if we did not return we have to measure something.
      if (!fabric._measuringContext) {
        fabric._measuringContext = this.canvas && this.canvas.contextCache ||
          fabric.util.createCanvasElement().getContext('2d');
      }
      return fabric._measuringContext;
    },

    /**
     * @private
     * Divides text into lines of text and lines of graphemes.
     */
    _splitText: function() {
      var newLines = this._splitTextIntoLines(this.text);
      this.textLines = newLines.lines;
      this._textLines = newLines.graphemeLines;
      this._unwrappedTextLines = newLines._unwrappedLines;
      this._text = newLines.graphemeText;
      return newLines;
    },

    /**
     * Initialize or update text dimensions.
     * Updates this.width and this.height with the proper values.
     * Does not return dimensions.
     */
    initDimensions: function() {
      if (this.__skipDimension) {
        return;
      }
      this._splitText();
      this._clearCache();
      this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;
      if (this.textAlign.indexOf('justify') !== -1) {
        // once text is measured we need to make space fatter to make justified text.
        this.enlargeSpaces();
      }
      this.height = this.calcTextHeight();
      this.saveState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * Enlarge space boxes and shift the others
     */
    enlargeSpaces: function() {
      var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        if (this.textAlign !== 'justify' && (i === len - 1 || this.isEndOfWrapping(i))) {
          continue;
        }
        accumulatedSpace = 0;
        line = this._textLines[i];
        currentLineWidth = this.getLineWidth(i);
        if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {
          numberOfSpaces = spaces.length;
          diffSpace = (this.width - currentLineWidth) / numberOfSpaces;
          for (var j = 0, jlen = line.length; j <= jlen; j++) {
            charBound = this.__charBounds[i][j];
            if (this._reSpaceAndTab.test(line[j])) {
              charBound.width += diffSpace;
              charBound.kernedWidth += diffSpace;
              charBound.left += accumulatedSpace;
              accumulatedSpace += diffSpace;
            }
            else {
              charBound.left += accumulatedSpace;
            }
          }
        }
      }
    },

    /**
     * Detect if the text line is ended with an hard break
     * text and itext do not have wrapping, return false
     * @return {Boolean}
     */
    isEndOfWrapping: function(lineIndex) {
      return lineIndex === this._textLines.length - 1;
    },

    /**
     * Returns string representation of an instance
     * @return {String} String representation of text object
     */
    toString: function() {
      return '#<fabric.Text (' + this.complexity() +
        '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
    },

    /**
     * Return the dimension and the zoom level needed to create a cache canvas
     * big enough to host the object to be cached.
     * @private
     * @param {Object} dim.x width of object to be cached
     * @param {Object} dim.y height of object to be cached
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _getCacheCanvasDimensions: function() {
      var dims = this.callSuper('_getCacheCanvasDimensions');
      var fontSize = this.fontSize;
      dims.width += fontSize * dims.zoomX;
      dims.height += fontSize * dims.zoomY;
      return dims;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      this._setTextStyles(ctx);
      this._renderTextLinesBackground(ctx);
      this._renderTextDecoration(ctx, 'underline');
      this._renderText(ctx);
      this._renderTextDecoration(ctx, 'overline');
      this._renderTextDecoration(ctx, 'linethrough');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderText: function(ctx) {
      if (this.paintFirst === 'stroke') {
        this._renderTextStroke(ctx);
        this._renderTextFill(ctx);
      }
      else {
        this._renderTextFill(ctx);
        this._renderTextStroke(ctx);
      }
    },

    /**
     * Set the font parameter of the context with the object properties or with charStyle
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [charStyle] object with font style properties
     * @param {String} [charStyle.fontFamily] Font Family
     * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )
     * @param {String} [charStyle.fontWeight] Font weight
     * @param {String} [charStyle.fontStyle] Font style (italic|normal)
     */
    _setTextStyles: function(ctx, charStyle, forMeasuring) {
      ctx.textBaseline = 'alphabetic';
      ctx.font = this._getFontDeclaration(charStyle, forMeasuring);
    },

    /**
     * calculate and return the text Width measuring each line.
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @return {Number} Maximum width of fabric.Text object
     */
    calcTextWidth: function() {
      var maxWidth = this.getLineWidth(0);

      for (var i = 1, len = this._textLines.length; i < len; i++) {
        var currentLineWidth = this.getLineWidth(i);
        if (currentLineWidth > maxWidth) {
          maxWidth = currentLineWidth;
        }
      }
      return maxWidth;
    },

    /**
     * @private
     * @param {String} method Method name ("fillText" or "strokeText")
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {String} line Text to render
     * @param {Number} left Left position of text
     * @param {Number} top Top position of text
     * @param {Number} lineIndex Index of a line in a text
     */
    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
      this._renderChars(method, ctx, line, left, top, lineIndex);
    },

    /**
     * Renders the text background for lines, taking care of style
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextLinesBackground: function(ctx) {
      if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor')) {
        return;
      }
      var lineTopOffset = 0, heightOfLine,
          lineLeftOffset, originalFill = ctx.fillStyle,
          line, lastColor,
          leftOffset = this._getLeftOffset(),
          topOffset = this._getTopOffset(),
          boxStart = 0, boxWidth = 0, charBox, currentColor;

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        heightOfLine = this.getHeightOfLine(i);
        if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor', i)) {
          lineTopOffset += heightOfLine;
          continue;
        }
        line = this._textLines[i];
        lineLeftOffset = this._getLineLeftOffset(i);
        boxWidth = 0;
        boxStart = 0;
        lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
          if (currentColor !== lastColor) {
            ctx.fillStyle = lastColor;
            lastColor && ctx.fillRect(
              leftOffset + lineLeftOffset + boxStart,
              topOffset + lineTopOffset,
              boxWidth,
              heightOfLine / this.lineHeight
            );
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastColor = currentColor;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        if (currentColor) {
          ctx.fillStyle = currentColor;
          ctx.fillRect(
            leftOffset + lineLeftOffset + boxStart,
            topOffset + lineTopOffset,
            boxWidth,
            heightOfLine / this.lineHeight
          );
        }
        lineTopOffset += heightOfLine;
      }
      ctx.fillStyle = originalFill;
      // if there is text background color no
      // other shadows should be casted
      this._removeShadow(ctx);
    },

    /**
     * @private
     * @param {Object} decl style declaration for cache
     * @param {String} decl.fontFamily fontFamily
     * @param {String} decl.fontStyle fontStyle
     * @param {String} decl.fontWeight fontWeight
     * @return {Object} reference to cache
     */
    getFontCache: function(decl) {
      var fontFamily = decl.fontFamily.toLowerCase();
      if (!fabric.charWidthsCache[fontFamily]) {
        fabric.charWidthsCache[fontFamily] = { };
      }
      var cache = fabric.charWidthsCache[fontFamily],
          cacheProp = decl.fontStyle.toLowerCase() + '_' + (decl.fontWeight + '').toLowerCase();
      if (!cache[cacheProp]) {
        cache[cacheProp] = { };
      }
      return cache[cacheProp];
    },

    /**
     * apply all the character style to canvas for rendering
     * @private
     * @param {String} _char
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {Object} [decl]
     */
    _applyCharStyles: function(method, ctx, lineIndex, charIndex, styleDeclaration) {

      this._setFillStyles(ctx, styleDeclaration);
      this._setStrokeStyles(ctx, styleDeclaration);

      ctx.font = this._getFontDeclaration(styleDeclaration);
    },

    /**
     * measure and return the width of a single character.
     * possibly overridden to accommodate different measure logic or
     * to hook some external lib for character measurement
     * @private
     * @param {String} char to be measured
     * @param {Object} charStyle style of char to be measured
     * @param {String} [previousChar] previous char
     * @param {Object} [prevCharStyle] style of previous char
     */
    _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {
      // first i try to return from cache
      var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle),
          previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char,
          stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth,
          fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;

      if (previousChar && fontCache[previousChar] !== undefined) {
        previousWidth = fontCache[previousChar];
      }
      if (fontCache[_char] !== undefined) {
        kernedWidth = width = fontCache[_char];
      }
      if (stylesAreEqual && fontCache[couple] !== undefined) {
        coupleWidth = fontCache[couple];
        kernedWidth = coupleWidth - previousWidth;
      }
      if (width === undefined || previousWidth === undefined || coupleWidth === undefined) {
        var ctx = this.getMeasuringContext();
        // send a TRUE to specify measuring font size CACHE_FONT_SIZE
        this._setTextStyles(ctx, charStyle, true);
      }
      if (width === undefined) {
        kernedWidth = width = ctx.measureText(_char).width;
        fontCache[_char] = width;
      }
      if (previousWidth === undefined && stylesAreEqual && previousChar) {
        previousWidth = ctx.measureText(previousChar).width;
        fontCache[previousChar] = previousWidth;
      }
      if (stylesAreEqual && coupleWidth === undefined) {
        // we can measure the kerning couple and subtract the width of the previous character
        coupleWidth = ctx.measureText(couple).width;
        fontCache[couple] = coupleWidth;
        kernedWidth = coupleWidth - previousWidth;
      }
      return { width: width * fontMultiplier, kernedWidth: kernedWidth * fontMultiplier };
    },

    /**
     * Computes height of character at given position
     * @param {Number} line the line number
     * @param {Number} char the character number
     * @return {Number} fontSize of the character
     */
    getHeightOfChar: function(line, char) {
      return this.getValueOfPropertyAt(line, char, 'fontSize');
    },

    /**
     * measure a text line measuring all characters.
     * @param {Number} lineIndex line number
     * @return {Number} Line width
     */
    measureLine: function(lineIndex) {
      var lineInfo = this._measureLine(lineIndex);
      if (this.charSpacing !== 0) {
        lineInfo.width -= this._getWidthOfCharSpacing();
      }
      if (lineInfo.width < 0) {
        lineInfo.width = 0;
      }
      return lineInfo;
    },

    /**
     * measure every grapheme of a line, populating __charBounds
     * @param {Number} lineIndex
     * @return {Object} object.width total width of characters
     * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs
     */
    _measureLine: function(lineIndex) {
      var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme,
          graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length);

      this.__charBounds[lineIndex] = lineBounds;
      for (i = 0; i < line.length; i++) {
        grapheme = line[i];
        graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);
        lineBounds[i] = graphemeInfo;
        width += graphemeInfo.kernedWidth;
        prevGrapheme = grapheme;
      }
      // this latest bound box represent the last character of the line
      // to simplify cursor handling in interactive mode.
      lineBounds[i] = {
        left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,
        width: 0,
        kernedWidth: 0,
        height: this.fontSize
      };
      return { width: width, numOfSpaces: numOfSpaces };
    },

    /**
     * Measure and return the info of a single grapheme.
     * needs the the info of previous graphemes already filled
     * @private
     * @param {String} grapheme to be measured
     * @param {Number} lineIndex index of the line where the char is
     * @param {Number} charIndex position in the line
     * @param {String} [prevGrapheme] character preceding the one to be measured
     */
    _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {
      var style = this.getCompleteStyleDeclaration(lineIndex, charIndex),
          prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : { },
          info = this._measureChar(grapheme, style, prevGrapheme, prevStyle),
          kernedWidth = info.kernedWidth,
          width = info.width, charSpacing;

      if (this.charSpacing !== 0) {
        charSpacing = this._getWidthOfCharSpacing();
        width += charSpacing;
        kernedWidth += charSpacing;
      }

      var box = {
        width: width,
        left: 0,
        height: style.fontSize,
        kernedWidth: kernedWidth,
        deltaY: style.deltaY,
      };
      if (charIndex > 0 && !skipLeft) {
        var previousBox = this.__charBounds[lineIndex][charIndex - 1];
        box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;
      }
      return box;
    },

    /**
     * Calculate height of line at 'lineIndex'
     * @param {Number} lineIndex index of line to calculate
     * @return {Number}
     */
    getHeightOfLine: function(lineIndex) {
      if (this.__lineHeights[lineIndex]) {
        return this.__lineHeights[lineIndex];
      }

      var line = this._textLines[lineIndex],
          // char 0 is measured before the line cycle because it nneds to char
          // emptylines
          maxHeight = this.getHeightOfChar(lineIndex, 0);
      for (var i = 1, len = line.length; i < len; i++) {
        maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);
      }

      return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
    },

    /**
     * Calculate text box height
     */
    calcTextHeight: function() {
      var lineHeight, height = 0;
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        lineHeight = this.getHeightOfLine(i);
        height += (i === len - 1 ? lineHeight / this.lineHeight : lineHeight);
      }
      return height;
    },

    /**
     * @private
     * @return {Number} Left offset
     */
    _getLeftOffset: function() {
      return -this.width / 2;
    },

    /**
     * @private
     * @return {Number} Top offset
     */
    _getTopOffset: function() {
      return -this.height / 2;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {String} method Method name ("fillText" or "strokeText")
     */
    _renderTextCommon: function(ctx, method) {
      ctx.save();
      var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset(),
          offsets = this._applyPatternGradientTransform(ctx, method === 'fillText' ? this.fill : this.stroke);
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        var heightOfLine = this.getHeightOfLine(i),
            maxHeight = heightOfLine / this.lineHeight,
            leftOffset = this._getLineLeftOffset(i);
        this._renderTextLine(
          method,
          ctx,
          this._textLines[i],
          left + leftOffset - offsets.offsetX,
          top + lineHeights + maxHeight - offsets.offsetY,
          i
        );
        lineHeights += heightOfLine;
      }
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextFill: function(ctx) {
      if (!this.fill && !this.styleHas('fill')) {
        return;
      }

      this._renderTextCommon(ctx, 'fillText');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextStroke: function(ctx) {
      if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {
        return;
      }

      if (this.shadow && !this.shadow.affectStroke) {
        this._removeShadow(ctx);
      }

      ctx.save();
      this._setLineDash(ctx, this.strokeDashArray);
      ctx.beginPath();
      this._renderTextCommon(ctx, 'strokeText');
      ctx.closePath();
      ctx.restore();
    },

    /**
     * @private
     * @param {String} method
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {String} line Content of the line
     * @param {Number} left
     * @param {Number} top
     * @param {Number} lineIndex
     * @param {Number} charOffset
     */
    _renderChars: function(method, ctx, line, left, top, lineIndex) {
      // set proper line offset
      var lineHeight = this.getHeightOfLine(lineIndex),
          isJustify = this.textAlign.indexOf('justify') !== -1,
          actualStyle,
          nextStyle,
          charsToRender = '',
          charBox,
          boxWidth = 0,
          timeToRender,
          shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex);

      ctx.save();
      top -= lineHeight * this._fontSizeFraction / this.lineHeight;
      if (shortCut) {
        // render all the line in one pass without checking
        this._renderChar(method, ctx, lineIndex, 0, this.textLines[lineIndex], left, top, lineHeight);
        ctx.restore();
        return;
      }
      for (var i = 0, len = line.length - 1; i <= len; i++) {
        timeToRender = i === len || this.charSpacing;
        charsToRender += line[i];
        charBox = this.__charBounds[lineIndex][i];
        if (boxWidth === 0) {
          left += charBox.kernedWidth - charBox.width;
          boxWidth += charBox.width;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
        if (isJustify && !timeToRender) {
          if (this._reSpaceAndTab.test(line[i])) {
            timeToRender = true;
          }
        }
        if (!timeToRender) {
          // if we have charSpacing, we render char by char
          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
          timeToRender = this._hasStyleChanged(actualStyle, nextStyle);
        }
        if (timeToRender) {
          this._renderChar(method, ctx, lineIndex, i, charsToRender, left, top, lineHeight);
          charsToRender = '';
          actualStyle = nextStyle;
          left += boxWidth;
          boxWidth = 0;
        }
      }
      ctx.restore();
    },

    /**
     * @private
     * @param {String} method
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {String} _char
     * @param {Number} left Left coordinate
     * @param {Number} top Top coordinate
     * @param {Number} lineHeight Height of the line
     */
    _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {
      var decl = this._getStyleDeclaration(lineIndex, charIndex),
          fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex),
          shouldFill = method === 'fillText' && fullDecl.fill,
          shouldStroke = method === 'strokeText' && fullDecl.stroke && fullDecl.strokeWidth;

      if (!shouldStroke && !shouldFill) {
        return;
      }
      decl && ctx.save();

      this._applyCharStyles(method, ctx, lineIndex, charIndex, fullDecl);

      if (decl && decl.textBackgroundColor) {
        this._removeShadow(ctx);
      }
      if (decl && decl.deltaY) {
        top += decl.deltaY;
      }

      shouldFill && ctx.fillText(_char, left, top);
      shouldStroke && ctx.strokeText(_char, left, top);
      decl && ctx.restore();
    },

    /**
     * Turns the character into a 'superior figure' (i.e. 'superscript')
     * @param {Number} start selection start
     * @param {Number} end selection end
     * @returns {fabric.Text} thisArg
     * @chainable
     */
    setSuperscript: function(start, end) {
      return this._setScript(start, end, this.superscript);
    },

    /**
     * Turns the character into an 'inferior figure' (i.e. 'subscript')
     * @param {Number} start selection start
     * @param {Number} end selection end
     * @returns {fabric.Text} thisArg
     * @chainable
     */
    setSubscript: function(start, end) {
      return this._setScript(start, end, this.subscript);
    },

    /**
     * Applies 'schema' at given position
     * @private
     * @param {Number} start selection start
     * @param {Number} end selection end
     * @param {Number} schema
     * @returns {fabric.Text} thisArg
     * @chainable
     */
    _setScript: function(start, end, schema) {
      var loc = this.get2DCursorLocation(start, true),
          fontSize = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'fontSize'),
          dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'deltaY'),
          style = { fontSize: fontSize * schema.size, deltaY: dy + fontSize * schema.baseline };
      this.setSelectionStyles(style, start, end);
      return this;
    },

    /**
     * @private
     * @param {Object} prevStyle
     * @param {Object} thisStyle
     */
    _hasStyleChanged: function(prevStyle, thisStyle) {
      return prevStyle.fill !== thisStyle.fill ||
              prevStyle.stroke !== thisStyle.stroke ||
              prevStyle.strokeWidth !== thisStyle.strokeWidth ||
              prevStyle.fontSize !== thisStyle.fontSize ||
              prevStyle.fontFamily !== thisStyle.fontFamily ||
              prevStyle.fontWeight !== thisStyle.fontWeight ||
              prevStyle.fontStyle !== thisStyle.fontStyle ||
              prevStyle.deltaY !== thisStyle.deltaY;
    },

    /**
     * @private
     * @param {Object} prevStyle
     * @param {Object} thisStyle
     */
    _hasStyleChangedForSvg: function(prevStyle, thisStyle) {
      return this._hasStyleChanged(prevStyle, thisStyle) ||
        prevStyle.overline !== thisStyle.overline ||
        prevStyle.underline !== thisStyle.underline ||
        prevStyle.linethrough !== thisStyle.linethrough;
    },

    /**
     * @private
     * @param {Number} lineIndex index text line
     * @return {Number} Line left offset
     */
    _getLineLeftOffset: function(lineIndex) {
      var lineWidth = this.getLineWidth(lineIndex);
      if (this.textAlign === 'center') {
        return (this.width - lineWidth) / 2;
      }
      if (this.textAlign === 'right') {
        return this.width - lineWidth;
      }
      if (this.textAlign === 'justify-center' && this.isEndOfWrapping(lineIndex)) {
        return (this.width - lineWidth) / 2;
      }
      if (this.textAlign === 'justify-right' && this.isEndOfWrapping(lineIndex)) {
        return this.width - lineWidth;
      }
      return 0;
    },

    /**
     * @private
     */
    _clearCache: function() {
      this.__lineWidths = [];
      this.__lineHeights = [];
      this.__charBounds = [];
    },

    /**
     * @private
     */
    _shouldClearDimensionCache: function() {
      var shouldClear = this._forceClearCache;
      shouldClear || (shouldClear = this.hasStateChanged('_dimensionAffectingProps'));
      if (shouldClear) {
        this.dirty = true;
        this._forceClearCache = false;
      }
      return shouldClear;
    },

    /**
     * Measure a single line given its index. Used to calculate the initial
     * text bounding box. The values are calculated and stored in __lineWidths cache.
     * @private
     * @param {Number} lineIndex line number
     * @return {Number} Line width
     */
    getLineWidth: function(lineIndex) {
      if (this.__lineWidths[lineIndex]) {
        return this.__lineWidths[lineIndex];
      }

      var width, line = this._textLines[lineIndex], lineInfo;

      if (line === '') {
        width = 0;
      }
      else {
        lineInfo = this.measureLine(lineIndex);
        width = lineInfo.width;
      }
      this.__lineWidths[lineIndex] = width;
      return width;
    },

    _getWidthOfCharSpacing: function() {
      if (this.charSpacing !== 0) {
        return this.fontSize * this.charSpacing / 1000;
      }
      return 0;
    },

    /**
     * Retrieves the value of property at given character position
     * @param {Number} lineIndex the line number
     * @param {Number} charIndex the charater number
     * @param {String} property the property name
     * @returns the value of 'property'
     */
    getValueOfPropertyAt: function(lineIndex, charIndex, property) {
      var charStyle = this._getStyleDeclaration(lineIndex, charIndex);
      if (charStyle && typeof charStyle[property] !== 'undefined') {
        return charStyle[property];
      }
      return this[property];
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextDecoration: function(ctx, type) {
      if (!this[type] && !this.styleHas(type)) {
        return;
      }
      var heightOfLine, size, _size,
          lineLeftOffset, dy, _dy,
          line, lastDecoration,
          leftOffset = this._getLeftOffset(),
          topOffset = this._getTopOffset(), top,
          boxStart, boxWidth, charBox, currentDecoration,
          maxHeight, currentFill, lastFill,
          charSpacing = this._getWidthOfCharSpacing();

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        heightOfLine = this.getHeightOfLine(i);
        if (!this[type] && !this.styleHas(type, i)) {
          topOffset += heightOfLine;
          continue;
        }
        line = this._textLines[i];
        maxHeight = heightOfLine / this.lineHeight;
        lineLeftOffset = this._getLineLeftOffset(i);
        boxStart = 0;
        boxWidth = 0;
        lastDecoration = this.getValueOfPropertyAt(i, 0, type);
        lastFill = this.getValueOfPropertyAt(i, 0, 'fill');
        top = topOffset + maxHeight * (1 - this._fontSizeFraction);
        size = this.getHeightOfChar(i, 0);
        dy = this.getValueOfPropertyAt(i, 0, 'deltaY');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentDecoration = this.getValueOfPropertyAt(i, j, type);
          currentFill = this.getValueOfPropertyAt(i, j, 'fill');
          _size = this.getHeightOfChar(i, j);
          _dy = this.getValueOfPropertyAt(i, j, 'deltaY');
          if ((currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy) &&
              boxWidth > 0) {
            ctx.fillStyle = lastFill;
            lastDecoration && lastFill && ctx.fillRect(
              leftOffset + lineLeftOffset + boxStart,
              top + this.offsets[type] * size + dy,
              boxWidth,
              this.fontSize / 15
            );
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastDecoration = currentDecoration;
            lastFill = currentFill;
            size = _size;
            dy = _dy;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        ctx.fillStyle = currentFill;
        currentDecoration && currentFill && ctx.fillRect(
          leftOffset + lineLeftOffset + boxStart,
          top + this.offsets[type] * size + dy,
          boxWidth - charSpacing,
          this.fontSize / 15
        );
        topOffset += heightOfLine;
      }
      // if there is text background color no
      // other shadows should be casted
      this._removeShadow(ctx);
    },

    /**
     * return font declaration string for canvas context
     * @param {Object} [styleObject] object
     * @returns {String} font declaration formatted for canvas context.
     */
    _getFontDeclaration: function(styleObject, forMeasuring) {
      var style = styleObject || this, family = this.fontFamily,
          fontIsGeneric = fabric.Text.genericFonts.indexOf(family.toLowerCase()) > -1;
      var fontFamily = family === undefined ||
      family.indexOf('\'') > -1 ||
      family.indexOf('"') > -1 || fontIsGeneric
        ? style.fontFamily : '"' + style.fontFamily + '"';
      return [
        // node-canvas needs "weight style", while browsers need "style weight"
        (fabric.isLikelyNode ? style.fontWeight : style.fontStyle),
        (fabric.isLikelyNode ? style.fontStyle : style.fontWeight),
        forMeasuring ? this.CACHE_FONT_SIZE + 'px' : style.fontSize + 'px',
        fontFamily
      ].join(' ');
    },

    /**
     * Renders text instance on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      // do not render if object is not visible
      if (!this.visible) {
        return;
      }
      if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
        return;
      }
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
      }
      this.callSuper('render', ctx);
    },

    /**
     * Returns the text as an array of lines.
     * @param {String} text text to split
     * @returns {Array} Lines in the text
     */
    _splitTextIntoLines: function(text) {
      var lines = text.split(this._reNewline),
          newLines = new Array(lines.length),
          newLine = ['\n'],
          newText = [];
      for (var i = 0; i < lines.length; i++) {
        newLines[i] = fabric.util.string.graphemeSplit(lines[i]);
        newText = newText.concat(newLines[i], newLine);
      }
      newText.pop();
      return { _unwrappedLines: newLines, lines: lines, graphemeText: newText, graphemeLines: newLines };
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var additionalProperties = [
        'text',
        'fontSize',
        'fontWeight',
        'fontFamily',
        'fontStyle',
        'lineHeight',
        'underline',
        'overline',
        'linethrough',
        'textAlign',
        'textBackgroundColor',
        'charSpacing',
      ].concat(propertiesToInclude);
      var obj = this.callSuper('toObject', additionalProperties);
      obj.styles = clone(this.styles, true);
      return obj;
    },

    /**
     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
     * @param {String|Object} key Property name or object (if object, iterate over the object properties)
     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    set: function(key, value) {
      this.callSuper('set', key, value);
      var needsDims = false;
      if (typeof key === 'object') {
        for (var _key in key) {
          needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;
        }
      }
      else {
        needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;
      }
      if (needsDims) {
        this.initDimensions();
        this.setCoords();
      }
      return this;
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity
     */
    complexity: function() {
      return 1;
    }
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})
   * @static
   * @memberOf fabric.Text
   * @see: http://www.w3.org/TR/SVG/text.html#TextElement
   */
  fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(
    'x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor'.split(' '));

  /**
   * Default SVG font size
   * @static
   * @memberOf fabric.Text
   */
  fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;

  /**
   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
   * @static
   * @memberOf fabric.Text
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Text.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }

    var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES),
        parsedAnchor = parsedAttributes.textAnchor || 'left';
    options = fabric.util.object.extend((options ? clone(options) : { }), parsedAttributes);

    options.top = options.top || 0;
    options.left = options.left || 0;
    if (parsedAttributes.textDecoration) {
      var textDecoration = parsedAttributes.textDecoration;
      if (textDecoration.indexOf('underline') !== -1) {
        options.underline = true;
      }
      if (textDecoration.indexOf('overline') !== -1) {
        options.overline = true;
      }
      if (textDecoration.indexOf('line-through') !== -1) {
        options.linethrough = true;
      }
      delete options.textDecoration;
    }
    if ('dx' in parsedAttributes) {
      options.left += parsedAttributes.dx;
    }
    if ('dy' in parsedAttributes) {
      options.top += parsedAttributes.dy;
    }
    if (!('fontSize' in options)) {
      options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
    }

    var textContent = '';

    // The XML is not properly parsed in IE9 so a workaround to get
    // textContent is through firstChild.data. Another workaround would be
    // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)
    if (!('textContent' in element)) {
      if ('firstChild' in element && element.firstChild !== null) {
        if ('data' in element.firstChild && element.firstChild.data !== null) {
          textContent = element.firstChild.data;
        }
      }
    }
    else {
      textContent = element.textContent;
    }

    textContent = textContent.replace(/^\s+|\s+$|\n+/g, '').replace(/\s+/g, ' ');
    var originalStrokeWidth = options.strokeWidth;
    options.strokeWidth = 0;

    var text = new fabric.Text(textContent, options),
        textHeightScaleFactor = text.getScaledHeight() / text.height,
        lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height,
        scaledDiff = lineHeightDiff * textHeightScaleFactor,
        textHeight = text.getScaledHeight() + scaledDiff,
        offX = 0;
    /*
      Adjust positioning:
        x/y attributes in SVG correspond to the bottom-left corner of text bounding box
        fabric output by default at top, left.
    */
    if (parsedAnchor === 'center') {
      offX = text.getScaledWidth() / 2;
    }
    if (parsedAnchor === 'right') {
      offX = text.getScaledWidth();
    }
    text.set({
      left: text.left - offX,
      top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,
      strokeWidth: typeof originalStrokeWidth !== 'undefined' ? originalStrokeWidth : 1,
    });
    callback(text);
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Text instance from an object representation
   * @static
   * @memberOf fabric.Text
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created
   */
  fabric.Text.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Text', object, callback, 'text');
  };

  fabric.Text.genericFonts = ['sans-serif', 'serif', 'cursive', 'fantasy', 'monospace'];

  fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);

})( true ? exports : undefined);


(function() {
  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {
    /**
     * Returns true if object has no styling or no styling in a line
     * @param {Number} lineIndex , lineIndex is on wrapped lines.
     * @return {Boolean}
     */
    isEmptyStyles: function(lineIndex) {
      if (!this.styles) {
        return true;
      }
      if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
        return true;
      }
      var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
      for (var p1 in obj) {
        for (var p2 in obj[p1]) {
          // eslint-disable-next-line no-unused-vars
          for (var p3 in obj[p1][p2]) {
            return false;
          }
        }
      }
      return true;
    },

    /**
     * Returns true if object has a style property or has it ina specified line
     * @param {Number} lineIndex
     * @return {Boolean}
     */
    styleHas: function(property, lineIndex) {
      if (!this.styles || !property || property === '') {
        return false;
      }
      if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
        return false;
      }
      var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
      // eslint-disable-next-line
      for (var p1 in obj) {
        // eslint-disable-next-line
        for (var p2 in obj[p1]) {
          if (typeof obj[p1][p2][property] !== 'undefined') {
            return true;
          }
        }
      }
      return false;
    },

    /**
     * Check if characters in a text have a value for a property
     * whose value matches the textbox's value for that property.  If so,
     * the character-level property is deleted.  If the character
     * has no other properties, then it is also deleted.  Finally,
     * if the line containing that character has no other characters
     * then it also is deleted.
     *
     * @param {string} property The property to compare between characters and text.
     */
    cleanStyle: function(property) {
      if (!this.styles || !property || property === '') {
        return false;
      }
      var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue,
          allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;
      // eslint-disable-next-line
      for (var p1 in obj) {
        letterCount = 0;
        // eslint-disable-next-line
        for (var p2 in obj[p1]) {
          var styleObject = obj[p1][p2],
              stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);

          stylesCount++;

          if (stylePropertyHasBeenSet) {
            if (!stylePropertyValue) {
              stylePropertyValue = styleObject[property];
            }
            else if (styleObject[property] !== stylePropertyValue) {
              allStyleObjectPropertiesMatch = false;
            }

            if (styleObject[property] === this[property]) {
              delete styleObject[property];
            }
          }
          else {
            allStyleObjectPropertiesMatch = false;
          }

          if (Object.keys(styleObject).length !== 0) {
            letterCount++;
          }
          else {
            delete obj[p1][p2];
          }
        }

        if (letterCount === 0) {
          delete obj[p1];
        }
      }
      // if every grapheme has the same style set then
      // delete those styles and set it on the parent
      for (var i = 0; i < this._textLines.length; i++) {
        graphemeCount += this._textLines[i].length;
      }
      if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {
        this[property] = stylePropertyValue;
        this.removeStyle(property);
      }
    },

    /**
     * Remove a style property or properties from all individual character styles
     * in a text object.  Deletes the character style object if it contains no other style
     * props.  Deletes a line style object if it contains no other character styles.
     *
     * @param {String} props The property to remove from character styles.
     */
    removeStyle: function(property) {
      if (!this.styles || !property || property === '') {
        return;
      }
      var obj = this.styles, line, lineNum, charNum;
      for (lineNum in obj) {
        line = obj[lineNum];
        for (charNum in line) {
          delete line[charNum][property];
          if (Object.keys(line[charNum]).length === 0) {
            delete line[charNum];
          }
        }
        if (Object.keys(line).length === 0) {
          delete obj[lineNum];
        }
      }
    },

    /**
     * @private
     */
    _extendStyles: function(index, styles) {
      var loc = this.get2DCursorLocation(index);

      if (!this._getLineStyle(loc.lineIndex)) {
        this._setLineStyle(loc.lineIndex, {});
      }

      if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
        this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
      }

      fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
    },

    /**
     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
     * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. usefull to manage styles.
     */
    get2DCursorLocation: function(selectionStart, skipWrapping) {
      if (typeof selectionStart === 'undefined') {
        selectionStart = this.selectionStart;
      }
      var lines = skipWrapping ? this._unwrappedTextLines : this._textLines;
      var len = lines.length;
      for (var i = 0; i < len; i++) {
        if (selectionStart <= lines[i].length) {
          return {
            lineIndex: i,
            charIndex: selectionStart
          };
        }
        selectionStart -= lines[i].length + 1;
      }
      return {
        lineIndex: i - 1,
        charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart
      };
    },

    /**
     * Gets style of a current selection/cursor (at the start position)
     * if startIndex or endIndex are not provided, slectionStart or selectionEnd will be used.
     * @param {Number} [startIndex] Start index to get styles at
     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
     * @param {Boolean} [complete] get full style or not
     * @return {Array} styles an array with one, zero or more Style objects
     */
    getSelectionStyles: function(startIndex, endIndex, complete) {
      if (typeof startIndex === 'undefined') {
        startIndex = this.selectionStart || 0;
      }
      if (typeof endIndex === 'undefined') {
        endIndex = this.selectionEnd || startIndex;
      }
      var styles = [];
      for (var i = startIndex; i < endIndex; i++) {
        styles.push(this.getStyleAtPosition(i, complete));
      }
      return styles;
    },

    /**
     * Gets style of a current selection/cursor position
     * @param {Number} position  to get styles at
     * @param {Boolean} [complete] full style if true
     * @return {Object} style Style object at a specified index
     * @private
     */
    getStyleAtPosition: function(position, complete) {
      var loc = this.get2DCursorLocation(position),
          style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) :
            this._getStyleDeclaration(loc.lineIndex, loc.charIndex);
      return style || {};
    },

    /**
     * Sets style of a current selection, if no selection exist, do not set anything.
     * @param {Object} [styles] Styles object
     * @param {Number} [startIndex] Start index to get styles at
     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
     * @return {fabric.IText} thisArg
     * @chainable
     */
    setSelectionStyles: function(styles, startIndex, endIndex) {
      if (typeof startIndex === 'undefined') {
        startIndex = this.selectionStart || 0;
      }
      if (typeof endIndex === 'undefined') {
        endIndex = this.selectionEnd || startIndex;
      }
      for (var i = startIndex; i < endIndex; i++) {
        this._extendStyles(i, styles);
      }
      /* not included in _extendStyles to avoid clearing cache more than once */
      this._forceClearCache = true;
      return this;
    },

    /**
     * get the reference, not a clone, of the style object for a given character
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @return {Object} style object
     */
    _getStyleDeclaration: function(lineIndex, charIndex) {
      var lineStyle = this.styles && this.styles[lineIndex];
      if (!lineStyle) {
        return null;
      }
      return lineStyle[charIndex];
    },

    /**
     * return a new object that contains all the style property for a character
     * the object returned is newly created
     * @param {Number} lineIndex of the line where the character is
     * @param {Number} charIndex position of the character on the line
     * @return {Object} style object
     */
    getCompleteStyleDeclaration: function(lineIndex, charIndex) {
      var style = this._getStyleDeclaration(lineIndex, charIndex) || { },
          styleObject = { }, prop;
      for (var i = 0; i < this._styleProperties.length; i++) {
        prop = this._styleProperties[i];
        styleObject[prop] = typeof style[prop] === 'undefined' ? this[prop] : style[prop];
      }
      return styleObject;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {Object} style
     * @private
     */
    _setStyleDeclaration: function(lineIndex, charIndex, style) {
      this.styles[lineIndex][charIndex] = style;
    },

    /**
     *
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _deleteStyleDeclaration: function(lineIndex, charIndex) {
      delete this.styles[lineIndex][charIndex];
    },

    /**
     * @param {Number} lineIndex
     * @private
     */
    _getLineStyle: function(lineIndex) {
      return this.styles[lineIndex];
    },

    /**
     * @param {Number} lineIndex
     * @param {Object} style
     * @private
     */
    _setLineStyle: function(lineIndex, style) {
      this.styles[lineIndex] = style;
    },

    /**
     * @param {Number} lineIndex
     * @private
     */
    _deleteLineStyle: function(lineIndex) {
      delete this.styles[lineIndex];
    }
  });
})();


(function() {

  function parseDecoration(object) {
    if (object.textDecoration) {
      object.textDecoration.indexOf('underline') > -1 && (object.underline = true);
      object.textDecoration.indexOf('line-through') > -1 && (object.linethrough = true);
      object.textDecoration.indexOf('overline') > -1 && (object.overline = true);
      delete object.textDecoration;
    }
  }

  /**
   * IText class (introduced in <b>v1.4</b>) Events are also fired with "text:"
   * prefix when observing canvas.
   * @class fabric.IText
   * @extends fabric.Text
   * @mixes fabric.Observable
   *
   * @fires changed
   * @fires selection:changed
   * @fires editing:entered
   * @fires editing:exited
   *
   * @return {fabric.IText} thisArg
   * @see {@link fabric.IText#initialize} for constructor definition
   *
   * <p>Supported key combinations:</p>
   * <pre>
   *   Move cursor:                    left, right, up, down
   *   Select character:               shift + left, shift + right
   *   Select text vertically:         shift + up, shift + down
   *   Move cursor by word:            alt + left, alt + right
   *   Select words:                   shift + alt + left, shift + alt + right
   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end
   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end
   *   Jump to start/end of text:      cmd + up, cmd + down
   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown
   *   Delete character:               backspace
   *   Delete word:                    alt + backspace
   *   Delete line:                    cmd + backspace
   *   Forward delete:                 delete
   *   Copy text:                      ctrl/cmd + c
   *   Paste text:                     ctrl/cmd + v
   *   Cut text:                       ctrl/cmd + x
   *   Select entire text:             ctrl/cmd + a
   *   Quit editing                    tab or esc
   * </pre>
   *
   * <p>Supported mouse/touch combination</p>
   * <pre>
   *   Position cursor:                click/touch
   *   Create selection:               click/touch & drag
   *   Create selection:               click & shift + click
   *   Select word:                    double click
   *   Select line:                    triple click
   * </pre>
   */
  fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'i-text',

    /**
     * Index where text selection starts (or where cursor is when there is no selection)
     * @type Number
     * @default
     */
    selectionStart: 0,

    /**
     * Index where text selection ends
     * @type Number
     * @default
     */
    selectionEnd: 0,

    /**
     * Color of text selection
     * @type String
     * @default
     */
    selectionColor: 'rgba(17,119,255,0.3)',

    /**
     * Indicates whether text is in editing mode
     * @type Boolean
     * @default
     */
    isEditing: false,

    /**
     * Indicates whether a text can be edited
     * @type Boolean
     * @default
     */
    editable: true,

    /**
     * Border color of text object while it's in editing mode
     * @type String
     * @default
     */
    editingBorderColor: 'rgba(102,153,255,0.25)',

    /**
     * Width of cursor (in px)
     * @type Number
     * @default
     */
    cursorWidth: 2,

    /**
     * Color of default cursor (when not overwritten by character style)
     * @type String
     * @default
     */
    cursorColor: '#333',

    /**
     * Delay between cursor blink (in ms)
     * @type Number
     * @default
     */
    cursorDelay: 1000,

    /**
     * Duration of cursor fadein (in ms)
     * @type Number
     * @default
     */
    cursorDuration: 600,

    /**
     * Indicates whether internal text char widths can be cached
     * @type Boolean
     * @default
     */
    caching: true,

    /**
     * @private
     */
    _reSpace: /\s|\n/,

    /**
     * @private
     */
    _currentCursorOpacity: 0,

    /**
     * @private
     */
    _selectionDirection: null,

    /**
     * @private
     */
    _abortCursorAnimation: false,

    /**
     * @private
     */
    __widthOfSpace: [],

    /**
     * Helps determining when the text is in composition, so that the cursor
     * rendering is altered.
     */
    inCompositionMode: false,

    /**
     * Constructor
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.IText} thisArg
     */
    initialize: function(text, options) {
      this.callSuper('initialize', text, options);
      this.initBehavior();
    },

    /**
     * Sets selection start (left boundary of a selection)
     * @param {Number} index Index to set selection start to
     */
    setSelectionStart: function(index) {
      index = Math.max(index, 0);
      this._updateAndFire('selectionStart', index);
    },

    /**
     * Sets selection end (right boundary of a selection)
     * @param {Number} index Index to set selection end to
     */
    setSelectionEnd: function(index) {
      index = Math.min(index, this.text.length);
      this._updateAndFire('selectionEnd', index);
    },

    /**
     * @private
     * @param {String} property 'selectionStart' or 'selectionEnd'
     * @param {Number} index new position of property
     */
    _updateAndFire: function(property, index) {
      if (this[property] !== index) {
        this._fireSelectionChanged();
        this[property] = index;
      }
      this._updateTextarea();
    },

    /**
     * Fires the even of selection changed
     * @private
     */
    _fireSelectionChanged: function() {
      this.fire('selection:changed');
      this.canvas && this.canvas.fire('text:selection:changed', { target: this });
    },

    /**
     * Initialize text dimensions. Render all text on given context
     * or on a offscreen canvas to get the text width with measureText.
     * Updates this.width and this.height with the proper values.
     * Does not return dimensions.
     * @private
     */
    initDimensions: function() {
      this.isEditing && this.initDelayedCursor();
      this.clearContextTop();
      this.callSuper('initDimensions');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      this.clearContextTop();
      this.callSuper('render', ctx);
      // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor
      // the correct position but not at every cursor animation.
      this.cursorOffsetCache = { };
      this.renderCursorOrSelection();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      this.callSuper('_render', ctx);
    },

    /**
     * Prepare and clean the contextTop
     */
    clearContextTop: function(skipRestore) {
      if (!this.isEditing) {
        return;
      }
      if (this.canvas && this.canvas.contextTop) {
        var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;
        ctx.save();
        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        this.transform(ctx);
        this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);
        this._clearTextArea(ctx);
        skipRestore || ctx.restore();
      }
    },

    /**
     * Renders cursor or selection (depending on what exists)
     */
    renderCursorOrSelection: function() {
      if (!this.isEditing || !this.canvas) {
        return;
      }
      var boundaries = this._getCursorBoundaries(), ctx;
      if (this.canvas && this.canvas.contextTop) {
        ctx = this.canvas.contextTop;
        this.clearContextTop(true);
      }
      else {
        ctx = this.canvas.contextContainer;
        ctx.save();
      }
      if (this.selectionStart === this.selectionEnd) {
        this.renderCursor(boundaries, ctx);
      }
      else {
        this.renderSelection(boundaries, ctx);
      }
      ctx.restore();
    },

    _clearTextArea: function(ctx) {
      // we add 4 pixel, to be sure to do not leave any pixel out
      var width = this.width + 4, height = this.height + 4;
      ctx.clearRect(-width / 2, -height / 2, width, height);
    },

    /**
     * Returns cursor boundaries (left, top, leftOffset, topOffset)
     * @private
     * @param {Array} chars Array of characters
     * @param {String} typeOfBoundaries
     */
    _getCursorBoundaries: function(position) {

      // left/top are left/top of entire text box
      // leftOffset/topOffset are offset from that left/top point of a text box

      if (typeof position === 'undefined') {
        position = this.selectionStart;
      }

      var left = this._getLeftOffset(),
          top = this._getTopOffset(),
          offsets = this._getCursorBoundariesOffsets(position);

      return {
        left: left,
        top: top,
        leftOffset: offsets.left,
        topOffset: offsets.top
      };
    },

    /**
     * @private
     */
    _getCursorBoundariesOffsets: function(position) {
      if (this.cursorOffsetCache && 'top' in this.cursorOffsetCache) {
        return this.cursorOffsetCache;
      }
      var lineLeftOffset,
          lineIndex,
          charIndex,
          topOffset = 0,
          leftOffset = 0,
          boundaries,
          cursorPosition = this.get2DCursorLocation(position);
      charIndex = cursorPosition.charIndex;
      lineIndex = cursorPosition.lineIndex;
      for (var i = 0; i < lineIndex; i++) {
        topOffset += this.getHeightOfLine(i);
      }
      lineLeftOffset = this._getLineLeftOffset(lineIndex);
      var bound = this.__charBounds[lineIndex][charIndex];
      bound && (leftOffset = bound.left);
      if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {
        leftOffset -= this._getWidthOfCharSpacing();
      }
      boundaries = {
        top: topOffset,
        left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0),
      };
      this.cursorOffsetCache = boundaries;
      return this.cursorOffsetCache;
    },

    /**
     * Renders cursor
     * @param {Object} boundaries
     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
     */
    renderCursor: function(boundaries, ctx) {
      var cursorLocation = this.get2DCursorLocation(),
          lineIndex = cursorLocation.lineIndex,
          charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0,
          charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize'),
          multiplier = this.scaleX * this.canvas.getZoom(),
          cursorWidth = this.cursorWidth / multiplier,
          topOffset = boundaries.topOffset,
          dy = this.getValueOfPropertyAt(lineIndex, charIndex, 'deltaY');

      topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight
        - charHeight * (1 - this._fontSizeFraction);

      if (this.inCompositionMode) {
        this.renderSelection(boundaries, ctx);
      }

      ctx.fillStyle = this.getValueOfPropertyAt(lineIndex, charIndex, 'fill');
      ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
      ctx.fillRect(
        boundaries.left + boundaries.leftOffset - cursorWidth / 2,
        topOffset + boundaries.top + dy,
        cursorWidth,
        charHeight);
    },

    /**
     * Renders text selection
     * @param {Object} boundaries Object with left/top/leftOffset/topOffset
     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
     */
    renderSelection: function(boundaries, ctx) {

      var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart,
          selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd,
          isJustify = this.textAlign.indexOf('justify') !== -1,
          start = this.get2DCursorLocation(selectionStart),
          end = this.get2DCursorLocation(selectionEnd),
          startLine = start.lineIndex,
          endLine = end.lineIndex,
          startChar = start.charIndex < 0 ? 0 : start.charIndex,
          endChar = end.charIndex < 0 ? 0 : end.charIndex;

      for (var i = startLine; i <= endLine; i++) {
        var lineOffset = this._getLineLeftOffset(i) || 0,
            lineHeight = this.getHeightOfLine(i),
            realLineHeight = 0, boxStart = 0, boxEnd = 0;

        if (i === startLine) {
          boxStart = this.__charBounds[startLine][startChar].left;
        }
        if (i >= startLine && i < endLine) {
          boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?
        }
        else if (i === endLine) {
          if (endChar === 0) {
            boxEnd = this.__charBounds[endLine][endChar].left;
          }
          else {
            var charSpacing = this._getWidthOfCharSpacing();
            boxEnd = this.__charBounds[endLine][endChar - 1].left
              + this.__charBounds[endLine][endChar - 1].width - charSpacing;
          }
        }
        realLineHeight = lineHeight;
        if (this.lineHeight < 1 || (i === endLine && this.lineHeight > 1)) {
          lineHeight /= this.lineHeight;
        }
        if (this.inCompositionMode) {
          ctx.fillStyle = this.compositionColor || 'black';
          ctx.fillRect(
            boundaries.left + lineOffset + boxStart,
            boundaries.top + boundaries.topOffset + lineHeight,
            boxEnd - boxStart,
            1);
        }
        else {
          ctx.fillStyle = this.selectionColor;
          ctx.fillRect(
            boundaries.left + lineOffset + boxStart,
            boundaries.top + boundaries.topOffset,
            boxEnd - boxStart,
            lineHeight);
        }


        boundaries.topOffset += realLineHeight;
      }
    },

    /**
     * High level function to know the height of the cursor.
     * the currentChar is the one that precedes the cursor
     * Returns fontSize of char at the current cursor
     * @return {Number} Character font size
     */
    getCurrentCharFontSize: function() {
      var cp = this._getCurrentCharIndex();
      return this.getValueOfPropertyAt(cp.l, cp.c, 'fontSize');
    },

    /**
     * High level function to know the color of the cursor.
     * the currentChar is the one that precedes the cursor
     * Returns color (fill) of char at the current cursor
     * @return {String} Character color (fill)
     */
    getCurrentCharColor: function() {
      var cp = this._getCurrentCharIndex();
      return this.getValueOfPropertyAt(cp.l, cp.c, 'fill');
    },

    /**
     * Returns the cursor position for the getCurrent.. functions
     * @private
     */
    _getCurrentCharIndex: function() {
      var cursorPosition = this.get2DCursorLocation(this.selectionStart, true),
          charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;
      return { l: cursorPosition.lineIndex, c: charIndex };
    }
  });

  /**
   * Returns fabric.IText instance from an object representation
   * @static
   * @memberOf fabric.IText
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as argument
   */
  fabric.IText.fromObject = function(object, callback) {
    parseDecoration(object);
    if (object.styles) {
      for (var i in object.styles) {
        for (var j in object.styles[i]) {
          parseDecoration(object.styles[i][j]);
        }
      }
    }
    fabric.Object._fromObject('IText', object, callback, 'text');
  };
})();


(function() {

  var clone = fabric.util.object.clone;

  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

    /**
     * Initializes all the interactive behavior of IText
     */
    initBehavior: function() {
      this.initAddedHandler();
      this.initRemovedHandler();
      this.initCursorSelectionHandlers();
      this.initDoubleClickSimulation();
      this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
    },

    onDeselect: function() {
      this.isEditing && this.exitEditing();
      this.selected = false;
    },

    /**
     * Initializes "added" event handler
     */
    initAddedHandler: function() {
      var _this = this;
      this.on('added', function() {
        var canvas = _this.canvas;
        if (canvas) {
          if (!canvas._hasITextHandlers) {
            canvas._hasITextHandlers = true;
            _this._initCanvasHandlers(canvas);
          }
          canvas._iTextInstances = canvas._iTextInstances || [];
          canvas._iTextInstances.push(_this);
        }
      });
    },

    initRemovedHandler: function() {
      var _this = this;
      this.on('removed', function() {
        var canvas = _this.canvas;
        if (canvas) {
          canvas._iTextInstances = canvas._iTextInstances || [];
          fabric.util.removeFromArray(canvas._iTextInstances, _this);
          if (canvas._iTextInstances.length === 0) {
            canvas._hasITextHandlers = false;
            _this._removeCanvasHandlers(canvas);
          }
        }
      });
    },

    /**
     * register canvas event to manage exiting on other instances
     * @private
     */
    _initCanvasHandlers: function(canvas) {
      canvas._mouseUpITextHandler = function() {
        if (canvas._iTextInstances) {
          canvas._iTextInstances.forEach(function(obj) {
            obj.__isMousedown = false;
          });
        }
      };
      canvas.on('mouse:up', canvas._mouseUpITextHandler);
    },

    /**
     * remove canvas event to manage exiting on other instances
     * @private
     */
    _removeCanvasHandlers: function(canvas) {
      canvas.off('mouse:up', canvas._mouseUpITextHandler);
    },

    /**
     * @private
     */
    _tick: function() {
      this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');
    },

    /**
     * @private
     */
    _animateCursor: function(obj, targetOpacity, duration, completeMethod) {

      var tickState;

      tickState = {
        isAborted: false,
        abort: function() {
          this.isAborted = true;
        },
      };

      obj.animate('_currentCursorOpacity', targetOpacity, {
        duration: duration,
        onComplete: function() {
          if (!tickState.isAborted) {
            obj[completeMethod]();
          }
        },
        onChange: function() {
          // we do not want to animate a selection, only cursor
          if (obj.canvas && obj.selectionStart === obj.selectionEnd) {
            obj.renderCursorOrSelection();
          }
        },
        abort: function() {
          return tickState.isAborted;
        }
      });
      return tickState;
    },

    /**
     * @private
     */
    _onTickComplete: function() {

      var _this = this;

      if (this._cursorTimeout1) {
        clearTimeout(this._cursorTimeout1);
      }
      this._cursorTimeout1 = setTimeout(function() {
        _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');
      }, 100);
    },

    /**
     * Initializes delayed cursor
     */
    initDelayedCursor: function(restart) {
      var _this = this,
          delay = restart ? 0 : this.cursorDelay;

      this.abortCursorAnimation();
      this._currentCursorOpacity = 1;
      this._cursorTimeout2 = setTimeout(function() {
        _this._tick();
      }, delay);
    },

    /**
     * Aborts cursor animation and clears all timeouts
     */
    abortCursorAnimation: function() {
      var shouldClear = this._currentTickState || this._currentTickCompleteState,
          canvas = this.canvas;
      this._currentTickState && this._currentTickState.abort();
      this._currentTickCompleteState && this._currentTickCompleteState.abort();

      clearTimeout(this._cursorTimeout1);
      clearTimeout(this._cursorTimeout2);

      this._currentCursorOpacity = 0;
      // to clear just itext area we need to transform the context
      // it may not be worth it
      if (shouldClear && canvas) {
        canvas.clearContext(canvas.contextTop || canvas.contextContainer);
      }

    },

    /**
     * Selects entire text
     * @return {fabric.IText} thisArg
     * @chainable
     */
    selectAll: function() {
      this.selectionStart = 0;
      this.selectionEnd = this._text.length;
      this._fireSelectionChanged();
      this._updateTextarea();
      return this;
    },

    /**
     * Returns selected text
     * @return {String}
     */
    getSelectedText: function() {
      return this._text.slice(this.selectionStart, this.selectionEnd).join('');
    },

    /**
     * Find new selection index representing start of current word according to current selection index
     * @param {Number} startFrom Surrent selection index
     * @return {Number} New selection index
     */
    findWordBoundaryLeft: function(startFrom) {
      var offset = 0, index = startFrom - 1;

      // remove space before cursor first
      if (this._reSpace.test(this._text[index])) {
        while (this._reSpace.test(this._text[index])) {
          offset++;
          index--;
        }
      }
      while (/\S/.test(this._text[index]) && index > -1) {
        offset++;
        index--;
      }

      return startFrom - offset;
    },

    /**
     * Find new selection index representing end of current word according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findWordBoundaryRight: function(startFrom) {
      var offset = 0, index = startFrom;

      // remove space after cursor first
      if (this._reSpace.test(this._text[index])) {
        while (this._reSpace.test(this._text[index])) {
          offset++;
          index++;
        }
      }
      while (/\S/.test(this._text[index]) && index < this.text.length) {
        offset++;
        index++;
      }

      return startFrom + offset;
    },

    /**
     * Find new selection index representing start of current line according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findLineBoundaryLeft: function(startFrom) {
      var offset = 0, index = startFrom - 1;

      while (!/\n/.test(this._text[index]) && index > -1) {
        offset++;
        index--;
      }

      return startFrom - offset;
    },

    /**
     * Find new selection index representing end of current line according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findLineBoundaryRight: function(startFrom) {
      var offset = 0, index = startFrom;

      while (!/\n/.test(this._text[index]) && index < this.text.length) {
        offset++;
        index++;
      }

      return startFrom + offset;
    },

    /**
     * Finds index corresponding to beginning or end of a word
     * @param {Number} selectionStart Index of a character
     * @param {Number} direction 1 or -1
     * @return {Number} Index of the beginning or end of a word
     */
    searchWordBoundary: function(selectionStart, direction) {
      var index     = this._reSpace.test(this.text.charAt(selectionStart)) ? selectionStart - 1 : selectionStart,
          _char     = this.text.charAt(index),
          reNonWord = /[ \n\.,;!\?\-]/;

      while (!reNonWord.test(_char) && index > 0 && index < this.text.length) {
        index += direction;
        _char = this.text.charAt(index);
      }
      if (reNonWord.test(_char) && _char !== '\n') {
        index += direction === 1 ? 0 : 1;
      }
      return index;
    },

    /**
     * Selects a word based on the index
     * @param {Number} selectionStart Index of a character
     */
    selectWord: function(selectionStart) {
      selectionStart = selectionStart || this.selectionStart;
      var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */
          newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */

      this.selectionStart = newSelectionStart;
      this.selectionEnd = newSelectionEnd;
      this._fireSelectionChanged();
      this._updateTextarea();
      this.renderCursorOrSelection();
    },

    /**
     * Selects a line based on the index
     * @param {Number} selectionStart Index of a character
     * @return {fabric.IText} thisArg
     * @chainable
     */
    selectLine: function(selectionStart) {
      selectionStart = selectionStart || this.selectionStart;
      var newSelectionStart = this.findLineBoundaryLeft(selectionStart),
          newSelectionEnd = this.findLineBoundaryRight(selectionStart);

      this.selectionStart = newSelectionStart;
      this.selectionEnd = newSelectionEnd;
      this._fireSelectionChanged();
      this._updateTextarea();
      return this;
    },

    /**
     * Enters editing state
     * @return {fabric.IText} thisArg
     * @chainable
     */
    enterEditing: function(e) {
      if (this.isEditing || !this.editable) {
        return;
      }

      if (this.canvas) {
        this.canvas.calcOffset();
        this.exitEditingOnOthers(this.canvas);
      }

      this.isEditing = true;

      this.initHiddenTextarea(e);
      this.hiddenTextarea.focus();
      this.hiddenTextarea.value = this.text;
      this._updateTextarea();
      this._saveEditingProps();
      this._setEditingProps();
      this._textBeforeEdit = this.text;

      this._tick();
      this.fire('editing:entered');
      this._fireSelectionChanged();
      if (!this.canvas) {
        return this;
      }
      this.canvas.fire('text:editing:entered', { target: this });
      this.initMouseMoveHandler();
      this.canvas.requestRenderAll();
      return this;
    },

    exitEditingOnOthers: function(canvas) {
      if (canvas._iTextInstances) {
        canvas._iTextInstances.forEach(function(obj) {
          obj.selected = false;
          if (obj.isEditing) {
            obj.exitEditing();
          }
        });
      }
    },

    /**
     * Initializes "mousemove" event handler
     */
    initMouseMoveHandler: function() {
      this.canvas.on('mouse:move', this.mouseMoveHandler);
    },

    /**
     * @private
     */
    mouseMoveHandler: function(options) {
      if (!this.__isMousedown || !this.isEditing) {
        return;
      }

      var newSelectionStart = this.getSelectionStartFromPointer(options.e),
          currentStart = this.selectionStart,
          currentEnd = this.selectionEnd;
      if (
        (newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd)
        &&
        (currentStart === newSelectionStart || currentEnd === newSelectionStart)
      ) {
        return;
      }
      if (newSelectionStart > this.__selectionStartOnMouseDown) {
        this.selectionStart = this.__selectionStartOnMouseDown;
        this.selectionEnd = newSelectionStart;
      }
      else {
        this.selectionStart = newSelectionStart;
        this.selectionEnd = this.__selectionStartOnMouseDown;
      }
      if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {
        this.restartCursorIfNeeded();
        this._fireSelectionChanged();
        this._updateTextarea();
        this.renderCursorOrSelection();
      }
    },

    /**
     * @private
     */
    _setEditingProps: function() {
      this.hoverCursor = 'text';

      if (this.canvas) {
        this.canvas.defaultCursor = this.canvas.moveCursor = 'text';
      }

      this.borderColor = this.editingBorderColor;

      this.hasControls = this.selectable = false;
      this.lockMovementX = this.lockMovementY = true;
    },

    /**
     * convert from textarea to grapheme indexes
     */
    fromStringToGraphemeSelection: function(start, end, text) {
      var smallerTextStart = text.slice(0, start),
          graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;
      if (start === end) {
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
      }
      var smallerTextEnd = text.slice(start, end),
          graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;
      return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
    },

    /**
     * convert from fabric to textarea values
     */
    fromGraphemeToStringSelection: function(start, end, _text) {
      var smallerTextStart = _text.slice(0, start),
          graphemeStart = smallerTextStart.join('').length;
      if (start === end) {
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
      }
      var smallerTextEnd = _text.slice(start, end),
          graphemeEnd = smallerTextEnd.join('').length;
      return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
    },

    /**
     * @private
     */
    _updateTextarea: function() {
      this.cursorOffsetCache = { };
      if (!this.hiddenTextarea) {
        return;
      }
      if (!this.inCompositionMode) {
        var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = newSelection.selectionStart;
        this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;
      }
      this.updateTextareaPosition();
    },

    /**
     * @private
     */
    updateFromTextArea: function() {
      if (!this.hiddenTextarea) {
        return;
      }
      this.cursorOffsetCache = { };
      this.text = this.hiddenTextarea.value;
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      var newSelection = this.fromStringToGraphemeSelection(
        this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);
      this.selectionEnd = this.selectionStart = newSelection.selectionEnd;
      if (!this.inCompositionMode) {
        this.selectionStart = newSelection.selectionStart;
      }
      this.updateTextareaPosition();
    },

    /**
     * @private
     */
    updateTextareaPosition: function() {
      if (this.selectionStart === this.selectionEnd) {
        var style = this._calcTextareaPosition();
        this.hiddenTextarea.style.left = style.left;
        this.hiddenTextarea.style.top = style.top;
      }
    },

    /**
     * @private
     * @return {Object} style contains style for hiddenTextarea
     */
    _calcTextareaPosition: function() {
      if (!this.canvas) {
        return { x: 1, y: 1 };
      }
      var desiredPostion = this.inCompositionMode ? this.compositionStart : this.selectionStart,
          boundaries = this._getCursorBoundaries(desiredPostion),
          cursorLocation = this.get2DCursorLocation(desiredPostion),
          lineIndex = cursorLocation.lineIndex,
          charIndex = cursorLocation.charIndex,
          charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize') * this.lineHeight,
          leftOffset = boundaries.leftOffset,
          m = this.calcTransformMatrix(),
          p = {
            x: boundaries.left + leftOffset,
            y: boundaries.top + boundaries.topOffset + charHeight
          },
          upperCanvas = this.canvas.upperCanvasEl,
          upperCanvasWidth = upperCanvas.width,
          upperCanvasHeight = upperCanvas.height,
          maxWidth = upperCanvasWidth - charHeight,
          maxHeight = upperCanvasHeight - charHeight,
          scaleX = upperCanvas.clientWidth / upperCanvasWidth,
          scaleY = upperCanvas.clientHeight / upperCanvasHeight;

      p = fabric.util.transformPoint(p, m);
      p = fabric.util.transformPoint(p, this.canvas.viewportTransform);
      p.x *= scaleX;
      p.y *= scaleY;
      if (p.x < 0) {
        p.x = 0;
      }
      if (p.x > maxWidth) {
        p.x = maxWidth;
      }
      if (p.y < 0) {
        p.y = 0;
      }
      if (p.y > maxHeight) {
        p.y = maxHeight;
      }

      // add canvas offset on document
      p.x += this.canvas._offset.left;
      p.y += this.canvas._offset.top;

      return { left: p.x + 'px', top: p.y + 'px', fontSize: charHeight + 'px', charHeight: charHeight };
    },

    /**
     * @private
     */
    _saveEditingProps: function() {
      this._savedProps = {
        hasControls: this.hasControls,
        borderColor: this.borderColor,
        lockMovementX: this.lockMovementX,
        lockMovementY: this.lockMovementY,
        hoverCursor: this.hoverCursor,
        defaultCursor: this.canvas && this.canvas.defaultCursor,
        moveCursor: this.canvas && this.canvas.moveCursor
      };
    },

    /**
     * @private
     */
    _restoreEditingProps: function() {
      if (!this._savedProps) {
        return;
      }

      this.hoverCursor = this._savedProps.hoverCursor;
      this.hasControls = this._savedProps.hasControls;
      this.borderColor = this._savedProps.borderColor;
      this.lockMovementX = this._savedProps.lockMovementX;
      this.lockMovementY = this._savedProps.lockMovementY;

      if (this.canvas) {
        this.canvas.defaultCursor = this._savedProps.defaultCursor;
        this.canvas.moveCursor = this._savedProps.moveCursor;
      }
    },

    /**
     * Exits from editing state
     * @return {fabric.IText} thisArg
     * @chainable
     */
    exitEditing: function() {
      var isTextChanged = (this._textBeforeEdit !== this.text);
      this.selected = false;
      this.isEditing = false;
      this.selectable = true;

      this.selectionEnd = this.selectionStart;

      if (this.hiddenTextarea) {
        this.hiddenTextarea.blur && this.hiddenTextarea.blur();
        this.canvas && this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea);
        this.hiddenTextarea = null;
      }

      this.abortCursorAnimation();
      this._restoreEditingProps();
      this._currentCursorOpacity = 0;
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      this.fire('editing:exited');
      isTextChanged && this.fire('modified');
      if (this.canvas) {
        this.canvas.off('mouse:move', this.mouseMoveHandler);
        this.canvas.fire('text:editing:exited', { target: this });
        isTextChanged && this.canvas.fire('object:modified', { target: this });
      }
      return this;
    },

    /**
     * @private
     */
    _removeExtraneousStyles: function() {
      for (var prop in this.styles) {
        if (!this._textLines[prop]) {
          delete this.styles[prop];
        }
      }
    },

    /**
     * remove and reflow a style block from start to end.
     * @param {Number} start linear start position for removal (included in removal)
     * @param {Number} end linear end position for removal ( excluded from removal )
     */
    removeStyleFromTo: function(start, end) {
      var cursorStart = this.get2DCursorLocation(start, true),
          cursorEnd = this.get2DCursorLocation(end, true),
          lineStart = cursorStart.lineIndex,
          charStart = cursorStart.charIndex,
          lineEnd = cursorEnd.lineIndex,
          charEnd = cursorEnd.charIndex,
          i, styleObj;
      if (lineStart !== lineEnd) {
        // step1 remove the trailing of lineStart
        if (this.styles[lineStart]) {
          for (i = charStart; i < this._unwrappedTextLines[lineStart].length; i++) {
            delete this.styles[lineStart][i];
          }
        }
        // step2 move the trailing of lineEnd to lineStart if needed
        if (this.styles[lineEnd]) {
          for (i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++) {
            styleObj = this.styles[lineEnd][i];
            if (styleObj) {
              this.styles[lineStart] || (this.styles[lineStart] = { });
              this.styles[lineStart][charStart + i - charEnd] = styleObj;
            }
          }
        }
        // step3 detects lines will be completely removed.
        for (i = lineStart + 1; i <= lineEnd; i++) {
          delete this.styles[i];
        }
        // step4 shift remaining lines.
        this.shiftLineStyles(lineEnd, lineStart - lineEnd);
      }
      else {
        // remove and shift left on the same line
        if (this.styles[lineStart]) {
          styleObj = this.styles[lineStart];
          var diff = charEnd - charStart, numericChar, _char;
          for (i = charStart; i < charEnd; i++) {
            delete styleObj[i];
          }
          for (_char in this.styles[lineStart]) {
            numericChar = parseInt(_char, 10);
            if (numericChar >= charEnd) {
              styleObj[numericChar - diff] = styleObj[_char];
              delete styleObj[_char];
            }
          }
        }
      }
    },

    /**
     * Shifts line styles up or down
     * @param {Number} lineIndex Index of a line
     * @param {Number} offset Can any number?
     */
    shiftLineStyles: function(lineIndex, offset) {
      // shift all line styles by offset upward or downward
      // do not clone deep. we need new array, not new style objects
      var clonedStyles = clone(this.styles);
      for (var line in this.styles) {
        var numericLine = parseInt(line, 10);
        if (numericLine > lineIndex) {
          this.styles[numericLine + offset] = clonedStyles[numericLine];
          if (!clonedStyles[numericLine - offset]) {
            delete this.styles[numericLine];
          }
        }
      }
    },

    restartCursorIfNeeded: function() {
      if (!this._currentTickState || this._currentTickState.isAborted
        || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted
      ) {
        this.initDelayedCursor();
      }
    },

    /**
     * Inserts new style object
     * @param {Number} lineIndex Index of a line
     * @param {Number} charIndex Index of a char
     * @param {Number} qty number of lines to add
     * @param {Array} copiedStyle Array of objects styles
     */
    insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {
      var currentCharStyle,
          newLineStyles = {},
          somethingAdded = false;

      qty || (qty = 1);
      this.shiftLineStyles(lineIndex, qty);
      if (this.styles[lineIndex]) {
        currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];
      }

      // we clone styles of all chars
      // after cursor onto the current line
      for (var index in this.styles[lineIndex]) {
        var numIndex = parseInt(index, 10);
        if (numIndex >= charIndex) {
          somethingAdded = true;
          newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];
          // remove lines from the previous line since they're on a new line now
          delete this.styles[lineIndex][index];
        }
      }
      if (somethingAdded) {
        this.styles[lineIndex + qty] = newLineStyles;
      }
      else {
        delete this.styles[lineIndex + qty];
      }
      // for the other lines
      // we clone current char style onto the next (otherwise empty) line
      while (qty > 1) {
        qty--;
        if (copiedStyle && copiedStyle[qty]) {
          this.styles[lineIndex + qty] = { 0: clone(copiedStyle[qty]) };
        }
        else if (currentCharStyle) {
          this.styles[lineIndex + qty] = { 0: clone(currentCharStyle) };
        }
        else {
          delete this.styles[lineIndex + qty];
        }
      }
      this._forceClearCache = true;
    },

    /**
     * Inserts style object for a given line/char index
     * @param {Number} lineIndex Index of a line
     * @param {Number} charIndex Index of a char
     * @param {Number} quantity number Style object to insert, if given
     * @param {Array} copiedStyle array of style objecs
     */
    insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {
      if (!this.styles) {
        this.styles = {};
      }
      var currentLineStyles       = this.styles[lineIndex],
          currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};

      quantity || (quantity = 1);
      // shift all char styles by quantity forward
      // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4
      for (var index in currentLineStylesCloned) {
        var numericIndex = parseInt(index, 10);
        if (numericIndex >= charIndex) {
          currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];
          // only delete the style if there was nothing moved there
          if (!currentLineStylesCloned[numericIndex - quantity]) {
            delete currentLineStyles[numericIndex];
          }
        }
      }
      this._forceClearCache = true;
      if (copiedStyle) {
        while (quantity--) {
          if (!Object.keys(copiedStyle[quantity]).length) {
            continue;
          }
          if (!this.styles[lineIndex]) {
            this.styles[lineIndex] = {};
          }
          this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);
        }
        return;
      }
      if (!currentLineStyles) {
        return;
      }
      var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];
      while (newStyle && quantity--) {
        this.styles[lineIndex][charIndex + quantity] = clone(newStyle);
      }
    },

    /**
     * Inserts style object(s)
     * @param {Array} insertedText Characters at the location where style is inserted
     * @param {Number} start cursor index for inserting style
     * @param {Array} [copiedStyle] array of style objects to insert.
     */
    insertNewStyleBlock: function(insertedText, start, copiedStyle) {
      var cursorLoc = this.get2DCursorLocation(start, true),
          addedLines = [0], linesLenght = 0;
      for (var i = 0; i < insertedText.length; i++) {
        if (insertedText[i] === '\n') {
          linesLenght++;
          addedLines[linesLenght] = 0;
        }
        else {
          addedLines[linesLenght]++;
        }
      }
      if (addedLines[0] > 0) {
        this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);
        copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);
      }
      linesLenght && this.insertNewlineStyleObject(
        cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLenght);
      for (var i = 1; i < linesLenght; i++) {
        if (addedLines[i] > 0) {
          this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
        }
        else if (copiedStyle) {
          this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];
        }
        copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);
      }
      // we use i outside the loop to get it like linesLength
      if (addedLines[i] > 0) {
        this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
      }
    },

    /**
     * Set the selectionStart and selectionEnd according to the ne postion of cursor
     * mimic the key - mouse navigation when shift is pressed.
     */
    setSelectionStartEndWithShift: function(start, end, newSelection) {
      if (newSelection <= start) {
        if (end === start) {
          this._selectionDirection = 'left';
        }
        else if (this._selectionDirection === 'right') {
          this._selectionDirection = 'left';
          this.selectionEnd = start;
        }
        this.selectionStart = newSelection;
      }
      else if (newSelection > start && newSelection < end) {
        if (this._selectionDirection === 'right') {
          this.selectionEnd = newSelection;
        }
        else {
          this.selectionStart = newSelection;
        }
      }
      else {
        // newSelection is > selection start and end
        if (end === start) {
          this._selectionDirection = 'right';
        }
        else if (this._selectionDirection === 'left') {
          this._selectionDirection = 'right';
          this.selectionStart = end;
        }
        this.selectionEnd = newSelection;
      }
    },

    setSelectionInBoundaries: function() {
      var length = this.text.length;
      if (this.selectionStart > length) {
        this.selectionStart = length;
      }
      else if (this.selectionStart < 0) {
        this.selectionStart = 0;
      }
      if (this.selectionEnd > length) {
        this.selectionEnd = length;
      }
      else if (this.selectionEnd < 0) {
        this.selectionEnd = 0;
      }
    }
  });
})();


fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
  /**
   * Initializes "dbclick" event handler
   */
  initDoubleClickSimulation: function() {

    // for double click
    this.__lastClickTime = +new Date();

    // for triple click
    this.__lastLastClickTime = +new Date();

    this.__lastPointer = { };

    this.on('mousedown', this.onMouseDown);
  },

  /**
   * Default event handler to simulate triple click
   * @private
   */
  onMouseDown: function(options) {
    if (!this.canvas) {
      return;
    }
    this.__newClickTime = +new Date();
    var newPointer = options.pointer;
    if (this.isTripleClick(newPointer)) {
      this.fire('tripleclick', options);
      this._stopEvent(options.e);
    }
    this.__lastLastClickTime = this.__lastClickTime;
    this.__lastClickTime = this.__newClickTime;
    this.__lastPointer = newPointer;
    this.__lastIsEditing = this.isEditing;
    this.__lastSelected = this.selected;
  },

  isTripleClick: function(newPointer) {
    return this.__newClickTime - this.__lastClickTime < 500 &&
        this.__lastClickTime - this.__lastLastClickTime < 500 &&
        this.__lastPointer.x === newPointer.x &&
        this.__lastPointer.y === newPointer.y;
  },

  /**
   * @private
   */
  _stopEvent: function(e) {
    e.preventDefault && e.preventDefault();
    e.stopPropagation && e.stopPropagation();
  },

  /**
   * Initializes event handlers related to cursor or selection
   */
  initCursorSelectionHandlers: function() {
    this.initMousedownHandler();
    this.initMouseupHandler();
    this.initClicks();
  },

  /**
   * Initializes double and triple click event handlers
   */
  initClicks: function() {
    this.on('mousedblclick', function(options) {
      this.selectWord(this.getSelectionStartFromPointer(options.e));
    });
    this.on('tripleclick', function(options) {
      this.selectLine(this.getSelectionStartFromPointer(options.e));
    });
  },

  /**
   * Default event handler for the basic functionalities needed on _mouseDown
   * can be overridden to do something different.
   * Scope of this implementation is: find the click position, set selectionStart
   * find selectionEnd, initialize the drawing of either cursor or selection area
   */
  _mouseDownHandler: function(options) {
    if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
      return;
    }

    this.__isMousedown = true;

    if (this.selected) {
      this.setCursorByClick(options.e);
    }

    if (this.isEditing) {
      this.__selectionStartOnMouseDown = this.selectionStart;
      if (this.selectionStart === this.selectionEnd) {
        this.abortCursorAnimation();
      }
      this.renderCursorOrSelection();
    }
  },

  /**
   * Default event handler for the basic functionalities needed on mousedown:before
   * can be overridden to do something different.
   * Scope of this implementation is: verify the object is already selected when mousing down
   */
  _mouseDownHandlerBefore: function(options) {
    if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
      return;
    }
    if (this === this.canvas._activeObject) {
      this.selected = true;
    }
  },

  /**
   * Initializes "mousedown" event handler
   */
  initMousedownHandler: function() {
    this.on('mousedown', this._mouseDownHandler);
    this.on('mousedown:before', this._mouseDownHandlerBefore);
  },

  /**
   * Initializes "mouseup" event handler
   */
  initMouseupHandler: function() {
    this.on('mouseup', this.mouseUpHandler);
  },

  /**
   * standard hander for mouse up, overridable
   * @private
   */
  mouseUpHandler: function(options) {
    this.__isMousedown = false;
    if (!this.editable || this.group ||
      (options.transform && options.transform.actionPerformed) ||
      (options.e.button && options.e.button !== 1)) {
      return;
    }

    if (this.canvas) {
      var currentActive = this.canvas._activeObject;
      if (currentActive && currentActive !== this) {
        // avoid running this logic when there is an active object
        // this because is possible with shift click and fast clicks,
        // to rapidly deselect and reselect this object and trigger an enterEdit
        return;
      }
    }

    if (this.__lastSelected && !this.__corner) {
      this.selected = false;
      this.__lastSelected = false;
      this.enterEditing(options.e);
      if (this.selectionStart === this.selectionEnd) {
        this.initDelayedCursor(true);
      }
      else {
        this.renderCursorOrSelection();
      }
    }
    else {
      this.selected = true;
    }
  },

  /**
   * Changes cursor location in a text depending on passed pointer (x/y) object
   * @param {Event} e Event object
   */
  setCursorByClick: function(e) {
    var newSelection = this.getSelectionStartFromPointer(e),
        start = this.selectionStart, end = this.selectionEnd;
    if (e.shiftKey) {
      this.setSelectionStartEndWithShift(start, end, newSelection);
    }
    else {
      this.selectionStart = newSelection;
      this.selectionEnd = newSelection;
    }
    if (this.isEditing) {
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Returns index of a character corresponding to where an object was clicked
   * @param {Event} e Event object
   * @return {Number} Index of a character
   */
  getSelectionStartFromPointer: function(e) {
    var mouseOffset = this.getLocalPointer(e),
        prevWidth = 0,
        width = 0,
        height = 0,
        charIndex = 0,
        lineIndex = 0,
        lineLeftOffset,
        line;

    for (var i = 0, len = this._textLines.length; i < len; i++) {
      if (height <= mouseOffset.y) {
        height += this.getHeightOfLine(i) * this.scaleY;
        lineIndex = i;
        if (i > 0) {
          charIndex += this._textLines[i - 1].length + 1;
        }
      }
      else {
        break;
      }
    }
    lineLeftOffset = this._getLineLeftOffset(lineIndex);
    width = lineLeftOffset * this.scaleX;
    line = this._textLines[lineIndex];
    for (var j = 0, jlen = line.length; j < jlen; j++) {
      prevWidth = width;
      // i removed something about flipX here, check.
      width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;
      if (width <= mouseOffset.x) {
        charIndex++;
      }
      else {
        break;
      }
    }
    return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);
  },

  /**
   * @private
   */
  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {
    // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0
    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
        distanceBtwNextCharAndCursor = width - mouseOffset.x,
        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ||
          distanceBtwNextCharAndCursor < 0 ? 0 : 1,
        newSelectionStart = index + offset;
    // if object is horizontally flipped, mirror cursor location from the end
    if (this.flipX) {
      newSelectionStart = jlen - newSelectionStart;
    }

    if (newSelectionStart > this._text.length) {
      newSelectionStart = this._text.length;
    }

    return newSelectionStart;
  }
});


fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

  /**
   * Initializes hidden textarea (needed to bring up keyboard in iOS)
   */
  initHiddenTextarea: function() {
    this.hiddenTextarea = fabric.document.createElement('textarea');
    this.hiddenTextarea.setAttribute('autocapitalize', 'off');
    this.hiddenTextarea.setAttribute('autocorrect', 'off');
    this.hiddenTextarea.setAttribute('autocomplete', 'off');
    this.hiddenTextarea.setAttribute('spellcheck', 'false');
    this.hiddenTextarea.setAttribute('data-fabric-hiddentextarea', '');
    this.hiddenTextarea.setAttribute('wrap', 'off');
    var style = this._calcTextareaPosition();
    // line-height: 1px; was removed from the style to fix this:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=870966
    this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top +
    '; left: ' + style.left + '; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;' +
    ' paddingtop: ' + style.fontSize + ';';
    fabric.document.body.appendChild(this.hiddenTextarea);

    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'cut', this.copy.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));

    if (!this._clickHandlerInitialized && this.canvas) {
      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
      this._clickHandlerInitialized = true;
    }
  },

  /**
   * For functionalities on keyDown
   * Map a special key to a function of the instance/prototype
   * If you need different behaviour for ESC or TAB or arrows, you have to change
   * this map setting the name of a function that you build on the fabric.Itext or
   * your prototype.
   * the map change will affect all Instances unless you need for only some text Instances
   * in that case you have to clone this object and assign your Instance.
   * this.keysMap = fabric.util.object.clone(this.keysMap);
   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]
   */
  keysMap: {
    9:  'exitEditing',
    27: 'exitEditing',
    33: 'moveCursorUp',
    34: 'moveCursorDown',
    35: 'moveCursorRight',
    36: 'moveCursorLeft',
    37: 'moveCursorLeft',
    38: 'moveCursorUp',
    39: 'moveCursorRight',
    40: 'moveCursorDown',
  },

  /**
   * For functionalities on keyUp + ctrl || cmd
   */
  ctrlKeysMapUp: {
    67: 'copy',
    88: 'cut'
  },

  /**
   * For functionalities on keyDown + ctrl || cmd
   */
  ctrlKeysMapDown: {
    65: 'selectAll'
  },

  onClick: function() {
    // No need to trigger click event here, focus is enough to have the keyboard appear on Android
    this.hiddenTextarea && this.hiddenTextarea.focus();
  },

  /**
   * Handles keyup event
   * @param {Event} e Event object
   */
  onKeyDown: function(e) {
    if (!this.isEditing || this.inCompositionMode) {
      return;
    }
    if (e.keyCode in this.keysMap) {
      this[this.keysMap[e.keyCode]](e);
    }
    else if ((e.keyCode in this.ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {
      this[this.ctrlKeysMapDown[e.keyCode]](e);
    }
    else {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    if (e.keyCode >= 33 && e.keyCode <= 40) {
      // if i press an arrow key just update selection
      this.clearContextTop();
      this.renderCursorOrSelection();
    }
    else {
      this.canvas && this.canvas.requestRenderAll();
    }
  },

  /**
   * Handles keyup event
   * We handle KeyUp because ie11 and edge have difficulties copy/pasting
   * if a copy/cut event fired, keyup is dismissed
   * @param {Event} e Event object
   */
  onKeyUp: function(e) {
    if (!this.isEditing || this._copyDone || this.inCompositionMode) {
      this._copyDone = false;
      return;
    }
    if ((e.keyCode in this.ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {
      this[this.ctrlKeysMapUp[e.keyCode]](e);
    }
    else {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    this.canvas && this.canvas.requestRenderAll();
  },

  /**
   * Handles onInput event
   * @param {Event} e Event object
   */
  onInput: function(e) {
    var fromPaste = this.fromPaste;
    this.fromPaste = false;
    e && e.stopPropagation();
    if (!this.isEditing) {
      return;
    }
    // decisions about style changes.
    var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,
        charCount = this._text.length,
        nextCharCount = nextText.length,
        removedText, insertedText,
        charDiff = nextCharCount - charCount;
    if (this.hiddenTextarea.value === '') {
      this.styles = { };
      this.updateFromTextArea();
      this.fire('changed');
      if (this.canvas) {
        this.canvas.fire('text:changed', { target: this });
        this.canvas.requestRenderAll();
      }
      return;
    }

    var textareaSelection = this.fromStringToGraphemeSelection(
      this.hiddenTextarea.selectionStart,
      this.hiddenTextarea.selectionEnd,
      this.hiddenTextarea.value
    );
    var backDelete = this.selectionStart > textareaSelection.selectionStart;

    if (this.selectionStart !== this.selectionEnd) {
      removedText = this._text.slice(this.selectionStart, this.selectionEnd);
      charDiff += this.selectionEnd - this.selectionStart;
    }
    else if (nextCharCount < charCount) {
      if (backDelete) {
        removedText = this._text.slice(this.selectionEnd + charDiff, this.selectionEnd);
      }
      else {
        removedText = this._text.slice(this.selectionStart, this.selectionStart - charDiff);
      }
    }
    insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);
    if (removedText && removedText.length) {
      if (this.selectionStart !== this.selectionEnd) {
        this.removeStyleFromTo(this.selectionStart, this.selectionEnd);
      }
      else if (backDelete) {
        // detect differencies between forwardDelete and backDelete
        this.removeStyleFromTo(this.selectionEnd - removedText.length, this.selectionEnd);
      }
      else {
        this.removeStyleFromTo(this.selectionEnd, this.selectionEnd + removedText.length);
      }
    }
    if (insertedText.length) {
      if (fromPaste && insertedText.join('') === fabric.copiedText) {
        this.insertNewStyleBlock(insertedText, this.selectionStart, fabric.copiedTextStyle);
      }
      else {
        this.insertNewStyleBlock(insertedText, this.selectionStart);
      }
    }
    this.updateFromTextArea();
    this.fire('changed');
    if (this.canvas) {
      this.canvas.fire('text:changed', { target: this });
      this.canvas.requestRenderAll();
    }
  },
  /**
   * Composition start
   */
  onCompositionStart: function() {
    this.inCompositionMode = true;
  },

  /**
   * Composition end
   */
  onCompositionEnd: function() {
    this.inCompositionMode = false;
  },

  // /**
  //  * Composition update
  //  */
  onCompositionUpdate: function(e) {
    this.compositionStart = e.target.selectionStart;
    this.compositionEnd = e.target.selectionEnd;
    this.updateTextareaPosition();
  },

  /**
   * Copies selected text
   * @param {Event} e Event object
   */
  copy: function() {
    if (this.selectionStart === this.selectionEnd) {
      //do not cut-copy if no selection
      return;
    }

    fabric.copiedText = this.getSelectedText();
    fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);
    this._copyDone = true;
  },

  /**
   * Pastes text
   * @param {Event} e Event object
   */
  paste: function() {
    this.fromPaste = true;
  },

  /**
   * @private
   * @param {Event} e Event object
   * @return {Object} Clipboard data object
   */
  _getClipboardData: function(e) {
    return (e && e.clipboardData) || fabric.window.clipboardData;
  },

  /**
   * Finds the width in pixels before the cursor on the same line
   * @private
   * @param {Number} lineIndex
   * @param {Number} charIndex
   * @return {Number} widthBeforeCursor width before cursor
   */
  _getWidthBeforeCursor: function(lineIndex, charIndex) {
    var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;

    if (charIndex > 0) {
      bound = this.__charBounds[lineIndex][charIndex - 1];
      widthBeforeCursor += bound.left + bound.width;
    }
    return widthBeforeCursor;
  },

  /**
   * Gets start offset of a selection
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  getDownCursorOffset: function(e, isRight) {
    var selectionProp = this._getSelectionForOffset(e, isRight),
        cursorLocation = this.get2DCursorLocation(selectionProp),
        lineIndex = cursorLocation.lineIndex;
    // if on last line, down cursor goes to end of line
    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
      // move to the end of a text
      return this._text.length - selectionProp;
    }
    var charIndex = cursorLocation.charIndex,
        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
        indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),
        textAfterCursor = this._textLines[lineIndex].slice(charIndex);
    return textAfterCursor.length + indexOnOtherLine + 2;
  },

  /**
   * private
   * Helps finding if the offset should be counted from Start or End
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  _getSelectionForOffset: function(e, isRight) {
    if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
      return this.selectionEnd;
    }
    else {
      return this.selectionStart;
    }
  },

  /**
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  getUpCursorOffset: function(e, isRight) {
    var selectionProp = this._getSelectionForOffset(e, isRight),
        cursorLocation = this.get2DCursorLocation(selectionProp),
        lineIndex = cursorLocation.lineIndex;
    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
      // if on first line, up cursor goes to start of line
      return -selectionProp;
    }
    var charIndex = cursorLocation.charIndex,
        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
        indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),
        textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex);
    // return a negative offset
    return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length;
  },

  /**
   * for a given width it founds the matching character.
   * @private
   */
  _getIndexOnLine: function(lineIndex, width) {

    var line = this._textLines[lineIndex],
        lineLeftOffset = this._getLineLeftOffset(lineIndex),
        widthOfCharsOnLine = lineLeftOffset,
        indexOnLine = 0, charWidth, foundMatch;

    for (var j = 0, jlen = line.length; j < jlen; j++) {
      charWidth = this.__charBounds[lineIndex][j].width;
      widthOfCharsOnLine += charWidth;
      if (widthOfCharsOnLine > width) {
        foundMatch = true;
        var leftEdge = widthOfCharsOnLine - charWidth,
            rightEdge = widthOfCharsOnLine,
            offsetFromLeftEdge = Math.abs(leftEdge - width),
            offsetFromRightEdge = Math.abs(rightEdge - width);

        indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
        break;
      }
    }

    // reached end
    if (!foundMatch) {
      indexOnLine = line.length - 1;
    }

    return indexOnLine;
  },


  /**
   * Moves cursor down
   * @param {Event} e Event object
   */
  moveCursorDown: function(e) {
    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
      return;
    }
    this._moveCursorUpOrDown('Down', e);
  },

  /**
   * Moves cursor up
   * @param {Event} e Event object
   */
  moveCursorUp: function(e) {
    if (this.selectionStart === 0 && this.selectionEnd === 0) {
      return;
    }
    this._moveCursorUpOrDown('Up', e);
  },

  /**
   * Moves cursor up or down, fires the events
   * @param {String} direction 'Up' or 'Down'
   * @param {Event} e Event object
   */
  _moveCursorUpOrDown: function(direction, e) {
    // getUpCursorOffset
    // getDownCursorOffset
    var action = 'get' + direction + 'CursorOffset',
        offset = this[action](e, this._selectionDirection === 'right');
    if (e.shiftKey) {
      this.moveCursorWithShift(offset);
    }
    else {
      this.moveCursorWithoutShift(offset);
    }
    if (offset !== 0) {
      this.setSelectionInBoundaries();
      this.abortCursorAnimation();
      this._currentCursorOpacity = 1;
      this.initDelayedCursor();
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Moves cursor with shift
   * @param {Number} offset
   */
  moveCursorWithShift: function(offset) {
    var newSelection = this._selectionDirection === 'left'
      ? this.selectionStart + offset
      : this.selectionEnd + offset;
    this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
    return offset !== 0;
  },

  /**
   * Moves cursor up without shift
   * @param {Number} offset
   */
  moveCursorWithoutShift: function(offset) {
    if (offset < 0) {
      this.selectionStart += offset;
      this.selectionEnd = this.selectionStart;
    }
    else {
      this.selectionEnd += offset;
      this.selectionStart = this.selectionEnd;
    }
    return offset !== 0;
  },

  /**
   * Moves cursor left
   * @param {Event} e Event object
   */
  moveCursorLeft: function(e) {
    if (this.selectionStart === 0 && this.selectionEnd === 0) {
      return;
    }
    this._moveCursorLeftOrRight('Left', e);
  },

  /**
   * @private
   * @return {Boolean} true if a change happened
   */
  _move: function(e, prop, direction) {
    var newValue;
    if (e.altKey) {
      newValue = this['findWordBoundary' + direction](this[prop]);
    }
    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
      newValue = this['findLineBoundary' + direction](this[prop]);
    }
    else {
      this[prop] += direction === 'Left' ? -1 : 1;
      return true;
    }
    if (typeof newValue !== undefined && this[prop] !== newValue) {
      this[prop] = newValue;
      return true;
    }
  },

  /**
   * @private
   */
  _moveLeft: function(e, prop) {
    return this._move(e, prop, 'Left');
  },

  /**
   * @private
   */
  _moveRight: function(e, prop) {
    return this._move(e, prop, 'Right');
  },

  /**
   * Moves cursor left without keeping selection
   * @param {Event} e
   */
  moveCursorLeftWithoutShift: function(e) {
    var change = true;
    this._selectionDirection = 'left';

    // only move cursor when there is no selection,
    // otherwise we discard it, and leave cursor on same place
    if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
      change = this._moveLeft(e, 'selectionStart');

    }
    this.selectionEnd = this.selectionStart;
    return change;
  },

  /**
   * Moves cursor left while keeping selection
   * @param {Event} e
   */
  moveCursorLeftWithShift: function(e) {
    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
      return this._moveLeft(e, 'selectionEnd');
    }
    else if (this.selectionStart !== 0){
      this._selectionDirection = 'left';
      return this._moveLeft(e, 'selectionStart');
    }
  },

  /**
   * Moves cursor right
   * @param {Event} e Event object
   */
  moveCursorRight: function(e) {
    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
      return;
    }
    this._moveCursorLeftOrRight('Right', e);
  },

  /**
   * Moves cursor right or Left, fires event
   * @param {String} direction 'Left', 'Right'
   * @param {Event} e Event object
   */
  _moveCursorLeftOrRight: function(direction, e) {
    var actionName = 'moveCursor' + direction + 'With';
    this._currentCursorOpacity = 1;

    if (e.shiftKey) {
      actionName += 'Shift';
    }
    else {
      actionName += 'outShift';
    }
    if (this[actionName](e)) {
      this.abortCursorAnimation();
      this.initDelayedCursor();
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Moves cursor right while keeping selection
   * @param {Event} e
   */
  moveCursorRightWithShift: function(e) {
    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
      return this._moveRight(e, 'selectionStart');
    }
    else if (this.selectionEnd !== this._text.length) {
      this._selectionDirection = 'right';
      return this._moveRight(e, 'selectionEnd');
    }
  },

  /**
   * Moves cursor right without keeping selection
   * @param {Event} e Event object
   */
  moveCursorRightWithoutShift: function(e) {
    var changed = true;
    this._selectionDirection = 'right';

    if (this.selectionStart === this.selectionEnd) {
      changed = this._moveRight(e, 'selectionStart');
      this.selectionEnd = this.selectionStart;
    }
    else {
      this.selectionStart = this.selectionEnd;
    }
    return changed;
  },

  /**
   * Removes characters from start/end
   * start/end ar per grapheme position in _text array.
   *
   * @param {Number} start
   * @param {Number} end default to start + 1
   */
  removeChars: function(start, end) {
    if (typeof end === 'undefined') {
      end = start + 1;
    }
    this.removeStyleFromTo(start, end);
    this._text.splice(start, end - start);
    this.text = this._text.join('');
    this.set('dirty', true);
    if (this._shouldClearDimensionCache()) {
      this.initDimensions();
      this.setCoords();
    }
    this._removeExtraneousStyles();
  },

  /**
   * insert characters at start position, before start position.
   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1
   * if style array is provided, it must be as the same length of text in graphemes
   * if end is provided and is bigger than start, old text is replaced.
   * start/end ar per grapheme position in _text array.
   *
   * @param {String} text text to insert
   * @param {Array} style array of style objects
   * @param {Number} start
   * @param {Number} end default to start + 1
   */
  insertChars: function(text, style, start, end) {
    if (typeof end === 'undefined') {
      end = start;
    }
    if (end > start) {
      this.removeStyleFromTo(start, end);
    }
    var graphemes = fabric.util.string.graphemeSplit(text);
    this.insertNewStyleBlock(graphemes, start, style);
    this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));
    this.text = this._text.join('');
    this.set('dirty', true);
    if (this._shouldClearDimensionCache()) {
      this.initDimensions();
      this.setCoords();
    }
    this._removeExtraneousStyles();
  },

});


/* _TO_SVG_START_ */
(function() {
  var toFixed = fabric.util.toFixed,
      multipleSpacesRegex = /  +/g;

  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {

    /**
     * Returns SVG representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var offsets = this._getSVGLeftTopOffsets(),
          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft),
          internalMarkup = this._wrapSVGTextAndBg(textAndBg);
      return this._createBaseSVGMarkup(
        internalMarkup, { reviver: reviver, noStyle: true, withShadow: true });
    },

    /**
     * @private
     */
    _getSVGLeftTopOffsets: function() {
      return {
        textLeft: -this.width / 2,
        textTop: -this.height / 2,
        lineTop: this.getHeightOfLine(0)
      };
    },

    /**
     * @private
     */
    _wrapSVGTextAndBg: function(textAndBg) {
      var noShadow = true,
          textDecoration = this.getSvgTextDecoration(this);
      return [
        textAndBg.textBgRects.join(''),
        '\t\t<text xml:space="preserve" ',
        (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
        (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
        (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
        (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
        (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),
        'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
        textAndBg.textSpans.join(''),
        '</text>\n'
      ];
    },

    /**
     * @private
     * @param {Number} textTopOffset Text top offset
     * @param {Number} textLeftOffset Text left offset
     * @return {Object}
     */
    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
      var textSpans = [],
          textBgRects = [],
          height = textTopOffset, lineOffset;
      // bounding-box background
      this._setSVGBg(textBgRects);

      // text and text-background
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        lineOffset = this._getLineLeftOffset(i);
        if (this.textBackgroundColor || this.styleHas('textBackgroundColor', i)) {
          this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);
        }
        this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);
        height += this.getHeightOfLine(i);
      }

      return {
        textSpans: textSpans,
        textBgRects: textBgRects
      };
    },

    /**
     * @private
     */
    _createTextCharSpan: function(_char, styleDecl, left, top) {
      var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex),
          styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace),
          fillStyles = styleProps ? 'style="' + styleProps + '"' : '',
          dy = styleDecl.deltaY, dySpan = '',
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
      if (dy) {
        dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
      }
      return [
        '<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
        toFixed(top, NUM_FRACTION_DIGITS), '" ', dySpan,
        fillStyles, '>',
        fabric.util.string.escapeXml(_char),
        '</tspan>'
      ].join('');
    },

    _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {
      // set proper line offset
      var lineHeight = this.getHeightOfLine(lineIndex),
          isJustify = this.textAlign.indexOf('justify') !== -1,
          actualStyle,
          nextStyle,
          charsToRender = '',
          charBox, style,
          boxWidth = 0,
          line = this._textLines[lineIndex],
          timeToRender;

      textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;
      for (var i = 0, len = line.length - 1; i <= len; i++) {
        timeToRender = i === len || this.charSpacing;
        charsToRender += line[i];
        charBox = this.__charBounds[lineIndex][i];
        if (boxWidth === 0) {
          textLeftOffset += charBox.kernedWidth - charBox.width;
          boxWidth += charBox.width;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
        if (isJustify && !timeToRender) {
          if (this._reSpaceAndTab.test(line[i])) {
            timeToRender = true;
          }
        }
        if (!timeToRender) {
          // if we have charSpacing, we render char by char
          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
          timeToRender = this._hasStyleChangedForSvg(actualStyle, nextStyle);
        }
        if (timeToRender) {
          style = this._getStyleDeclaration(lineIndex, i) || { };
          textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));
          charsToRender = '';
          actualStyle = nextStyle;
          textLeftOffset += boxWidth;
          boxWidth = 0;
        }
      }
    },

    _pushTextBgRect: function(textBgRects, color, left, top, width, height) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
      textBgRects.push(
        '\t\t<rect ',
        this._getFillAttributes(color),
        ' x="',
        toFixed(left, NUM_FRACTION_DIGITS),
        '" y="',
        toFixed(top, NUM_FRACTION_DIGITS),
        '" width="',
        toFixed(width, NUM_FRACTION_DIGITS),
        '" height="',
        toFixed(height, NUM_FRACTION_DIGITS),
        '"></rect>\n');
    },

    _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {
      var line = this._textLines[i],
          heightOfLine = this.getHeightOfLine(i) / this.lineHeight,
          boxWidth = 0,
          boxStart = 0,
          charBox, currentColor,
          lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
      for (var j = 0, jlen = line.length; j < jlen; j++) {
        charBox = this.__charBounds[i][j];
        currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
        if (currentColor !== lastColor) {
          lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart,
            textTopOffset, boxWidth, heightOfLine);
          boxStart = charBox.left;
          boxWidth = charBox.width;
          lastColor = currentColor;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
      }
      currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart,
        textTopOffset, boxWidth, heightOfLine);
    },

    /**
     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
     * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
     *
     * @private
     * @param {*} value
     * @return {String}
     */
    _getFillAttributes: function(value) {
      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
        return 'fill="' + value + '"';
      }
      return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
    },

    /**
     * @private
     */
    _getSVGLineTopOffset: function(lineIndex) {
      var lineTopOffset = 0, lastHeight = 0;
      for (var j = 0; j < lineIndex; j++) {
        lineTopOffset += this.getHeightOfLine(j);
      }
      lastHeight = this.getHeightOfLine(j);
      return {
        lineTop: lineTopOffset,
        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
      };
    },

    /**
     * Returns styles-string for svg-export
     * @param {Boolean} skipShadow a boolean to skip shadow filter output
     * @return {String}
     */
    getSvgStyles: function(skipShadow) {
      var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);
      return svgStyle + ' white-space: pre;';
    },
  });
})();
/* _TO_SVG_END_ */


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = {});

  /**
   * Textbox class, based on IText, allows the user to resize the text rectangle
   * and wraps lines automatically. Textboxes have their Y scaling locked, the
   * user can only change width. Height is adjusted automatically based on the
   * wrapping of lines.
   * @class fabric.Textbox
   * @extends fabric.IText
   * @mixes fabric.Observable
   * @return {fabric.Textbox} thisArg
   * @see {@link fabric.Textbox#initialize} for constructor definition
   */
  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'textbox',

    /**
     * Minimum width of textbox, in pixels.
     * @type Number
     * @default
     */
    minWidth: 20,

    /**
     * Minimum calculated width of a textbox, in pixels.
     * fixed to 2 so that an empty textbox cannot go to 0
     * and is still selectable without text.
     * @type Number
     * @default
     */
    dynamicMinWidth: 2,

    /**
     * Cached array of text wrapping.
     * @type Array
     */
    __cachedLines: null,

    /**
     * Override standard Object class values
     */
    lockScalingFlip: true,

    /**
     * Override standard Object class values
     * Textbox needs this on false
     */
    noScaleCache: false,

    /**
     * Properties which when set cause object to change dimensions
     * @type Object
     * @private
     */
    _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat('width'),

    /**
     * Use this regular expression to split strings in breakable lines
     * @private
     */
    _wordJoiners: /[ \t\r\u200B\u200C]/,

    /**
     * Use this boolean property in order to split strings that have no white space concept.
     * this is a cheap way to help with chinese/japaense
     * @type Boolean
     * @since 2.6.0
     */
    splitByGrapheme: false,

    /**
     * Unlike superclass's version of this function, Textbox does not update
     * its width.
     * @private
     * @override
     */
    initDimensions: function() {
      if (this.__skipDimension) {
        return;
      }
      this.isEditing && this.initDelayedCursor();
      this.clearContextTop();
      this._clearCache();
      // clear dynamicMinWidth as it will be different after we re-wrap line
      this.dynamicMinWidth = 0;
      // wrap lines
      this._styleMap = this._generateStyleMap(this._splitText());
      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
      if (this.dynamicMinWidth > this.width) {
        this._set('width', this.dynamicMinWidth);
      }
      if (this.textAlign.indexOf('justify') !== -1) {
        // once text is measured we need to make space fatter to make justified text.
        this.enlargeSpaces();
      }
      // clear cache and re-calculate height
      this.height = this.calcTextHeight();
      this.saveState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * Generate an object that translates the style object so that it is
     * broken up by visual lines (new lines and automatic wrapping).
     * The original text styles object is broken up by actual lines (new lines only),
     * which is only sufficient for Text / IText
     * @private
     */
    _generateStyleMap: function(textInfo) {
      var realLineCount     = 0,
          realLineCharCount = 0,
          charCount         = 0,
          map               = {};

      for (var i = 0; i < textInfo.graphemeLines.length; i++) {
        if (textInfo.graphemeText[charCount] === '\n' && i > 0) {
          realLineCharCount = 0;
          charCount++;
          realLineCount++;
        }
        else if (this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {
          // this case deals with space's that are removed from end of lines when wrapping
          realLineCharCount++;
          charCount++;
        }

        map[i] = { line: realLineCount, offset: realLineCharCount };

        charCount += textInfo.graphemeLines[i].length;
        realLineCharCount += textInfo.graphemeLines[i].length;
      }

      return map;
    },

    /**
     * Returns true if object has a style property or has it ina specified line
     * @param {Number} lineIndex
     * @return {Boolean}
     */
    styleHas: function(property, lineIndex) {
      if (this._styleMap && !this.isWrapping) {
        var map = this._styleMap[lineIndex];
        if (map) {
          lineIndex = map.line;
        }
      }
      return fabric.Text.prototype.styleHas.call(this, property, lineIndex);
    },

    /**
     * Returns true if object has no styling or no styling in a line
     * @param {Number} lineIndex , lineIndex is on wrapped lines.
     * @return {Boolean}
     */
    isEmptyStyles: function(lineIndex) {
      var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false;
      var map = this._styleMap[lineIndex];
      var mapNextLine = this._styleMap[lineIndex + 1];
      if (map) {
        lineIndex = map.line;
        offset = map.offset;
      }
      if (mapNextLine) {
        nextLineIndex = mapNextLine.line;
        shouldLimit = nextLineIndex === lineIndex;
        nextOffset = mapNextLine.offset;
      }
      obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
      for (var p1 in obj) {
        for (var p2 in obj[p1]) {
          if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {
            // eslint-disable-next-line no-unused-vars
            for (var p3 in obj[p1][p2]) {
              return false;
            }
          }
        }
      }
      return true;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _getStyleDeclaration: function(lineIndex, charIndex) {
      if (this._styleMap && !this.isWrapping) {
        var map = this._styleMap[lineIndex];
        if (!map) {
          return null;
        }
        lineIndex = map.line;
        charIndex = map.offset + charIndex;
      }
      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex);
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {Object} style
     * @private
     */
    _setStyleDeclaration: function(lineIndex, charIndex, style) {
      var map = this._styleMap[lineIndex];
      lineIndex = map.line;
      charIndex = map.offset + charIndex;

      this.styles[lineIndex][charIndex] = style;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _deleteStyleDeclaration: function(lineIndex, charIndex) {
      var map = this._styleMap[lineIndex];
      lineIndex = map.line;
      charIndex = map.offset + charIndex;

      delete this.styles[lineIndex][charIndex];
    },

    /**
    * probably broken need a fix
     * @param {Number} lineIndex
     * @private
     */
    _getLineStyle: function(lineIndex) {
      var map = this._styleMap[lineIndex];
      return this.styles[map.line];
    },

    /**
     * probably broken need a fix
     * @param {Number} lineIndex
     * @param {Object} style
     * @private
     */
    _setLineStyle: function(lineIndex, style) {
      var map = this._styleMap[lineIndex];
      this.styles[map.line] = style;
    },

    /**
     * probably broken need a fix
     * @param {Number} lineIndex
     * @private
     */
    _deleteLineStyle: function(lineIndex) {
      var map = this._styleMap[lineIndex];
      delete this.styles[map.line];
    },

    /**
     * Wraps text using the 'width' property of Textbox. First this function
     * splits text on newlines, so we preserve newlines entered by the user.
     * Then it wraps each line using the width of the Textbox by calling
     * _wrapLine().
     * @param {Array} lines The string array of text that is split into lines
     * @param {Number} desiredWidth width you want to wrap to
     * @returns {Array} Array of lines
     */
    _wrapText: function(lines, desiredWidth) {
      var wrapped = [], i;
      this.isWrapping = true;
      for (i = 0; i < lines.length; i++) {
        wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));
      }
      this.isWrapping = false;
      return wrapped;
    },

    /**
     * Helper function to measure a string of text, given its lineIndex and charIndex offset
     * it gets called when charBounds are not available yet.
     * @param {CanvasRenderingContext2D} ctx
     * @param {String} text
     * @param {number} lineIndex
     * @param {number} charOffset
     * @returns {number}
     * @private
     */
    _measureWord: function(word, lineIndex, charOffset) {
      var width = 0, prevGrapheme, skipLeft = true;
      charOffset = charOffset || 0;
      for (var i = 0, len = word.length; i < len; i++) {
        var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);
        width += box.kernedWidth;
        prevGrapheme = word[i];
      }
      return width;
    },

    /**
     * Wraps a line of text using the width of the Textbox and a context.
     * @param {Array} line The grapheme array that represent the line
     * @param {Number} lineIndex
     * @param {Number} desiredWidth width you want to wrap the line to
     * @param {Number} reservedSpace space to remove from wrapping for custom functionalities
     * @returns {Array} Array of line(s) into which the given text is wrapped
     * to.
     */
    _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {
      var lineWidth = 0,
          splitByGrapheme = this.splitByGrapheme,
          graphemeLines = [],
          line = [],
          // spaces in different languges?
          words = splitByGrapheme ? fabric.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners),
          word = '',
          offset = 0,
          infix = splitByGrapheme ? '' : ' ',
          wordWidth = 0,
          infixWidth = 0,
          largestWordWidth = 0,
          lineJustStarted = true,
          additionalSpace = splitByGrapheme ? 0 : this._getWidthOfCharSpacing(),
          reservedSpace = reservedSpace || 0;

      desiredWidth -= reservedSpace;
      for (var i = 0; i < words.length; i++) {
        // i would avoid resplitting the graphemes
        word = fabric.util.string.graphemeSplit(words[i]);
        wordWidth = this._measureWord(word, lineIndex, offset);
        offset += word.length;

        lineWidth += infixWidth + wordWidth - additionalSpace;

        if (lineWidth >= desiredWidth && !lineJustStarted) {
          graphemeLines.push(line);
          line = [];
          lineWidth = wordWidth;
          lineJustStarted = true;
        }
        else {
          lineWidth += additionalSpace;
        }

        if (!lineJustStarted) {
          line.push(infix);
        }
        line = line.concat(word);

        infixWidth = this._measureWord([infix], lineIndex, offset);
        offset++;
        lineJustStarted = false;
        // keep track of largest word
        if (wordWidth > largestWordWidth) {
          largestWordWidth = wordWidth;
        }
      }

      i && graphemeLines.push(line);

      if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {
        this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;
      }

      return graphemeLines;
    },

    /**
     * Detect if the text line is ended with an hard break
     * text and itext do not have wrapping, return false
     * @param {Number} lineIndex text to split
     * @return {Boolean}
     */
    isEndOfWrapping: function(lineIndex) {
      if (!this._styleMap[lineIndex + 1]) {
        // is last line, return true;
        return true;
      }
      if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {
        // this is last line before a line break, return true;
        return true;
      }
      return false;
    },

    /**
    * Gets lines of text to render in the Textbox. This function calculates
    * text wrapping on the fly every time it is called.
    * @param {String} text text to split
    * @returns {Array} Array of lines in the Textbox.
    * @override
    */
    _splitTextIntoLines: function(text) {
      var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text),
          graphemeLines = this._wrapText(newText.lines, this.width),
          lines = new Array(graphemeLines.length);

      for (var i = 0; i < graphemeLines.length; i++) {
        lines[i] = graphemeLines[i].join('');
      }
      newText.lines = lines;
      newText.graphemeLines = graphemeLines;
      return newText;
    },

    getMinWidth: function() {
      return Math.max(this.minWidth, this.dynamicMinWidth);
    },

    /**
     * Returns object representation of an instance
     * @method toObject
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['minWidth', 'splitByGrapheme'].concat(propertiesToInclude));
    }
  });

  /**
   * Returns fabric.Textbox instance from an object representation
   * @static
   * @memberOf fabric.Textbox
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created
   */
  fabric.Textbox.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Textbox', object, callback, 'text');
  };
})( true ? exports : undefined);


(function() {

  /**
   * Override _setObjectScale and add Textbox specific resizing behavior. Resizing
   * a Textbox doesn't scale text, it only changes width and makes text wrap automatically.
   */
  var setObjectScaleOverridden = fabric.Canvas.prototype._setObjectScale;

  fabric.Canvas.prototype._setObjectScale = function(localMouse, transform,
    lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {

    var t = transform.target, scaled,
        scaleX = localMouse.x * t.scaleX / _dim.x,
        scaleY = localMouse.y * t.scaleY / _dim.y;
    if (by === 'x' && t instanceof fabric.Textbox) {
      var tw = t._getTransformedDimensions().x;
      var w = t.width * (localMouse.x / tw);
      transform.newScaleX = scaleX;
      transform.newScaleY = scaleY;
      if (w >= t.getMinWidth()) {
        scaled = w !== t.width;
        t.set('width', w);
        return scaled;
      }
    }
    else {
      return setObjectScaleOverridden.call(fabric.Canvas.prototype, localMouse, transform,
        lockScalingX, lockScalingY, by, lockScalingFlip, _dim);
    }
  };

  fabric.util.object.extend(fabric.Textbox.prototype, /** @lends fabric.IText.prototype */ {
    /**
     * @private
     */
    _removeExtraneousStyles: function() {
      for (var prop in this._styleMap) {
        if (!this._textLines[prop]) {
          delete this.styles[this._styleMap[prop].line];
        }
      }
    },

  });
})();


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/app/index.ts":
/*!**************************!*\
  !*** ./src/app/index.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fabric_1 = __webpack_require__(/*! fabric */ "./node_modules/fabric/dist/fabric.js");
var Rectangle_1 = __webpack_require__(/*! ./model/Rectangle */ "./src/app/model/Rectangle.ts");
var Color_1 = __webpack_require__(/*! ./model/Color */ "./src/app/model/Color.ts");
var canvas = new fabric_1.fabric.Canvas("canvas");
var defaultValue = new Rectangle_1.Rectangle(100, 160, 170);
defaultValue.setColor(Color_1.Color.Green);
var rect = new fabric_1.fabric.Rect({
    top: 100,
    left: defaultValue.Left,
    width: defaultValue.Width,
    height: defaultValue.Height,
    fill: defaultValue.FillColor
});
canvas.add(rect);


/***/ }),

/***/ "./src/app/model/Color.ts":
/*!********************************!*\
  !*** ./src/app/model/Color.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Color;
(function (Color) {
    Color["Red"] = "red";
    Color["Green"] = "green";
    Color["Blue"] = "blue";
})(Color = exports.Color || (exports.Color = {}));


/***/ }),

/***/ "./src/app/model/Rectangle.ts":
/*!************************************!*\
  !*** ./src/app/model/Rectangle.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Rectangle = /** @class */ (function () {
    function Rectangle(left, width, height) {
        this.Left = left;
        this.Width = width;
        this.Height = height;
        this.FillColor = "";
    }
    Rectangle.prototype.setColor = function (color) {
        this.FillColor = color;
    };
    return Rectangle;
}());
exports.Rectangle = Rectangle;


/***/ }),

/***/ 0:
/*!***********************!*\
  !*** jsdom (ignored) ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!********************************************************!*\
  !*** jsdom/lib/jsdom/living/generated/utils (ignored) ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!***************************************!*\
  !*** jsdom/lib/jsdom/utils (ignored) ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!************************!*\
  !*** xmldom (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYWJyaWMvZGlzdC9mYWJyaWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvbW9kZWwvQ29sb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9tb2RlbC9SZWN0YW5nbGUudHMiLCJ3ZWJwYWNrOi8vL2pzZG9tIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vanNkb20vbGliL2pzZG9tL2xpdmluZy9nZW5lcmF0ZWQvdXRpbHMgKGlnbm9yZWQpIiwid2VicGFjazovLy9qc2RvbS9saWIvanNkb20vdXRpbHMgKGlnbm9yZWQpIiwid2VicGFjazovLy94bWxkb20gKGlnbm9yZWQpIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixFQUFFOztBQUVyQjtBQUNBLGtCQUFrQixFQUFFOztBQUVwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6QixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxTQUFTO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEVBQUU7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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TUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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T0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsS0FBOEIsYUFBYSxTQUFJOzs7QUFHbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVILENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUMsK0JBQStCLGNBQWM7QUFDN0MsK0JBQStCLGNBQWM7QUFDN0MsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxREFBcUQ7QUFDbEUsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUIsRUFBRTtBQUNuRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDhEQUE4RDtBQUNySCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQsU0FBUztBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxVQUFVO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxTQUFTOztBQUV0RDs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxvQ0FBb0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLFdBQVcsOEJBQThCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FB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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNB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Q0FBQyxJQUFJLENBQUM7SUFDdkIsR0FBRyxFQUFHLEdBQUc7SUFDRCxJQUFJLEVBQUcsWUFBWSxDQUFDLElBQUk7SUFDeEIsS0FBSyxFQUFHLFlBQVksQ0FBQyxLQUFLO0lBQzFCLE1BQU0sRUFBRyxZQUFZLENBQUMsTUFBTTtJQUM1QixJQUFJLEVBQUcsWUFBWSxDQUFDLFNBQVM7Q0FDeEMsQ0FBQyxDQUFDO0FBRUgsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FDaEJqQixJQUFZLEtBSVg7QUFKRCxXQUFZLEtBQUs7SUFDYixvQkFBVztJQUNYLHdCQUFlO0lBQ2Ysc0JBQWE7QUFDakIsQ0FBQyxFQUpXLEtBQUssR0FBTCxhQUFLLEtBQUwsYUFBSyxRQUloQjs7Ozs7Ozs7Ozs7Ozs7O0FDQUQ7SUFPSSxtQkFBWSxJQUFhLEVBQUUsS0FBWSxFQUFFLE1BQWU7UUFFcEQsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBSSxNQUFNLENBQUM7UUFDdEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVNLDRCQUFRLEdBQWYsVUFBZ0IsS0FBYTtRQUV6QixJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztJQUMzQixDQUFDO0lBQ0wsZ0JBQUM7QUFBRCxDQUFDO0FBbkJZLDhCQUFTOzs7Ozs7Ozs7Ozs7QUNKdEIsZTs7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7O0FDQUEsZSIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9hcHBcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvYXBwL2luZGV4LnRzXCIpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvKiBidWlsZDogYG5vZGUgYnVpbGQuanMgbW9kdWxlcz1BTEwgZXhjbHVkZT1nZXN0dXJlcyxhY2Nlc3NvcnMgcmVxdWlyZWpzIG1pbmlmaWVyPXVnbGlmeWpzYCAqL1xuLyohIEZhYnJpYy5qcyBDb3B5cmlnaHQgMjAwOC0yMDE1LCBQcmludGlvIChKdXJpeSBaYXl0c2V2LCBNYXhpbSBDaGVybnlhaykgKi9cblxudmFyIGZhYnJpYyA9IGZhYnJpYyB8fCB7IHZlcnNpb246ICcyLjYuMCcgfTtcbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZXhwb3J0cy5mYWJyaWMgPSBmYWJyaWM7XG59XG4vKiBfQU1EX1NUQVJUXyAqL1xuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBmYWJyaWM7IH0pO1xufVxuLyogX0FNRF9FTkRfICovXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBmYWJyaWMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgZmFicmljLndpbmRvdyA9IHdpbmRvdztcbn1cbmVsc2Uge1xuICAvLyBhc3N1bWUgd2UncmUgcnVubmluZyB1bmRlciBub2RlLmpzIHdoZW4gZG9jdW1lbnQvd2luZG93IGFyZSBub3QgcHJlc2VudFxuICBmYWJyaWMuZG9jdW1lbnQgPSByZXF1aXJlKCdqc2RvbScpXG4gICAgLmpzZG9tKFxuICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KCclM0MhRE9DVFlQRSUyMGh0bWwlM0UlM0NodG1sJTNFJTNDaGVhZCUzRSUzQyUyRmhlYWQlM0UlM0Nib2R5JTNFJTNDJTJGYm9keSUzRSUzQyUyRmh0bWwlM0UnKSxcbiAgICAgIHsgZmVhdHVyZXM6IHtcbiAgICAgICAgRmV0Y2hFeHRlcm5hbFJlc291cmNlczogWydpbWcnXVxuICAgICAgfVxuICAgICAgfSk7XG4gIGZhYnJpYy5qc2RvbUltcGxGb3JXcmFwcGVyID0gcmVxdWlyZSgnanNkb20vbGliL2pzZG9tL2xpdmluZy9nZW5lcmF0ZWQvdXRpbHMnKS5pbXBsRm9yV3JhcHBlcjtcbiAgZmFicmljLm5vZGVDYW52YXMgPSByZXF1aXJlKCdqc2RvbS9saWIvanNkb20vdXRpbHMnKS5DYW52YXM7XG4gIGZhYnJpYy53aW5kb3cgPSBmYWJyaWMuZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIERPTVBhcnNlciA9IHJlcXVpcmUoJ3htbGRvbScpLkRPTVBhcnNlcjtcbn1cblxuLyoqXG4gKiBUcnVlIHdoZW4gaW4gZW52aXJvbm1lbnQgdGhhdCBzdXBwb3J0cyB0b3VjaCBldmVudHNcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xuZmFicmljLmlzVG91Y2hTdXBwb3J0ZWQgPSAnb250b3VjaHN0YXJ0JyBpbiBmYWJyaWMud2luZG93IHx8ICdvbnRvdWNoc3RhcnQnIGluIGZhYnJpYy5kb2N1bWVudCB8fFxuICAoZmFicmljLndpbmRvdyAmJiBmYWJyaWMud2luZG93Lm5hdmlnYXRvciAmJiBmYWJyaWMud2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDApO1xuXG4vKipcbiAqIFRydWUgd2hlbiBpbiBlbnZpcm9ubWVudCB0aGF0J3MgcHJvYmFibHkgTm9kZS5qc1xuICogQHR5cGUgYm9vbGVhblxuICovXG5mYWJyaWMuaXNMaWtlbHlOb2RlID0gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcblxuLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuLyoqXG4gKiBBdHRyaWJ1dGVzIHBhcnNlZCBmcm9tIGFsbCBTVkcgZWxlbWVudHNcbiAqIEB0eXBlIGFycmF5XG4gKi9cbmZhYnJpYy5TSEFSRURfQVRUUklCVVRFUyA9IFtcbiAgJ2Rpc3BsYXknLFxuICAndHJhbnNmb3JtJyxcbiAgJ2ZpbGwnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsXG4gICdvcGFjaXR5JyxcbiAgJ3N0cm9rZScsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsXG4gICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLFxuICAnaWQnLCAncGFpbnQtb3JkZXInLFxuICAnaW5zdGFudGlhdGVkX2J5X3VzZScsICdjbGlwLXBhdGgnXG5dO1xuLyogX0ZST01fU1ZHX0VORF8gKi9cblxuLyoqXG4gKiBQaXhlbCBwZXIgSW5jaCBhcyBhIGRlZmF1bHQgdmFsdWUgc2V0IHRvIDk2LiBDYW4gYmUgY2hhbmdlZCBmb3IgbW9yZSByZWFsaXN0aWMgY29udmVyc2lvbi5cbiAqL1xuZmFicmljLkRQSSA9IDk2O1xuZmFicmljLnJlTnVtID0gJyg/OlstK10/KD86XFxcXGQrfFxcXFxkKlxcXFwuXFxcXGQrKSg/OmVbLStdP1xcXFxkKyk/KSc7XG5mYWJyaWMuZm9udFBhdGhzID0geyB9O1xuZmFicmljLmlNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF07XG5mYWJyaWMuY2FudmFzTW9kdWxlID0gJ2NhbnZhcyc7XG5cbi8qKlxuICogUGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzLiAxTXB4ICwgNE1weCBzaG91bGQgYmUgZmluZS5cbiAqIEBzaW5jZSAxLjcuMTRcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbCA9IDIwOTcxNTI7XG5cbi8qKlxuICogUGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzIHdpZHRoIG9yIGhlaWdodC4gSUUgZml4ZXMgdGhlIG1heGltdW0gYXQgNTAwMFxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMubWF4Q2FjaGVTaWRlTGltaXQgPSA0MDk2O1xuXG4vKipcbiAqIExvd2VzdCBwaXhlbCBsaW1pdCBmb3IgY2FjaGUgY2FudmFzZXMsIHNldCBhdCAyNTZQWFxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMubWluQ2FjaGVTaWRlTGltaXQgPSAyNTY7XG5cbi8qKlxuICogQ2FjaGUgT2JqZWN0IGZvciB3aWR0aHMgb2YgY2hhcnMgaW4gdGV4dCByZW5kZXJpbmcuXG4gKi9cbmZhYnJpYy5jaGFyV2lkdGhzQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogaWYgd2ViZ2wgaXMgZW5hYmxlZCBhbmQgYXZhaWxhYmxlLCB0ZXh0dXJlU2l6ZSB3aWxsIGRldGVybWluZSB0aGUgc2l6ZVxuICogb2YgdGhlIGNhbnZhcyBiYWNrZW5kXG4gKiBAc2luY2UgMi4wLjBcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLnRleHR1cmVTaXplID0gMjA0ODtcblxuLyoqXG4gKiBFbmFibGUgd2ViZ2wgZm9yIGZpbHRlcmluZyBwaWN0dXJlIGlzIGF2YWlsYWJsZVxuICogQSBmaWx0ZXJpbmcgYmFja2VuZCB3aWxsIGJlIGluaXRpYWxpemVkLCB0aGlzIHdpbGwgYm90aCB0YWtlIG1lbW9yeSBhbmRcbiAqIHRpbWUgc2luY2UgYSBkZWZhdWx0IDIwNDh4MjA0OCBjYW52YXMgd2lsbCBiZSBjcmVhdGVkIGZvciB0aGUgZ2wgY29udGV4dFxuICogQHNpbmNlIDIuMC4wXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMuZW5hYmxlR0xGaWx0ZXJpbmcgPSB0cnVlO1xuXG4vKipcbiAqIERldmljZSBQaXhlbCBSYXRpb1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9zYWZhcmkvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvSFRNTC1jYW52YXMtZ3VpZGUvU2V0dGluZ1VwdGhlQ2FudmFzL1NldHRpbmdVcHRoZUNhbnZhcy5odG1sXG4gKi9cbmZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvID0gZmFicmljLndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cud2Via2l0RGV2aWNlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1vekRldmljZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMTtcbi8qKlxuICogQnJvd3Nlci1zcGVjaWZpYyBjb25zdGFudCB0byBhZGp1c3QgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnNoYWRvd0JsdXIgdmFsdWUsXG4gKiB3aGljaCBpcyB1bml0bGVzcyBhbmQgbm90IHJlbmRlcmVkIGVxdWFsbHkgYWNyb3NzIGJyb3dzZXJzLlxuICpcbiAqIFZhbHVlcyB0aGF0IHdvcmsgcXVpdGUgd2VsbCAoYXMgb2YgT2N0b2JlciAyMDE3KSBhcmU6XG4gKiAtIENocm9tZTogMS41XG4gKiAtIEVkZ2U6IDEuNzVcbiAqIC0gRmlyZWZveDogMC45XG4gKiAtIFNhZmFyaTogMC45NVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdCAxXG4gKi9cbmZhYnJpYy5icm93c2VyU2hhZG93Qmx1ckNvbnN0YW50ID0gMTtcblxuLyoqXG4gKiBUaGlzIG9iamVjdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIGFyYyB0byBiZWl6ZXIgY29udmVyc2lvbiBmb3IgZmFzdGVyIHJldHJpZXZpbmcgaWYgdGhlIHNhbWUgYXJjIG5lZWRzIHRvIGJlIGNvbnZlcnRlZCBhZ2Fpbi5cbiAqIEl0IHdhcyBhbiBpbnRlcm5hbCB2YXJpYWJsZSwgaXMgYWNjZXNzaWJsZSBzaW5jZSB2ZXJzaW9uIDIuMy40XG4gKi9cbmZhYnJpYy5hcmNUb1NlZ21lbnRzQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogVGhpcyBvYmplY3Qga2VlcHMgdGhlIHJlc3VsdHMgb2YgdGhlIGJvdW5kc09mQ3VydmUgY2FsY3VsYXRpb24gbWFwcGVkIGJ5IHRoZSBqb2luZWQgYXJndW1lbnRzIG5lY2Vzc2FyeSB0byBjYWxjdWxhdGUgaXQuXG4gKiBJdCBkb2VzIHNwZWVkIHVwIGNhbGN1bGF0aW9uLCBpZiB5b3UgcGFyc2UgYW5kIGFkZCBhbHdheXMgdGhlIHNhbWUgcGF0aHMsIGJ1dCBpbiBjYXNlIG9mIGhlYXZ5IHVzYWdlIG9mIGZyZWVkcmF3aW5nXG4gKiB5b3UgZG8gbm90IGdldCBhbnkgc3BlZWQgYmVuZWZpdCBhbmQgeW91IGdldCBhIGJpZyBvYmplY3QgaW4gbWVtb3J5LlxuICogVGhlIG9iamVjdCB3YXMgYSBwcml2YXRlIHZhcmlhYmxlIGJlZm9yZSwgd2hpbGUgbm93IGlzIGFwcGVuZGVkIHRvIHRoZSBsaWIgc28gdGhhdCB5b3UgaGF2ZSBhY2Nlc3MgdG8gaXQgYW5kIHlvdVxuICogY2FuIGV2ZW50dWFsbHkgY2xlYXIgaXQuXG4gKiBJdCB3YXMgYW4gaW50ZXJuYWwgdmFyaWFibGUsIGlzIGFjY2Vzc2libGUgc2luY2UgdmVyc2lvbiAyLjMuNFxuICovXG5mYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlID0geyB9O1xuXG4vKipcbiAqIElmIGRpc2FibGVkIGJvdW5kc09mQ3VydmVDYWNoZSBpcyBub3QgdXNlZC4gRm9yIGFwcHMgdGhhdCBtYWtlIGhlYXZ5IHVzYWdlIG9mIHBlbmNpbCBkcmF3aW5nIHByb2JhYmx5IGRpc2FibGluZyBpdCBpcyBiZXR0ZXJcbiAqIEBkZWZhdWx0IHRydWVcbiAqL1xuZmFicmljLmNhY2hlc0JvdW5kc09mQ3VydmUgPSB0cnVlO1xuXG5mYWJyaWMuaW5pdEZpbHRlckJhY2tlbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGZhYnJpYy5lbmFibGVHTEZpbHRlcmluZyAmJiBmYWJyaWMuaXNXZWJnbFN1cHBvcnRlZCAmJiBmYWJyaWMuaXNXZWJnbFN1cHBvcnRlZChmYWJyaWMudGV4dHVyZVNpemUpKSB7XG4gICAgY29uc29sZS5sb2coJ21heCB0ZXh0dXJlIHNpemU6ICcgKyBmYWJyaWMubWF4VGV4dHVyZVNpemUpO1xuICAgIHJldHVybiAobmV3IGZhYnJpYy5XZWJnbEZpbHRlckJhY2tlbmQoeyB0aWxlU2l6ZTogZmFicmljLnRleHR1cmVTaXplIH0pKTtcbiAgfVxuICBlbHNlIGlmIChmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kKSB7XG4gICAgcmV0dXJuIChuZXcgZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZCgpKTtcbiAgfVxufTtcblxuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBlbnN1cmUgZ2xvYmFsaXR5IGV2ZW4gaWYgZW50aXJlIGxpYnJhcnkgd2VyZSBmdW5jdGlvbiB3cmFwcGVkIChhcyBpbiBNZXRlb3IuanMgcGFja2FnaW5nIHN5c3RlbSlcbiAgd2luZG93LmZhYnJpYyA9IGZhYnJpYztcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBldmVudExpc3RlbmVyW2V2ZW50TGlzdGVuZXIuaW5kZXhPZihoYW5kbGVyKV0gPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmYWJyaWMudXRpbC5hcnJheS5maWxsKGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZXMgc3BlY2lmaWVkIGV2ZW50XG4gICAqIEBkZXByZWNhdGVkIGBvYnNlcnZlYCBkZXByZWNhdGVkIHNpbmNlIDAuOC4zNCAodXNlIGBvbmAgaW5zdGVhZClcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBhbGlhcyBvblxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50TmFtZSBFdmVudCBuYW1lIChlZy4gJ2FmdGVyOnJlbmRlcicpIG9yIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyAoZWcuIHsnYWZ0ZXI6cmVuZGVyJzogaGFuZGxlciwgJ3NlbGVjdGlvbjpjbGVhcmVkJzogaGFuZGxlcn0pXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnMgPSB7IH07XG4gICAgfVxuICAgIC8vIG9uZSBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgd2FzIHBhc3NlZFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLm9uKHByb3AsIGV2ZW50TmFtZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSkge1xuICAgICAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgZXZlbnQgb2JzZXJ2aW5nIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQgaGFuZGxlci4gQ2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiB3aXRob3V0IGFyZ3VtZW50cyByZW1vdmVzIGFsbCBoYW5kbGVycyBmb3IgYWxsIGV2ZW50c1xuICAgKiBAZGVwcmVjYXRlZCBgc3RvcE9ic2VydmluZ2AgZGVwcmVjYXRlZCBzaW5jZSAwLjguMzQgKHVzZSBgb2ZmYCBpbnN0ZWFkKVxuICAgKiBAbWVtYmVyT2YgZmFicmljLk9ic2VydmFibGVcbiAgICogQGFsaWFzIG9mZlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50TmFtZSBFdmVudCBuYW1lIChlZy4gJ2FmdGVyOnJlbmRlcicpIG9yIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyAoZWcuIHsnYWZ0ZXI6cmVuZGVyJzogaGFuZGxlciwgJ3NlbGVjdGlvbjpjbGVhcmVkJzogaGFuZGxlcn0pXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdG8gYmUgZGVsZXRlZCBmcm9tIEV2ZW50TGlzdGVuZXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gc3RvcE9ic2VydmluZyhldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbGwga2V5L3ZhbHVlIHBhaXJzIChldmVudCBuYW1lIC0+IGV2ZW50IGhhbmRsZXIpXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAoZXZlbnROYW1lIGluIHRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9uZSBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgd2FzIHBhc3NlZFxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgcHJvcCwgZXZlbnROYW1lW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGV2ZW50IHdpdGggYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAgICogQGRlcHJlY2F0ZWQgYGZpcmVgIGRlcHJlY2F0ZWQgc2luY2UgMS4wLjcgKHVzZSBgdHJpZ2dlcmAgaW5zdGVhZClcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBhbGlhcyB0cmlnZ2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZSB0byBmaXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBmaXJlKGV2ZW50TmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVyc0ZvckV2ZW50ID0gdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgaWYgKCFsaXN0ZW5lcnNGb3JFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnNGb3JFdmVudC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGlzdGVuZXJzRm9yRXZlbnRbaV0gJiYgbGlzdGVuZXJzRm9yRXZlbnRbaV0uY2FsbCh0aGlzLCBvcHRpb25zIHx8IHsgfSk7XG4gICAgfVxuICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdID0gbGlzdGVuZXJzRm9yRXZlbnQuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLk9ic2VydmFibGVcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjZXZlbnRzfVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2V2ZW50c3xFdmVudHMgZGVtb31cbiAgICovXG4gIGZhYnJpYy5PYnNlcnZhYmxlID0ge1xuICAgIG9ic2VydmU6IG9ic2VydmUsXG4gICAgc3RvcE9ic2VydmluZzogc3RvcE9ic2VydmluZyxcbiAgICBmaXJlOiBmaXJlLFxuXG4gICAgb246IG9ic2VydmUsXG4gICAgb2ZmOiBzdG9wT2JzZXJ2aW5nLFxuICAgIHRyaWdnZXI6IGZpcmVcbiAgfTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5Db2xsZWN0aW9uXG4gKi9cbmZhYnJpYy5Db2xsZWN0aW9uID0ge1xuXG4gIF9vYmplY3RzOiBbXSxcblxuICAvKipcbiAgICogQWRkcyBvYmplY3RzIHRvIGNvbGxlY3Rpb24sIENhbnZhcyBvciBHcm91cCwgdGhlbiByZW5kZXJzIGNhbnZhc1xuICAgKiAoaWYgYHJlbmRlck9uQWRkUmVtb3ZlYCBpcyBub3QgYGZhbHNlYCkuXG4gICAqIGluIGNhc2Ugb2YgR3JvdXAgbm8gY2hhbmdlcyB0byBib3VuZGluZyBib3ggYXJlIG1hZGUuXG4gICAqIE9iamVjdHMgc2hvdWxkIGJlIGluc3RhbmNlcyBvZiAob3IgaW5oZXJpdCBmcm9tKSBmYWJyaWMuT2JqZWN0XG4gICAqIFVzZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBmb3IgZ3JvdXBzLlxuICAgKiB5b3UgY2FuIGFkZCBhIGJ1bmNoIG9mIG9iamVjdHMgd2l0aCB0aGUgYWRkIG1ldGhvZCBidXQgdGhlbiB5b3UgTkVFRFxuICAgKiB0byBydW4gYSBhZGRXaXRoVXBkYXRlIGNhbGwgZm9yIHRoZSBHcm91cCBjbGFzcyBvciBwb3NpdGlvbi9iYm94IHdpbGwgYmUgd3JvbmcuXG4gICAqIEBwYXJhbSB7Li4uZmFicmljLk9iamVjdH0gb2JqZWN0IFplcm8gb3IgbW9yZSBmYWJyaWMgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fb2JqZWN0cy5wdXNoLmFwcGx5KHRoaXMuX29iamVjdHMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuX29uT2JqZWN0QWRkZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fb25PYmplY3RBZGRlZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGFuIG9iamVjdCBpbnRvIGNvbGxlY3Rpb24gYXQgc3BlY2lmaWVkIGluZGV4LCB0aGVuIHJlbmRlcnMgY2FudmFzIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKVxuICAgKiBBbiBvYmplY3Qgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIChvciBpbmhlcml0IGZyb20pIGZhYnJpYy5PYmplY3RcbiAgICogVXNlIG9mIHRoaXMgZnVuY3Rpb24gaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGZvciBncm91cHMuXG4gICAqIHlvdSBjYW4gYWRkIGEgYnVuY2ggb2Ygb2JqZWN0cyB3aXRoIHRoZSBpbnNlcnRBdCBtZXRob2QgYnV0IHRoZW4geW91IE5FRURcbiAgICogdG8gcnVuIGEgYWRkV2l0aFVwZGF0ZSBjYWxsIGZvciB0aGUgR3JvdXAgY2xhc3Mgb3IgcG9zaXRpb24vYmJveCB3aWxsIGJlIHdyb25nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IHRvIGluc2VydCBvYmplY3QgYXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBub25TcGxpY2luZyBXaGVuIGB0cnVlYCwgbm8gc3BsaWNpbmcgKHNoaWZ0aW5nKSBvZiBvYmplY3RzIG9jY3Vyc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGluc2VydEF0OiBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgbm9uU3BsaWNpbmcpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHM7XG4gICAgaWYgKG5vblNwbGljaW5nKSB7XG4gICAgICBvYmplY3RzW2luZGV4XSA9IG9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvYmplY3RzLnNwbGljZShpbmRleCwgMCwgb2JqZWN0KTtcbiAgICB9XG4gICAgdGhpcy5fb25PYmplY3RBZGRlZCAmJiB0aGlzLl9vbk9iamVjdEFkZGVkKG9iamVjdCk7XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBvYmplY3RzIGZyb20gYSBjb2xsZWN0aW9uLCB0aGVuIHJlbmRlcnMgY2FudmFzIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKVxuICAgKiBAcGFyYW0gey4uLmZhYnJpYy5PYmplY3R9IG9iamVjdCBaZXJvIG9yIG1vcmUgZmFicmljIGluc3RhbmNlc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuICAgICAgICBpbmRleCwgc29tZXRoaW5nUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2YoYXJndW1lbnRzW2ldKTtcblxuICAgICAgLy8gb25seSBjYWxsIG9uT2JqZWN0UmVtb3ZlZCBpZiBhbiBvYmplY3Qgd2FzIGFjdHVhbGx5IHJlbW92ZWRcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc29tZXRoaW5nUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIG9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5fb25PYmplY3RSZW1vdmVkICYmIHRoaXMuX29uT2JqZWN0UmVtb3ZlZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgc29tZXRoaW5nUmVtb3ZlZCAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggb2JqZWN0IGluIHRoaXMgZ3JvdXBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGN1cnJlbnQgb2JqZWN0IGFzIGZpcnN0IGFyZ3VtZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICBpbmRleCAtIGFzIHNlY29uZCBhbmQgYW4gYXJyYXkgb2YgYWxsIG9iamVjdHMgLSBhcyB0aGlyZC5cbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaXMgaW52b2tlZCBpbiBhIGNvbnRleHQgb2YgR2xvYmFsIE9iamVjdCAoZS5nLiBgd2luZG93YClcbiAgICogICAgICAgICAgICAgICAgICAgd2hlbiBubyBgY29udGV4dGAgYXJndW1lbnQgaXMgZ2l2ZW5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgQ29udGV4dCAoYWthIHRoaXNPYmplY3QpXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZm9yRWFjaE9iamVjdDogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG9iamVjdHNbaV0sIGksIG9iamVjdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjaGlsZHJlbiBvYmplY3RzIG9mIHRoaXMgaW5zdGFuY2VcbiAgICogVHlwZSBwYXJhbWV0ZXIgaW50cm9kdWNlZCBpbiAxLjMuMTBcbiAgICogc2luY2UgMi4zLjUgdGhpcyBtZXRob2QgcmV0dXJuIGFsd2F5cyBhIENPUFkgb2YgdGhlIGFycmF5O1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFdoZW4gc3BlY2lmaWVkLCBvbmx5IG9iamVjdHMgb2YgdGhpcyB0eXBlIGFyZSByZXR1cm5lZFxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldE9iamVjdHM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5jb25jYXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBvLnR5cGUgPT09IHR5cGU7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2JqZWN0IGF0IHNwZWNpZmllZCBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKi9cbiAgaXRlbTogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHNbaW5kZXhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY29sbGVjdGlvbiBjb250YWlucyBubyBvYmplY3RzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgY29sbGVjdGlvbiBpcyBlbXB0eVxuICAgKi9cbiAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmxlbmd0aCA9PT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHNpemUgb2YgYSBjb2xsZWN0aW9uIChpLmU6IGxlbmd0aCBvZiBhbiBhcnJheSBjb250YWluaW5nIGl0cyBvYmplY3RzKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvbGxlY3Rpb24gc2l6ZVxuICAgKi9cbiAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY29sbGVjdGlvbiBjb250YWlucyBhbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2hlY2sgYWdhaW5zdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgY29sbGVjdGlvbiBjb250YWlucyBhbiBvYmplY3RcbiAgICovXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBudW1iZXIgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xsZWN0aW9uIGNvbXBsZXhpdHlcbiAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5XG4gICAqL1xuICBjb21wbGV4aXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjdXJyZW50KSB7XG4gICAgICBtZW1vICs9IGN1cnJlbnQuY29tcGxleGl0eSA/IGN1cnJlbnQuY29tcGxleGl0eSgpIDogMDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG5hbWVzcGFjZSBmYWJyaWMuQ29tbW9uTWV0aG9kc1xuICovXG5mYWJyaWMuQ29tbW9uTWV0aG9kcyA9IHtcblxuICAvKipcbiAgICogU2V0cyBvYmplY3QncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBfc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5zZXQocHJvcCwgb3B0aW9uc1twcm9wXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2ZpbGxlcl0gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gcHJvcGVydHkgdG8gc2V0IHRoZSBHcmFkaWVudCB0b1xuICAgKi9cbiAgX2luaXRHcmFkaWVudDogZnVuY3Rpb24oZmlsbGVyLCBwcm9wZXJ0eSkge1xuICAgIGlmIChmaWxsZXIgJiYgZmlsbGVyLmNvbG9yU3RvcHMgJiYgIShmaWxsZXIgaW5zdGFuY2VvZiBmYWJyaWMuR3JhZGllbnQpKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgbmV3IGZhYnJpYy5HcmFkaWVudChmaWxsZXIpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsbGVyXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSBwcm9wZXJ0eSB0byBzZXQgdGhlIFBhdHRlcm4gdG9cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayB0byBpbnZva2UgYWZ0ZXIgcGF0dGVybiBsb2FkXG4gICAqL1xuICBfaW5pdFBhdHRlcm46IGZ1bmN0aW9uKGZpbGxlciwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgaWYgKGZpbGxlciAmJiBmaWxsZXIuc291cmNlICYmICEoZmlsbGVyIGluc3RhbmNlb2YgZmFicmljLlBhdHRlcm4pKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgbmV3IGZhYnJpYy5QYXR0ZXJuKGZpbGxlciwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgX2luaXRDbGlwcGluZzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5jbGlwVG8gfHwgdHlwZW9mIG9wdGlvbnMuY2xpcFRvICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmdW5jdGlvbkJvZHkgPSBmYWJyaWMudXRpbC5nZXRGdW5jdGlvbkJvZHkob3B0aW9ucy5jbGlwVG8pO1xuICAgIGlmICh0eXBlb2YgZnVuY3Rpb25Cb2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5jbGlwVG8gPSBuZXcgRnVuY3Rpb24oJ2N0eCcsIGZ1bmN0aW9uQm9keSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIHRoaXMuX3NldChwcm9wLCBvYmpbcHJvcF0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBwcm9wZXJ0eSB0byBhIGdpdmVuIHZhbHVlLiBXaGVuIGNoYW5naW5nIHBvc2l0aW9uL2RpbWVuc2lvbiAtcmVsYXRlZCBwcm9wZXJ0aWVzIChsZWZ0LCB0b3AsIHNjYWxlLCBhbmdsZSwgZXRjLikgYHNldGAgZG9lcyBub3QgdXBkYXRlIHBvc2l0aW9uIG9mIG9iamVjdCdzIGJvcmRlcnMvY29udHJvbHMuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aG9zZSwgY2FsbCBgc2V0Q29vcmRzKClgLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGtleSBQcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCAoaWYgb2JqZWN0LCBpdGVyYXRlIG92ZXIgdGhlIG9iamVjdCBwcm9wZXJ0aWVzKVxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgKGlmIGZ1bmN0aW9uLCB0aGUgdmFsdWUgaXMgcGFzc2VkIGludG8gaXQgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBhcyBhIG5ldyBvbmUpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl9zZXRPYmplY3Qoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIGtleSAhPT0gJ2NsaXBUbycpIHtcbiAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUodGhpcy5nZXQoa2V5KSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIGB0cnVlYCB0byBgZmFsc2VgIG9yIGZyb20gYGZhbHNlYCB0byBgdHJ1ZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHRvZ2dsZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHRvZ2dsZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChwcm9wZXJ0eSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgIXZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhc2ljIGdldHRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgKiBAcmV0dXJuIHsqfSB2YWx1ZSBvZiBhIHByb3BlcnR5XG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICB9XG59O1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICB2YXIgc3FydCA9IE1hdGguc3FydCxcbiAgICAgIGF0YW4yID0gTWF0aC5hdGFuMixcbiAgICAgIHBvdyA9IE1hdGgucG93LFxuICAgICAgYWJzID0gTWF0aC5hYnMsXG4gICAgICBQaUJ5MTgwID0gTWF0aC5QSSAvIDE4MCxcbiAgICAgIFBpQnkyID0gTWF0aC5QSSAvIDI7XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWxcbiAgICovXG4gIGZhYnJpYy51dGlsID0ge1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb3Mgb2YgYW4gYW5nbGUsIGF2b2lkaW5nIHJldHVybmluZyBmbG9hdHMgZm9yIGtub3duIHJlc3VsdHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIHRoZSBhbmdsZSBpbiByYWRpYW5zIG9yIGluIGRlZ3JlZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBjb3M6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHsgcmV0dXJuIDE7IH1cbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgLy8gY29zKGEpID0gY29zKC1hKVxuICAgICAgICBhbmdsZSA9IC1hbmdsZTtcbiAgICAgIH1cbiAgICAgIHZhciBhbmdsZVNsaWNlID0gYW5nbGUgLyBQaUJ5MjtcbiAgICAgIHN3aXRjaCAoYW5nbGVTbGljZSkge1xuICAgICAgICBjYXNlIDE6IGNhc2UgMzogcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguY29zKGFuZ2xlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzaW4gb2YgYW4gYW5nbGUsIGF2b2lkaW5nIHJldHVybmluZyBmbG9hdHMgZm9yIGtub3duIHJlc3VsdHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIHRoZSBhbmdsZSBpbiByYWRpYW5zIG9yIGluIGRlZ3JlZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBzaW46IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHsgcmV0dXJuIDA7IH1cbiAgICAgIHZhciBhbmdsZVNsaWNlID0gYW5nbGUgLyBQaUJ5Miwgc2lnbiA9IDE7XG4gICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgIC8vIHNpbigtYSkgPSAtc2luKGEpXG4gICAgICAgIHNpZ24gPSAtMTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYW5nbGVTbGljZSkge1xuICAgICAgICBjYXNlIDE6IHJldHVybiBzaWduO1xuICAgICAgICBjYXNlIDI6IHJldHVybiAwO1xuICAgICAgICBjYXNlIDM6IHJldHVybiAtc2lnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnNpbihhbmdsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICAgKiBQcmVzZW5jZSBvZiB2YWx1ZSAoYW5kIGl0cyBwb3NpdGlvbiBpbiBhbiBhcnJheSkgaXMgZGV0ZXJtaW5lZCB2aWEgYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3JpZ2luYWwgYXJyYXlcbiAgICAgKi9cbiAgICByZW1vdmVGcm9tQXJyYXk6IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGlkeCA9IGFycmF5LmluZGV4T2YodmFsdWUpO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmFuZG9tIG51bWJlciBiZXR3ZWVuIDIgc3BlY2lmaWVkIG9uZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gbG93ZXIgbGltaXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4IHVwcGVyIGxpbWl0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSByYW5kb20gdmFsdWUgKGJldHdlZW4gbWluIGFuZCBtYXgpXG4gICAgICovXG4gICAgZ2V0UmFuZG9tSW50OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgZGVncmVlcyB0byByYWRpYW5zLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVncmVlcyB2YWx1ZSBpbiBkZWdyZWVzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSBpbiByYWRpYW5zXG4gICAgICovXG4gICAgZGVncmVlc1RvUmFkaWFuczogZnVuY3Rpb24oZGVncmVlcykge1xuICAgICAgcmV0dXJuIGRlZ3JlZXMgKiBQaUJ5MTgwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnMgdmFsdWUgaW4gcmFkaWFuc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWUgaW4gZGVncmVlc1xuICAgICAqL1xuICAgIHJhZGlhbnNUb0RlZ3JlZXM6IGZ1bmN0aW9uKHJhZGlhbnMpIHtcbiAgICAgIHJldHVybiByYWRpYW5zIC8gUGlCeTE4MDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBgcG9pbnRgIGFyb3VuZCBgb3JpZ2luYCB3aXRoIGByYWRpYW5zYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBvcmlnaW4gVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW4sIHJhZGlhbnMpIHtcbiAgICAgIHBvaW50LnN1YnRyYWN0RXF1YWxzKG9yaWdpbik7XG4gICAgICB2YXIgdiA9IGZhYnJpYy51dGlsLnJvdGF0ZVZlY3Rvcihwb2ludCwgcmFkaWFucyk7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh2LngsIHYueSkuYWRkRXF1YWxzKG9yaWdpbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYHZlY3RvcmAgd2l0aCBgcmFkaWFuc2BcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZlY3RvciBUaGUgdmVjdG9yIHRvIHJvdGF0ZSAoeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlVmVjdG9yOiBmdW5jdGlvbih2ZWN0b3IsIHJhZGlhbnMpIHtcbiAgICAgIHZhciBzaW4gPSBmYWJyaWMudXRpbC5zaW4ocmFkaWFucyksXG4gICAgICAgICAgY29zID0gZmFicmljLnV0aWwuY29zKHJhZGlhbnMpLFxuICAgICAgICAgIHJ4ID0gdmVjdG9yLnggKiBjb3MgLSB2ZWN0b3IueSAqIHNpbixcbiAgICAgICAgICByeSA9IHZlY3Rvci54ICogc2luICsgdmVjdG9yLnkgKiBjb3M7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByeCxcbiAgICAgICAgeTogcnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0IHRvIHBvaW50IHBcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7ZmFicmljLlBvaW50fSBwIFRoZSBwb2ludCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gdCBUaGUgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2lnbm9yZU9mZnNldF0gSW5kaWNhdGVzIHRoYXQgdGhlIG9mZnNldCBzaG91bGQgbm90IGJlIGFwcGxpZWRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IFRoZSB0cmFuc2Zvcm1lZCBwb2ludFxuICAgICAqL1xuICAgIHRyYW5zZm9ybVBvaW50OiBmdW5jdGlvbihwLCB0LCBpZ25vcmVPZmZzZXQpIHtcbiAgICAgIGlmIChpZ25vcmVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgICAgdFswXSAqIHAueCArIHRbMl0gKiBwLnksXG4gICAgICAgICAgdFsxXSAqIHAueCArIHRbM10gKiBwLnlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KFxuICAgICAgICB0WzBdICogcC54ICsgdFsyXSAqIHAueSArIHRbNF0sXG4gICAgICAgIHRbMV0gKiBwLnggKyB0WzNdICogcC55ICsgdFs1XVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBwb2ludHMncyBib3VuZGluZyByZWN0YW5nbGUgKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgNCBwb2ludHMgYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgbWFrZUJvdW5kaW5nQm94RnJvbVBvaW50czogZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgICB2YXIgeFBvaW50cyA9IFtwb2ludHNbMF0ueCwgcG9pbnRzWzFdLngsIHBvaW50c1syXS54LCBwb2ludHNbM10ueF0sXG4gICAgICAgICAgbWluWCA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbih4UG9pbnRzKSxcbiAgICAgICAgICBtYXhYID0gZmFicmljLnV0aWwuYXJyYXkubWF4KHhQb2ludHMpLFxuICAgICAgICAgIHdpZHRoID0gbWF4WCAtIG1pblgsXG4gICAgICAgICAgeVBvaW50cyA9IFtwb2ludHNbMF0ueSwgcG9pbnRzWzFdLnksIHBvaW50c1syXS55LCBwb2ludHNbM10ueV0sXG4gICAgICAgICAgbWluWSA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbih5UG9pbnRzKSxcbiAgICAgICAgICBtYXhZID0gZmFicmljLnV0aWwuYXJyYXkubWF4KHlQb2ludHMpLFxuICAgICAgICAgIGhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBtaW5YLFxuICAgICAgICB0b3A6IG1pblksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludmVydCB0cmFuc2Zvcm1hdGlvbiB0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHQgVGhlIHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgaW52ZXJ0ZWQgdHJhbnNmb3JtXG4gICAgICovXG4gICAgaW52ZXJ0VHJhbnNmb3JtOiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgYSA9IDEgLyAodFswXSAqIHRbM10gLSB0WzFdICogdFsyXSksXG4gICAgICAgICAgciA9IFthICogdFszXSwgLWEgKiB0WzFdLCAtYSAqIHRbMl0sIGEgKiB0WzBdXSxcbiAgICAgICAgICBvID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoeyB4OiB0WzRdLCB5OiB0WzVdIH0sIHIsIHRydWUpO1xuICAgICAgcls0XSA9IC1vLng7XG4gICAgICByWzVdID0gLW8ueTtcbiAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgYXJvdW5kIE51bWJlciN0b0ZpeGVkLCB3aGljaCBjb250cmFyeSB0byBuYXRpdmUgbWV0aG9kIHJldHVybnMgbnVtYmVyLCBub3Qgc3RyaW5nLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG51bWJlciBudW1iZXIgdG8gb3BlcmF0ZSBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFjdGlvbkRpZ2l0cyBudW1iZXIgb2YgZnJhY3Rpb24gZGlnaXRzIHRvIFwibGVhdmVcIlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICB0b0ZpeGVkOiBmdW5jdGlvbihudW1iZXIsIGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChOdW1iZXIobnVtYmVyKS50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGZyb20gYXR0cmlidXRlIHZhbHVlIHRvIHBpeGVsIHZhbHVlIGlmIGFwcGxpY2FibGUuXG4gICAgICogUmV0dXJucyBjb252ZXJ0ZWQgcGl4ZWxzIG9yIG9yaWdpbmFsIHZhbHVlIG5vdCBjb252ZXJ0ZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSBudW1iZXIgdG8gb3BlcmF0ZSBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb250U2l6ZVxuICAgICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9XG4gICAgICovXG4gICAgcGFyc2VVbml0OiBmdW5jdGlvbih2YWx1ZSwgZm9udFNpemUpIHtcbiAgICAgIHZhciB1bml0ID0gL1xcRHswLDJ9JC8uZXhlYyh2YWx1ZSksXG4gICAgICAgICAgbnVtYmVyID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBpZiAoIWZvbnRTaXplKSB7XG4gICAgICAgIGZvbnRTaXplID0gZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh1bml0WzBdKSB7XG4gICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDI1LjQ7XG5cbiAgICAgICAgY2FzZSAnY20nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gMi41NDtcblxuICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEk7XG5cbiAgICAgICAgY2FzZSAncHQnOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gNzI7IC8vIG9yICogNCAvIDNcblxuICAgICAgICBjYXNlICdwYyc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyA3MiAqIDEyOyAvLyBvciAqIDE2XG5cbiAgICAgICAgY2FzZSAnZW0nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmb250U2l6ZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZmFsc2VGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMga2xhc3MgXCJDbGFzc1wiIG9iamVjdCBvZiBnaXZlbiBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIG9iamVjdCAoZWcuICdjaXJjbGUnKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHRvIGdldCBrbGFzcyBcIkNsYXNzXCIgb2JqZWN0IGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGtsYXNzIFwiQ2xhc3NcIlxuICAgICAqL1xuICAgIGdldEtsYXNzOiBmdW5jdGlvbih0eXBlLCBuYW1lc3BhY2UpIHtcbiAgICAgIC8vIGNhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9ubHlcbiAgICAgIHR5cGUgPSBmYWJyaWMudXRpbC5zdHJpbmcuY2FtZWxpemUodHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc2xpY2UoMSkpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlKVt0eXBlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhcnJheSBvZiBhdHRyaWJ1dGVzIGZvciBnaXZlbiBzdmcgdGhhdCBmYWJyaWMgcGFyc2VzXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBzdmcgZWxlbWVudCAoZWcuICdjaXJjbGUnKVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBzdHJpbmcgbmFtZXMgb2Ygc3VwcG9ydGVkIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBnZXRTdmdBdHRyaWJ1dGVzOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IFtcbiAgICAgICAgJ2luc3RhbnRpYXRlZF9ieV91c2UnLFxuICAgICAgICAnc3R5bGUnLFxuICAgICAgICAnaWQnLFxuICAgICAgICAnY2xhc3MnXG4gICAgICBdO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2xpbmVhckdyYWRpZW50JzpcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQoWyd4MScsICd5MScsICd4MicsICd5MicsICdncmFkaWVudFVuaXRzJywgJ2dyYWRpZW50VHJhbnNmb3JtJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYWRpYWxHcmFkaWVudCc6XG4gICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KFsnZ3JhZGllbnRVbml0cycsICdncmFkaWVudFRyYW5zZm9ybScsICdjeCcsICdjeScsICdyJywgJ2Z4JywgJ2Z5JywgJ2ZyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdG9wJzpcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQoWydvZmZzZXQnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3Qgb2YgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2Ugc3RyaW5nIGUuZy4gJ2ZhYnJpYy5JbWFnZS5maWx0ZXInIG9yICdmYWJyaWMnXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgZm9yIGdpdmVuIG5hbWVzcGFjZSAoZGVmYXVsdCBmYWJyaWMpXG4gICAgICovXG4gICAgcmVzb2x2ZU5hbWVzcGFjZTogZnVuY3Rpb24obmFtZXNwYWNlKSB7XG4gICAgICBpZiAoIW5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gZmFicmljO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFydHMgPSBuYW1lc3BhY2Uuc3BsaXQoJy4nKSxcbiAgICAgICAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsIGksXG4gICAgICAgICAgb2JqID0gZ2xvYmFsIHx8IGZhYnJpYy53aW5kb3c7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBvYmogPSBvYmpbcGFydHNbaV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBpbWFnZSBlbGVtZW50IGZyb20gZ2l2ZW4gdXJsIGFuZCBwYXNzZXMgaXQgdG8gYSBjYWxsYmFja1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHJlcHJlc2VudGluZyBhbiBpbWFnZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrOyBpbnZva2VkIHdpdGggbG9hZGVkIGltYWdlXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gQ29udGV4dCB0byBpbnZva2UgY2FsbGJhY2sgaW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2Nyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiB2YWx1ZSB0byBzZXQgaW1hZ2UgZWxlbWVudCB0b1xuICAgICAqL1xuICAgIGxvYWRJbWFnZTogZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgY29udGV4dCwgY3Jvc3NPcmlnaW4pIHtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgdXJsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nID0gZmFicmljLnV0aWwuY3JlYXRlSW1hZ2UoKTtcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIHZhciBvbkxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb250ZXh0LCBpbWcpO1xuICAgICAgICBpbWcgPSBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgaW1nLm9ubG9hZCA9IG9uTG9hZENhbGxiYWNrO1xuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZhYnJpYy5sb2coJ0Vycm9yIGxvYWRpbmcgJyArIGltZy5zcmMpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG51bGwsIHRydWUpO1xuICAgICAgICBpbWcgPSBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLy8gZGF0YS11cmxzIGFwcGVhciB0byBiZSBidWdneSB3aXRoIGNyb3NzT3JpZ2luXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy9jb21taXQvZDBhYmI5MGYxY2Q1YzVlZjlkMmE5NGQzZmIyMWEyMjMzMGRhM2UwYSNjb21taXRjb21tZW50LTQ1MTM3NjdcbiAgICAgIC8vIHNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzE1MTUyXG4gICAgICAvLyAgICAgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTM1MDY5XG4gICAgICBpZiAodXJsLmluZGV4T2YoJ2RhdGEnKSAhPT0gMCAmJiBjcm9zc09yaWdpbikge1xuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICAgIH1cblxuICAgICAgLy8gSUUxMCAvIElFMTEtRml4OiBTVkcgY29udGVudHMgZnJvbSBkYXRhOiBVUklcbiAgICAgIC8vIHdpbGwgb25seSBiZSBhdmFpbGFibGUgaWYgdGhlIElNRyBpcyBwcmVzZW50XG4gICAgICAvLyBpbiB0aGUgRE9NIChhbmQgdmlzaWJsZSlcbiAgICAgIGlmICh1cmwuc3Vic3RyaW5nKDAsMTQpID09PSAnZGF0YTppbWFnZS9zdmcnKSB7XG4gICAgICAgIGltZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2VJbkRvbShpbWcsIG9uTG9hZENhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgU1ZHIGltYWdlIHdpdGggZGF0YTogVVJMIHRvIHRoZSBkb21cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1nIEltYWdlIG9iamVjdCB3aXRoIGRhdGE6aW1hZ2Uvc3ZnIHNyY1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrOyBpbnZva2VkIHdpdGggbG9hZGVkIGltYWdlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBET00gZWxlbWVudCAoZGl2IGNvbnRhaW5pbmcgdGhlIFNWRyBpbWFnZSlcbiAgICAgKi9cbiAgICBsb2FkSW1hZ2VJbkRvbTogZnVuY3Rpb24oaW1nLCBvbkxvYWRDYWxsYmFjaykge1xuICAgICAgdmFyIGRpdiA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS5oZWlnaHQgPSAnMXB4JztcbiAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gZGl2LnN0eWxlLnRvcCA9ICctMTAwJSc7XG4gICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICBmYWJyaWMuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXAgaW4gZnVuY3Rpb24gdG86XG4gICAgICAgKiAgIDEuIENhbGwgZXhpc3RpbmcgY2FsbGJhY2tcbiAgICAgICAqICAgMi4gQ2xlYW51cCBET01cbiAgICAgICAqL1xuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25Mb2FkQ2FsbGJhY2soKTtcbiAgICAgICAgZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgZGl2ID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY29ycmVzcG9uZGluZyBmYWJyaWMgaW5zdGFuY2VzIGZyb20gdGhlaXIgb2JqZWN0IHJlcHJlc2VudGF0aW9uc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIE9iamVjdHMgdG8gZW5saXZlblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFsbCBvYmplY3RzIGFyZSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2UgdG8gZ2V0IGtsYXNzIFwiQ2xhc3NcIiBvYmplY3QgZnJvbVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJldml2ZXIgTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygb2JqZWN0IGVsZW1lbnRzLFxuICAgICAqIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbmxpdmVuT2JqZWN0czogZnVuY3Rpb24ob2JqZWN0cywgY2FsbGJhY2ssIG5hbWVzcGFjZSwgcmV2aXZlcikge1xuICAgICAgb2JqZWN0cyA9IG9iamVjdHMgfHwgW107XG5cbiAgICAgIGZ1bmN0aW9uIG9uTG9hZGVkKCkge1xuICAgICAgICBpZiAoKytudW1Mb2FkZWRPYmplY3RzID09PSBudW1Ub3RhbE9iamVjdHMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5saXZlbmVkT2JqZWN0cyA9IFtdLFxuICAgICAgICAgIG51bUxvYWRlZE9iamVjdHMgPSAwLFxuICAgICAgICAgIG51bVRvdGFsT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXG4gICAgICBpZiAoIW51bVRvdGFsT2JqZWN0cykge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKG8sIGluZGV4KSB7XG4gICAgICAgIC8vIGlmIHNwYXJzZSBhcnJheVxuICAgICAgICBpZiAoIW8gfHwgIW8udHlwZSkge1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrbGFzcyA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG8udHlwZSwgbmFtZXNwYWNlKTtcbiAgICAgICAga2xhc3MuZnJvbU9iamVjdChvLCBmdW5jdGlvbiAob2JqLCBlcnJvcikge1xuICAgICAgICAgIGVycm9yIHx8IChlbmxpdmVuZWRPYmplY3RzW2luZGV4XSA9IG9iaik7XG4gICAgICAgICAgcmV2aXZlciAmJiByZXZpdmVyKG8sIG9iaiwgZXJyb3IpO1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgd2FpdCBmb3IgbG9hZGluZyBvZiBwYXR0ZXJuc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXR0ZXJucyBPYmplY3RzIHRvIGVubGl2ZW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgb2JqZWN0cyBhcmUgY3JlYXRlZFxuICAgICAqIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbmxpdmVuUGF0dGVybnM6IGZ1bmN0aW9uKHBhdHRlcm5zLCBjYWxsYmFjaykge1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucyB8fCBbXTtcblxuICAgICAgZnVuY3Rpb24gb25Mb2FkZWQoKSB7XG4gICAgICAgIGlmICgrK251bUxvYWRlZFBhdHRlcm5zID09PSBudW1QYXR0ZXJucykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZFBhdHRlcm5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5saXZlbmVkUGF0dGVybnMgPSBbXSxcbiAgICAgICAgICBudW1Mb2FkZWRQYXR0ZXJucyA9IDAsXG4gICAgICAgICAgbnVtUGF0dGVybnMgPSBwYXR0ZXJucy5sZW5ndGg7XG5cbiAgICAgIGlmICghbnVtUGF0dGVybnMpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkUGF0dGVybnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBhdHRlcm5zLmZvckVhY2goZnVuY3Rpb24gKHAsIGluZGV4KSB7XG4gICAgICAgIGlmIChwICYmIHAuc291cmNlKSB7XG4gICAgICAgICAgbmV3IGZhYnJpYy5QYXR0ZXJuKHAsIGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHBhdHRlcm47XG4gICAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHA7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBTVkcgZWxlbWVudHMgKHVzdWFsbHkgdGhvc2UgcmV0cmlldmVkIGZyb20gU1ZHIGRvY3VtZW50KVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50cyBTVkcgZWxlbWVudHMgdG8gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVmFsdWUgdG8gc2V0IHNvdXJjZVBhdGggdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fGZhYnJpYy5Hcm91cH1cbiAgICAgKi9cbiAgICBncm91cFNWR0VsZW1lbnRzOiBmdW5jdGlvbihlbGVtZW50cywgb3B0aW9ucywgcGF0aCkge1xuICAgICAgdmFyIG9iamVjdDtcbiAgICAgIGlmIChlbGVtZW50cyAmJiBlbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzWzBdO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgICAgICBvcHRpb25zLmNlbnRlclBvaW50ID0ge1xuICAgICAgICAgICAgeDogb3B0aW9ucy53aWR0aCAvIDIsXG4gICAgICAgICAgICB5OiBvcHRpb25zLmhlaWdodCAvIDJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLndpZHRoO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqZWN0ID0gbmV3IGZhYnJpYy5Hcm91cChlbGVtZW50cywgb3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIHBhdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5zb3VyY2VQYXRoID0gcGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlcyBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcHJvcGVydGllcyBQcm9wZXJ0aWVzIG5hbWVzIHRvIGluY2x1ZGVcbiAgICAgKi9cbiAgICBwb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzOiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uLCBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAocHJvcGVydGllcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvcGVydGllcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllc1tpXSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnRpZXNbaV1dID0gc291cmNlW3Byb3BlcnRpZXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGRhc2hlZCBsaW5lIGJldHdlZW4gdHdvIHBvaW50c1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBkcmF3IGRhc2hlZCBsaW5lIGFyb3VuZCBzZWxlY3Rpb24gYXJlYS5cbiAgICAgKiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDU3NjcyNC9kb3R0ZWQtc3Ryb2tlLWluLWNhbnZhc1wiPmRvdHRlZCBzdHJva2UgaW4gY2FudmFzPC9hPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggIHN0YXJ0IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHN0YXJ0IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MiBlbmQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIGVuZCB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYSBkYXNoIGFycmF5IHBhdHRlcm5cbiAgICAgKi9cbiAgICBkcmF3RGFzaGVkTGluZTogZnVuY3Rpb24oY3R4LCB4LCB5LCB4MiwgeTIsIGRhKSB7XG4gICAgICB2YXIgZHggPSB4MiAtIHgsXG4gICAgICAgICAgZHkgPSB5MiAtIHksXG4gICAgICAgICAgbGVuID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXG4gICAgICAgICAgcm90ID0gYXRhbjIoZHksIGR4KSxcbiAgICAgICAgICBkYyA9IGRhLmxlbmd0aCxcbiAgICAgICAgICBkaSA9IDAsXG4gICAgICAgICAgZHJhdyA9IHRydWU7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgIGN0eC5yb3RhdGUocm90KTtcblxuICAgICAgeCA9IDA7XG4gICAgICB3aGlsZSAobGVuID4geCkge1xuICAgICAgICB4ICs9IGRhW2RpKysgJSBkY107XG4gICAgICAgIGlmICh4ID4gbGVuKSB7XG4gICAgICAgICAgeCA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBjdHhbZHJhdyA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHgsIDApO1xuICAgICAgICBkcmF3ID0gIWRyYXc7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7Q2FudmFzRWxlbWVudH0gaW5pdGlhbGl6ZWQgY2FudmFzIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjYW52YXMgZWxlbWVudCB0aGF0IGlzIGEgY29weSBvZiBhbm90aGVyIGFuZCBpcyBhbHNvIHBhaW50ZWRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0VsZW1lbnR9IGNhbnZhcyB0byBjb3B5IHNpemUgYW5kIGNvbnRlbnQgb2ZcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7Q2FudmFzRWxlbWVudH0gaW5pdGlhbGl6ZWQgY2FudmFzIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjb3B5Q2FudmFzRWxlbWVudDogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICB2YXIgbmV3Q2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgbmV3Q2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgbmV3Q2FudmFzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICBuZXdDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcbiAgICAgIHJldHVybiBuZXdDYW52YXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNpbmNlIDIuNi4wIG1vdmVkIGZyb20gY2FudmFzIGluc3RhbmNlIHRvIHV0aWxpdHkuXG4gICAgICogQHBhcmFtIHtDYW52YXNFbGVtZW50fSBjYW52YXNFbCB0byBjb3B5IHNpemUgYW5kIGNvbnRlbnQgb2ZcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0ICdqcGVnJyBvciAncG5nJywgaW4gc29tZSBicm93c2VycyAnd2VicCcgaXMgb2sgdG9vXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHF1YWxpdHkgPD0gMSBhbmQgPiAwXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZGF0YSB1cmxcbiAgICAgKi9cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uKGNhbnZhc0VsLCBmb3JtYXQsIHF1YWxpdHkpIHtcbiAgICAgIHJldHVybiBjYW52YXNFbC50b0RhdGFVUkwoJ2ltYWdlLycgKyBmb3JtYXQsIHF1YWxpdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGltYWdlIGVsZW1lbnQgKHdvcmtzIG9uIGNsaWVudCBhbmQgbm9kZSlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gSFRNTCBpbWFnZSBlbGVtZW50XG4gICAgICovXG4gICAgY3JlYXRlSW1hZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIDIuMC4wXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSByZWNlaXZlciBPYmplY3QgaW1wbGVtZW50aW5nIGBjbGlwVG9gIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBjbGlwXG4gICAgICovXG4gICAgY2xpcENvbnRleHQ6IGZ1bmN0aW9uKHJlY2VpdmVyLCBjdHgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICByZWNlaXZlci5jbGlwVG8oY3R4KTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IG1hdHJpeCBBIGJ5IG1hdHJpeCBCIHRvIG5lc3QgdHJhbnNmb3JtYXRpb25zXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhIEZpcnN0IHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBiIFNlY29uZCB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpczJ4MiBmbGFnIHRvIG11bHRpcGx5IG1hdHJpY2VzIGFzIDJ4MiBtYXRyaWNlc1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgcHJvZHVjdCBvZiB0aGUgdHdvIHRyYW5zZm9ybSBtYXRyaWNlc1xuICAgICAqL1xuICAgIG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXM6IGZ1bmN0aW9uKGEsIGIsIGlzMngyKSB7XG4gICAgICAvLyBNYXRyaXggbXVsdGlwbHkgYSAqIGJcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGFbMF0gKiBiWzBdICsgYVsyXSAqIGJbMV0sXG4gICAgICAgIGFbMV0gKiBiWzBdICsgYVszXSAqIGJbMV0sXG4gICAgICAgIGFbMF0gKiBiWzJdICsgYVsyXSAqIGJbM10sXG4gICAgICAgIGFbMV0gKiBiWzJdICsgYVszXSAqIGJbM10sXG4gICAgICAgIGlzMngyID8gMCA6IGFbMF0gKiBiWzRdICsgYVsyXSAqIGJbNV0gKyBhWzRdLFxuICAgICAgICBpczJ4MiA/IDAgOiBhWzFdICogYls0XSArIGFbM10gKiBiWzVdICsgYVs1XVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjb21wb3NlcyBzdGFuZGFyZCAyeDIgbWF0cml4IGludG8gdHJhbnNmb3JtIGNvbXBvbmVudGVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhIHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ29tcG9uZW50cyBvZiB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBxckRlY29tcG9zZTogZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGFuZ2xlID0gYXRhbjIoYVsxXSwgYVswXSksXG4gICAgICAgICAgZGVub20gPSBwb3coYVswXSwgMikgKyBwb3coYVsxXSwgMiksXG4gICAgICAgICAgc2NhbGVYID0gc3FydChkZW5vbSksXG4gICAgICAgICAgc2NhbGVZID0gKGFbMF0gKiBhWzNdIC0gYVsyXSAqIGEgWzFdKSAvIHNjYWxlWCxcbiAgICAgICAgICBza2V3WCA9IGF0YW4yKGFbMF0gKiBhWzJdICsgYVsxXSAqIGEgWzNdLCBkZW5vbSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbmdsZTogYW5nbGUgIC8gUGlCeTE4MCxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICBza2V3WDogc2tld1ggLyBQaUJ5MTgwLFxuICAgICAgICBza2V3WTogMCxcbiAgICAgICAgdHJhbnNsYXRlWDogYVs0XSxcbiAgICAgICAgdHJhbnNsYXRlWTogYVs1XVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgY3VzdG9tVHJhbnNmb3JtTWF0cml4OiBmdW5jdGlvbihzY2FsZVgsIHNjYWxlWSwgc2tld1gpIHtcbiAgICAgIHZhciBza2V3TWF0cml4WCA9IFsxLCAwLCBhYnMoTWF0aC50YW4oc2tld1ggKiBQaUJ5MTgwKSksIDFdLFxuICAgICAgICAgIHNjYWxlTWF0cml4ID0gW2FicyhzY2FsZVgpLCAwLCAwLCBhYnMoc2NhbGVZKV07XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhzY2FsZU1hdHJpeCwgc2tld01hdHJpeFgsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXNldCBhbiBvYmplY3QgdHJhbnNmb3JtIHN0YXRlIHRvIG5ldXRyYWwuIFRvcCBhbmQgbGVmdCBhcmUgbm90IGFjY291bnRlZCBmb3JcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IG9iamVjdCB0byB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICByZXNldE9iamVjdFRyYW5zZm9ybTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdGFyZ2V0LnNjYWxlWCA9IDE7XG4gICAgICB0YXJnZXQuc2NhbGVZID0gMTtcbiAgICAgIHRhcmdldC5za2V3WCA9IDA7XG4gICAgICB0YXJnZXQuc2tld1kgPSAwO1xuICAgICAgdGFyZ2V0LmZsaXBYID0gZmFsc2U7XG4gICAgICB0YXJnZXQuZmxpcFkgPSBmYWxzZTtcbiAgICAgIHRhcmdldC5yb3RhdGUoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgT2JqZWN0IHRyYW5zZm9ybSB2YWx1ZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IG9iamVjdCB0byByZWFkIGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvbXBvbmVudHMgb2YgdHJhbnNmb3JtXG4gICAgICovXG4gICAgc2F2ZU9iamVjdFRyYW5zZm9ybTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGVYOiB0YXJnZXQuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHRhcmdldC5zY2FsZVksXG4gICAgICAgIHNrZXdYOiB0YXJnZXQuc2tld1gsXG4gICAgICAgIHNrZXdZOiB0YXJnZXQuc2tld1ksXG4gICAgICAgIGFuZ2xlOiB0YXJnZXQuYW5nbGUsXG4gICAgICAgIGxlZnQ6IHRhcmdldC5sZWZ0LFxuICAgICAgICBmbGlwWDogdGFyZ2V0LmZsaXBYLFxuICAgICAgICBmbGlwWTogdGFyZ2V0LmZsaXBZLFxuICAgICAgICB0b3A6IHRhcmdldC50b3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGZ1bmN0aW9uIGJvZHlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBnZXQgYm9keSBvZlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gRnVuY3Rpb24gYm9keVxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uQm9keTogZnVuY3Rpb24oZm4pIHtcbiAgICAgIHJldHVybiAoU3RyaW5nKGZuKS5tYXRjaCgvZnVuY3Rpb25bXntdKlxceyhbXFxzXFxTXSopXFx9LykgfHwge30pWzFdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgY29udGV4dCBoYXMgdHJhbnNwYXJlbnQgcGl4ZWxcbiAgICAgKiBhdCBzcGVjaWZpZWQgbG9jYXRpb24gKHRha2luZyB0b2xlcmFuY2UgaW50byBhY2NvdW50KVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlXG4gICAgICovXG4gICAgaXNUcmFuc3BhcmVudDogZnVuY3Rpb24oY3R4LCB4LCB5LCB0b2xlcmFuY2UpIHtcblxuICAgICAgLy8gSWYgdG9sZXJhbmNlIGlzID4gMCBhZGp1c3Qgc3RhcnQgY29vcmRzIHRvIHRha2UgaW50byBhY2NvdW50LlxuICAgICAgLy8gSWYgbW92ZXMgb2ZmIENhbnZhcyBmaXggdG8gMFxuICAgICAgaWYgKHRvbGVyYW5jZSA+IDApIHtcbiAgICAgICAgaWYgKHggPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICB4IC09IHRvbGVyYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgIHkgLT0gdG9sZXJhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXNUcmFuc3BhcmVudCA9IHRydWUsIGksIHRlbXAsXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCAodG9sZXJhbmNlICogMikgfHwgMSwgKHRvbGVyYW5jZSAqIDIpIHx8IDEpLFxuICAgICAgICAgIGwgPSBpbWFnZURhdGEuZGF0YS5sZW5ndGg7XG5cbiAgICAgIC8vIFNwbGl0IGltYWdlIGRhdGEgLSBmb3IgdG9sZXJhbmNlID4gMSwgcGl4ZWxEYXRhU2l6ZSA9IDQ7XG4gICAgICBmb3IgKGkgPSAzOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICAgIHRlbXAgPSBpbWFnZURhdGEuZGF0YVtpXTtcbiAgICAgICAgX2lzVHJhbnNwYXJlbnQgPSB0ZW1wIDw9IDA7XG4gICAgICAgIGlmIChfaXNUcmFuc3BhcmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhazsgLy8gU3RvcCBpZiBjb2xvdXIgZm91bmRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbWFnZURhdGEgPSBudWxsO1xuXG4gICAgICByZXR1cm4gX2lzVHJhbnNwYXJlbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHByZXNlcnZlQXNwZWN0UmF0aW8gYXR0cmlidXRlIGZyb20gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgdG8gYmUgcGFyc2VkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3QgY29udGFpbmluZyBhbGlnbiBhbmQgbWVldE9yU2xpY2UgYXR0cmlidXRlXG4gICAgICovXG4gICAgcGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlOiBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBtZWV0T3JTbGljZSA9ICdtZWV0JywgYWxpZ25YID0gJ01pZCcsIGFsaWduWSA9ICdNaWQnLFxuICAgICAgICAgIGFzcGVjdFJhdGlvQXR0cnMgPSBhdHRyaWJ1dGUuc3BsaXQoJyAnKSwgYWxpZ247XG5cbiAgICAgIGlmIChhc3BlY3RSYXRpb0F0dHJzICYmIGFzcGVjdFJhdGlvQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgIG1lZXRPclNsaWNlID0gYXNwZWN0UmF0aW9BdHRycy5wb3AoKTtcbiAgICAgICAgaWYgKG1lZXRPclNsaWNlICE9PSAnbWVldCcgJiYgbWVldE9yU2xpY2UgIT09ICdzbGljZScpIHtcbiAgICAgICAgICBhbGlnbiA9IG1lZXRPclNsaWNlO1xuICAgICAgICAgIG1lZXRPclNsaWNlID0gJ21lZXQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzcGVjdFJhdGlvQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgYWxpZ24gPSBhc3BlY3RSYXRpb0F0dHJzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2RpdmlkZSBhbGlnbiBpbiBhbGlnblggYW5kIGFsaWduWVxuICAgICAgYWxpZ25YID0gYWxpZ24gIT09ICdub25lJyA/IGFsaWduLnNsaWNlKDEsIDQpIDogJ25vbmUnO1xuICAgICAgYWxpZ25ZID0gYWxpZ24gIT09ICdub25lJyA/IGFsaWduLnNsaWNlKDUsIDgpIDogJ25vbmUnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVldE9yU2xpY2U6IG1lZXRPclNsaWNlLFxuICAgICAgICBhbGlnblg6IGFsaWduWCxcbiAgICAgICAgYWxpZ25ZOiBhbGlnbllcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGNoYXIgd2lkdGhzIGNhY2hlIGZvciB0aGUgZ2l2ZW4gZm9udCBmYW1pbHkgb3IgYWxsIHRoZSBjYWNoZSBpZiBub1xuICAgICAqIGZvbnRGYW1pbHkgaXMgc3BlY2lmaWVkLlxuICAgICAqIFVzZSBpdCBpZiB5b3Uga25vdyB5b3UgYXJlIGxvYWRpbmcgZm9udHMgaW4gYSBsYXp5IHdheSBhbmQgeW91IGFyZSBub3Qgd2FpdGluZ1xuICAgICAqIGZvciBjdXN0b20gZm9udHMgdG8gbG9hZCBwcm9wZXJseSB3aGVuIGFkZGluZyB0ZXh0IG9iamVjdHMgdG8gdGhlIGNhbnZhcy5cbiAgICAgKiBJZiBhIHRleHQgb2JqZWN0IGlzIGFkZGVkIHdoZW4gaXRzIG93biBmb250IGlzIG5vdCBsb2FkZWQgeWV0LCB5b3Ugd2lsbCBnZXQgd3JvbmdcbiAgICAgKiBtZWFzdXJlbWVudCBhbmQgc28gd3JvbmcgYm91bmRpbmcgYm94ZXMuXG4gICAgICogQWZ0ZXIgdGhlIGZvbnQgY2FjaGUgaXMgY2xlYXJlZCwgZWl0aGVyIGNoYW5nZSB0aGUgdGV4dE9iamVjdCB0ZXh0IGNvbnRlbnQgb3IgY2FsbFxuICAgICAqIGluaXREaW1lbnNpb25zKCkgdG8gdHJpZ2dlciBhIHJlY2FsY3VsYXRpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZvbnRGYW1pbHldIGZvbnQgZmFtaWx5IHRvIGNsZWFyXG4gICAgICovXG4gICAgY2xlYXJGYWJyaWNGb250Q2FjaGU6IGZ1bmN0aW9uKGZvbnRGYW1pbHkpIHtcbiAgICAgIGZvbnRGYW1pbHkgPSAoZm9udEZhbWlseSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghZm9udEZhbWlseSkge1xuICAgICAgICBmYWJyaWMuY2hhcldpZHRoc0NhY2hlID0geyB9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSkge1xuICAgICAgICBkZWxldGUgZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gY3VycmVudCBhc3BlY3QgcmF0aW8sIGRldGVybWluZXMgdGhlIG1heCB3aWR0aCBhbmQgaGVpZ2h0IHRoYXQgY2FuXG4gICAgICogcmVzcGVjdCB0aGUgdG90YWwgYWxsb3dlZCBhcmVhIGZvciB0aGUgY2FjaGUuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyIGFzcGVjdCByYXRpb1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhpbXVtQXJlYSBNYXhpbXVtIGFyZWEgeW91IHdhbnQgdG8gYWNoaWV2ZVxuICAgICAqIEByZXR1cm4ge09iamVjdC54fSBMaW1pdGVkIGRpbWVuc2lvbnMgYnkgWFxuICAgICAqIEByZXR1cm4ge09iamVjdC55fSBMaW1pdGVkIGRpbWVuc2lvbnMgYnkgWVxuICAgICAqL1xuICAgIGxpbWl0RGltc0J5QXJlYTogZnVuY3Rpb24oYXIsIG1heGltdW1BcmVhKSB7XG4gICAgICB2YXIgcm91Z2hXaWR0aCA9IE1hdGguc3FydChtYXhpbXVtQXJlYSAqIGFyKSxcbiAgICAgICAgICBwZXJmTGltaXRTaXplWSA9IE1hdGguZmxvb3IobWF4aW11bUFyZWEgLyByb3VnaFdpZHRoKTtcbiAgICAgIHJldHVybiB7IHg6IE1hdGguZmxvb3Iocm91Z2hXaWR0aCksIHk6IHBlcmZMaW1pdFNpemVZIH07XG4gICAgfSxcblxuICAgIGNhcFZhbHVlOiBmdW5jdGlvbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbiAgICB9LFxuXG4gICAgZmluZFNjYWxlVG9GaXQ6IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihkZXN0aW5hdGlvbi53aWR0aCAvIHNvdXJjZS53aWR0aCwgZGVzdGluYXRpb24uaGVpZ2h0IC8gc291cmNlLmhlaWdodCk7XG4gICAgfSxcblxuICAgIGZpbmRTY2FsZVRvQ292ZXI6IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChkZXN0aW5hdGlvbi53aWR0aCAvIHNvdXJjZS53aWR0aCwgZGVzdGluYXRpb24uaGVpZ2h0IC8gc291cmNlLmhlaWdodCk7XG4gICAgfVxuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgX2pvaW4gPSBBcnJheS5wcm90b3R5cGUuam9pbjtcblxuICAvKiBBZGFwdGVkIGZyb20gaHR0cDovL2R4ci5tb3ppbGxhLm9yZy9tb3ppbGxhLWNlbnRyYWwvc291cmNlL2NvbnRlbnQvc3ZnL2NvbnRlbnQvc3JjL25zU1ZHUGF0aERhdGFQYXJzZXIuY3BwXG4gICAqIGJ5IEFuZHJlYSBCb2dhenppIGNvZGUgaXMgdW5kZXIgTVBMLiBpZiB5b3UgZG9uJ3QgaGF2ZSBhIGNvcHkgb2YgdGhlIGxpY2Vuc2UgeW91IGNhbiB0YWtlIGl0IGhlcmVcbiAgICogaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvXG4gICAqL1xuICBmdW5jdGlvbiBhcmNUb1NlZ21lbnRzKHRvWCwgdG9ZLCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90YXRlWCkge1xuICAgIHZhciBhcmdzU3RyaW5nID0gX2pvaW4uY2FsbChhcmd1bWVudHMpO1xuICAgIGlmIChmYWJyaWMuYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJpbmddKSB7XG4gICAgICByZXR1cm4gZmFicmljLmFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyaW5nXTtcbiAgICB9XG5cbiAgICB2YXIgUEkgPSBNYXRoLlBJLCB0aCA9IHJvdGF0ZVggKiBQSSAvIDE4MCxcbiAgICAgICAgc2luVGggPSBmYWJyaWMudXRpbC5zaW4odGgpLFxuICAgICAgICBjb3NUaCA9IGZhYnJpYy51dGlsLmNvcyh0aCksXG4gICAgICAgIGZyb21YID0gMCwgZnJvbVkgPSAwO1xuXG4gICAgcnggPSBNYXRoLmFicyhyeCk7XG4gICAgcnkgPSBNYXRoLmFicyhyeSk7XG5cbiAgICB2YXIgcHggPSAtY29zVGggKiB0b1ggKiAwLjUgLSBzaW5UaCAqIHRvWSAqIDAuNSxcbiAgICAgICAgcHkgPSAtY29zVGggKiB0b1kgKiAwLjUgKyBzaW5UaCAqIHRvWCAqIDAuNSxcbiAgICAgICAgcngyID0gcnggKiByeCwgcnkyID0gcnkgKiByeSwgcHkyID0gcHkgKiBweSwgcHgyID0gcHggKiBweCxcbiAgICAgICAgcGwgPSByeDIgKiByeTIgLSByeDIgKiBweTIgLSByeTIgKiBweDIsXG4gICAgICAgIHJvb3QgPSAwO1xuXG4gICAgaWYgKHBsIDwgMCkge1xuICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMSAtIHBsIC8gKHJ4MiAqIHJ5MikpO1xuICAgICAgcnggKj0gcztcbiAgICAgIHJ5ICo9IHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcm9vdCA9IChsYXJnZSA9PT0gc3dlZXAgPyAtMS4wIDogMS4wKSAqXG4gICAgICAgICAgICAgIE1hdGguc3FydCggcGwgLyAocngyICogcHkyICsgcnkyICogcHgyKSk7XG4gICAgfVxuXG4gICAgdmFyIGN4ID0gcm9vdCAqIHJ4ICogcHkgLyByeSxcbiAgICAgICAgY3kgPSAtcm9vdCAqIHJ5ICogcHggLyByeCxcbiAgICAgICAgY3gxID0gY29zVGggKiBjeCAtIHNpblRoICogY3kgKyB0b1ggKiAwLjUsXG4gICAgICAgIGN5MSA9IHNpblRoICogY3ggKyBjb3NUaCAqIGN5ICsgdG9ZICogMC41LFxuICAgICAgICBtVGhldGEgPSBjYWxjVmVjdG9yQW5nbGUoMSwgMCwgKHB4IC0gY3gpIC8gcngsIChweSAtIGN5KSAvIHJ5KSxcbiAgICAgICAgZHRoZXRhID0gY2FsY1ZlY3RvckFuZ2xlKChweCAtIGN4KSAvIHJ4LCAocHkgLSBjeSkgLyByeSwgKC1weCAtIGN4KSAvIHJ4LCAoLXB5IC0gY3kpIC8gcnkpO1xuXG4gICAgaWYgKHN3ZWVwID09PSAwICYmIGR0aGV0YSA+IDApIHtcbiAgICAgIGR0aGV0YSAtPSAyICogUEk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN3ZWVwID09PSAxICYmIGR0aGV0YSA8IDApIHtcbiAgICAgIGR0aGV0YSArPSAyICogUEk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBpbnRvIGN1YmljIGJlemllciBzZWdtZW50cyA8PSA5MGRlZ1xuICAgIHZhciBzZWdtZW50cyA9IE1hdGguY2VpbChNYXRoLmFicyhkdGhldGEgLyBQSSAqIDIpKSxcbiAgICAgICAgcmVzdWx0ID0gW10sIG1EZWx0YSA9IGR0aGV0YSAvIHNlZ21lbnRzLFxuICAgICAgICBtVCA9IDggLyAzICogTWF0aC5zaW4obURlbHRhIC8gNCkgKiBNYXRoLnNpbihtRGVsdGEgLyA0KSAvIE1hdGguc2luKG1EZWx0YSAvIDIpLFxuICAgICAgICB0aDMgPSBtVGhldGEgKyBtRGVsdGE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IHNlZ21lbnRUb0JlemllcihtVGhldGEsIHRoMywgY29zVGgsIHNpblRoLCByeCwgcnksIGN4MSwgY3kxLCBtVCwgZnJvbVgsIGZyb21ZKTtcbiAgICAgIGZyb21YID0gcmVzdWx0W2ldWzRdO1xuICAgICAgZnJvbVkgPSByZXN1bHRbaV1bNV07XG4gICAgICBtVGhldGEgPSB0aDM7XG4gICAgICB0aDMgKz0gbURlbHRhO1xuICAgIH1cbiAgICBmYWJyaWMuYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJpbmddID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZWdtZW50VG9CZXppZXIodGgyLCB0aDMsIGNvc1RoLCBzaW5UaCwgcngsIHJ5LCBjeDEsIGN5MSwgbVQsIGZyb21YLCBmcm9tWSkge1xuICAgIHZhciBjb3N0aDIgPSBmYWJyaWMudXRpbC5jb3ModGgyKSxcbiAgICAgICAgc2ludGgyID0gZmFicmljLnV0aWwuc2luKHRoMiksXG4gICAgICAgIGNvc3RoMyA9IGZhYnJpYy51dGlsLmNvcyh0aDMpLFxuICAgICAgICBzaW50aDMgPSBmYWJyaWMudXRpbC5zaW4odGgzKSxcbiAgICAgICAgdG9YID0gY29zVGggKiByeCAqIGNvc3RoMyAtIHNpblRoICogcnkgKiBzaW50aDMgKyBjeDEsXG4gICAgICAgIHRvWSA9IHNpblRoICogcnggKiBjb3N0aDMgKyBjb3NUaCAqIHJ5ICogc2ludGgzICsgY3kxLFxuICAgICAgICBjcDFYID0gZnJvbVggKyBtVCAqICggLWNvc1RoICogcnggKiBzaW50aDIgLSBzaW5UaCAqIHJ5ICogY29zdGgyKSxcbiAgICAgICAgY3AxWSA9IGZyb21ZICsgbVQgKiAoIC1zaW5UaCAqIHJ4ICogc2ludGgyICsgY29zVGggKiByeSAqIGNvc3RoMiksXG4gICAgICAgIGNwMlggPSB0b1ggKyBtVCAqICggY29zVGggKiByeCAqIHNpbnRoMyArIHNpblRoICogcnkgKiBjb3N0aDMpLFxuICAgICAgICBjcDJZID0gdG9ZICsgbVQgKiAoIHNpblRoICogcnggKiBzaW50aDMgLSBjb3NUaCAqIHJ5ICogY29zdGgzKTtcblxuICAgIHJldHVybiBbXG4gICAgICBjcDFYLCBjcDFZLFxuICAgICAgY3AyWCwgY3AyWSxcbiAgICAgIHRvWCwgdG9ZXG4gICAgXTtcbiAgfVxuXG4gIC8qXG4gICAqIFByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNhbGNWZWN0b3JBbmdsZSh1eCwgdXksIHZ4LCB2eSkge1xuICAgIHZhciB0YSA9IE1hdGguYXRhbjIodXksIHV4KSxcbiAgICAgICAgdGIgPSBNYXRoLmF0YW4yKHZ5LCB2eCk7XG4gICAgaWYgKHRiID49IHRhKSB7XG4gICAgICByZXR1cm4gdGIgLSB0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gMiAqIE1hdGguUEkgLSAodGEgLSB0Yik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERyYXdzIGFyY1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeFxuICAgKiBAcGFyYW0ge051bWJlcn0gZnlcbiAgICogQHBhcmFtIHtBcnJheX0gY29vcmRzXG4gICAqL1xuICBmYWJyaWMudXRpbC5kcmF3QXJjID0gZnVuY3Rpb24oY3R4LCBmeCwgZnksIGNvb3Jkcykge1xuICAgIHZhciByeCA9IGNvb3Jkc1swXSxcbiAgICAgICAgcnkgPSBjb29yZHNbMV0sXG4gICAgICAgIHJvdCA9IGNvb3Jkc1syXSxcbiAgICAgICAgbGFyZ2UgPSBjb29yZHNbM10sXG4gICAgICAgIHN3ZWVwID0gY29vcmRzWzRdLFxuICAgICAgICB0eCA9IGNvb3Jkc1s1XSxcbiAgICAgICAgdHkgPSBjb29yZHNbNl0sXG4gICAgICAgIHNlZ3MgPSBbW10sIFtdLCBbXSwgW11dLFxuICAgICAgICBzZWdzTm9ybSA9IGFyY1RvU2VnbWVudHModHggLSBmeCwgdHkgLSBmeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2Vnc05vcm0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNlZ3NbaV1bMF0gPSBzZWdzTm9ybVtpXVswXSArIGZ4O1xuICAgICAgc2Vnc1tpXVsxXSA9IHNlZ3NOb3JtW2ldWzFdICsgZnk7XG4gICAgICBzZWdzW2ldWzJdID0gc2Vnc05vcm1baV1bMl0gKyBmeDtcbiAgICAgIHNlZ3NbaV1bM10gPSBzZWdzTm9ybVtpXVszXSArIGZ5O1xuICAgICAgc2Vnc1tpXVs0XSA9IHNlZ3NOb3JtW2ldWzRdICsgZng7XG4gICAgICBzZWdzW2ldWzVdID0gc2Vnc05vcm1baV1bNV0gKyBmeTtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvLmFwcGx5KGN0eCwgc2Vnc1tpXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94IG9mIGEgZWxsaXB0aWMtYXJjXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeCBzdGFydCBwb2ludCBvZiBhcmNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSByeCBob3Jpem9udGFsIHJhZGl1c1xuICAgKiBAcGFyYW0ge051bWJlcn0gcnkgdmVydGljYWwgcmFkaXVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3QgYW5nbGUgb2YgaG9yaXpvbnRhbCBheGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxhcmdlIDEgb3IgMCwgd2hhdGV2ZXIgdGhlIGFyYyBpcyB0aGUgYmlnIG9yIHRoZSBzbWFsbCBvbiB0aGUgMiBwb2ludHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN3ZWVwIDEgb3IgMCwgMSBjbG9ja3dpc2Ugb3IgY291bnRlcmNsb2Nrd2lzZSBkaXJlY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR4IGVuZCBwb2ludCBvZiBhcmNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR5XG4gICAqL1xuICBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkFyYyA9IGZ1bmN0aW9uKGZ4LCBmeSwgcngsIHJ5LCByb3QsIGxhcmdlLCBzd2VlcCwgdHgsIHR5KSB7XG5cbiAgICB2YXIgZnJvbVggPSAwLCBmcm9tWSA9IDAsIGJvdW5kLCBib3VuZHMgPSBbXSxcbiAgICAgICAgc2VncyA9IGFyY1RvU2VnbWVudHModHggLSBmeCwgdHkgLSBmeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2Vncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYm91bmQgPSBnZXRCb3VuZHNPZkN1cnZlKGZyb21YLCBmcm9tWSwgc2Vnc1tpXVswXSwgc2Vnc1tpXVsxXSwgc2Vnc1tpXVsyXSwgc2Vnc1tpXVszXSwgc2Vnc1tpXVs0XSwgc2Vnc1tpXVs1XSk7XG4gICAgICBib3VuZHMucHVzaCh7IHg6IGJvdW5kWzBdLnggKyBmeCwgeTogYm91bmRbMF0ueSArIGZ5IH0pO1xuICAgICAgYm91bmRzLnB1c2goeyB4OiBib3VuZFsxXS54ICsgZngsIHk6IGJvdW5kWzFdLnkgKyBmeSB9KTtcbiAgICAgIGZyb21YID0gc2Vnc1tpXVs0XTtcbiAgICAgIGZyb21ZID0gc2Vnc1tpXVs1XTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGJvdW5kaW5nIGJveCBvZiBhIGJlemllcmN1cnZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MCBzdGFydGluZyBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgxIGZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MiBzZWNvbmRvIGNvbnRyb2wgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MyBlbmQgb2YgYmVpemVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5M1xuICAgKi9cbiAgLy8gdGFrZW4gZnJvbSBodHRwOi8vanNiaW4uY29tL2l2b21pcS81Ni9lZGl0ICBubyBjcmVkaXRzIGF2YWlsYWJsZSBmb3IgdGhhdC5cbiAgZnVuY3Rpb24gZ2V0Qm91bmRzT2ZDdXJ2ZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICB2YXIgYXJnc1N0cmluZztcbiAgICBpZiAoZmFicmljLmNhY2hlc0JvdW5kc09mQ3VydmUpIHtcbiAgICAgIGFyZ3NTdHJpbmcgPSBfam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBpZiAoZmFicmljLmJvdW5kc09mQ3VydmVDYWNoZVthcmdzU3RyaW5nXSkge1xuICAgICAgICByZXR1cm4gZmFicmljLmJvdW5kc09mQ3VydmVDYWNoZVthcmdzU3RyaW5nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3FydCA9IE1hdGguc3FydCxcbiAgICAgICAgbWluID0gTWF0aC5taW4sIG1heCA9IE1hdGgubWF4LFxuICAgICAgICBhYnMgPSBNYXRoLmFicywgdHZhbHVlcyA9IFtdLFxuICAgICAgICBib3VuZHMgPSBbW10sIFtdXSxcbiAgICAgICAgYSwgYiwgYywgdCwgdDEsIHQyLCBiMmFjLCBzcXJ0YjJhYztcblxuICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgIGMgPSAzICogeDEgLSAzICogeDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGIgPSA2ICogeTAgLSAxMiAqIHkxICsgNiAqIHkyO1xuICAgICAgICBhID0gLTMgKiB5MCArIDkgKiB5MSAtIDkgKiB5MiArIDMgKiB5MztcbiAgICAgICAgYyA9IDMgKiB5MSAtIDMgKiB5MDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFicyhhKSA8IDFlLTEyKSB7XG4gICAgICAgIGlmIChhYnMoYikgPCAxZS0xMikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHQgPSAtYyAvIGI7XG4gICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGIyYWMgPSBiICogYiAtIDQgKiBjICogYTtcbiAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNxcnRiMmFjID0gc3FydChiMmFjKTtcbiAgICAgIHQxID0gKC1iICsgc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XG4gICAgICB9XG4gICAgICB0MiA9ICgtYiAtIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB4LCB5LCBqID0gdHZhbHVlcy5sZW5ndGgsIGpsZW4gPSBqLCBtdDtcbiAgICB3aGlsZSAoai0tKSB7XG4gICAgICB0ID0gdHZhbHVlc1tqXTtcbiAgICAgIG10ID0gMSAtIHQ7XG4gICAgICB4ID0gKG10ICogbXQgKiBtdCAqIHgwKSArICgzICogbXQgKiBtdCAqIHQgKiB4MSkgKyAoMyAqIG10ICogdCAqIHQgKiB4MikgKyAodCAqIHQgKiB0ICogeDMpO1xuICAgICAgYm91bmRzWzBdW2pdID0geDtcblxuICAgICAgeSA9IChtdCAqIG10ICogbXQgKiB5MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeTEpICsgKDMgKiBtdCAqIHQgKiB0ICogeTIpICsgKHQgKiB0ICogdCAqIHkzKTtcbiAgICAgIGJvdW5kc1sxXVtqXSA9IHk7XG4gICAgfVxuXG4gICAgYm91bmRzWzBdW2psZW5dID0geDA7XG4gICAgYm91bmRzWzFdW2psZW5dID0geTA7XG4gICAgYm91bmRzWzBdW2psZW4gKyAxXSA9IHgzO1xuICAgIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5MztcbiAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAge1xuICAgICAgICB4OiBtaW4uYXBwbHkobnVsbCwgYm91bmRzWzBdKSxcbiAgICAgICAgeTogbWluLmFwcGx5KG51bGwsIGJvdW5kc1sxXSlcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHg6IG1heC5hcHBseShudWxsLCBib3VuZHNbMF0pLFxuICAgICAgICB5OiBtYXguYXBwbHkobnVsbCwgYm91bmRzWzFdKVxuICAgICAgfVxuICAgIF07XG4gICAgaWYgKGZhYnJpYy5jYWNoZXNCb3VuZHNPZkN1cnZlKSB7XG4gICAgICBmYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSA9IGdldEJvdW5kc09mQ3VydmU7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogSW52b2tlcyBtZXRob2Qgb24gYWxsIGl0ZW1zIGluIGEgZ2l2ZW4gYXJyYXlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE5hbWUgb2YgYSBtZXRob2QgdG8gaW52b2tlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gaW52b2tlKGFycmF5LCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSwgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhcmdzLmxlbmd0aCA/IGFycmF5W2ldW21ldGhvZF0uYXBwbHkoYXJyYXlbaV0sIGFyZ3MpIDogYXJyYXlbaV1bbWV0aG9kXS5jYWxsKGFycmF5W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtYXhpbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWF4KGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID49IHZhbHVlMjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtaW5pbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWluKGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxIDwgdmFsdWUyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBrID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChrLS0pIHtcbiAgICAgIGFycmF5W2tdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZChhcnJheSwgYnlQcm9wZXJ0eSwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDEsXG4gICAgICAgIHJlc3VsdCA9IGJ5UHJvcGVydHkgPyBhcnJheVtpXVtieVByb3BlcnR5XSA6IGFycmF5W2ldO1xuICAgIGlmIChieVByb3BlcnR5KSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oYXJyYXlbaV1bYnlQcm9wZXJ0eV0sIHJlc3VsdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBhcnJheVtpXVtieVByb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihhcnJheVtpXSwgcmVzdWx0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5hcnJheVxuICAgKi9cbiAgZmFicmljLnV0aWwuYXJyYXkgPSB7XG4gICAgZmlsbDogZmlsbCxcbiAgICBpbnZva2U6IGludm9rZSxcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heFxuICB9O1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIENvcGllcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIG9uZSBqcyBvYmplY3QgdG8gYW5vdGhlclxuICAgKiB0aGlzIGRvZXMgbm90IGFuZCBjYW5ub3QgY29tcGV0ZSB3aXRoIGdlbmVyaWMgdXRpbHMuXG4gICAqIERvZXMgbm90IGNsb25lIG9yIGV4dGVuZCBmYWJyaWMuT2JqZWN0IHN1YmNsYXNzZXMuXG4gICAqIFRoaXMgaXMgbW9zdGx5IGZvciBpbnRlcm5hbCB1c2UgYW5kIGhhcyBleHRyYSBoYW5kbGluZyBmb3IgZmFicmljSlMgb2JqZWN0c1xuICAgKiBpdCBza2lwcyB0aGUgY2FudmFzIHByb3BlcnR5IGluIGRlZXAgY2xvbmluZy5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLm9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gV2hlcmUgdG8gY29weSB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFdoZXJlIHRvIGNvcHkgZnJvbVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGV4dGVuZChkZXN0aW5hdGlvbiwgc291cmNlLCBkZWVwKSB7XG4gICAgLy8gSlNjcmlwdCBEb250RW51bSBidWcgaXMgbm90IHRha2VuIGNhcmUgb2ZcbiAgICAvLyB0aGUgZGVlcCBjbG9uZSBpcyBmb3IgaW50ZXJuYWwgdXNlLCBpcyBub3QgbWVhbnQgdG8gYXZvaWRcbiAgICAvLyBqYXZhc2NyaXB0IHRyYXBzIG9yIGNsb25pbmcgaHRtbCBlbGVtZW50IG9yIHNlbGYgcmVmZXJlbmNlZCBvYmplY3RzLlxuICAgIGlmIChkZWVwKSB7XG4gICAgICBpZiAoIWZhYnJpYy5pc0xpa2VseU5vZGUgJiYgc291cmNlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAvLyBhdm9pZCBjbG9uaW5nIGRlZXAgaW1hZ2VzLCBjYW52YXNlcyxcbiAgICAgICAgZGVzdGluYXRpb24gPSBzb3VyY2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBkZXN0aW5hdGlvbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25baV0gPSBleHRlbmQoeyB9LCBzb3VyY2VbaV0sIGRlZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzb3VyY2UgJiYgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnY2FudmFzJykge1xuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gZXh0ZW5kKHsgfSwgc291cmNlW3Byb3BlcnR5XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IGV4dGVuZCh7IH0sIHNvdXJjZVtwcm9wZXJ0eV0sIGRlZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgc291bmRzIG9kZCBmb3IgYW4gZXh0ZW5kIGJ1dCBpcyBvayBmb3IgcmVjdXJzaXZlIHVzZVxuICAgICAgICBkZXN0aW5hdGlvbiA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZW1wdHkgb2JqZWN0IGFuZCBjb3BpZXMgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbm90aGVyIG9iamVjdCB0byBpdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwub2JqZWN0XG4gICAqIFRPRE86IHRoaXMgZnVuY3Rpb24gcmV0dXJuIGFuIGVtcHR5IG9iamVjdCBpZiB5b3UgdHJ5IHRvIGNsb25lIG51bGxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2xvbmVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZnVuY3Rpb24gY2xvbmUob2JqZWN0LCBkZWVwKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7IH0sIG9iamVjdCwgZGVlcCk7XG4gIH1cblxuICAvKiogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5vYmplY3QgKi9cbiAgZmFicmljLnV0aWwub2JqZWN0ID0ge1xuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGNsb25lOiBjbG9uZVxuICB9O1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy51dGlsLCBmYWJyaWMuT2JzZXJ2YWJsZSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQ2FtZWxpemVzIGEgc3RyaW5nXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gY2FtZWxpemVcbiAgICogQHJldHVybiB7U3RyaW5nfSBDYW1lbGl6ZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8tKyguKT8vZywgZnVuY3Rpb24obWF0Y2gsIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3RlciA/IGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpIDogJyc7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FwaXRhbGl6ZXMgYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBjYXBpdGFsaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZpcnN0TGV0dGVyT25seV0gSWYgdHJ1ZSBvbmx5IGZpcnN0IGxldHRlciBpcyBjYXBpdGFsaXplZFxuICAgKiBhbmQgb3RoZXIgbGV0dGVycyBzdGF5IHVudG91Y2hlZCwgaWYgZmFsc2UgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkXG4gICAqIGFuZCBvdGhlciBsZXR0ZXJzIGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhcGl0YWxpemVkIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nLCBmaXJzdExldHRlck9ubHkpIHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgIChmaXJzdExldHRlck9ubHkgPyBzdHJpbmcuc2xpY2UoMSkgOiBzdHJpbmcuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlcyBYTUwgaW4gYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBlc2NhcGVcbiAgICogQHJldHVybiB7U3RyaW5nfSBFc2NhcGVkIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVhtbChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgIC5yZXBsYWNlKC8nL2csICcmYXBvczsnKVxuICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGUgYSBzdHJpbmcgaW4gdGhlIHVzZXIgcGVyY2VpdmVkIHNpbmdsZSB1bml0c1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0c3RyaW5nIFN0cmluZyB0byBlc2NhcGVcbiAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IGNvbnRhaW5pbmcgdGhlIGdyYXBoZW1lc1xuICAgKi9cbiAgZnVuY3Rpb24gZ3JhcGhlbWVTcGxpdCh0ZXh0c3RyaW5nKSB7XG4gICAgdmFyIGkgPSAwLCBjaHIsIGdyYXBoZW1lcyA9IFtdO1xuICAgIGZvciAoaSA9IDAsIGNocjsgaSA8IHRleHRzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgoY2hyID0gZ2V0V2hvbGVDaGFyKHRleHRzdHJpbmcsIGkpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBncmFwaGVtZXMucHVzaChjaHIpO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhcGhlbWVzO1xuICB9XG5cbiAgLy8gdGFrZW4gZnJvbSBtZG4gaW4gdGhlIGNoYXJBdCBkb2MgcGFnZS5cbiAgZnVuY3Rpb24gZ2V0V2hvbGVDaGFyKHN0ciwgaSkge1xuICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoaXNOYU4oY29kZSkpIHtcbiAgICAgIHJldHVybiAnJzsgLy8gUG9zaXRpb24gbm90IGZvdW5kXG4gICAgfVxuICAgIGlmIChjb2RlIDwgMHhEODAwIHx8IGNvZGUgPiAweERGRkYpIHtcbiAgICAgIHJldHVybiBzdHIuY2hhckF0KGkpO1xuICAgIH1cblxuICAgIC8vIEhpZ2ggc3Vycm9nYXRlIChjb3VsZCBjaGFuZ2UgbGFzdCBoZXggdG8gMHhEQjdGIHRvIHRyZWF0IGhpZ2ggcHJpdmF0ZVxuICAgIC8vIHN1cnJvZ2F0ZXMgYXMgc2luZ2xlIGNoYXJhY3RlcnMpXG4gICAgaWYgKDB4RDgwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA8PSAoaSArIDEpKSB7XG4gICAgICAgIHRocm93ICdIaWdoIHN1cnJvZ2F0ZSB3aXRob3V0IGZvbGxvd2luZyBsb3cgc3Vycm9nYXRlJztcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0ID0gc3RyLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgaWYgKDB4REMwMCA+IG5leHQgfHwgbmV4dCA+IDB4REZGRikge1xuICAgICAgICB0aHJvdyAnSGlnaCBzdXJyb2dhdGUgd2l0aG91dCBmb2xsb3dpbmcgbG93IHN1cnJvZ2F0ZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyLmNoYXJBdChpKSArIHN0ci5jaGFyQXQoaSArIDEpO1xuICAgIH1cbiAgICAvLyBMb3cgc3Vycm9nYXRlICgweERDMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4REZGRilcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgdGhyb3cgJ0xvdyBzdXJyb2dhdGUgd2l0aG91dCBwcmVjZWRpbmcgaGlnaCBzdXJyb2dhdGUnO1xuICAgIH1cbiAgICB2YXIgcHJldiA9IHN0ci5jaGFyQ29kZUF0KGkgLSAxKTtcblxuICAgIC8vIChjb3VsZCBjaGFuZ2UgbGFzdCBoZXggdG8gMHhEQjdGIHRvIHRyZWF0IGhpZ2ggcHJpdmF0ZVxuICAgIC8vIHN1cnJvZ2F0ZXMgYXMgc2luZ2xlIGNoYXJhY3RlcnMpXG4gICAgaWYgKDB4RDgwMCA+IHByZXYgfHwgcHJldiA+IDB4REJGRikge1xuICAgICAgdGhyb3cgJ0xvdyBzdXJyb2dhdGUgd2l0aG91dCBwcmVjZWRpbmcgaGlnaCBzdXJyb2dhdGUnO1xuICAgIH1cbiAgICAvLyBXZSBjYW4gcGFzcyBvdmVyIGxvdyBzdXJyb2dhdGVzIG5vdyBhcyB0aGUgc2Vjb25kIGNvbXBvbmVudFxuICAgIC8vIGluIGEgcGFpciB3aGljaCB3ZSBoYXZlIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cblxuICAvKipcbiAgICogU3RyaW5nIHV0aWxpdGllc1xuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKi9cbiAgZmFicmljLnV0aWwuc3RyaW5nID0ge1xuICAgIGNhbWVsaXplOiBjYW1lbGl6ZSxcbiAgICBjYXBpdGFsaXplOiBjYXBpdGFsaXplLFxuICAgIGVzY2FwZVhtbDogZXNjYXBlWG1sLFxuICAgIGdyYXBoZW1lU3BsaXQ6IGdyYXBoZW1lU3BsaXRcbiAgfTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSwgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgICBJU19ET05URU5VTV9CVUdHWSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiB7IHRvU3RyaW5nOiAxIH0pIHtcbiAgICAgICAgICBpZiAocCA9PT0gJ3RvU3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pKCksXG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBhZGRNZXRob2RzID0gZnVuY3Rpb24oa2xhc3MsIHNvdXJjZSwgcGFyZW50KSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuXG4gICAgICAgICAgaWYgKHByb3BlcnR5IGluIGtsYXNzLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgICB0eXBlb2Yga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAoc291cmNlW3Byb3BlcnR5XSArICcnKS5pbmRleE9mKCdjYWxsU3VwZXInKSA+IC0xKSB7XG5cbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPSAoZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHN1cGVyY2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3M7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSAnaW5pdGlhbGl6ZScpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKElTX0RPTlRFTlVNX0JVR0dZKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS50b1N0cmluZyA9IHNvdXJjZS50b1N0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2UudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSB7XG4gICAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS52YWx1ZU9mID0gc291cmNlLnZhbHVlT2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gIGZ1bmN0aW9uIFN1YmNsYXNzKCkgeyB9XG5cbiAgZnVuY3Rpb24gY2FsbFN1cGVyKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgcGFyZW50TWV0aG9kID0gbnVsbCxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gY2xpbWIgcHJvdG90eXBlIGNoYWluIHRvIGZpbmQgbWV0aG9kIG5vdCBlcXVhbCB0byBjYWxsZWUncyBtZXRob2RcbiAgICB3aGlsZSAoX3RoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcykge1xuICAgICAgdmFyIHN1cGVyQ2xhc3NNZXRob2QgPSBfdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXTtcbiAgICAgIGlmIChfdGhpc1ttZXRob2ROYW1lXSAhPT0gc3VwZXJDbGFzc01ldGhvZCkge1xuICAgICAgICBwYXJlbnRNZXRob2QgPSBzdXBlckNsYXNzTWV0aG9kO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgX3RoaXMgPSBfdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzLnByb3RvdHlwZTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmVudE1ldGhvZCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKCd0cmllZCB0byBjYWxsU3VwZXIgJyArIG1ldGhvZE5hbWUgKyAnLCBtZXRob2Qgbm90IGZvdW5kIGluIHByb3RvdHlwZSBjaGFpbicsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICA/IHBhcmVudE1ldGhvZC5hcHBseSh0aGlzLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpXG4gICAgICA6IHBhcmVudE1ldGhvZC5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgY3JlYXRpb24gb2YgXCJjbGFzc2VzXCIuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyZW50XSBvcHRpb25hbCBcIkNsYXNzXCIgdG8gaW5oZXJpdCBmcm9tXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gUHJvcGVydGllcyBzaGFyZWQgYnkgYWxsIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzXG4gICAqICAgICAgICAgICAgICAgICAgKGJlIGNhcmVmdWwgbW9kaWZ5aW5nIG9iamVjdHMgZGVmaW5lZCBoZXJlIGFzIHRoaXMgd291bGQgYWZmZWN0IGFsbCBpbnN0YW5jZXMpXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDbGFzcygpIHtcbiAgICB2YXIgcGFyZW50ID0gbnVsbCxcbiAgICAgICAgcHJvcGVydGllcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGFyZW50ID0gcHJvcGVydGllcy5zaGlmdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrbGFzcygpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGtsYXNzLnN1cGVyY2xhc3MgPSBwYXJlbnQ7XG4gICAga2xhc3Muc3ViY2xhc3NlcyA9IFtdO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgU3ViY2xhc3MucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgIGtsYXNzLnByb3RvdHlwZSA9IG5ldyBTdWJjbGFzcygpO1xuICAgICAgcGFyZW50LnN1YmNsYXNzZXMucHVzaChrbGFzcyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGRNZXRob2RzKGtsYXNzLCBwcm9wZXJ0aWVzW2ldLCBwYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoIWtsYXNzLnByb3RvdHlwZS5pbml0aWFsaXplKSB7XG4gICAgICBrbGFzcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGVtcHR5RnVuY3Rpb247XG4gICAgfVxuICAgIGtsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGtsYXNzO1xuICAgIGtsYXNzLnByb3RvdHlwZS5jYWxsU3VwZXIgPSBjYWxsU3VwZXI7XG4gICAgcmV0dXJuIGtsYXNzO1xuICB9XG5cbiAgZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MgPSBjcmVhdGVDbGFzcztcbn0pKCk7XG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdW5rbm93biA9ICd1bmtub3duJztcblxuICAvKiBFVkVOVCBIQU5ETElORyAqL1xuXG4gIGZ1bmN0aW9uIGFyZUhvc3RNZXRob2RzKG9iamVjdCkge1xuICAgIHZhciBtZXRob2ROYW1lcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgIHQsIGksIGxlbiA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHQgPSB0eXBlb2Ygb2JqZWN0W21ldGhvZE5hbWVzW2ldXTtcbiAgICAgIGlmICghKC9eKD86ZnVuY3Rpb258b2JqZWN0fHVua25vd24pJC8pLnRlc3QodCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaWdub3JlICovXG4gIHZhciBnZXRFbGVtZW50LFxuICAgICAgc2V0RWxlbWVudCxcbiAgICAgIGdldFVuaXF1ZUlkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVpZCA9IDA7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50Ll9fdW5pcXVlSUQgfHwgKGVsZW1lbnQuX191bmlxdWVJRCA9ICd1bmlxdWVJRF9fJyArIHVpZCsrKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKCk7XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB7IH07XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBnZXRFbGVtZW50ID0gZnVuY3Rpb24gKHVpZCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRzW3VpZF07XG4gICAgfTtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHNldEVsZW1lbnQgPSBmdW5jdGlvbiAodWlkLCBlbGVtZW50KSB7XG4gICAgICBlbGVtZW50c1t1aWRdID0gZWxlbWVudDtcbiAgICB9O1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyKHVpZCwgaGFuZGxlcikge1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgd3JhcHBlZEhhbmRsZXI6IGNyZWF0ZVdyYXBwZWRIYW5kbGVyKHVpZCwgaGFuZGxlcilcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlZEhhbmRsZXIodWlkLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICBoYW5kbGVyLmNhbGwoZ2V0RWxlbWVudCh1aWQpLCBlIHx8IGZhYnJpYy53aW5kb3cuZXZlbnQpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVEaXNwYXRjaGVyKHVpZCwgZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoaGFuZGxlcnNbdWlkXSAmJiBoYW5kbGVyc1t1aWRdW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzRm9yRXZlbnQgPSBoYW5kbGVyc1t1aWRdW2V2ZW50TmFtZV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBoYW5kbGVyc0ZvckV2ZW50Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaGFuZGxlcnNGb3JFdmVudFtpXS5jYWxsKHRoaXMsIGUgfHwgZmFicmljLndpbmRvdy5ldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHNob3VsZFVzZUFkZExpc3RlbmVyUmVtb3ZlTGlzdGVuZXIgPSAoXG4gICAgICAgIGFyZUhvc3RNZXRob2RzKGZhYnJpYy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdhZGRFdmVudExpc3RlbmVyJywgJ3JlbW92ZUV2ZW50TGlzdGVuZXInKSAmJlxuICAgICAgICBhcmVIb3N0TWV0aG9kcyhmYWJyaWMud2luZG93LCAnYWRkRXZlbnRMaXN0ZW5lcicsICdyZW1vdmVFdmVudExpc3RlbmVyJykpLFxuXG4gICAgICBzaG91bGRVc2VBdHRhY2hFdmVudERldGFjaEV2ZW50ID0gKFxuICAgICAgICBhcmVIb3N0TWV0aG9kcyhmYWJyaWMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnYXR0YWNoRXZlbnQnLCAnZGV0YWNoRXZlbnQnKSAmJlxuICAgICAgICBhcmVIb3N0TWV0aG9kcyhmYWJyaWMud2luZG93LCAnYXR0YWNoRXZlbnQnLCAnZGV0YWNoRXZlbnQnKSksXG5cbiAgICAgIC8vIElFIGJyYW5jaFxuICAgICAgbGlzdGVuZXJzID0geyB9LFxuXG4gICAgICAvLyBET00gTDAgYnJhbmNoXG4gICAgICBoYW5kbGVycyA9IHsgfSxcblxuICAgICAgYWRkTGlzdGVuZXIsIHJlbW92ZUxpc3RlbmVyO1xuXG4gIGlmIChzaG91bGRVc2VBZGRMaXN0ZW5lclJlbW92ZUxpc3RlbmVyKSB7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgIC8vIHNpbmNlIGllMTAgb3IgaWU5IGNhbiB1c2UgYWRkRXZlbnRMaXN0ZW5lciBidXQgdGhleSBkbyBub3Qgc3VwcG9ydCBvcHRpb25zLCBpIG5lZWQgdG8gY2hlY2tcbiAgICAgIGVsZW1lbnQgJiYgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgc2hvdWxkVXNlQXR0YWNoRXZlbnREZXRhY2hFdmVudCA/IGZhbHNlIDogb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgZWxlbWVudCAmJiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBzaG91bGRVc2VBdHRhY2hFdmVudERldGFjaEV2ZW50ID8gZmFsc2UgOiBvcHRpb25zKTtcbiAgICB9O1xuICB9XG5cbiAgZWxzZSBpZiAoc2hvdWxkVXNlQXR0YWNoRXZlbnREZXRhY2hFdmVudCkge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHVpZCA9IGdldFVuaXF1ZUlkKGVsZW1lbnQpO1xuICAgICAgc2V0RWxlbWVudCh1aWQsIGVsZW1lbnQpO1xuICAgICAgaWYgKCFsaXN0ZW5lcnNbdWlkXSkge1xuICAgICAgICBsaXN0ZW5lcnNbdWlkXSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIGlmICghbGlzdGVuZXJzW3VpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICBsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdID0gW107XG5cbiAgICAgIH1cbiAgICAgIHZhciBsaXN0ZW5lciA9IGNyZWF0ZUxpc3RlbmVyKHVpZCwgaGFuZGxlcik7XG4gICAgICBsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lci53cmFwcGVkSGFuZGxlcik7XG4gICAgfTtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB1aWQgPSBnZXRVbmlxdWVJZChlbGVtZW50KSwgbGlzdGVuZXI7XG4gICAgICBpZiAobGlzdGVuZXJzW3VpZF0gJiYgbGlzdGVuZXJzW3VpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzW3VpZF1bZXZlbnROYW1lXS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXJzW3VpZF1bZXZlbnROYW1lXVtpXTtcbiAgICAgICAgICBpZiAobGlzdGVuZXIgJiYgbGlzdGVuZXIuaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgZWxlbWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lci53cmFwcGVkSGFuZGxlcik7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdW2ldID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGVsc2Uge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHVpZCA9IGdldFVuaXF1ZUlkKGVsZW1lbnQpO1xuICAgICAgaWYgKCFoYW5kbGVyc1t1aWRdKSB7XG4gICAgICAgIGhhbmRsZXJzW3VpZF0gPSB7IH07XG4gICAgICB9XG4gICAgICBpZiAoIWhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICBoYW5kbGVyc1t1aWRdW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgdmFyIGV4aXN0aW5nSGFuZGxlciA9IGVsZW1lbnRbJ29uJyArIGV2ZW50TmFtZV07XG4gICAgICAgIGlmIChleGlzdGluZ0hhbmRsZXIpIHtcbiAgICAgICAgICBoYW5kbGVyc1t1aWRdW2V2ZW50TmFtZV0ucHVzaChleGlzdGluZ0hhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRbJ29uJyArIGV2ZW50TmFtZV0gPSBjcmVhdGVEaXNwYXRjaGVyKHVpZCwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdWlkID0gZ2V0VW5pcXVlSWQoZWxlbWVudCk7XG4gICAgICBpZiAoaGFuZGxlcnNbdWlkXSAmJiBoYW5kbGVyc1t1aWRdW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzRm9yRXZlbnQgPSBoYW5kbGVyc1t1aWRdW2V2ZW50TmFtZV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBoYW5kbGVyc0ZvckV2ZW50Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGhhbmRsZXJzRm9yRXZlbnRbaV0gPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzRm9yRXZlbnQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byBhbiBlbGVtZW50XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyID0gYWRkTGlzdGVuZXI7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBhbiBlbGVtZW50XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZhYnJpYy51dGlsLnJlbW92ZUxpc3RlbmVyID0gcmVtb3ZlTGlzdGVuZXI7XG5cbiAgLyoqXG4gICAqIENyb3NzLWJyb3dzZXIgd3JhcHBlciBmb3IgZ2V0dGluZyBldmVudCdzIGNvb3JkaW5hdGVzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudCBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIGdldFBvaW50ZXIoZXZlbnQpIHtcbiAgICBldmVudCB8fCAoZXZlbnQgPSBmYWJyaWMud2luZG93LmV2ZW50KTtcblxuICAgIHZhciBlbGVtZW50ID0gZXZlbnQudGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgICAodHlwZW9mIGV2ZW50LnNyY0VsZW1lbnQgIT09IHVua25vd24gPyBldmVudC5zcmNFbGVtZW50IDogbnVsbCksXG5cbiAgICAgICAgc2Nyb2xsID0gZmFicmljLnV0aWwuZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcG9pbnRlclgoZXZlbnQpICsgc2Nyb2xsLmxlZnQsXG4gICAgICB5OiBwb2ludGVyWShldmVudCkgKyBzY3JvbGwudG9wXG4gICAgfTtcbiAgfVxuXG4gIHZhciBwb2ludGVyWCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5jbGllbnRYO1xuICAgICAgfSxcblxuICAgICAgcG9pbnRlclkgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQuY2xpZW50WTtcbiAgICAgIH07XG5cbiAgZnVuY3Rpb24gX2dldFBvaW50ZXIoZXZlbnQsIHBhZ2VQcm9wLCBjbGllbnRQcm9wKSB7XG4gICAgdmFyIHRvdWNoUHJvcCA9IGV2ZW50LnR5cGUgPT09ICd0b3VjaGVuZCcgPyAnY2hhbmdlZFRvdWNoZXMnIDogJ3RvdWNoZXMnO1xuICAgIHZhciBwb2ludGVyLCBldmVudFRvdWNoUHJvcCA9IGV2ZW50W3RvdWNoUHJvcF07XG5cbiAgICBpZiAoZXZlbnRUb3VjaFByb3AgJiYgZXZlbnRUb3VjaFByb3BbMF0pIHtcbiAgICAgIHBvaW50ZXIgPSBldmVudFRvdWNoUHJvcFswXVtjbGllbnRQcm9wXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBvaW50ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwb2ludGVyID0gZXZlbnRbY2xpZW50UHJvcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50ZXI7XG4gIH1cblxuICBpZiAoZmFicmljLmlzVG91Y2hTdXBwb3J0ZWQpIHtcbiAgICBwb2ludGVyWCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICByZXR1cm4gX2dldFBvaW50ZXIoZXZlbnQsICdwYWdlWCcsICdjbGllbnRYJyk7XG4gICAgfTtcbiAgICBwb2ludGVyWSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICByZXR1cm4gX2dldFBvaW50ZXIoZXZlbnQsICdwYWdlWScsICdjbGllbnRZJyk7XG4gICAgfTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmdldFBvaW50ZXIgPSBnZXRQb2ludGVyO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyb3NzLWJyb3dzZXIgd3JhcHBlciBmb3Igc2V0dGluZyBlbGVtZW50J3Mgc3R5bGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlc1xuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGVzKSB7XG4gICAgdmFyIGVsZW1lbnRTdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgaWYgKCFlbGVtZW50U3R5bGUpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBzdHlsZXM7XG4gICAgICByZXR1cm4gc3R5bGVzLmluZGV4T2YoJ29wYWNpdHknKSA+IC0xXG4gICAgICAgID8gc2V0T3BhY2l0eShlbGVtZW50LCBzdHlsZXMubWF0Y2goL29wYWNpdHk6XFxzKihcXGQ/XFwuP1xcZCopLylbMV0pXG4gICAgICAgIDogZWxlbWVudDtcbiAgICB9XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAocHJvcGVydHkgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICBzZXRPcGFjaXR5KGVsZW1lbnQsIHN0eWxlc1twcm9wZXJ0eV0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkUHJvcGVydHkgPSAocHJvcGVydHkgPT09ICdmbG9hdCcgfHwgcHJvcGVydHkgPT09ICdjc3NGbG9hdCcpXG4gICAgICAgICAgPyAodHlwZW9mIGVsZW1lbnRTdHlsZS5zdHlsZUZsb2F0ID09PSAndW5kZWZpbmVkJyA/ICdjc3NGbG9hdCcgOiAnc3R5bGVGbG9hdCcpXG4gICAgICAgICAgOiBwcm9wZXJ0eTtcbiAgICAgICAgZWxlbWVudFN0eWxlW25vcm1hbGl6ZWRQcm9wZXJ0eV0gPSBzdHlsZXNbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHZhciBwYXJzZUVsID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgc3VwcG9ydHNPcGFjaXR5ID0gdHlwZW9mIHBhcnNlRWwuc3R5bGUub3BhY2l0eSA9PT0gJ3N0cmluZycsXG4gICAgICBzdXBwb3J0c0ZpbHRlcnMgPSB0eXBlb2YgcGFyc2VFbC5zdHlsZS5maWx0ZXIgPT09ICdzdHJpbmcnLFxuICAgICAgcmVPcGFjaXR5ID0gL2FscGhhXFxzKlxcKFxccypvcGFjaXR5XFxzKj1cXHMqKFteXFwpXSspXFwpLyxcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudDsgfTtcblxuICBpZiAoc3VwcG9ydHNPcGFjaXR5KSB7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBzZXRPcGFjaXR5ID0gZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbiAgfVxuICBlbHNlIGlmIChzdXBwb3J0c0ZpbHRlcnMpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgdmFyIGVzID0gZWxlbWVudC5zdHlsZTtcbiAgICAgIGlmIChlbGVtZW50LmN1cnJlbnRTdHlsZSAmJiAhZWxlbWVudC5jdXJyZW50U3R5bGUuaGFzTGF5b3V0KSB7XG4gICAgICAgIGVzLnpvb20gPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHJlT3BhY2l0eS50ZXN0KGVzLmZpbHRlcikpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PSAwLjk5OTkgPyAnJyA6ICgnYWxwaGEob3BhY2l0eT0nICsgKHZhbHVlICogMTAwKSArICcpJyk7XG4gICAgICAgIGVzLmZpbHRlciA9IGVzLmZpbHRlci5yZXBsYWNlKHJlT3BhY2l0eSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVzLmZpbHRlciArPSAnIGFscGhhKG9wYWNpdHk9JyArICh2YWx1ZSAqIDEwMCkgKyAnKSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICB9XG5cbiAgZmFicmljLnV0aWwuc2V0U3R5bGUgPSBzZXRTdHlsZTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIF9zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogVGFrZXMgaWQgYW5kIHJldHVybnMgYW4gZWxlbWVudCB3aXRoIHRoYXQgaWQgKGlmIG9uZSBleGlzdHMgaW4gYSBkb2N1bWVudClcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fSBpZFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZmFicmljLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xuICB9XG5cbiAgdmFyIHNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cyxcbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYW4gYXJyYXktbGlrZSBvYmplY3QgKGUuZy4gYXJndW1lbnRzIG9yIE5vZGVMaXN0KSB0byBhbiBhcnJheVxuICAgICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJyYXlMaWtlXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAqL1xuICAgICAgdG9BcnJheSA9IGZ1bmN0aW9uKGFycmF5TGlrZSkge1xuICAgICAgICByZXR1cm4gX3NsaWNlLmNhbGwoYXJyYXlMaWtlLCAwKTtcbiAgICAgIH07XG5cbiAgdHJ5IHtcbiAgICBzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMgPSB0b0FycmF5KGZhYnJpYy5kb2N1bWVudC5jaGlsZE5vZGVzKSBpbnN0YW5jZW9mIEFycmF5O1xuICB9XG4gIGNhdGNoIChlcnIpIHsgfVxuXG4gIGlmICghc2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzKSB7XG4gICAgdG9BcnJheSA9IGZ1bmN0aW9uKGFycmF5TGlrZSkge1xuICAgICAgdmFyIGFyciA9IG5ldyBBcnJheShhcnJheUxpa2UubGVuZ3RoKSwgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGFycmF5TGlrZVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHNwZWNpZmllZCBlbGVtZW50IHdpdGggc3BlY2lmaWVkIGF0dHJpYnV0ZXNcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lIFR5cGUgb2YgYW4gZWxlbWVudCB0byBjcmVhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldCBvbiBhbiBlbGVtZW50XG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBOZXdseSBjcmVhdGVkIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VFbGVtZW50KHRhZ05hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgZWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBmb3IgKHZhciBwcm9wIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChwcm9wID09PSAnY2xhc3MnKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcm9wID09PSAnZm9yJykge1xuICAgICAgICBlbC5odG1sRm9yID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGNsYXNzIHRvIGFuIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBhZGQgY2xhc3MgdG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBDbGFzcyB0byBhZGQgdG8gYW4gZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQgJiYgKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgPT09IC0xKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSAoZWxlbWVudC5jbGFzc05hbWUgPyAnICcgOiAnJykgKyBjbGFzc05hbWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGVsZW1lbnQgd2l0aCBhbm90aGVyIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byB3cmFwXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSB3cmFwcGVyIEVsZW1lbnQgdG8gd3JhcCB3aXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gQXR0cmlidXRlcyB0byBzZXQgb24gYSB3cmFwcGVyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSB3cmFwcGVyXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwRWxlbWVudChlbGVtZW50LCB3cmFwcGVyLCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKHR5cGVvZiB3cmFwcGVyID09PSAnc3RyaW5nJykge1xuICAgICAgd3JhcHBlciA9IG1ha2VFbGVtZW50KHdyYXBwZXIsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHdyYXBwZXIsIGVsZW1lbnQpO1xuICAgIH1cbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZWxlbWVudCBzY3JvbGwgb2Zmc2V0c1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIG9wZXJhdGUgb25cbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBsZWZ0L3RvcCB2YWx1ZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNjcm9sbExlZnRUb3AoZWxlbWVudCkge1xuXG4gICAgdmFyIGxlZnQgPSAwLFxuICAgICAgICB0b3AgPSAwLFxuICAgICAgICBkb2NFbGVtZW50ID0gZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgYm9keSA9IGZhYnJpYy5kb2N1bWVudC5ib2R5IHx8IHtcbiAgICAgICAgICBzY3JvbGxMZWZ0OiAwLCBzY3JvbGxUb3A6IDBcbiAgICAgICAgfTtcblxuICAgIC8vIFdoaWxlIGxvb3AgY2hlY2tzIChhbmQgdGhlbiBzZXRzIGVsZW1lbnQgdG8pIC5wYXJlbnROb2RlIE9SIC5ob3N0XG4gICAgLy8gIHRvIGFjY291bnQgZm9yIFNoYWRvd0RPTS4gV2Ugc3RpbGwgd2FudCB0byB0cmF2ZXJzZSB1cCBvdXQgb2YgU2hhZG93RE9NLFxuICAgIC8vICBidXQgdGhlIC5wYXJlbnROb2RlIG9mIGEgcm9vdCBTaGFkb3dET00gbm9kZSB3aWxsIGFsd2F5cyBiZSBudWxsLCBpbnN0ZWFkXG4gICAgLy8gIGl0IHNob3VsZCBiZSBhY2Nlc3NlZCB0aHJvdWdoIC5ob3N0LiBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjQ3NjU1MjgvNDM4MzkzOFxuICAgIHdoaWxlIChlbGVtZW50ICYmIChlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0KSkge1xuXG4gICAgICAvLyBTZXQgZWxlbWVudCB0byBlbGVtZW50IHBhcmVudCwgb3IgJ2hvc3QnIGluIGNhc2Ugb2YgU2hhZG93RE9NXG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcblxuICAgICAgaWYgKGVsZW1lbnQgPT09IGZhYnJpYy5kb2N1bWVudCkge1xuICAgICAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsZW1lbnQuc2Nyb2xsTGVmdCB8fCAwO1xuICAgICAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCAgZG9jRWxlbWVudC5zY3JvbGxUb3AgfHwgMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZWZ0ICs9IGVsZW1lbnQuc2Nyb2xsTGVmdCB8fCAwO1xuICAgICAgICB0b3AgKz0gZWxlbWVudC5zY3JvbGxUb3AgfHwgMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDEgJiYgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2Zmc2V0IGZvciBhIGdpdmVuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gZ2V0IG9mZnNldCBmb3JcbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBcImxlZnRcIiBhbmQgXCJ0b3BcIiBwcm9wZXJ0aWVzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jRWxlbSxcbiAgICAgICAgZG9jID0gZWxlbWVudCAmJiBlbGVtZW50Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGJveCA9IHsgbGVmdDogMCwgdG9wOiAwIH0sXG4gICAgICAgIG9mZnNldCA9IHsgbGVmdDogMCwgdG9wOiAwIH0sXG4gICAgICAgIHNjcm9sbExlZnRUb3AsXG4gICAgICAgIG9mZnNldEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgYm9yZGVyTGVmdFdpZHRoOiAnbGVmdCcsXG4gICAgICAgICAgYm9yZGVyVG9wV2lkdGg6ICAndG9wJyxcbiAgICAgICAgICBwYWRkaW5nTGVmdDogICAgICdsZWZ0JyxcbiAgICAgICAgICBwYWRkaW5nVG9wOiAgICAgICd0b3AnXG4gICAgICAgIH07XG5cbiAgICBpZiAoIWRvYykge1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBhdHRyIGluIG9mZnNldEF0dHJpYnV0ZXMpIHtcbiAgICAgIG9mZnNldFtvZmZzZXRBdHRyaWJ1dGVzW2F0dHJdXSArPSBwYXJzZUludChnZXRFbGVtZW50U3R5bGUoZWxlbWVudCwgYXR0ciksIDEwKSB8fCAwO1xuICAgIH1cblxuICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIGlmICggdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgIGJveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuXG4gICAgc2Nyb2xsTGVmdFRvcCA9IGdldFNjcm9sbExlZnRUb3AoZWxlbWVudCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogYm94LmxlZnQgKyBzY3JvbGxMZWZ0VG9wLmxlZnQgLSAoZG9jRWxlbS5jbGllbnRMZWZ0IHx8IDApICsgb2Zmc2V0LmxlZnQsXG4gICAgICB0b3A6IGJveC50b3AgKyBzY3JvbGxMZWZ0VG9wLnRvcCAtIChkb2NFbGVtLmNsaWVudFRvcCB8fCAwKSAgKyBvZmZzZXQudG9wXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHN0eWxlIGF0dHJpYnV0ZSB2YWx1ZSBvZiBhIGdpdmVuIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBnZXQgc3R5bGUgYXR0cmlidXRlIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBTdHlsZSBhdHRyaWJ1dGUgdG8gZ2V0IGZvciBlbGVtZW50XG4gICAqIEByZXR1cm4ge1N0cmluZ30gU3R5bGUgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKi9cbiAgdmFyIGdldEVsZW1lbnRTdHlsZTtcbiAgaWYgKGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0VmlldyAmJiBmYWJyaWMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgIGdldEVsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgIHZhciBzdHlsZSA9IGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgICAgcmV0dXJuIHN0eWxlID8gc3R5bGVbYXR0cl0gOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgfVxuICBlbHNlIHtcbiAgICBnZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XG4gICAgICB2YXIgdmFsdWUgPSBlbGVtZW50LnN0eWxlW2F0dHJdO1xuICAgICAgaWYgKCF2YWx1ZSAmJiBlbGVtZW50LmN1cnJlbnRTdHlsZSkge1xuICAgICAgICB2YWx1ZSA9IGVsZW1lbnQuY3VycmVudFN0eWxlW2F0dHJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH1cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IGZhYnJpYy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gICAgICAgIHNlbGVjdFByb3AgPSAndXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICA/ICd1c2VyU2VsZWN0J1xuICAgICAgICAgIDogJ01velVzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgICA/ICdNb3pVc2VyU2VsZWN0J1xuICAgICAgICAgICAgOiAnV2Via2l0VXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICAgICAgPyAnV2Via2l0VXNlclNlbGVjdCdcbiAgICAgICAgICAgICAgOiAnS2h0bWxVc2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgICAgICAgID8gJ0todG1sVXNlclNlbGVjdCdcbiAgICAgICAgICAgICAgICA6ICcnO1xuXG4gICAgLyoqXG4gICAgICogTWFrZXMgZWxlbWVudCB1bnNlbGVjdGFibGVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbWFrZSB1bnNlbGVjdGFibGVcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlRWxlbWVudFVuc2VsZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQub25zZWxlY3RzdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gZmFicmljLnV0aWwuZmFsc2VGdW5jdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RQcm9wKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc2VsZWN0UHJvcF0gPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC51bnNlbGVjdGFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsZW1lbnQudW5zZWxlY3RhYmxlID0gJ29uJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGVsZW1lbnQgc2VsZWN0YWJsZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBtYWtlIHNlbGVjdGFibGVcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlRWxlbWVudFNlbGVjdGFibGUoZWxlbWVudCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0UHJvcCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3NlbGVjdFByb3BdID0gJyc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC51bnNlbGVjdGFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsZW1lbnQudW5zZWxlY3RhYmxlID0gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZSA9IG1ha2VFbGVtZW50VW5zZWxlY3RhYmxlO1xuICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50U2VsZWN0YWJsZSA9IG1ha2VFbGVtZW50U2VsZWN0YWJsZTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgc2NyaXB0IGVsZW1lbnQgd2l0aCBhIGdpdmVuIHVybCBpbnRvIGEgZG9jdW1lbnQ7IGludm9rZXMgY2FsbGJhY2ssIHdoZW4gdGhhdCBzY3JpcHQgaXMgZmluaXNoZWQgbG9hZGluZ1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIG9mIGEgc2NyaXB0IHRvIGxvYWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gc2NyaXB0IGlzIGZpbmlzaGVkIGxvYWRpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTY3JpcHQodXJsLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGhlYWRFbCA9IGZhYnJpYy5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLFxuICAgICAgICAgIHNjcmlwdEVsID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuICAgICAgICAgIGxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgc2NyaXB0RWwub25sb2FkID0gLyoqIEBpZ25vcmUgKi8gc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAobG9hZGluZykge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5yZWFkeVN0YXRlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgIT09ICdsb2FkZWQnICYmXG4gICAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgY2FsbGJhY2soZSB8fCBmYWJyaWMud2luZG93LmV2ZW50KTtcbiAgICAgICAgICBzY3JpcHRFbCA9IHNjcmlwdEVsLm9ubG9hZCA9IHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzY3JpcHRFbC5zcmMgPSB1cmw7XG4gICAgICBoZWFkRWwuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgLy8gY2F1c2VzIGlzc3VlIGluIE9wZXJhXG4gICAgICAvLyBoZWFkRWwucmVtb3ZlQ2hpbGQoc2NyaXB0RWwpO1xuICAgIH1cblxuICAgIGZhYnJpYy51dGlsLmdldFNjcmlwdCA9IGdldFNjcmlwdDtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBnZXROb2RlQ2FudmFzKGVsZW1lbnQpIHtcbiAgICB2YXIgaW1wbCA9IGZhYnJpYy5qc2RvbUltcGxGb3JXcmFwcGVyKGVsZW1lbnQpO1xuICAgIHJldHVybiBpbXBsLl9jYW52YXMgfHwgaW1wbC5faW1hZ2U7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2xlYW5VcEpzZG9tTm9kZShlbGVtZW50KSB7XG4gICAgaWYgKCFmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbXBsID0gZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIoZWxlbWVudCk7XG4gICAgaWYgKGltcGwpIHtcbiAgICAgIGltcGwuX2ltYWdlID0gbnVsbDtcbiAgICAgIGltcGwuX2NhbnZhcyA9IG51bGw7XG4gICAgICAvLyB1bnN1cmUgaWYgbmVjZXNzYXJ5XG4gICAgICBpbXBsLl9jdXJyZW50U3JjID0gbnVsbDtcbiAgICAgIGltcGwuX2F0dHJpYnV0ZXMgPSBudWxsO1xuICAgICAgaW1wbC5fY2xhc3NMaXN0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmYWJyaWMudXRpbC5nZXRCeUlkID0gZ2V0QnlJZDtcbiAgZmFicmljLnV0aWwudG9BcnJheSA9IHRvQXJyYXk7XG4gIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50ID0gbWFrZUVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLmFkZENsYXNzID0gYWRkQ2xhc3M7XG4gIGZhYnJpYy51dGlsLndyYXBFbGVtZW50ID0gd3JhcEVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLmdldFNjcm9sbExlZnRUb3AgPSBnZXRTY3JvbGxMZWZ0VG9wO1xuICBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0ID0gZ2V0RWxlbWVudE9mZnNldDtcbiAgZmFicmljLnV0aWwuZ2V0RWxlbWVudFN0eWxlID0gZ2V0RWxlbWVudFN0eWxlO1xuICBmYWJyaWMudXRpbC5nZXROb2RlQ2FudmFzID0gZ2V0Tm9kZUNhbnZhcztcbiAgZmFicmljLnV0aWwuY2xlYW5VcEpzZG9tTm9kZSA9IGNsZWFuVXBKc2RvbU5vZGU7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIGFkZFBhcmFtVG9VcmwodXJsLCBwYXJhbSkge1xuICAgIHJldHVybiB1cmwgKyAoL1xcPy8udGVzdCh1cmwpID8gJyYnIDogJz8nKSArIHBhcmFtO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlGbigpIHsgfVxuXG4gIC8qKlxuICAgKiBDcm9zcy1icm93c2VyIGFic3RyYWN0aW9uIGZvciBzZW5kaW5nIFhNTEh0dHBSZXF1ZXN0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBzZW5kIFhNTEh0dHBSZXF1ZXN0IHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1ldGhvZD1cIkdFVFwiXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFyYW1ldGVyc10gcGFyYW1ldGVycyB0byBhcHBlbmQgdG8gdXJsIGluIEdFVCBvciBpbiBib2R5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ib2R5XSBib2R5IHRvIHNlbmQgd2l0aCBQT1NUIG9yIFBVVCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25Db21wbGV0ZSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiByZXF1ZXN0IGlzIGNvbXBsZXRlZFxuICAgKiBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdH0gcmVxdWVzdFxuICAgKi9cbiAgZnVuY3Rpb24gcmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCA/IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiAnR0VUJyxcbiAgICAgICAgb25Db21wbGV0ZSA9IG9wdGlvbnMub25Db21wbGV0ZSB8fCBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgeGhyID0gbmV3IGZhYnJpYy53aW5kb3cuWE1MSHR0cFJlcXVlc3QoKSxcbiAgICAgICAgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLnBhcmFtZXRlcnM7XG5cbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBvbkNvbXBsZXRlKHhocik7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eUZuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgYm9keSA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMucGFyYW1ldGVycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdXJsID0gYWRkUGFyYW1Ub1VybCh1cmwsIG9wdGlvbnMucGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ1BPU1QnIHx8IG1ldGhvZCA9PT0gJ1BVVCcpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgfVxuXG4gICAgeGhyLnNlbmQoYm9keSk7XG4gICAgcmV0dXJuIHhocjtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLnJlcXVlc3QgPSByZXF1ZXN0O1xufSkoKTtcblxuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIGBjb25zb2xlLmxvZ2AgKHdoZW4gYXZhaWxhYmxlKVxuICogQHBhcmFtIHsqfSBbdmFsdWVzXSBWYWx1ZXMgdG8gbG9nXG4gKi9cbmZhYnJpYy5sb2cgPSBmdW5jdGlvbigpIHsgfTtcblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBgY29uc29sZS53YXJuYCAod2hlbiBhdmFpbGFibGUpXG4gKiBAcGFyYW0geyp9IFt2YWx1ZXNdIFZhbHVlcyB0byBsb2cgYXMgYSB3YXJuaW5nXG4gKi9cbmZhYnJpYy53YXJuID0gZnVuY3Rpb24oKSB7IH07XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgWydsb2cnLCAnd2FybiddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlW21ldGhvZE5hbWVdICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgY29uc29sZVttZXRob2ROYW1lXS5hcHBseSA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICBmYWJyaWNbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGVbbWV0aG9kTmFtZV0uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cbi8qIGVzbGludC1lbmFibGUgKi9cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB2YWx1ZSBmcm9tIG9uZSB0byBhbm90aGVyIHdpdGhpbiBjZXJ0YWluIHBlcmlvZCBvZiB0aW1lLCBpbnZva2luZyBjYWxsYmFja3MgYXMgdmFsdWUgaXMgYmVpbmcgY2hhbmdlZC5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW5pbWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25DaGFuZ2VdIENhbGxiYWNrOyBpbnZva2VkIG9uIGV2ZXJ5IHZhbHVlIGNoYW5nZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNvbXBsZXRlXSBDYWxsYmFjazsgaW52b2tlZCB3aGVuIHZhbHVlIGNoYW5nZSBpcyBjb21wbGV0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0YXJ0VmFsdWU9MF0gU3RhcnRpbmcgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVuZFZhbHVlPTEwMF0gRW5kaW5nIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ieVZhbHVlPTEwMF0gVmFsdWUgdG8gbW9kaWZ5IHRoZSBwcm9wZXJ0eSBieVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5lYXNpbmddIEVhc2luZyBmdW5jdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb249NTAwXSBEdXJhdGlvbiBvZiBjaGFuZ2UgKGluIG1zKVxuICAgKi9cbiAgZnVuY3Rpb24gYW5pbWF0ZShvcHRpb25zKSB7XG5cbiAgICByZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBzdGFydCA9IHRpbWVzdGFtcCB8fCArbmV3IERhdGUoKSxcbiAgICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgNTAwLFxuICAgICAgICAgIGZpbmlzaCA9IHN0YXJ0ICsgZHVyYXRpb24sIHRpbWUsXG4gICAgICAgICAgb25DaGFuZ2UgPSBvcHRpb25zLm9uQ2hhbmdlIHx8IG5vb3AsXG4gICAgICAgICAgYWJvcnQgPSBvcHRpb25zLmFib3J0IHx8IG5vb3AsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IG9wdGlvbnMub25Db21wbGV0ZSB8fCBub29wLFxuICAgICAgICAgIGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nIHx8IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtyZXR1cm4gLWMgKiBNYXRoLmNvcyh0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYyArIGI7fSxcbiAgICAgICAgICBzdGFydFZhbHVlID0gJ3N0YXJ0VmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXJ0VmFsdWUgOiAwLFxuICAgICAgICAgIGVuZFZhbHVlID0gJ2VuZFZhbHVlJyBpbiBvcHRpb25zID8gb3B0aW9ucy5lbmRWYWx1ZSA6IDEwMCxcbiAgICAgICAgICBieVZhbHVlID0gb3B0aW9ucy5ieVZhbHVlIHx8IGVuZFZhbHVlIC0gc3RhcnRWYWx1ZTtcblxuICAgICAgb3B0aW9ucy5vblN0YXJ0ICYmIG9wdGlvbnMub25TdGFydCgpO1xuXG4gICAgICAoZnVuY3Rpb24gdGljayh0aWNrdGltZSkge1xuICAgICAgICBpZiAoYWJvcnQoKSkge1xuICAgICAgICAgIG9uQ29tcGxldGUoZW5kVmFsdWUsIDEsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lID0gdGlja3RpbWUgfHwgK25ldyBEYXRlKCk7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IHRpbWUgPiBmaW5pc2ggPyBkdXJhdGlvbiA6ICh0aW1lIC0gc3RhcnQpLFxuICAgICAgICAgICAgdGltZVBlcmMgPSBjdXJyZW50VGltZSAvIGR1cmF0aW9uLFxuICAgICAgICAgICAgY3VycmVudCA9IGVhc2luZyhjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgYnlWYWx1ZSwgZHVyYXRpb24pLFxuICAgICAgICAgICAgdmFsdWVQZXJjID0gTWF0aC5hYnMoKGN1cnJlbnQgLSBzdGFydFZhbHVlKSAvIGJ5VmFsdWUpO1xuICAgICAgICBvbkNoYW5nZShjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKTtcbiAgICAgICAgaWYgKHRpbWUgPiBmaW5pc2gpIHtcbiAgICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUgJiYgb3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltRnJhbWUodGljayk7XG4gICAgICB9KShzdGFydCk7XG4gICAgfSk7XG5cbiAgfVxuXG4gIHZhciBfcmVxdWVzdEFuaW1GcmFtZSA9IGZhYnJpYy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhYnJpYy53aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICB2YXIgX2NhbmNlbEFuaW1GcmFtZSA9IGZhYnJpYy53aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZmFicmljLndpbmRvdy5jbGVhclRpbWVvdXQ7XG5cbiAgLyoqXG4gICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBiYXNlZCBvbiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICAgKiBJbiBvcmRlciB0byBnZXQgYSBwcmVjaXNlIHN0YXJ0IHRpbWUsIGByZXF1ZXN0QW5pbUZyYW1lYCBzaG91bGQgYmUgY2FsbGVkIGFzIGFuIGVudHJ5IGludG8gdGhlIG1ldGhvZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCBvcHRpb25hbCBFbGVtZW50IHRvIGFzc29jaWF0ZSB3aXRoIGFuaW1hdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZSgpIHtcbiAgICByZXR1cm4gX3JlcXVlc3RBbmltRnJhbWUuYXBwbHkoZmFicmljLndpbmRvdywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZSgpIHtcbiAgICByZXR1cm4gX2NhbmNlbEFuaW1GcmFtZS5hcHBseShmYWJyaWMud2luZG93LCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZmFicmljLnV0aWwuYW5pbWF0ZSA9IGFuaW1hdGU7XG4gIGZhYnJpYy51dGlsLnJlcXVlc3RBbmltRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lO1xuICBmYWJyaWMudXRpbC5jYW5jZWxBbmltRnJhbWUgPSBjYW5jZWxBbmltRnJhbWU7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLy8gQ2FsY3VsYXRlIGFuIGluLWJldHdlZW4gY29sb3IuIFJldHVybnMgYSBcInJnYmEoKVwiIHN0cmluZy5cbiAgLy8gQ3JlZGl0OiBFZHdpbiBNYXJ0aW4gPGVkd2luQGJpdHN0b3JtLm9yZz5cbiAgLy8gICAgICAgICBodHRwOi8vd3d3LmJpdHN0b3JtLm9yZy9qcXVlcnkvY29sb3ItYW5pbWF0aW9uL2pxdWVyeS5hbmltYXRlLWNvbG9ycy5qc1xuICBmdW5jdGlvbiBjYWxjdWxhdGVDb2xvcihiZWdpbiwgZW5kLCBwb3MpIHtcbiAgICB2YXIgY29sb3IgPSAncmdiYSgnXG4gICAgICAgICsgcGFyc2VJbnQoKGJlZ2luWzBdICsgcG9zICogKGVuZFswXSAtIGJlZ2luWzBdKSksIDEwKSArICcsJ1xuICAgICAgICArIHBhcnNlSW50KChiZWdpblsxXSArIHBvcyAqIChlbmRbMV0gLSBiZWdpblsxXSkpLCAxMCkgKyAnLCdcbiAgICAgICAgKyBwYXJzZUludCgoYmVnaW5bMl0gKyBwb3MgKiAoZW5kWzJdIC0gYmVnaW5bMl0pKSwgMTApO1xuXG4gICAgY29sb3IgKz0gJywnICsgKGJlZ2luICYmIGVuZCA/IHBhcnNlRmxvYXQoYmVnaW5bM10gKyBwb3MgKiAoZW5kWzNdIC0gYmVnaW5bM10pKSA6IDEpO1xuICAgIGNvbG9yICs9ICcpJztcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgY29sb3IgZnJvbSBvbmUgdG8gYW5vdGhlciB3aXRoaW4gY2VydGFpbiBwZXJpb2Qgb2YgdGltZSwgaW52b2tpbmcgY2FsbGJhY2tzIGFzIHZhbHVlIGlzIGJlaW5nIGNoYW5nZWQuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbUNvbG9yIFRoZSBzdGFydGluZyBjb2xvciBpbiBoZXggb3IgcmdiKGEpIGZvcm1hdC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRvQ29sb3IgVGhlIHN0YXJ0aW5nIGNvbG9yIGluIGhleCBvciByZ2IoYSkgZm9ybWF0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uXSBEdXJhdGlvbiBvZiBjaGFuZ2UgKGluIG1zKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNoYW5nZV0gQ2FsbGJhY2s7IGludm9rZWQgb24gZXZlcnkgdmFsdWUgY2hhbmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ29tcGxldGVdIENhbGxiYWNrOyBpbnZva2VkIHdoZW4gdmFsdWUgY2hhbmdlIGlzIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jb2xvckVhc2luZ10gRWFzaW5nIGZ1bmN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBvbmx5IHRha2UgdHdvIGFyZ3VtZW50cyAoY3VycmVudFRpbWUsIGR1cmF0aW9uKS4gVGh1cyB0aGUgcmVndWxhciBhbmltYXRpb24gZWFzaW5nIGZ1bmN0aW9ucyBjYW5ub3QgYmUgdXNlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGFuaW1hdGVDb2xvcihmcm9tQ29sb3IsIHRvQ29sb3IsIGR1cmF0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIHN0YXJ0Q29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGZyb21Db2xvcikuZ2V0U291cmNlKCksXG4gICAgICAgIGVuZENvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0b0NvbG9yKS5nZXRTb3VyY2UoKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZShmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiB8fCA1MDAsXG4gICAgICBzdGFydFZhbHVlOiBzdGFydENvbG9yLFxuICAgICAgZW5kVmFsdWU6IGVuZENvbG9yLFxuICAgICAgYnlWYWx1ZTogZW5kQ29sb3IsXG4gICAgICBlYXNpbmc6IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgYnlWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIHBvc1ZhbHVlID0gb3B0aW9ucy5jb2xvckVhc2luZ1xuICAgICAgICAgID8gb3B0aW9ucy5jb2xvckVhc2luZyhjdXJyZW50VGltZSwgZHVyYXRpb24pXG4gICAgICAgICAgOiAxIC0gTWF0aC5jb3MoY3VycmVudFRpbWUgLyBkdXJhdGlvbiAqIChNYXRoLlBJIC8gMikpO1xuICAgICAgICByZXR1cm4gY2FsY3VsYXRlQ29sb3Ioc3RhcnRWYWx1ZSwgYnlWYWx1ZSwgcG9zVmFsdWUpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmFuaW1hdGVDb2xvciA9IGFuaW1hdGVDb2xvcjtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplKGEsIGMsIHAsIHMpIHtcbiAgICBpZiAoYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICBhID0gYztcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL2hhbmRsZSB0aGUgMC8wIGNhc2U6XG4gICAgICBpZiAoYyA9PT0gMCAmJiBhID09PSAwKSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhOiBhLCBjOiBjLCBwOiBwLCBzOiBzIH07XG4gIH1cblxuICBmdW5jdGlvbiBlbGFzdGljKG9wdHMsIHQsIGQpIHtcbiAgICByZXR1cm4gb3B0cy5hICpcbiAgICAgIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICpcbiAgICAgIE1hdGguc2luKCAodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1YmljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRDdWJpYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ3ViaWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVhcnRpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRRdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRRdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gLWMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5RdWludCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dFF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbnVzb2lkYWwgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5TaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiBNYXRoLmNvcyh0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogU2ludXNvaWRhbCBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0U2luZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiBNYXRoLnNpbih0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW51c29pZGFsIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRTaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgLyAyICogKE1hdGguY29zKE1hdGguUEkgKiB0IC8gZCkgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5FeHBvKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gKHQgPT09IDApID8gYiA6IGMgKiBNYXRoLnBvdygyLCAxMCAqICh0IC8gZCAtIDEpKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEV4cG8odCwgYiwgYywgZCkge1xuICAgIHJldHVybiAodCA9PT0gZCkgPyBiICsgYyA6IGMgKiAoLU1hdGgucG93KDIsIC0xMCAqIHQgLyBkKSArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0RXhwbyh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBpZiAodCA9PT0gZCkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkNpcmModCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIChNYXRoLnNxcnQoMSAtICh0IC89IGQpICogdCkgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dENpcmModCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogTWF0aC5zcXJ0KDEgLSAodCA9IHQgLyBkIC0gMSkgKiB0KSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dENpcmModCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gLWMgLyAyICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5FbGFzdGljKHQsIGIsIGMsIGQpIHtcbiAgICB2YXIgcyA9IDEuNzAxNTgsIHAgPSAwLCBhID0gYztcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHQgLz0gZDtcbiAgICBpZiAodCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogMC4zO1xuICAgIH1cbiAgICB2YXIgb3B0cyA9IG5vcm1hbGl6ZShhLCBjLCBwLCBzKTtcbiAgICByZXR1cm4gLWVsYXN0aWMob3B0cywgdCwgZCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkO1xuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAwLjM7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIHJldHVybiBvcHRzLmEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICkgKyBvcHRzLmMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA9PT0gMikge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogKDAuMyAqIDEuNSk7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiBlbGFzdGljKG9wdHMsIHQsIGQpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIG9wdHMuYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqXG4gICAgICBNYXRoLnNpbigodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApICogMC41ICsgb3B0cy5jICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrd2FyZHMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5CYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRCYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0QmFjayh0LCBiLCBjLCBkLCBzKSB7XG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcyA9IDEuNzAxNTg7XG4gICAgfVxuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb3VuY2luZyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgLSBlYXNlT3V0Qm91bmNlIChkIC0gdCwgMCwgYywgZCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRCb3VuY2UodCwgYiwgYywgZCkge1xuICAgIGlmICgodCAvPSBkKSA8ICgxIC8gMi43NSkpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqIHQgKiB0KSArIGI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHQgPCAoMiAvIDIuNzUpKSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMS41IC8gMi43NSkpICogdCArIDAuNzUpICsgYjtcbiAgICB9XG4gICAgZWxzZSBpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgMC45Mzc1KSArIGI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuNjI1IC8gMi43NSkpICogdCArIDAuOTg0Mzc1KSArIGI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRCb3VuY2UodCwgYiwgYywgZCkge1xuICAgIGlmICh0IDwgZCAvIDIpIHtcbiAgICAgIHJldHVybiBlYXNlSW5Cb3VuY2UgKHQgKiAyLCAwLCBjLCBkKSAqIDAuNSArIGI7XG4gICAgfVxuICAgIHJldHVybiBlYXNlT3V0Qm91bmNlKHQgKiAyIC0gZCwgMCwgYywgZCkgKiAwLjUgKyBjICogMC41ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFYXNpbmcgZnVuY3Rpb25zXG4gICAqIFNlZSA8YSBocmVmPVwiaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXCI+RWFzaW5nIEVxdWF0aW9ucyBieSBSb2JlcnQgUGVubmVyPC9hPlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZhYnJpYy51dGlsLmVhc2UgPSB7XG5cbiAgICAvKipcbiAgICAgKiBRdWFkcmF0aWMgZWFzaW5nIGluXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1YWRyYXRpYyBlYXNpbmcgb3V0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlT3V0UXVhZDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVhZHJhdGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICB0IC89IChkIC8gMik7XG4gICAgICBpZiAodCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKyBiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC1jIC8gMiAqICgoLS10KSAqICh0IC0gMikgLSAxKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEN1YmljIGVhc2luZyBpblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAgICovXG4gICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCArIGI7XG4gICAgfSxcblxuICAgIGVhc2VPdXRDdWJpYzogZWFzZU91dEN1YmljLFxuICAgIGVhc2VJbk91dEN1YmljOiBlYXNlSW5PdXRDdWJpYyxcbiAgICBlYXNlSW5RdWFydDogZWFzZUluUXVhcnQsXG4gICAgZWFzZU91dFF1YXJ0OiBlYXNlT3V0UXVhcnQsXG4gICAgZWFzZUluT3V0UXVhcnQ6IGVhc2VJbk91dFF1YXJ0LFxuICAgIGVhc2VJblF1aW50OiBlYXNlSW5RdWludCxcbiAgICBlYXNlT3V0UXVpbnQ6IGVhc2VPdXRRdWludCxcbiAgICBlYXNlSW5PdXRRdWludDogZWFzZUluT3V0UXVpbnQsXG4gICAgZWFzZUluU2luZTogZWFzZUluU2luZSxcbiAgICBlYXNlT3V0U2luZTogZWFzZU91dFNpbmUsXG4gICAgZWFzZUluT3V0U2luZTogZWFzZUluT3V0U2luZSxcbiAgICBlYXNlSW5FeHBvOiBlYXNlSW5FeHBvLFxuICAgIGVhc2VPdXRFeHBvOiBlYXNlT3V0RXhwbyxcbiAgICBlYXNlSW5PdXRFeHBvOiBlYXNlSW5PdXRFeHBvLFxuICAgIGVhc2VJbkNpcmM6IGVhc2VJbkNpcmMsXG4gICAgZWFzZU91dENpcmM6IGVhc2VPdXRDaXJjLFxuICAgIGVhc2VJbk91dENpcmM6IGVhc2VJbk91dENpcmMsXG4gICAgZWFzZUluRWxhc3RpYzogZWFzZUluRWxhc3RpYyxcbiAgICBlYXNlT3V0RWxhc3RpYzogZWFzZU91dEVsYXN0aWMsXG4gICAgZWFzZUluT3V0RWxhc3RpYzogZWFzZUluT3V0RWxhc3RpYyxcbiAgICBlYXNlSW5CYWNrOiBlYXNlSW5CYWNrLFxuICAgIGVhc2VPdXRCYWNrOiBlYXNlT3V0QmFjayxcbiAgICBlYXNlSW5PdXRCYWNrOiBlYXNlSW5PdXRCYWNrLFxuICAgIGVhc2VJbkJvdW5jZTogZWFzZUluQm91bmNlLFxuICAgIGVhc2VPdXRCb3VuY2U6IGVhc2VPdXRCb3VuY2UsXG4gICAgZWFzZUluT3V0Qm91bmNlOiBlYXNlSW5PdXRCb3VuY2VcbiAgfTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBmYWJyaWNcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIHBhcnNlVW5pdCA9IGZhYnJpYy51dGlsLnBhcnNlVW5pdCxcbiAgICAgIG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMgPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzLFxuXG4gICAgICBzdmdWYWxpZFRhZ05hbWVzID0gWydwYXRoJywgJ2NpcmNsZScsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ2VsbGlwc2UnLCAncmVjdCcsICdsaW5lJyxcbiAgICAgICAgJ2ltYWdlJywgJ3RleHQnXSxcbiAgICAgIHN2Z1ZpZXdCb3hFbGVtZW50cyA9IFsnc3ltYm9sJywgJ2ltYWdlJywgJ21hcmtlcicsICdwYXR0ZXJuJywgJ3ZpZXcnLCAnc3ZnJ10sXG4gICAgICBzdmdJbnZhbGlkQW5jZXN0b3JzID0gWydwYXR0ZXJuJywgJ2RlZnMnLCAnc3ltYm9sJywgJ21ldGFkYXRhJywgJ2NsaXBQYXRoJywgJ21hc2snLCAnZGVzYyddLFxuICAgICAgc3ZnVmFsaWRQYXJlbnRzID0gWydzeW1ib2wnLCAnZycsICdhJywgJ3N2ZycsICdjbGlwUGF0aCcsICdkZWZzJ10sXG5cbiAgICAgIGF0dHJpYnV0ZXNNYXAgPSB7XG4gICAgICAgIGN4OiAgICAgICAgICAgICAgICAgICAnbGVmdCcsXG4gICAgICAgIHg6ICAgICAgICAgICAgICAgICAgICAnbGVmdCcsXG4gICAgICAgIHI6ICAgICAgICAgICAgICAgICAgICAncmFkaXVzJyxcbiAgICAgICAgY3k6ICAgICAgICAgICAgICAgICAgICd0b3AnLFxuICAgICAgICB5OiAgICAgICAgICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgIGRpc3BsYXk6ICAgICAgICAgICAgICAndmlzaWJsZScsXG4gICAgICAgIHZpc2liaWxpdHk6ICAgICAgICAgICAndmlzaWJsZScsXG4gICAgICAgIHRyYW5zZm9ybTogICAgICAgICAgICAndHJhbnNmb3JtTWF0cml4JyxcbiAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6ICAgICAgICdmaWxsT3BhY2l0eScsXG4gICAgICAgICdmaWxsLXJ1bGUnOiAgICAgICAgICAnZmlsbFJ1bGUnLFxuICAgICAgICAnZm9udC1mYW1pbHknOiAgICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgICAnZm9udC1zaXplJzogICAgICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICAgJ2ZvbnQtc3R5bGUnOiAgICAgICAgICdmb250U3R5bGUnLFxuICAgICAgICAnZm9udC13ZWlnaHQnOiAgICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgICAnbGV0dGVyLXNwYWNpbmcnOiAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgICAgJ3BhaW50LW9yZGVyJzogICAgICAgICdwYWludEZpcnN0JyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAgICdzdHJva2VEYXNoQXJyYXknLFxuICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAgJ3N0cm9rZURhc2hPZmZzZXQnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAgICAgJ3N0cm9rZUxpbmVDYXAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVqb2luJzogICAgJ3N0cm9rZUxpbmVKb2luJyxcbiAgICAgICAgJ3N0cm9rZS1taXRlcmxpbWl0JzogICdzdHJva2VNaXRlckxpbWl0JyxcbiAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICAgICAgICdzdHJva2VXaWR0aCcsXG4gICAgICAgICd0ZXh0LWRlY29yYXRpb24nOiAgICAndGV4dERlY29yYXRpb24nLFxuICAgICAgICAndGV4dC1hbmNob3InOiAgICAgICAgJ3RleHRBbmNob3InLFxuICAgICAgICBvcGFjaXR5OiAgICAgICAgICAgICAgJ29wYWNpdHknLFxuICAgICAgICAnY2xpcC1wYXRoJzogICAgICAgICAgJ2NsaXBQYXRoJyxcbiAgICAgICAgJ2NsaXAtcnVsZSc6ICAgICAgICAgICdjbGlwUnVsZScsXG4gICAgICB9LFxuXG4gICAgICBjb2xvckF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHN0cm9rZTogJ3N0cm9rZU9wYWNpdHknLFxuICAgICAgICBmaWxsOiAgICdmaWxsT3BhY2l0eSdcbiAgICAgIH07XG5cbiAgZmFicmljLnN2Z1ZhbGlkVGFnTmFtZXNSZWdFeCA9IGdldFN2Z1JlZ2V4KHN2Z1ZhbGlkVGFnTmFtZXMpO1xuICBmYWJyaWMuc3ZnVmlld0JveEVsZW1lbnRzUmVnRXggPSBnZXRTdmdSZWdleChzdmdWaWV3Qm94RWxlbWVudHMpO1xuICBmYWJyaWMuc3ZnSW52YWxpZEFuY2VzdG9yc1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnSW52YWxpZEFuY2VzdG9ycyk7XG4gIGZhYnJpYy5zdmdWYWxpZFBhcmVudHNSZWdFeCA9IGdldFN2Z1JlZ2V4KHN2Z1ZhbGlkUGFyZW50cyk7XG5cbiAgZmFicmljLmNzc1J1bGVzID0geyB9O1xuICBmYWJyaWMuZ3JhZGllbnREZWZzID0geyB9O1xuICBmYWJyaWMuY2xpcFBhdGhzID0geyB9O1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHIoYXR0cikge1xuICAgIC8vIHRyYW5zZm9ybSBhdHRyaWJ1dGUgbmFtZXNcbiAgICBpZiAoYXR0ciBpbiBhdHRyaWJ1dGVzTWFwKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlc01hcFthdHRyXTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHI7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZShhdHRyLCB2YWx1ZSwgcGFyZW50QXR0cmlidXRlcywgZm9udFNpemUpIHtcbiAgICB2YXIgaXNBcnJheSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICAgIHBhcnNlZDtcblxuICAgIGlmICgoYXR0ciA9PT0gJ2ZpbGwnIHx8IGF0dHIgPT09ICdzdHJva2UnKSAmJiB2YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnc3Ryb2tlRGFzaEFycmF5Jykge1xuICAgICAgaWYgKHZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvLC9nLCAnICcpLnNwbGl0KC9cXHMrLykubWFwKHBhcnNlRmxvYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAndHJhbnNmb3JtTWF0cml4Jykge1xuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgcGFyZW50QXR0cmlidXRlcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdmFsdWUgPSBtdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKFxuICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZXMudHJhbnNmb3JtTWF0cml4LCBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICd2aXNpYmxlJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gJ25vbmUnICYmIHZhbHVlICE9PSAnaGlkZGVuJztcbiAgICAgIC8vIGRpc3BsYXk9bm9uZSBvbiBwYXJlbnQgZWxlbWVudCBhbHdheXMgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGNoaWxkIGVsZW1lbnRcbiAgICAgIGlmIChwYXJlbnRBdHRyaWJ1dGVzICYmIHBhcmVudEF0dHJpYnV0ZXMudmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ29wYWNpdHknKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgdHlwZW9mIHBhcmVudEF0dHJpYnV0ZXMub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFsdWUgKj0gcGFyZW50QXR0cmlidXRlcy5vcGFjaXR5O1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAndGV4dEFuY2hvcicgLyogdGV4dC1hbmNob3IgKi8pIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT09ICdzdGFydCcgPyAnbGVmdCcgOiB2YWx1ZSA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdjaGFyU3BhY2luZycpIHtcbiAgICAgIC8vIHBhcnNlVW5pdCByZXR1cm5zIHB4IGFuZCB3ZSBjb252ZXJ0IGl0IHRvIGVtXG4gICAgICBwYXJzZWQgPSBwYXJzZVVuaXQodmFsdWUsIGZvbnRTaXplKSAvIGZvbnRTaXplICogMTAwMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3BhaW50Rmlyc3QnKSB7XG4gICAgICB2YXIgZmlsbEluZGV4ID0gdmFsdWUuaW5kZXhPZignZmlsbCcpO1xuICAgICAgdmFyIHN0cm9rZUluZGV4ID0gdmFsdWUuaW5kZXhPZignc3Ryb2tlJyk7XG4gICAgICB2YXIgdmFsdWUgPSAnZmlsbCc7XG4gICAgICBpZiAoZmlsbEluZGV4ID4gLTEgJiYgc3Ryb2tlSW5kZXggPiAtMSAmJiBzdHJva2VJbmRleCA8IGZpbGxJbmRleCkge1xuICAgICAgICB2YWx1ZSA9ICdzdHJva2UnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmlsbEluZGV4ID09PSAtMSAmJiBzdHJva2VJbmRleCA+IC0xKSB7XG4gICAgICAgIHZhbHVlID0gJ3N0cm9rZSc7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdocmVmJyB8fCBhdHRyID09PSAneGxpbms6aHJlZicpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwYXJzZWQgPSBpc0FycmF5ID8gdmFsdWUubWFwKHBhcnNlVW5pdCkgOiBwYXJzZVVuaXQodmFsdWUsIGZvbnRTaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCFpc0FycmF5ICYmIGlzTmFOKHBhcnNlZCkgPyB2YWx1ZSA6IHBhcnNlZCk7XG4gIH1cblxuICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3ZnUmVnZXgoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14oJyArIGFyci5qb2luKCd8JykgKyAnKVxcXFxiJywgJ2knKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHBhcnNlXG4gICAqL1xuICBmdW5jdGlvbiBfc2V0U3Ryb2tlRmlsbE9wYWNpdHkoYXR0cmlidXRlcykge1xuICAgIGZvciAodmFyIGF0dHIgaW4gY29sb3JBdHRyaWJ1dGVzKSB7XG5cbiAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlc1tjb2xvckF0dHJpYnV0ZXNbYXR0cl1dID09PSAndW5kZWZpbmVkJyB8fCBhdHRyaWJ1dGVzW2F0dHJdID09PSAnJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzW2F0dHJdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIWZhYnJpYy5PYmplY3QucHJvdG90eXBlW2F0dHJdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlc1thdHRyXSA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlW2F0dHJdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlc1thdHRyXS5pbmRleE9mKCd1cmwoJykgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gY29sb3Iuc2V0QWxwaGEodG9GaXhlZChjb2xvci5nZXRBbHBoYSgpICogYXR0cmlidXRlc1tjb2xvckF0dHJpYnV0ZXNbYXR0cl1dLCAyKSkudG9SZ2JhKCk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIG5vZGVOYW1lcykge1xuICAgIHZhciBub2RlTmFtZSwgbm9kZUFycmF5ID0gW10sIG5vZGVMaXN0LCBpLCBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gbm9kZU5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBub2RlTmFtZSA9IG5vZGVOYW1lc1tpXTtcbiAgICAgIG5vZGVMaXN0ID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5vZGVOYW1lKTtcbiAgICAgIG5vZGVBcnJheSA9IG5vZGVBcnJheS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZUxpc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVBcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHJldHVybmluZyBhbiBhcnJheSBvZiB2YWx1ZXNcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlVmFsdWUgU3RyaW5nIGNvbnRhaW5pbmcgYXR0cmlidXRlIHZhbHVlXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiA2IGVsZW1lbnRzIHJlcHJlc2VudGluZyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICovXG4gIGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiByb3RhdGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICB2YXIgY29zID0gZmFicmljLnV0aWwuY29zKGFyZ3NbMF0pLCBzaW4gPSBmYWJyaWMudXRpbC5zaW4oYXJnc1swXSksXG4gICAgICAgICAgeCA9IDAsIHkgPSAwO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHggPSBhcmdzWzFdO1xuICAgICAgICB5ID0gYXJnc1syXTtcbiAgICAgIH1cblxuICAgICAgbWF0cml4WzBdID0gY29zO1xuICAgICAgbWF0cml4WzFdID0gc2luO1xuICAgICAgbWF0cml4WzJdID0gLXNpbjtcbiAgICAgIG1hdHJpeFszXSA9IGNvcztcbiAgICAgIG1hdHJpeFs0XSA9IHggLSAoY29zICogeCAtIHNpbiAqIHkpO1xuICAgICAgbWF0cml4WzVdID0geSAtIChzaW4gKiB4ICsgY29zICogeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICB2YXIgbXVsdGlwbGllclggPSBhcmdzWzBdLFxuICAgICAgICAgIG11bHRpcGxpZXJZID0gKGFyZ3MubGVuZ3RoID09PSAyKSA/IGFyZ3NbMV0gOiBhcmdzWzBdO1xuXG4gICAgICBtYXRyaXhbMF0gPSBtdWx0aXBsaWVyWDtcbiAgICAgIG1hdHJpeFszXSA9IG11bHRpcGxpZXJZO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZXdNYXRyaXgobWF0cml4LCBhcmdzLCBwb3MpIHtcbiAgICAgIG1hdHJpeFtwb3NdID0gTWF0aC50YW4oZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhhcmdzWzBdKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlTWF0cml4KG1hdHJpeCwgYXJncykge1xuICAgICAgbWF0cml4WzRdID0gYXJnc1swXTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBtYXRyaXhbNV0gPSBhcmdzWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlkZW50aXR5IG1hdHJpeFxuICAgIHZhciBpTWF0cml4ID0gZmFicmljLmlNYXRyaXgsXG5cbiAgICAgICAgLy8gPT0gYmVnaW4gdHJhbnNmb3JtIHJlZ2V4cFxuICAgICAgICBudW1iZXIgPSBmYWJyaWMucmVOdW0sXG5cbiAgICAgICAgY29tbWFXc3AgPSAnKD86XFxcXHMrLD9cXFxccyp8LFxcXFxzKiknLFxuXG4gICAgICAgIHNrZXdYID0gJyg/Oihza2V3WClcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHNrZXdZID0gJyg/Oihza2V3WSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHJvdGF0ZSA9ICcoPzoocm90YXRlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpJyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgc2NhbGUgPSAnKD86KHNjYWxlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIHRyYW5zbGF0ZSA9ICcoPzoodHJhbnNsYXRlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIG1hdHJpeCA9ICcoPzoobWF0cml4KVxcXFxzKlxcXFwoXFxcXHMqJyArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgJ1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgdHJhbnNmb3JtID0gJyg/OicgK1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXggKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUgKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICBzY2FsZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHNrZXdYICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgc2tld1kgK1xuICAgICAgICAgICAgICAgICAgICAnKScsXG5cbiAgICAgICAgdHJhbnNmb3JtcyA9ICcoPzonICsgdHJhbnNmb3JtICsgJyg/OicgKyBjb21tYVdzcCArICcqJyArIHRyYW5zZm9ybSArICcpKicgKyAnKScsXG5cbiAgICAgICAgdHJhbnNmb3JtTGlzdCA9ICdeXFxcXHMqKD86JyArIHRyYW5zZm9ybXMgKyAnPylcXFxccyokJyxcblxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjVHJhbnNmb3JtQXR0cmlidXRlXG4gICAgICAgIHJlVHJhbnNmb3JtTGlzdCA9IG5ldyBSZWdFeHAodHJhbnNmb3JtTGlzdCksXG4gICAgICAgIC8vID09IGVuZCB0cmFuc2Zvcm0gcmVnZXhwXG5cbiAgICAgICAgcmVUcmFuc2Zvcm0gPSBuZXcgUmVnRXhwKHRyYW5zZm9ybSwgJ2cnKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhdHRyaWJ1dGVWYWx1ZSkge1xuXG4gICAgICAvLyBzdGFydCB3aXRoIGlkZW50aXR5IG1hdHJpeFxuICAgICAgdmFyIG1hdHJpeCA9IGlNYXRyaXguY29uY2F0KCksXG4gICAgICAgICAgbWF0cmljZXMgPSBbXTtcblxuICAgICAgLy8gcmV0dXJuIGlmIG5vIGFyZ3VtZW50IHdhcyBnaXZlbiBvclxuICAgICAgLy8gYW4gYXJndW1lbnQgZG9lcyBub3QgbWF0Y2ggdHJhbnNmb3JtIGF0dHJpYnV0ZSByZWdleHBcbiAgICAgIGlmICghYXR0cmlidXRlVmFsdWUgfHwgKGF0dHJpYnV0ZVZhbHVlICYmICFyZVRyYW5zZm9ybUxpc3QudGVzdChhdHRyaWJ1dGVWYWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICB9XG5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlLnJlcGxhY2UocmVUcmFuc2Zvcm0sIGZ1bmN0aW9uKG1hdGNoKSB7XG5cbiAgICAgICAgdmFyIG0gPSBuZXcgUmVnRXhwKHRyYW5zZm9ybSkuZXhlYyhtYXRjaCkuZmlsdGVyKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAvLyBtYXRjaCAhPT0gJycgJiYgbWF0Y2ggIT0gbnVsbFxuICAgICAgICAgICAgICByZXR1cm4gKCEhbWF0Y2gpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvcGVyYXRpb24gPSBtWzFdLFxuICAgICAgICAgICAgYXJncyA9IG0uc2xpY2UoMikubWFwKHBhcnNlRmxvYXQpO1xuXG4gICAgICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAndHJhbnNsYXRlJzpcbiAgICAgICAgICAgIHRyYW5zbGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgIGFyZ3NbMF0gPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKGFyZ3NbMF0pO1xuICAgICAgICAgICAgcm90YXRlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgICBzY2FsZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2tld1gnOlxuICAgICAgICAgICAgc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2tld1knOlxuICAgICAgICAgICAgc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWF0cml4JzpcbiAgICAgICAgICAgIG1hdHJpeCA9IGFyZ3M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNuYXBzaG90IGN1cnJlbnQgbWF0cml4IGludG8gbWF0cmljZXMgYXJyYXlcbiAgICAgICAgbWF0cmljZXMucHVzaChtYXRyaXguY29uY2F0KCkpO1xuICAgICAgICAvLyByZXNldFxuICAgICAgICBtYXRyaXggPSBpTWF0cml4LmNvbmNhdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjb21iaW5lZE1hdHJpeCA9IG1hdHJpY2VzWzBdO1xuICAgICAgd2hpbGUgKG1hdHJpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbWF0cmljZXMuc2hpZnQoKTtcbiAgICAgICAgY29tYmluZWRNYXRyaXggPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKGNvbWJpbmVkTWF0cml4LCBtYXRyaWNlc1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWRNYXRyaXg7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3R5bGVTdHJpbmcoc3R5bGUsIG9TdHlsZSkge1xuICAgIHZhciBhdHRyLCB2YWx1ZTtcbiAgICBzdHlsZS5yZXBsYWNlKC87XFxzKiQvLCAnJykuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgdmFyIHBhaXIgPSBjaHVuay5zcGxpdCgnOicpO1xuXG4gICAgICBhdHRyID0gcGFpclswXS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gIHBhaXJbMV0udHJpbSgpO1xuXG4gICAgICBvU3R5bGVbYXR0cl0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdHlsZU9iamVjdChzdHlsZSwgb1N0eWxlKSB7XG4gICAgdmFyIGF0dHIsIHZhbHVlO1xuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3R5bGVbcHJvcF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBhdHRyID0gcHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSBzdHlsZVtwcm9wXTtcblxuICAgICAgb1N0eWxlW2F0dHJdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRHbG9iYWxTdHlsZXNGb3JFbGVtZW50KGVsZW1lbnQsIHN2Z1VpZCkge1xuICAgIHZhciBzdHlsZXMgPSB7IH07XG4gICAgZm9yICh2YXIgcnVsZSBpbiBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXSkge1xuICAgICAgaWYgKGVsZW1lbnRNYXRjaGVzUnVsZShlbGVtZW50LCBydWxlLnNwbGl0KCcgJykpKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdW3J1bGVdKSB7XG4gICAgICAgICAgc3R5bGVzW3Byb3BlcnR5XSA9IGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdW3J1bGVdW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlc1J1bGUoZWxlbWVudCwgc2VsZWN0b3JzKSB7XG4gICAgdmFyIGZpcnN0TWF0Y2hpbmcsIHBhcmVudE1hdGNoaW5nID0gdHJ1ZTtcbiAgICAvL3N0YXJ0IGZyb20gcmlnaHRtb3N0IHNlbGVjdG9yLlxuICAgIGZpcnN0TWF0Y2hpbmcgPSBzZWxlY3Rvck1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3JzLnBvcCgpKTtcbiAgICBpZiAoZmlyc3RNYXRjaGluZyAmJiBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICBwYXJlbnRNYXRjaGluZyA9IGRvZXNTb21lUGFyZW50TWF0Y2goZWxlbWVudCwgc2VsZWN0b3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0TWF0Y2hpbmcgJiYgcGFyZW50TWF0Y2hpbmcgJiYgKHNlbGVjdG9ycy5sZW5ndGggPT09IDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9lc1NvbWVQYXJlbnRNYXRjaChlbGVtZW50LCBzZWxlY3RvcnMpIHtcbiAgICB2YXIgc2VsZWN0b3IsIHBhcmVudE1hdGNoaW5nID0gdHJ1ZTtcbiAgICB3aGlsZSAoZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICBpZiAocGFyZW50TWF0Y2hpbmcpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnMucG9wKCk7XG4gICAgICB9XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgcGFyZW50TWF0Y2hpbmcgPSBzZWxlY3Rvck1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3JzLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2VsZWN0b3JNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZSxcbiAgICAgICAgY2xhc3NOYW1lcyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLFxuICAgICAgICBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpLCBtYXRjaGVyLCBpO1xuICAgIC8vIGkgY2hlY2sgaWYgYSBzZWxlY3RvciBtYXRjaGVzIHNsaWNpbmcgYXdheSBwYXJ0IGZyb20gaXQuXG4gICAgLy8gaWYgaSBnZXQgZW1wdHkgc3RyaW5nIGkgc2hvdWxkIG1hdGNoXG4gICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJ14nICsgbm9kZU5hbWUsICdpJyk7XG4gICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICBpZiAoaWQgJiYgc2VsZWN0b3IubGVuZ3RoKSB7XG4gICAgICBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnIycgKyBpZCArICcoPyFbYS16QS1aXFxcXC1dKyknLCAnaScpO1xuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICB9XG4gICAgaWYgKGNsYXNzTmFtZXMgJiYgc2VsZWN0b3IubGVuZ3RoKSB7XG4gICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcy5zcGxpdCgnICcpO1xuICAgICAgZm9yIChpID0gY2xhc3NOYW1lcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJ1xcXFwuJyArIGNsYXNzTmFtZXNbaV0gKyAnKD8hW2EtekEtWlxcXFwtXSspJywgJ2knKTtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB0byBzdXBwb3J0IElFOCBtaXNzaW5nIGdldEVsZW1lbnRCeUlkIG9uIFNWR2RvY3VtZW50IGFuZCBvbiBub2RlIHhtbERPTVxuICAgKi9cbiAgZnVuY3Rpb24gZWxlbWVudEJ5SWQoZG9jLCBpZCkge1xuICAgIHZhciBlbDtcbiAgICBkb2MuZ2V0RWxlbWVudEJ5SWQgJiYgKGVsID0gZG9jLmdldEVsZW1lbnRCeUlkKGlkKSk7XG4gICAgaWYgKGVsKSB7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIHZhciBub2RlLCBpLCBsZW4sIG5vZGVsaXN0ID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJyk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gbm9kZWxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5vZGUgPSBub2RlbGlzdFtpXTtcbiAgICAgIGlmIChpZCA9PT0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVVzZURpcmVjdGl2ZXMoZG9jKSB7XG4gICAgdmFyIG5vZGVsaXN0ID0gX2dldE11bHRpcGxlTm9kZXMoZG9jLCBbJ3VzZScsICdzdmc6dXNlJ10pLCBpID0gMDtcbiAgICB3aGlsZSAobm9kZWxpc3QubGVuZ3RoICYmIGkgPCBub2RlbGlzdC5sZW5ndGgpIHtcbiAgICAgIHZhciBlbCA9IG5vZGVsaXN0W2ldLFxuICAgICAgICAgIHhsaW5rID0gKGVsLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpIHx8IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKS5zdWJzdHIoMSksXG4gICAgICAgICAgeCA9IGVsLmdldEF0dHJpYnV0ZSgneCcpIHx8IDAsXG4gICAgICAgICAgeSA9IGVsLmdldEF0dHJpYnV0ZSgneScpIHx8IDAsXG4gICAgICAgICAgZWwyID0gZWxlbWVudEJ5SWQoZG9jLCB4bGluaykuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICAgIGN1cnJlbnRUcmFucyA9IChlbDIuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSB8fCAnJykgKyAnIHRyYW5zbGF0ZSgnICsgeCArICcsICcgKyB5ICsgJyknLFxuICAgICAgICAgIHBhcmVudE5vZGUsIG9sZExlbmd0aCA9IG5vZGVsaXN0Lmxlbmd0aCwgYXR0ciwgaiwgYXR0cnMsIGxlbjtcblxuICAgICAgYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGVsMik7XG4gICAgICBpZiAoL15zdmckL2kudGVzdChlbDIubm9kZU5hbWUpKSB7XG4gICAgICAgIHZhciBlbDMgPSBlbDIub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdnJyk7XG4gICAgICAgIGZvciAoaiA9IDAsIGF0dHJzID0gZWwyLmF0dHJpYnV0ZXMsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgYXR0ciA9IGF0dHJzLml0ZW0oaik7XG4gICAgICAgICAgZWwzLnNldEF0dHJpYnV0ZShhdHRyLm5vZGVOYW1lLCBhdHRyLm5vZGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWwyLmZpcnN0Q2hpbGQgIT0gbnVsbFxuICAgICAgICB3aGlsZSAoZWwyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBlbDMuYXBwZW5kQ2hpbGQoZWwyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsMiA9IGVsMztcbiAgICAgIH1cblxuICAgICAgZm9yIChqID0gMCwgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzLCBsZW4gPSBhdHRycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBhdHRyID0gYXR0cnMuaXRlbShqKTtcbiAgICAgICAgaWYgKGF0dHIubm9kZU5hbWUgPT09ICd4JyB8fCBhdHRyLm5vZGVOYW1lID09PSAneScgfHxcbiAgICAgICAgICBhdHRyLm5vZGVOYW1lID09PSAneGxpbms6aHJlZicgfHwgYXR0ci5ub2RlTmFtZSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXR0ci5ub2RlTmFtZSA9PT0gJ3RyYW5zZm9ybScpIHtcbiAgICAgICAgICBjdXJyZW50VHJhbnMgPSBhdHRyLm5vZGVWYWx1ZSArICcgJyArIGN1cnJlbnRUcmFucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlbDIuc2V0QXR0cmlidXRlKGF0dHIubm9kZU5hbWUsIGF0dHIubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbDIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBjdXJyZW50VHJhbnMpO1xuICAgICAgZWwyLnNldEF0dHJpYnV0ZSgnaW5zdGFudGlhdGVkX2J5X3VzZScsICcxJyk7XG4gICAgICBlbDIucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgcGFyZW50Tm9kZSA9IGVsLnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbDIsIGVsKTtcbiAgICAgIC8vIHNvbWUgYnJvd3NlcnMgZG8gbm90IHNob3J0ZW4gbm9kZWxpc3QgYWZ0ZXIgcmVwbGFjZUNoaWxkIChJRTgpXG4gICAgICBpZiAobm9kZWxpc3QubGVuZ3RoID09PSBvbGRMZW5ndGgpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNWaWV3Qm94QXR0cmlidXRlXG4gIC8vIG1hdGNoZXMsIGUuZy46ICsxNC41NmUtMTIsIGV0Yy5cbiAgdmFyIHJlVmlld0JveEF0dHJWYWx1ZSA9IG5ldyBSZWdFeHAoXG4gICAgJ14nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyosPycgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKiw/JyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqLD8nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyonICtcbiAgICAnJCdcbiAgKTtcblxuICAvKipcbiAgICogQWRkIGEgPGc+IGVsZW1lbnQgdGhhdCBlbnZlbG9wIGFsbCBjaGlsZCBlbGVtZW50cyBhbmQgbWFrZXMgdGhlIHZpZXdib3ggdHJhbnNmb3JtTWF0cml4IGRlc2NlbmQgb24gYWxsIGVsZW1lbnRzXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseVZpZXdib3hUcmFuc2Zvcm0oZWxlbWVudCkge1xuXG4gICAgdmFyIHZpZXdCb3hBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSxcbiAgICAgICAgc2NhbGVYID0gMSxcbiAgICAgICAgc2NhbGVZID0gMSxcbiAgICAgICAgbWluWCA9IDAsXG4gICAgICAgIG1pblkgPSAwLFxuICAgICAgICB2aWV3Qm94V2lkdGgsIHZpZXdCb3hIZWlnaHQsIG1hdHJpeCwgZWwsXG4gICAgICAgIHdpZHRoQXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLFxuICAgICAgICBoZWlnaHRBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpLFxuICAgICAgICB4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3gnKSB8fCAwLFxuICAgICAgICB5ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3knKSB8fCAwLFxuICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKSB8fCAnJyxcbiAgICAgICAgbWlzc2luZ1ZpZXdCb3ggPSAoIXZpZXdCb3hBdHRyIHx8ICFmYWJyaWMuc3ZnVmlld0JveEVsZW1lbnRzUmVnRXgudGVzdChlbGVtZW50Lm5vZGVOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgISh2aWV3Qm94QXR0ciA9IHZpZXdCb3hBdHRyLm1hdGNoKHJlVmlld0JveEF0dHJWYWx1ZSkpKSxcbiAgICAgICAgbWlzc2luZ0RpbUF0dHIgPSAoIXdpZHRoQXR0ciB8fCAhaGVpZ2h0QXR0ciB8fCB3aWR0aEF0dHIgPT09ICcxMDAlJyB8fCBoZWlnaHRBdHRyID09PSAnMTAwJScpLFxuICAgICAgICB0b0JlUGFyc2VkID0gbWlzc2luZ1ZpZXdCb3ggJiYgbWlzc2luZ0RpbUF0dHIsXG4gICAgICAgIHBhcnNlZERpbSA9IHsgfSwgdHJhbnNsYXRlTWF0cml4ID0gJycsIHdpZHRoRGlmZiA9IDAsIGhlaWdodERpZmYgPSAwO1xuXG4gICAgcGFyc2VkRGltLndpZHRoID0gMDtcbiAgICBwYXJzZWREaW0uaGVpZ2h0ID0gMDtcbiAgICBwYXJzZWREaW0udG9CZVBhcnNlZCA9IHRvQmVQYXJzZWQ7XG5cbiAgICBpZiAodG9CZVBhcnNlZCkge1xuICAgICAgcmV0dXJuIHBhcnNlZERpbTtcbiAgICB9XG5cbiAgICBpZiAobWlzc2luZ1ZpZXdCb3gpIHtcbiAgICAgIHBhcnNlZERpbS53aWR0aCA9IHBhcnNlVW5pdCh3aWR0aEF0dHIpO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHBhcnNlVW5pdChoZWlnaHRBdHRyKTtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuXG4gICAgbWluWCA9IC1wYXJzZUZsb2F0KHZpZXdCb3hBdHRyWzFdKTtcbiAgICBtaW5ZID0gLXBhcnNlRmxvYXQodmlld0JveEF0dHJbMl0pO1xuICAgIHZpZXdCb3hXaWR0aCA9IHBhcnNlRmxvYXQodmlld0JveEF0dHJbM10pO1xuICAgIHZpZXdCb3hIZWlnaHQgPSBwYXJzZUZsb2F0KHZpZXdCb3hBdHRyWzRdKTtcblxuICAgIGlmICghbWlzc2luZ0RpbUF0dHIpIHtcbiAgICAgIHBhcnNlZERpbS53aWR0aCA9IHBhcnNlVW5pdCh3aWR0aEF0dHIpO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHBhcnNlVW5pdChoZWlnaHRBdHRyKTtcbiAgICAgIHNjYWxlWCA9IHBhcnNlZERpbS53aWR0aCAvIHZpZXdCb3hXaWR0aDtcbiAgICAgIHNjYWxlWSA9IHBhcnNlZERpbS5oZWlnaHQgLyB2aWV3Qm94SGVpZ2h0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHBhcnNlZERpbS53aWR0aCA9IHZpZXdCb3hXaWR0aDtcbiAgICAgIHBhcnNlZERpbS5oZWlnaHQgPSB2aWV3Qm94SGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgaXMgdG8gcHJlc2VydmUgYXNwZWN0IHJhdGlvXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbyA9IGZhYnJpYy51dGlsLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZShwcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggIT09ICdub25lJykge1xuICAgICAgLy90cmFuc2xhdGUgYWxsIGNvbnRhaW5lciBmb3IgdGhlIGVmZmVjdCBvZiBNaWQsIE1pbiwgTWF4XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5tZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICAgIHNjYWxlWSA9IHNjYWxlWCA9IChzY2FsZVggPiBzY2FsZVkgPyBzY2FsZVkgOiBzY2FsZVgpO1xuICAgICAgICAvLyBjYWxjdWxhdGUgYWRkaXRpb25hbCB0cmFuc2xhdGlvbiB0byBtb3ZlIHRoZSB2aWV3Ym94XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5tZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICBzY2FsZVkgPSBzY2FsZVggPSAoc2NhbGVYID4gc2NhbGVZID8gc2NhbGVYIDogc2NhbGVZKTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIGFkZGl0aW9uYWwgdHJhbnNsYXRpb24gdG8gbW92ZSB0aGUgdmlld2JveFxuICAgICAgfVxuICAgICAgd2lkdGhEaWZmID0gcGFyc2VkRGltLndpZHRoIC0gdmlld0JveFdpZHRoICogc2NhbGVYO1xuICAgICAgaGVpZ2h0RGlmZiA9IHBhcnNlZERpbS5oZWlnaHQgLSB2aWV3Qm94SGVpZ2h0ICogc2NhbGVYO1xuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25YID09PSAnTWlkJykge1xuICAgICAgICB3aWR0aERpZmYgLz0gMjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWSA9PT0gJ01pZCcpIHtcbiAgICAgICAgaGVpZ2h0RGlmZiAvPSAyO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25YID09PSAnTWluJykge1xuICAgICAgICB3aWR0aERpZmYgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25ZID09PSAnTWluJykge1xuICAgICAgICBoZWlnaHREaWZmID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMSAmJiBtaW5YID09PSAwICYmIG1pblkgPT09IDAgJiYgeCA9PT0gMCAmJiB5ID09PSAwKSB7XG4gICAgICByZXR1cm4gcGFyc2VkRGltO1xuICAgIH1cblxuICAgIGlmICh4IHx8IHkpIHtcbiAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9ICcgdHJhbnNsYXRlKCcgKyBwYXJzZVVuaXQoeCkgKyAnICcgKyBwYXJzZVVuaXQoeSkgKyAnKSAnO1xuICAgIH1cblxuICAgIG1hdHJpeCA9IHRyYW5zbGF0ZU1hdHJpeCArICcgbWF0cml4KCcgKyBzY2FsZVggK1xuICAgICAgICAgICAgICAgICAgJyAwJyArXG4gICAgICAgICAgICAgICAgICAnIDAgJyArXG4gICAgICAgICAgICAgICAgICBzY2FsZVkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgKG1pblggKiBzY2FsZVggKyB3aWR0aERpZmYpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIChtaW5ZICogc2NhbGVZICsgaGVpZ2h0RGlmZikgKyAnKSAnO1xuICAgIHBhcnNlZERpbS52aWV3Ym94VHJhbnNmb3JtID0gZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKG1hdHJpeCk7XG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdzdmcnKSB7XG4gICAgICBlbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdnJyk7XG4gICAgICAvLyBlbGVtZW50LmZpcnN0Q2hpbGQgIT0gbnVsbFxuICAgICAgd2hpbGUgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWwgPSBlbGVtZW50O1xuICAgICAgbWF0cml4ID0gZWwuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSArIG1hdHJpeDtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBtYXRyaXgpO1xuICAgIHJldHVybiBwYXJzZWREaW07XG4gIH1cblxuICBmdW5jdGlvbiBoYXNBbmNlc3RvcldpdGhOb2RlTmFtZShlbGVtZW50LCBub2RlTmFtZSkge1xuICAgIHdoaWxlIChlbGVtZW50ICYmIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlKSkge1xuICAgICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgJiYgbm9kZU5hbWUudGVzdChlbGVtZW50Lm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpXG4gICAgICAgICYmICFlbGVtZW50LmdldEF0dHJpYnV0ZSgnaW5zdGFudGlhdGVkX2J5X3VzZScpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIFNWRyBkb2N1bWVudCwgY29udmVydHMgaXQgdG8gYW4gYXJyYXkgb2YgY29ycmVzcG9uZGluZyBmYWJyaWMuKiBpbnN0YW5jZXMgYW5kIHBhc3NlcyB0aGVtIHRvIGEgY2FsbGJhY2tcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAcGFyYW0ge1NWR0RvY3VtZW50fSBkb2MgU1ZHIGRvY3VtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGNhbGwgd2hlbiBwYXJzaW5nIGlzIGZpbmlzaGVkO1xuICAgKiBJdCdzIGJlaW5nIHBhc3NlZCBhbiBhcnJheSBvZiBlbGVtZW50cyAocGFyc2VkIGZyb20gYSBkb2N1bWVudCkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJzaW5nT3B0aW9uc10gb3B0aW9ucyBmb3IgcGFyc2luZyBkb2N1bWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcnNpbmdPcHRpb25zLmNyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiBzZXR0aW5nc1xuICAgKi9cbiAgZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQgPSBmdW5jdGlvbihkb2MsIGNhbGxiYWNrLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykge1xuICAgIGlmICghZG9jKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFyc2VVc2VEaXJlY3RpdmVzKGRvYyk7XG5cbiAgICB2YXIgc3ZnVWlkID0gIGZhYnJpYy5PYmplY3QuX191aWQrKywgaSwgbGVuLFxuICAgICAgICBvcHRpb25zID0gYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGRvYyksXG4gICAgICAgIGRlc2NlbmRhbnRzID0gZmFicmljLnV0aWwudG9BcnJheShkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSk7XG4gICAgb3B0aW9ucy5jcm9zc09yaWdpbiA9IHBhcnNpbmdPcHRpb25zICYmIHBhcnNpbmdPcHRpb25zLmNyb3NzT3JpZ2luO1xuICAgIG9wdGlvbnMuc3ZnVWlkID0gc3ZnVWlkO1xuXG4gICAgaWYgKGRlc2NlbmRhbnRzLmxlbmd0aCA9PT0gMCAmJiBmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgICAvLyB3ZSdyZSBsaWtlbHkgaW4gbm9kZSwgd2hlcmUgXCJvMy14bWxcIiBsaWJyYXJ5IGZhaWxzIHRvIGdFQlROKFwiKlwiKVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FqYXhvcmcvbm9kZS1vMy14bWwvaXNzdWVzLzIxXG4gICAgICBkZXNjZW5kYW50cyA9IGRvYy5zZWxlY3ROb2RlcygnLy8qW25hbWUoLikhPVwic3ZnXCJdJyk7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkZXNjZW5kYW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBkZXNjZW5kYW50c1tpXTtcbiAgICAgIH1cbiAgICAgIGRlc2NlbmRhbnRzID0gYXJyO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50cyA9IGRlc2NlbmRhbnRzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGVsKTtcbiAgICAgIHJldHVybiBmYWJyaWMuc3ZnVmFsaWRUYWdOYW1lc1JlZ0V4LnRlc3QoZWwubm9kZU5hbWUucmVwbGFjZSgnc3ZnOicsICcnKSkgJiZcbiAgICAgICAgICAgICFoYXNBbmNlc3RvcldpdGhOb2RlTmFtZShlbCwgZmFicmljLnN2Z0ludmFsaWRBbmNlc3RvcnNSZWdFeCk7IC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNEZWZzRWxlbWVudFxuICAgIH0pO1xuXG4gICAgaWYgKCFlbGVtZW50cyB8fCAoZWxlbWVudHMgJiYgIWVsZW1lbnRzLmxlbmd0aCkpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKFtdLCB7fSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjbGlwUGF0aHMgPSB7IH07XG4gICAgZGVzY2VuZGFudHMuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gZWwubm9kZU5hbWUucmVwbGFjZSgnc3ZnOicsICcnKSA9PT0gJ2NsaXBQYXRoJztcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICBjbGlwUGF0aHNbaWRdID0gZmFicmljLnV0aWwudG9BcnJheShlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpKS5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy5zdmdWYWxpZFRhZ05hbWVzUmVnRXgudGVzdChlbC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGZhYnJpYy5ncmFkaWVudERlZnNbc3ZnVWlkXSA9IGZhYnJpYy5nZXRHcmFkaWVudERlZnMoZG9jKTtcbiAgICBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXSA9IGZhYnJpYy5nZXRDU1NSdWxlcyhkb2MpO1xuICAgIGZhYnJpYy5jbGlwUGF0aHNbc3ZnVWlkXSA9IGNsaXBQYXRocztcbiAgICAvLyBQcmVjZWRlbmNlIG9mIHJ1bGVzOiAgIHN0eWxlID4gY2xhc3MgPiBhdHRyaWJ1dGVcbiAgICBmYWJyaWMucGFyc2VFbGVtZW50cyhlbGVtZW50cywgZnVuY3Rpb24oaW5zdGFuY2VzLCBlbGVtZW50cykge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGluc3RhbmNlcywgb3B0aW9ucywgZWxlbWVudHMsIGRlc2NlbmRhbnRzKTtcbiAgICAgICAgZGVsZXRlIGZhYnJpYy5ncmFkaWVudERlZnNbc3ZnVWlkXTtcbiAgICAgICAgZGVsZXRlIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdO1xuICAgICAgICBkZWxldGUgZmFicmljLmNsaXBQYXRoc1tzdmdVaWRdO1xuICAgICAgfVxuICAgIH0sIGNsb25lKG9wdGlvbnMpLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVjdXJzaXZlbHlQYXJzZUdyYWRpZW50c1hsaW5rKGRvYywgZ3JhZGllbnQpIHtcbiAgICB2YXIgZ3JhZGllbnRzQXR0cnMgPSBbJ2dyYWRpZW50VHJhbnNmb3JtJywgJ3gxJywgJ3gyJywgJ3kxJywgJ3kyJywgJ2dyYWRpZW50VW5pdHMnLCAnY3gnLCAnY3knLCAncicsICdmeCcsICdmeSddLFxuICAgICAgICB4bGlua0F0dHIgPSAneGxpbms6aHJlZicsXG4gICAgICAgIHhMaW5rID0gZ3JhZGllbnQuZ2V0QXR0cmlidXRlKHhsaW5rQXR0cikuc3Vic3RyKDEpLFxuICAgICAgICByZWZlcmVuY2VkR3JhZGllbnQgPSBlbGVtZW50QnlJZChkb2MsIHhMaW5rKTtcbiAgICBpZiAocmVmZXJlbmNlZEdyYWRpZW50ICYmIHJlZmVyZW5jZWRHcmFkaWVudC5nZXRBdHRyaWJ1dGUoeGxpbmtBdHRyKSkge1xuICAgICAgcmVjdXJzaXZlbHlQYXJzZUdyYWRpZW50c1hsaW5rKGRvYywgcmVmZXJlbmNlZEdyYWRpZW50KTtcbiAgICB9XG4gICAgZ3JhZGllbnRzQXR0cnMuZm9yRWFjaChmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoIWdyYWRpZW50Lmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgcmVmZXJlbmNlZEdyYWRpZW50LmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFncmFkaWVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciByZWZlcmVuY2VDbG9uZSA9IHJlZmVyZW5jZWRHcmFkaWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB3aGlsZSAocmVmZXJlbmNlQ2xvbmUuZmlyc3RDaGlsZCkge1xuICAgICAgICBncmFkaWVudC5hcHBlbmRDaGlsZChyZWZlcmVuY2VDbG9uZS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ3JhZGllbnQucmVtb3ZlQXR0cmlidXRlKHhsaW5rQXR0cik7XG4gIH1cblxuICB2YXIgcmVGb250RGVjbGFyYXRpb24gPSBuZXcgUmVnRXhwKFxuICAgICcobm9ybWFsfGl0YWxpYyk/XFxcXHMqKG5vcm1hbHxzbWFsbC1jYXBzKT9cXFxccyonICtcbiAgICAnKG5vcm1hbHxib2xkfGJvbGRlcnxsaWdodGVyfDEwMHwyMDB8MzAwfDQwMHw1MDB8NjAwfDcwMHw4MDB8OTAwKT9cXFxccyooJyArXG4gICAgICBmYWJyaWMucmVOdW0gK1xuICAgICcoPzpweHxjbXxtbXxlbXxwdHxwY3xpbikqKSg/OlxcXFwvKG5vcm1hbHwnICsgZmFicmljLnJlTnVtICsgJykpP1xcXFxzKyguKiknKTtcblxuICBleHRlbmQoZmFicmljLCB7XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc2hvcnQgZm9udCBkZWNsYXJhdGlvbiwgYnVpbGRpbmcgYWRkaW5nIGl0cyBwcm9wZXJ0aWVzIHRvIGEgc3R5bGUgb2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgZm9udCBkZWNsYXJhdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvU3R5bGUgZGVmaW5pdGlvblxuICAgICAqL1xuICAgIHBhcnNlRm9udERlY2xhcmF0aW9uOiBmdW5jdGlvbih2YWx1ZSwgb1N0eWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZUZvbnREZWNsYXJhdGlvbik7XG5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZvbnRTdHlsZSA9IG1hdGNoWzFdLFxuICAgICAgICAgIC8vIGZvbnQgdmFyaWFudCBpcyBub3QgdXNlZFxuICAgICAgICAgIC8vIGZvbnRWYXJpYW50ID0gbWF0Y2hbMl0sXG4gICAgICAgICAgZm9udFdlaWdodCA9IG1hdGNoWzNdLFxuICAgICAgICAgIGZvbnRTaXplID0gbWF0Y2hbNF0sXG4gICAgICAgICAgbGluZUhlaWdodCA9IG1hdGNoWzVdLFxuICAgICAgICAgIGZvbnRGYW1pbHkgPSBtYXRjaFs2XTtcblxuICAgICAgaWYgKGZvbnRTdHlsZSkge1xuICAgICAgICBvU3R5bGUuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRXZWlnaHQpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRXZWlnaHQgPSBpc05hTihwYXJzZUZsb2F0KGZvbnRXZWlnaHQpKSA/IGZvbnRXZWlnaHQgOiBwYXJzZUZsb2F0KGZvbnRXZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRTaXplKSB7XG4gICAgICAgIG9TdHlsZS5mb250U2l6ZSA9IHBhcnNlVW5pdChmb250U2l6ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZm9udEZhbWlseSkge1xuICAgICAgICBvU3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICB9XG4gICAgICBpZiAobGluZUhlaWdodCkge1xuICAgICAgICBvU3R5bGUubGluZUhlaWdodCA9IGxpbmVIZWlnaHQgPT09ICdub3JtYWwnID8gMSA6IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBTVkcgZG9jdW1lbnQsIHJldHVybmluZyBhbGwgb2YgdGhlIGdyYWRpZW50IGRlY2xhcmF0aW9ucyBmb3VuZCBpbiBpdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gR3JhZGllbnQgZGVmaW5pdGlvbnM7IGtleSBjb3JyZXNwb25kcyB0byBlbGVtZW50IGlkLCB2YWx1ZSAtLSB0byBncmFkaWVudCBkZWZpbml0aW9uIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRHcmFkaWVudERlZnM6IGZ1bmN0aW9uKGRvYykge1xuICAgICAgdmFyIHRhZ0FycmF5ID0gW1xuICAgICAgICAgICAgJ2xpbmVhckdyYWRpZW50JyxcbiAgICAgICAgICAgICdyYWRpYWxHcmFkaWVudCcsXG4gICAgICAgICAgICAnc3ZnOmxpbmVhckdyYWRpZW50JyxcbiAgICAgICAgICAgICdzdmc6cmFkaWFsR3JhZGllbnQnXSxcbiAgICAgICAgICBlbExpc3QgPSBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIHRhZ0FycmF5KSxcbiAgICAgICAgICBlbCwgaiA9IDAsIGdyYWRpZW50RGVmcyA9IHsgfTtcbiAgICAgIGogPSBlbExpc3QubGVuZ3RoO1xuICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICBlbCA9IGVsTGlzdFtqXTtcbiAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlQYXJzZUdyYWRpZW50c1hsaW5rKGRvYywgZWwpO1xuICAgICAgICB9XG4gICAgICAgIGdyYWRpZW50RGVmc1tlbC5nZXRBdHRyaWJ1dGUoJ2lkJyldID0gZWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JhZGllbnREZWZzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzJyBuYW1lL3ZhbHVlLCBnaXZlbiBlbGVtZW50IGFuZCBhbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXM7XG4gICAgICogUGFyc2VzIHBhcmVudCBcImdcIiBub2RlcyByZWN1cnNpdmVseSB1cHdhcmRzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhdHRyaWJ1dGVzIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHBhcnNlZCBhdHRyaWJ1dGVzJyBuYW1lcy92YWx1ZXNcbiAgICAgKi9cbiAgICBwYXJzZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZXMsIHN2Z1VpZCkge1xuXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUsXG4gICAgICAgICAgcGFyZW50QXR0cmlidXRlcyA9IHsgfSxcbiAgICAgICAgICBmb250U2l6ZSwgcGFyZW50Rm9udFNpemU7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3ZnVWlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdmdVaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3ZnVWlkJyk7XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGVyZSdzIGEgcGFyZW50IGNvbnRhaW5lciAoYGdgIG9yIGBhYCBvciBgc3ltYm9sYCBub2RlKSwgcGFyc2UgaXRzIGF0dHJpYnV0ZXMgcmVjdXJzaXZlbHkgdXB3YXJkc1xuICAgICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSAmJiBmYWJyaWMuc3ZnVmFsaWRQYXJlbnRzUmVnRXgudGVzdChlbGVtZW50LnBhcmVudE5vZGUubm9kZU5hbWUpKSB7XG4gICAgICAgIHBhcmVudEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQucGFyZW50Tm9kZSwgYXR0cmlidXRlcywgc3ZnVWlkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG93bkF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLnJlZHVjZShmdW5jdGlvbihtZW1vLCBhdHRyKSB7XG4gICAgICAgIHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIGlmICh2YWx1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgbWVtb1thdHRyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgfSwgeyB9KTtcbiAgICAgIC8vIGFkZCB2YWx1ZXMgcGFyc2VkIGZyb20gc3R5bGUsIHdoaWNoIHRha2UgcHJlY2VkZW5jZSBvdmVyIGF0dHJpYnV0ZXNcbiAgICAgIC8vIChzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHlsaW5nLmh0bWwjVXNpbmdQcmVzZW50YXRpb25BdHRyaWJ1dGVzKVxuICAgICAgb3duQXR0cmlidXRlcyA9IGV4dGVuZChvd25BdHRyaWJ1dGVzLFxuICAgICAgICBleHRlbmQoZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudChlbGVtZW50LCBzdmdVaWQpLCBmYWJyaWMucGFyc2VTdHlsZUF0dHJpYnV0ZShlbGVtZW50KSkpO1xuXG4gICAgICBmb250U2l6ZSA9IHBhcmVudEZvbnRTaXplID0gcGFyZW50QXR0cmlidXRlcy5mb250U2l6ZSB8fCBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkU7XG4gICAgICBpZiAob3duQXR0cmlidXRlc1snZm9udC1zaXplJ10pIHtcbiAgICAgICAgLy8gbG9va3MgbGlrZSB0aGUgbWluaW11bSBzaG91bGQgYmUgOXB4IHdoZW4gZGVhbGluZyB3aXRoIGVtcy4gdGhpcyBpcyB3aGF0IGxvb2tzIGxpa2UgaW4gYnJvd3NlcnMuXG4gICAgICAgIG93bkF0dHJpYnV0ZXNbJ2ZvbnQtc2l6ZSddID0gZm9udFNpemUgPSBwYXJzZVVuaXQob3duQXR0cmlidXRlc1snZm9udC1zaXplJ10sIHBhcmVudEZvbnRTaXplKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vcm1hbGl6ZWRBdHRyLCBub3JtYWxpemVkVmFsdWUsIG5vcm1hbGl6ZWRTdHlsZSA9IHt9O1xuICAgICAgZm9yICh2YXIgYXR0ciBpbiBvd25BdHRyaWJ1dGVzKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRBdHRyID0gbm9ybWFsaXplQXR0cihhdHRyKTtcbiAgICAgICAgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplVmFsdWUobm9ybWFsaXplZEF0dHIsIG93bkF0dHJpYnV0ZXNbYXR0cl0sIHBhcmVudEF0dHJpYnV0ZXMsIGZvbnRTaXplKTtcbiAgICAgICAgbm9ybWFsaXplZFN0eWxlW25vcm1hbGl6ZWRBdHRyXSA9IG5vcm1hbGl6ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub3JtYWxpemVkU3R5bGUgJiYgbm9ybWFsaXplZFN0eWxlLmZvbnQpIHtcbiAgICAgICAgZmFicmljLnBhcnNlRm9udERlY2xhcmF0aW9uKG5vcm1hbGl6ZWRTdHlsZS5mb250LCBub3JtYWxpemVkU3R5bGUpO1xuICAgICAgfVxuICAgICAgdmFyIG1lcmdlZEF0dHJzID0gZXh0ZW5kKHBhcmVudEF0dHJpYnV0ZXMsIG5vcm1hbGl6ZWRTdHlsZSk7XG4gICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkUGFyZW50c1JlZ0V4LnRlc3QoZWxlbWVudC5ub2RlTmFtZSkgPyBtZXJnZWRBdHRycyA6IF9zZXRTdHJva2VGaWxsT3BhY2l0eShtZXJnZWRBdHRycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2Ygc3ZnIGVsZW1lbnRzIHRvIGNvcnJlc3BvbmRpbmcgZmFicmljLiogaW5zdGFuY2VzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50cyBBcnJheSBvZiBlbGVtZW50cyB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEJlaW5nIHBhc3NlZCBhbiBhcnJheSBvZiBmYWJyaWMgaW5zdGFuY2VzICh0cmFuc2Zvcm1lZCBmcm9tIFNWRyBlbGVtZW50cylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqL1xuICAgIHBhcnNlRWxlbWVudHM6IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaywgb3B0aW9ucywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpIHtcbiAgICAgIG5ldyBmYWJyaWMuRWxlbWVudHNQYXJzZXIoZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykucGFyc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIFwic3R5bGVcIiBhdHRyaWJ1dGUsIHJldHVuaW5nIGFuIG9iamVjdCB3aXRoIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdHMgd2l0aCB2YWx1ZXMgcGFyc2VkIGZyb20gc3R5bGUgYXR0cmlidXRlIG9mIGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBwYXJzZVN0eWxlQXR0cmlidXRlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICB2YXIgb1N0eWxlID0geyB9LFxuICAgICAgICAgIHN0eWxlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG9TdHlsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyc2VTdHlsZVN0cmluZyhzdHlsZSwgb1N0eWxlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwYXJzZVN0eWxlT2JqZWN0KHN0eWxlLCBvU3R5bGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb1N0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgXCJwb2ludHNcIiBhdHRyaWJ1dGUsIHJldHVybmluZyBhbiBhcnJheSBvZiB2YWx1ZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb2ludHMgcG9pbnRzIGF0dHJpYnV0ZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcG9pbnRzXG4gICAgICovXG4gICAgcGFyc2VQb2ludHNBdHRyaWJ1dGU6IGZ1bmN0aW9uKHBvaW50cykge1xuXG4gICAgICAvLyBwb2ludHMgYXR0cmlidXRlIGlzIHJlcXVpcmVkIGFuZCBtdXN0IG5vdCBiZSBlbXB0eVxuICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlcGxhY2UgY29tbWFzIHdpdGggd2hpdGVzcGFjZSBhbmQgcmVtb3ZlIGJvb2tlbmRpbmcgd2hpdGVzcGFjZVxuICAgICAgcG9pbnRzID0gcG9pbnRzLnJlcGxhY2UoLywvZywgJyAnKS50cmltKCk7XG5cbiAgICAgIHBvaW50cyA9IHBvaW50cy5zcGxpdCgvXFxzKy8pO1xuICAgICAgdmFyIHBhcnNlZFBvaW50cyA9IFtdLCBpLCBsZW47XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBwYXJzZWRQb2ludHMucHVzaCh7XG4gICAgICAgICAgeDogcGFyc2VGbG9hdChwb2ludHNbaV0pLFxuICAgICAgICAgIHk6IHBhcnNlRmxvYXQocG9pbnRzW2kgKyAxXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9kZCBudW1iZXIgb2YgcG9pbnRzIGlzIGFuIGVycm9yXG4gICAgICAvLyBpZiAocGFyc2VkUG9pbnRzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgIC8vICAgcmV0dXJuIG51bGw7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiBwYXJzZWRQb2ludHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ1NTIHJ1bGVzIGZvciBhIGdpdmVuIFNWRyBkb2N1bWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ1NTIHJ1bGVzIG9mIHRoaXMgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBnZXRDU1NSdWxlczogZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgc3R5bGVzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHlsZScpLCBpLCBsZW4sXG4gICAgICAgICAgYWxsUnVsZXMgPSB7IH0sIHJ1bGVzO1xuXG4gICAgICAvLyB2ZXJ5IGNydWRlIHBhcnNpbmcgb2Ygc3R5bGUgY29udGVudHNcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0eWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBJRTkgZG9lc24ndCBzdXBwb3J0IHRleHRDb250ZW50LCBidXQgcHJvdmlkZXMgdGV4dCBpbnN0ZWFkLlxuICAgICAgICB2YXIgc3R5bGVDb250ZW50cyA9IHN0eWxlc1tpXS50ZXh0Q29udGVudCB8fCBzdHlsZXNbaV0udGV4dDtcblxuICAgICAgICAvLyByZW1vdmUgY29tbWVudHNcbiAgICAgICAgc3R5bGVDb250ZW50cyA9IHN0eWxlQ29udGVudHMucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy9nLCAnJyk7XG4gICAgICAgIGlmIChzdHlsZUNvbnRlbnRzLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBydWxlcyA9IHN0eWxlQ29udGVudHMubWF0Y2goL1tee10qXFx7W1xcc1xcU10qP1xcfS9nKTtcbiAgICAgICAgcnVsZXMgPSBydWxlcy5tYXAoZnVuY3Rpb24ocnVsZSkgeyByZXR1cm4gcnVsZS50cmltKCk7IH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgIHJ1bGVzLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuXG4gICAgICAgICAgdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgvKFtcXHNcXFNdKj8pXFxzKlxceyhbXn1dKilcXH0vKSxcbiAgICAgICAgICAgICAgcnVsZU9iaiA9IHsgfSwgZGVjbGFyYXRpb24gPSBtYXRjaFsyXS50cmltKCksXG4gICAgICAgICAgICAgIHByb3BlcnR5VmFsdWVQYWlycyA9IGRlY2xhcmF0aW9uLnJlcGxhY2UoLzskLywgJycpLnNwbGl0KC9cXHMqO1xccyovKTtcblxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHByb3BlcnR5VmFsdWVQYWlycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBwcm9wZXJ0eVZhbHVlUGFpcnNbaV0uc3BsaXQoL1xccyo6XFxzKi8pLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFpclswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhaXJbMV07XG4gICAgICAgICAgICBydWxlT2JqW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBydWxlID0gbWF0Y2hbMV07XG4gICAgICAgICAgcnVsZS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24oX3J1bGUpIHtcbiAgICAgICAgICAgIF9ydWxlID0gX3J1bGUucmVwbGFjZSgvXnN2Zy9pLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgaWYgKF9ydWxlID09PSAnJykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsUnVsZXNbX3J1bGVdKSB7XG4gICAgICAgICAgICAgIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoYWxsUnVsZXNbX3J1bGVdLCBydWxlT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBhbGxSdWxlc1tfcnVsZV0gPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUocnVsZU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbFJ1bGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB1cmwgY29ycmVzcG9uZGluZyB0byBhbiBTVkcgZG9jdW1lbnQsIGFuZCBwYXJzZXMgaXQgaW50byBhIHNldCBvZiBmYWJyaWMgb2JqZWN0cy5cbiAgICAgKiBOb3RlIHRoYXQgU1ZHIGlzIGZldGNoZWQgdmlhIFhNTEh0dHBSZXF1ZXN0LCBzbyBpdCBuZWVkcyB0byBjb25mb3JtIHRvIFNPUCAoU2FtZSBPcmlnaW4gUG9saWN5KVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiBjcm9zc09yaWdpbiBzZXR0aW5nIHRvIHVzZSBmb3IgZXh0ZXJuYWwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgbG9hZFNWR0Zyb21VUkw6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIHJldml2ZXIsIG9wdGlvbnMpIHtcblxuICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL15cXG5cXHMqLywgJycpLnRyaW0oKTtcbiAgICAgIG5ldyBmYWJyaWMudXRpbC5yZXF1ZXN0KHVybCwge1xuICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gb25Db21wbGV0ZShyKSB7XG5cbiAgICAgICAgdmFyIHhtbCA9IHIucmVzcG9uc2VYTUw7XG4gICAgICAgIGlmICh4bWwgJiYgIXhtbC5kb2N1bWVudEVsZW1lbnQgJiYgZmFicmljLndpbmRvdy5BY3RpdmVYT2JqZWN0ICYmIHIucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgeG1sID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKTtcbiAgICAgICAgICB4bWwuYXN5bmMgPSAnZmFsc2UnO1xuICAgICAgICAgIC8vSUUgY2hva2VzIG9uIERPQ1RZUEVcbiAgICAgICAgICB4bWwubG9hZFhNTChyLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC88IURPQ1RZUEVbXFxzXFxTXSo/KFxcW1tcXHNcXFNdKlxcXSkqPz4vaSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50KHhtbC5kb2N1bWVudEVsZW1lbnQsIGZ1bmN0aW9uIChyZXN1bHRzLCBfb3B0aW9ucywgZWxlbWVudHMsIGFsbEVsZW1lbnRzKSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cyk7XG4gICAgICAgIH0sIHJldml2ZXIsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBzdHJpbmcgY29ycmVzcG9uZGluZyB0byBhbiBTVkcgZG9jdW1lbnQsIGFuZCBwYXJzZXMgaXQgaW50byBhIHNldCBvZiBmYWJyaWMgb2JqZWN0c1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiBjcm9zc09yaWdpbiBzZXR0aW5nIHRvIHVzZSBmb3IgZXh0ZXJuYWwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgbG9hZFNWR0Zyb21TdHJpbmc6IGZ1bmN0aW9uKHN0cmluZywgY2FsbGJhY2ssIHJldml2ZXIsIG9wdGlvbnMpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG4gICAgICB2YXIgZG9jO1xuICAgICAgaWYgKHR5cGVvZiBET01QYXJzZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIGlmIChwYXJzZXIgJiYgcGFyc2VyLnBhcnNlRnJvbVN0cmluZykge1xuICAgICAgICAgIGRvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3RyaW5nLCAndGV4dC94bWwnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmFicmljLndpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICAgIGRvYyA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJyk7XG4gICAgICAgIGRvYy5hc3luYyA9ICdmYWxzZSc7XG4gICAgICAgIC8vIElFIGNob2tlcyBvbiBET0NUWVBFXG4gICAgICAgIGRvYy5sb2FkWE1MKHN0cmluZy5yZXBsYWNlKC88IURPQ1RZUEVbXFxzXFxTXSo/KFxcW1tcXHNcXFNdKlxcXSkqPz4vaSwgJycpKTtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQoZG9jLmRvY3VtZW50RWxlbWVudCwgZnVuY3Rpb24gKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpIHtcbiAgICAgICAgY2FsbGJhY2socmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cyk7XG4gICAgICB9LCByZXZpdmVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuZmFicmljLkVsZW1lbnRzUGFyc2VyID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykge1xuICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5yZXZpdmVyID0gcmV2aXZlcjtcbiAgdGhpcy5zdmdVaWQgPSAob3B0aW9ucyAmJiBvcHRpb25zLnN2Z1VpZCkgfHwgMDtcbiAgdGhpcy5wYXJzaW5nT3B0aW9ucyA9IHBhcnNpbmdPcHRpb25zO1xuICB0aGlzLnJlZ2V4VXJsID0gL151cmxcXChbJ1wiXT8jKFteJ1wiXSspWydcIl0/XFwpL2c7XG59O1xuXG4oZnVuY3Rpb24ocHJvdG8pIHtcbiAgcHJvdG8ucGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBBcnJheSh0aGlzLmVsZW1lbnRzLmxlbmd0aCk7XG4gICAgdGhpcy5udW1FbGVtZW50cyA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgIHRoaXMuY3JlYXRlT2JqZWN0cygpO1xuICB9O1xuXG4gIHByb3RvLmNyZWF0ZU9iamVjdHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3ZnVWlkJywgX3RoaXMuc3ZnVWlkKTtcbiAgICAgIF90aGlzLmNyZWF0ZU9iamVjdChlbGVtZW50LCBpKTtcbiAgICB9KTtcbiAgfTtcblxuICBwcm90by5maW5kVGFnID0gZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gZmFicmljW2ZhYnJpYy51dGlsLnN0cmluZy5jYXBpdGFsaXplKGVsLnRhZ05hbWUucmVwbGFjZSgnc3ZnOicsICcnKSldO1xuICB9O1xuXG4gIHByb3RvLmNyZWF0ZU9iamVjdCA9IGZ1bmN0aW9uKGVsLCBpbmRleCkge1xuICAgIHZhciBrbGFzcyA9IHRoaXMuZmluZFRhZyhlbCk7XG4gICAgaWYgKGtsYXNzICYmIGtsYXNzLmZyb21FbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBrbGFzcy5mcm9tRWxlbWVudChlbCwgdGhpcy5jcmVhdGVDYWxsYmFjayhpbmRleCwgZWwpLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICBmYWJyaWMubG9nKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jaGVja0lmRG9uZSgpO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5jcmVhdGVDYWxsYmFjayA9IGZ1bmN0aW9uKGluZGV4LCBlbCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIF9vcHRpb25zO1xuICAgICAgX3RoaXMucmVzb2x2ZUdyYWRpZW50KG9iaiwgJ2ZpbGwnKTtcbiAgICAgIF90aGlzLnJlc29sdmVHcmFkaWVudChvYmosICdzdHJva2UnKTtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBmYWJyaWMuSW1hZ2UgJiYgb2JqLl9vcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgX29wdGlvbnMgPSBvYmoucGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlKGVsKTtcbiAgICAgIH1cbiAgICAgIG9iai5fcmVtb3ZlVHJhbnNmb3JtTWF0cml4KF9vcHRpb25zKTtcbiAgICAgIF90aGlzLnJlc29sdmVDbGlwUGF0aChvYmopO1xuICAgICAgX3RoaXMucmV2aXZlciAmJiBfdGhpcy5yZXZpdmVyKGVsLCBvYmopO1xuICAgICAgX3RoaXMuaW5zdGFuY2VzW2luZGV4XSA9IG9iajtcbiAgICAgIF90aGlzLmNoZWNrSWZEb25lKCk7XG4gICAgfTtcbiAgfTtcblxuICBwcm90by5leHRyYWN0UHJvcGVydHlEZWZpbml0aW9uID0gZnVuY3Rpb24ob2JqLCBwcm9wZXJ0eSwgc3RvcmFnZSkge1xuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wZXJ0eV07XG4gICAgaWYgKCEoL151cmxcXCgvKS50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaWQgPSB0aGlzLnJlZ2V4VXJsLmV4ZWModmFsdWUpWzFdO1xuICAgIHRoaXMucmVnZXhVcmwubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gZmFicmljW3N0b3JhZ2VdW3RoaXMuc3ZnVWlkXVtpZF07XG4gIH07XG5cbiAgcHJvdG8ucmVzb2x2ZUdyYWRpZW50ID0gZnVuY3Rpb24ob2JqLCBwcm9wZXJ0eSkge1xuICAgIHZhciBncmFkaWVudERlZiA9IHRoaXMuZXh0cmFjdFByb3BlcnR5RGVmaW5pdGlvbihvYmosIHByb3BlcnR5LCAnZ3JhZGllbnREZWZzJyk7XG4gICAgaWYgKGdyYWRpZW50RGVmKSB7XG4gICAgICBvYmouc2V0KHByb3BlcnR5LCBmYWJyaWMuR3JhZGllbnQuZnJvbUVsZW1lbnQoZ3JhZGllbnREZWYsIG9iaikpO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5jcmVhdGVDbGlwUGF0aENhbGxiYWNrID0gZnVuY3Rpb24ob2JqLCBjb250YWluZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oX25ld09iaikge1xuICAgICAgX25ld09iai5fcmVtb3ZlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICBfbmV3T2JqLmZpbGxSdWxlID0gX25ld09iai5jbGlwUnVsZTtcbiAgICAgIGNvbnRhaW5lci5wdXNoKF9uZXdPYmopO1xuICAgIH07XG4gIH07XG5cbiAgcHJvdG8ucmVzb2x2ZUNsaXBQYXRoID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGNsaXBQYXRoID0gdGhpcy5leHRyYWN0UHJvcGVydHlEZWZpbml0aW9uKG9iaiwgJ2NsaXBQYXRoJywgJ2NsaXBQYXRocycpLFxuICAgICAgICBlbGVtZW50LCBrbGFzcywgb2JqVHJhbnNmb3JtSW52LCBjb250YWluZXIsIGdUcmFuc2Zvcm0sIG9wdGlvbnM7XG4gICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICBjb250YWluZXIgPSBbXTtcbiAgICAgIG9ialRyYW5zZm9ybUludiA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybShvYmouY2FsY1RyYW5zZm9ybU1hdHJpeCgpKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IGNsaXBQYXRoW2ldO1xuICAgICAgICBrbGFzcyA9IHRoaXMuZmluZFRhZyhlbGVtZW50KTtcbiAgICAgICAga2xhc3MuZnJvbUVsZW1lbnQoXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICB0aGlzLmNyZWF0ZUNsaXBQYXRoQ2FsbGJhY2sob2JqLCBjb250YWluZXIpLFxuICAgICAgICAgIHRoaXMub3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRhaW5lci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY2xpcFBhdGggPSBjb250YWluZXJbMF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2xpcFBhdGggPSBuZXcgZmFicmljLkdyb3VwKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgICBnVHJhbnNmb3JtID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhcbiAgICAgICAgb2JqVHJhbnNmb3JtSW52LFxuICAgICAgICBjbGlwUGF0aC5jYWxjVHJhbnNmb3JtTWF0cml4KClcbiAgICAgICk7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKGdUcmFuc2Zvcm0pO1xuICAgICAgY2xpcFBhdGguZmxpcFggPSBmYWxzZTtcbiAgICAgIGNsaXBQYXRoLmZsaXBZID0gZmFsc2U7XG4gICAgICBjbGlwUGF0aC5zZXQoJ3NjYWxlWCcsIG9wdGlvbnMuc2NhbGVYKTtcbiAgICAgIGNsaXBQYXRoLnNldCgnc2NhbGVZJywgb3B0aW9ucy5zY2FsZVkpO1xuICAgICAgY2xpcFBhdGguYW5nbGUgPSBvcHRpb25zLmFuZ2xlO1xuICAgICAgY2xpcFBhdGguc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgY2xpcFBhdGguc2tld1kgPSAwO1xuICAgICAgY2xpcFBhdGguc2V0UG9zaXRpb25CeU9yaWdpbih7IHg6IG9wdGlvbnMudHJhbnNsYXRlWCwgeTogb3B0aW9ucy50cmFuc2xhdGVZIH0sICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICBvYmouY2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8uY2hlY2tJZkRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoLS10aGlzLm51bUVsZW1lbnRzID09PSAwKSB7XG4gICAgICB0aGlzLmluc3RhbmNlcyA9IHRoaXMuaW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG4gICAgICAgIHJldHVybiBlbCAhPSBudWxsO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMuaW5zdGFuY2VzLCB0aGlzLmVsZW1lbnRzKTtcbiAgICB9XG4gIH07XG59KShmYWJyaWMuRWxlbWVudHNQYXJzZXIucHJvdG90eXBlKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIEFkYXB0YXRpb24gb2Ygd29yayBvZiBLZXZpbiBMaW5kc2V5IChrZXZpbkBrZXZsaW5kZXYuY29tKSAqL1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLlBvaW50KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2ludCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmYWJyaWMuUG9pbnQgPSBQb2ludDtcblxuICAvKipcbiAgICogUG9pbnQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Qb2ludFxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBQb2ludC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5Qb2ludC5wcm90b3R5cGUgKi8ge1xuXG4gICAgdHlwZTogJ3BvaW50JyxcblxuICAgIGNvbnN0cnVjdG9yOiBQb2ludCxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBwb2ludCB0byB0aGlzIG9uZSBhbmQgcmV0dXJucyBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBuZXcgUG9pbnQgaW5zdGFuY2Ugd2l0aCBhZGRlZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHRoYXQueCwgdGhpcy55ICsgdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbm90aGVyIHBvaW50IHRvIHRoaXMgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYWRkRXF1YWxzOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54ICs9IHRoYXQueDtcbiAgICAgIHRoaXMueSArPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB2YWx1ZSB0byB0aGlzIHBvaW50IGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IG5ldyBQb2ludCB3aXRoIGFkZGVkIHZhbHVlXG4gICAgICovXG4gICAgc2NhbGFyQWRkOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHNjYWxhciwgdGhpcy55ICsgc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB2YWx1ZSB0byB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsYXJBZGRFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCArPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgKz0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBhbm90aGVyIHBvaW50IGZyb20gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gbmV3IFBvaW50IG9iamVjdCB3aXRoIHN1YnRyYWN0ZWQgdmFsdWVzXG4gICAgICovXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHRoYXQueCwgdGhpcy55IC0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIGFub3RoZXIgcG9pbnQgZnJvbSB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc3VidHJhY3RFcXVhbHM6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB0aGlzLnggLT0gdGhhdC54O1xuICAgICAgdGhpcy55IC09IHRoYXQueTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdmFsdWUgZnJvbSB0aGlzIHBvaW50IGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgc2NhbGFyU3VidHJhY3Q6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gc2NhbGFyLCB0aGlzLnkgLSBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdmFsdWUgZnJvbSB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsYXJTdWJ0cmFjdEVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54IC09IHNjYWxhcjtcbiAgICAgIHRoaXMueSAtPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhck11bHRpcGx5IGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogc2NhbGFyLCB0aGlzLnkgKiBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJNdWx0aXBseUVxdWFscyBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIG11bHRpcGx5RXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyRGl2aWRlIGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZGl2aWRlOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHNjYWxhciwgdGhpcy55IC8gc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyRGl2aWRlRXF1YWxzIGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGl2aWRlRXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggLz0gc2NhbGFyO1xuICAgICAgdGhpcy55IC89IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBlcXVhbCB0byBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBlcTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54ID09PSB0aGF0LnggJiYgdGhpcy55ID09PSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBsZXNzIHRoYW4gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgbHQ6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA8IHRoYXQueCAmJiB0aGlzLnkgPCB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgbHRlOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPD0gdGhhdC54ICYmIHRoaXMueSA8PSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcblxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGdyZWF0ZXIgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ3Q6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA+IHRoYXQueCAmJiB0aGlzLnkgPiB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ3RlOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPj0gdGhhdC54ICYmIHRoaXMueSA+PSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5ldyBwb2ludCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdGhpcyBvbmUgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdCAsIHBvc2l0aW9uIG9mIGludGVycG9sYXRpb24sIGJldHdlZW4gMCBhbmQgMSBkZWZhdWx0IDAuNVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBsZXJwOiBmdW5jdGlvbiAodGhhdCwgdCkge1xuICAgICAgaWYgKHR5cGVvZiB0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0ID0gMC41O1xuICAgICAgfVxuICAgICAgdCA9IE1hdGgubWF4KE1hdGgubWluKDEsIHQpLCAwKTtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgKHRoYXQueCAtIHRoaXMueCkgKiB0LCB0aGlzLnkgKyAodGhhdC55IC0gdGhpcy55KSAqIHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBkaXN0YW5jZUZyb206IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB2YXIgZHggPSB0aGlzLnggLSB0aGF0LngsXG4gICAgICAgICAgZHkgPSB0aGlzLnkgLSB0aGF0Lnk7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgYmV0d2VlbiB0aGlzIHBvaW50IGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG1pZFBvaW50RnJvbTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlcnAodGhhdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhlIG1pbiBvZiB0aGlzIGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG1pbjogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoTWF0aC5taW4odGhpcy54LCB0aGF0LngpLCBNYXRoLm1pbih0aGlzLnksIHRoYXQueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHBvaW50IHdoaWNoIGlzIHRoZSBtYXggb2YgdGhpcyBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtYXg6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGgubWF4KHRoaXMueCwgdGhhdC54KSwgTWF0aC5tYXgodGhpcy55LCB0aGF0LnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwb2ludFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueCArICcsJyArIHRoaXMueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4L3kgb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0WFk6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHggb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFg6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeSBvZiB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0WTogZnVuY3Rpb24gKHkpIHtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4L3kgb2YgdGhpcyBwb2ludCBmcm9tIGFub3RoZXIgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRGcm9tUG9pbnQ6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB0aGlzLnggPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgeC95IG9mIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqL1xuICAgIHN3YXA6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB2YXIgeCA9IHRoaXMueCxcbiAgICAgICAgICB5ID0gdGhpcy55O1xuICAgICAgdGhpcy54ID0gdGhhdC54O1xuICAgICAgdGhpcy55ID0gdGhhdC55O1xuICAgICAgdGhhdC54ID0geDtcbiAgICAgIHRoYXQueSA9IHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIGNsb25lZCBpbnN0YW5jZSBvZiB0aGUgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogQWRhcHRhdGlvbiBvZiB3b3JrIG9mIEtldmluIExpbmRzZXkgKGtldmluQGtldmxpbmRldi5jb20pICovXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLkludGVyc2VjdGlvbikge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuSW50ZXJzZWN0aW9uIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcnNlY3Rpb24gY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbnRlcnNlY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEludGVyc2VjdGlvbihzdGF0dXMpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICB9XG5cbiAgZmFicmljLkludGVyc2VjdGlvbiA9IEludGVyc2VjdGlvbjtcblxuICBmYWJyaWMuSW50ZXJzZWN0aW9uLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkludGVyc2VjdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgY29uc3RydWN0b3I6IEludGVyc2VjdGlvbixcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBwb2ludCB0byBpbnRlcnNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGVuZFBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgcG9pbnRzIHRvIGludGVyc2VjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwZW5kUG9pbnRzOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICB0aGlzLnBvaW50cyA9IHRoaXMucG9pbnRzLmNvbmNhdChwb2ludHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgb25lIGxpbmUgaW50ZXJzZWN0cyBhbm90aGVyXG4gICAqIFRPRE86IHJlbmFtZSBpbiBpbnRlcnNlY3RTZWdtZW50U2VnbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTJcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGIxXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBiMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lTGluZSA9IGZ1bmN0aW9uIChhMSwgYTIsIGIxLCBiMikge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIHVhVCA9IChiMi54IC0gYjEueCkgKiAoYTEueSAtIGIxLnkpIC0gKGIyLnkgLSBiMS55KSAqIChhMS54IC0gYjEueCksXG4gICAgICAgIHViVCA9IChhMi54IC0gYTEueCkgKiAoYTEueSAtIGIxLnkpIC0gKGEyLnkgLSBhMS55KSAqIChhMS54IC0gYjEueCksXG4gICAgICAgIHVCID0gKGIyLnkgLSBiMS55KSAqIChhMi54IC0gYTEueCkgLSAoYjIueCAtIGIxLngpICogKGEyLnkgLSBhMS55KTtcbiAgICBpZiAodUIgIT09IDApIHtcbiAgICAgIHZhciB1YSA9IHVhVCAvIHVCLFxuICAgICAgICAgIHViID0gdWJUIC8gdUI7XG4gICAgICBpZiAoMCA8PSB1YSAmJiB1YSA8PSAxICYmIDAgPD0gdWIgJiYgdWIgPD0gMSkge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCdJbnRlcnNlY3Rpb24nKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZFBvaW50KG5ldyBmYWJyaWMuUG9pbnQoYTEueCArIHVhICogKGEyLnggLSBhMS54KSwgYTEueSArIHVhICogKGEyLnkgLSBhMS55KSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodWFUID09PSAwIHx8IHViVCA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCdDb2luY2lkZW50Jyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignUGFyYWxsZWwnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGxpbmUgaW50ZXJzZWN0cyBwb2x5Z29uXG4gICAqIFRPRE86IHJlbmFtZSBpbiBpbnRlcnNlY3RTZWdtZW50UG9seWdvblxuICAgKiBmaXggZGV0ZWN0aW9uIG9mIGNvaW5jaWRlbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGEyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbiA9IGZ1bmN0aW9uKGExLCBhMiwgcG9pbnRzKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKSxcbiAgICAgICAgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgYjEsIGIyLCBpbnRlciwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYjEgPSBwb2ludHNbaV07XG4gICAgICBiMiA9IHBvaW50c1soaSArIDEpICUgbGVuZ3RoXTtcbiAgICAgIGludGVyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVMaW5lKGExLCBhMiwgYjEsIGIyKTtcblxuICAgICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlci5wb2ludHMpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQuc3RhdHVzID0gJ0ludGVyc2VjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBwb2x5Z29uIGludGVyc2VjdHMgYW5vdGhlciBwb2x5Z29uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzMVxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25Qb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50czEsIHBvaW50czIpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpLFxuICAgICAgICBsZW5ndGggPSBwb2ludHMxLmxlbmd0aCwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGExID0gcG9pbnRzMVtpXSxcbiAgICAgICAgICBhMiA9IHBvaW50czFbKGkgKyAxKSAlIGxlbmd0aF0sXG4gICAgICAgICAgaW50ZXIgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24oYTEsIGEyLCBwb2ludHMyKTtcblxuICAgICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlci5wb2ludHMpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQuc3RhdHVzID0gJ0ludGVyc2VjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBwb2x5Z29uIGludGVyc2VjdHMgcmVjdGFuZ2xlXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSByMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcjJcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblJlY3RhbmdsZSA9IGZ1bmN0aW9uIChwb2ludHMsIHIxLCByMikge1xuICAgIHZhciBtaW4gPSByMS5taW4ocjIpLFxuICAgICAgICBtYXggPSByMS5tYXgocjIpLFxuICAgICAgICB0b3BSaWdodCA9IG5ldyBmYWJyaWMuUG9pbnQobWF4LngsIG1pbi55KSxcbiAgICAgICAgYm90dG9tTGVmdCA9IG5ldyBmYWJyaWMuUG9pbnQobWluLngsIG1heC55KSxcbiAgICAgICAgaW50ZXIxID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKG1pbiwgdG9wUmlnaHQsIHBvaW50cyksXG4gICAgICAgIGludGVyMiA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbih0b3BSaWdodCwgbWF4LCBwb2ludHMpLFxuICAgICAgICBpbnRlcjMgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24obWF4LCBib3R0b21MZWZ0LCBwb2ludHMpLFxuICAgICAgICBpbnRlcjQgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24oYm90dG9tTGVmdCwgbWluLCBwb2ludHMpLFxuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCk7XG5cbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyMS5wb2ludHMpO1xuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIyLnBvaW50cyk7XG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjMucG9pbnRzKTtcbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyNC5wb2ludHMpO1xuXG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5Db2xvcikge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuQ29sb3IgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xvciBjbGFzc1xuICAgKiBUaGUgcHVycG9zZSBvZiB7QGxpbmsgZmFicmljLkNvbG9yfSBpcyB0byBhYnN0cmFjdCBhbmQgZW5jYXBzdWxhdGUgY29tbW9uIGNvbG9yIG9wZXJhdGlvbnM7XG4gICAqIHtAbGluayBmYWJyaWMuQ29sb3J9IGlzIGEgY29uc3RydWN0b3IgYW5kIGNyZWF0ZXMgaW5zdGFuY2VzIG9mIHtAbGluayBmYWJyaWMuQ29sb3J9IG9iamVjdHMuXG4gICAqXG4gICAqIEBjbGFzcyBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIG9wdGlvbmFsIGluIGhleCBvciByZ2IoYSkgb3IgaHNsIGZvcm1hdCBvciBmcm9tIGtub3duIGNvbG9yIGxpc3RcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yLyNjb2xvcnN9XG4gICAqL1xuICBmdW5jdGlvbiBDb2xvcihjb2xvcikge1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHRoaXMuc2V0U291cmNlKFswLCAwLCAwLCAxXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fdHJ5UGFyc2luZ0NvbG9yKGNvbG9yKTtcbiAgICB9XG4gIH1cblxuICBmYWJyaWMuQ29sb3IgPSBDb2xvcjtcblxuICBmYWJyaWMuQ29sb3IucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuQ29sb3IucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGNvbG9yIENvbG9yIHZhbHVlIHRvIHBhcnNlXG4gICAgICovXG4gICAgX3RyeVBhcnNpbmdDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgIHZhciBzb3VyY2U7XG5cbiAgICAgIGlmIChjb2xvciBpbiBDb2xvci5jb2xvck5hbWVNYXApIHtcbiAgICAgICAgY29sb3IgPSBDb2xvci5jb2xvck5hbWVNYXBbY29sb3JdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgc291cmNlID0gWzI1NSwgMjU1LCAyNTUsIDBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBDb2xvci5zb3VyY2VGcm9tSGV4KGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSA9IENvbG9yLnNvdXJjZUZyb21SZ2IoY29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gQ29sb3Iuc291cmNlRnJvbUhzbChjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAvL2lmIGNvbG9yIGlzIG5vdCByZWNvZ25pemUgbGV0J3MgbWFrZSBibGFjayBhcyBjYW52YXMgZG9lc1xuICAgICAgICBzb3VyY2UgPSBbMCwgMCwgMCwgMV07XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cHM6Ly9yYXdnaXRodWIuY29tL21qaWphY2tzb24vbWppamFja3Nvbi5naXRodWIuY29tL21hc3Rlci8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHQuaHRtbFwiPmh0dHBzOi8vZ2l0aHViLmNvbS9tamlqYWNrc29uPC9hPlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgUmVkIGNvbG9yIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGcgR3JlZW4gY29sb3IgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBCbHVlIGNvbG9yIHZhbHVlXG4gICAgICogQHJldHVybiB7QXJyYXl9IEhzbCBjb2xvclxuICAgICAqL1xuICAgIF9yZ2JUb0hzbDogZnVuY3Rpb24ociwgZywgYikge1xuICAgICAgciAvPSAyNTU7IGcgLz0gMjU1OyBiIC89IDI1NTtcblxuICAgICAgdmFyIGgsIHMsIGwsXG4gICAgICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4KFtyLCBnLCBiXSksXG4gICAgICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluKFtyLCBnLCBiXSk7XG5cbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICBoID0gcyA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgICAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgICAgIGNhc2UgcjpcbiAgICAgICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaCAvPSA2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBNYXRoLnJvdW5kKGggKiAzNjApLFxuICAgICAgICBNYXRoLnJvdW5kKHMgKiAxMDApLFxuICAgICAgICBNYXRoLnJvdW5kKGwgKiAxMDApXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNvdXJjZSBvZiB0aGlzIGNvbG9yICh3aGVyZSBzb3VyY2UgaXMgYW4gYXJyYXkgcmVwcmVzZW50YXRpb247IGV4OiBbMjAwLCAyMDAsIDEwMCwgMV0pXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc291cmNlIG9mIHRoaXMgY29sb3IgKHdoZXJlIHNvdXJjZSBpcyBhbiBhcnJheSByZXByZXNlbnRhdGlvbjsgZXg6IFsyMDAsIDIwMCwgMTAwLCAxXSlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VcbiAgICAgKi9cbiAgICBzZXRTb3VyY2U6IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIFJHQiBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiByZ2IoMC0yNTUsMC0yNTUsMC0yNTUpXG4gICAgICovXG4gICAgdG9SZ2I6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgICByZXR1cm4gJ3JnYignICsgc291cmNlWzBdICsgJywnICsgc291cmNlWzFdICsgJywnICsgc291cmNlWzJdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIFJHQkEgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogcmdiYSgwLTI1NSwwLTI1NSwwLTI1NSwwLTEpXG4gICAgICovXG4gICAgdG9SZ2JhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgcmV0dXJuICdyZ2JhKCcgKyBzb3VyY2VbMF0gKyAnLCcgKyBzb3VyY2VbMV0gKyAnLCcgKyBzb3VyY2VbMl0gKyAnLCcgKyBzb3VyY2VbM10gKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSFNMIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IGhzbCgwLTM2MCwwJS0xMDAlLDAlLTEwMCUpXG4gICAgICovXG4gICAgdG9Ic2w6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgaHNsID0gdGhpcy5fcmdiVG9Ic2woc291cmNlWzBdLCBzb3VyY2VbMV0sIHNvdXJjZVsyXSk7XG5cbiAgICAgIHJldHVybiAnaHNsKCcgKyBoc2xbMF0gKyAnLCcgKyBoc2xbMV0gKyAnJSwnICsgaHNsWzJdICsgJyUpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBIU0xBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IGhzbGEoMC0zNjAsMCUtMTAwJSwwJS0xMDAlLDAtMSlcbiAgICAgKi9cbiAgICB0b0hzbGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgaHNsID0gdGhpcy5fcmdiVG9Ic2woc291cmNlWzBdLCBzb3VyY2VbMV0sIHNvdXJjZVsyXSk7XG5cbiAgICAgIHJldHVybiAnaHNsYSgnICsgaHNsWzBdICsgJywnICsgaHNsWzFdICsgJyUsJyArIGhzbFsyXSArICclLCcgKyBzb3VyY2VbM10gKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSEVYIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IEZGNTU1NVxuICAgICAqL1xuICAgIHRvSGV4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLCByLCBnLCBiO1xuXG4gICAgICByID0gc291cmNlWzBdLnRvU3RyaW5nKDE2KTtcbiAgICAgIHIgPSAoci5sZW5ndGggPT09IDEpID8gKCcwJyArIHIpIDogcjtcblxuICAgICAgZyA9IHNvdXJjZVsxXS50b1N0cmluZygxNik7XG4gICAgICBnID0gKGcubGVuZ3RoID09PSAxKSA/ICgnMCcgKyBnKSA6IGc7XG5cbiAgICAgIGIgPSBzb3VyY2VbMl0udG9TdHJpbmcoMTYpO1xuICAgICAgYiA9IChiLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgYikgOiBiO1xuXG4gICAgICByZXR1cm4gci50b1VwcGVyQ2FzZSgpICsgZy50b1VwcGVyQ2FzZSgpICsgYi50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhFWEEgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogRkY1NTU1Q0NcbiAgICAgKi9cbiAgICB0b0hleGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksIGE7XG5cbiAgICAgIGEgPSBNYXRoLnJvdW5kKHNvdXJjZVszXSAqIDI1NSk7XG4gICAgICBhID0gYS50b1N0cmluZygxNik7XG4gICAgICBhID0gKGEubGVuZ3RoID09PSAxKSA/ICgnMCcgKyBhKSA6IGE7XG5cbiAgICAgIHJldHVybiB0aGlzLnRvSGV4KCkgKyBhLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdmFsdWUgb2YgYWxwaGEgY2hhbm5lbCBmb3IgdGhpcyBjb2xvclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gMC0xXG4gICAgICovXG4gICAgZ2V0QWxwaGE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U291cmNlKClbM107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdmFsdWUgb2YgYWxwaGEgY2hhbm5lbCBmb3IgdGhpcyBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYSBBbHBoYSB2YWx1ZSAwLTFcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXRBbHBoYTogZnVuY3Rpb24oYWxwaGEpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgc291cmNlWzNdID0gYWxwaGE7XG4gICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29sb3IgdG8gaXRzIGdyYXlzY2FsZSByZXByZXNlbnRhdGlvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHRvR3JheXNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGF2ZXJhZ2UgPSBwYXJzZUludCgoc291cmNlWzBdICogMC4zICsgc291cmNlWzFdICogMC41OSArIHNvdXJjZVsyXSAqIDAuMTEpLnRvRml4ZWQoMCksIDEwKSxcbiAgICAgICAgICBjdXJyZW50QWxwaGEgPSBzb3VyY2VbM107XG4gICAgICB0aGlzLnNldFNvdXJjZShbYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY3VycmVudEFscGhhXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBjb2xvciB0byBpdHMgYmxhY2sgYW5kIHdoaXRlIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHRvQmxhY2tXaGl0ZTogZnVuY3Rpb24odGhyZXNob2xkKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBhdmVyYWdlID0gKHNvdXJjZVswXSAqIDAuMyArIHNvdXJjZVsxXSAqIDAuNTkgKyBzb3VyY2VbMl0gKiAwLjExKS50b0ZpeGVkKDApLFxuICAgICAgICAgIGN1cnJlbnRBbHBoYSA9IHNvdXJjZVszXTtcblxuICAgICAgdGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDEyNztcblxuICAgICAgYXZlcmFnZSA9IChOdW1iZXIoYXZlcmFnZSkgPCBOdW1iZXIodGhyZXNob2xkKSkgPyAwIDogMjU1O1xuICAgICAgdGhpcy5zZXRTb3VyY2UoW2F2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGN1cnJlbnRBbHBoYV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJsYXlzIGNvbG9yIHdpdGggYW5vdGhlciBjb2xvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfGZhYnJpYy5Db2xvcn0gb3RoZXJDb2xvclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIG92ZXJsYXlXaXRoOiBmdW5jdGlvbihvdGhlckNvbG9yKSB7XG4gICAgICBpZiAoIShvdGhlckNvbG9yIGluc3RhbmNlb2YgQ29sb3IpKSB7XG4gICAgICAgIG90aGVyQ29sb3IgPSBuZXcgQ29sb3Iob3RoZXJDb2xvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBhbHBoYSA9IHRoaXMuZ2V0QWxwaGEoKSxcbiAgICAgICAgICBvdGhlckFscGhhID0gMC41LFxuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgb3RoZXJTb3VyY2UgPSBvdGhlckNvbG9yLmdldFNvdXJjZSgpLCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKE1hdGgucm91bmQoKHNvdXJjZVtpXSAqICgxIC0gb3RoZXJBbHBoYSkpICsgKG90aGVyU291cmNlW2ldICogb3RoZXJBbHBoYSkpKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0WzNdID0gYWxwaGE7XG4gICAgICB0aGlzLnNldFNvdXJjZShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBSR0Igb3IgUkdCQSBmb3JtYXRzIChleDogcmdiKDAsIDAsIDApLCByZ2JhKDI1NSwgMTAwLCAxMCwgMC41KSwgcmdiYSggMjU1ICwgMTAwICwgMTAgLCAwLjUgKSwgcmdiKDEsMSwxKSwgcmdiYSgxMDAlLCA2MCUsIDEwJSwgMC41KSlcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgZmFicmljLkNvbG9yLnJlUkdCYSA9IC9ecmdiYT9cXChcXHMqKFxcZHsxLDN9KD86XFwuXFxkKyk/XFwlPylcXHMqLFxccyooXFxkezEsM30oPzpcXC5cXGQrKT9cXCU/KVxccyosXFxzKihcXGR7MSwzfSg/OlxcLlxcZCspP1xcJT8pXFxzKig/OlxccyosXFxzKigoPzpcXGQqXFwuP1xcZCspPylcXHMqKT9cXCkkL2k7XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIGNvbG9yIGluIEhTTCBvciBIU0xBIGZvcm1hdHMgKGV4OiBoc2woMjAwLCA4MCUsIDEwJSksIGhzbGEoMzAwLCA1MCUsIDgwJSwgMC41KSwgaHNsYSggMzAwICwgNTAlICwgODAlICwgMC41ICkpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5yZUhTTGEgPSAvXmhzbGE/XFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM31cXCUpXFxzKixcXHMqKFxcZHsxLDN9XFwlKVxccyooPzpcXHMqLFxccyooXFxkKyg/OlxcLlxcZCspPylcXHMqKT9cXCkkL2k7XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIGNvbG9yIGluIEhFWCBmb3JtYXQgKGV4OiAjRkY1NTQ0Q0MsICNGRjU1NTUsIDAxMDE1NSwgYWZmKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IucmVIZXggPSAvXiM/KFswLTlhLWZdezh9fFswLTlhLWZdezZ9fFswLTlhLWZdezR9fFswLTlhLWZdezN9KSQvaTtcblxuICAvKipcbiAgICogTWFwIG9mIHRoZSAxNDggY29sb3IgbmFtZXMgd2l0aCBIRVggY29kZVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBzZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5jb2xvck5hbWVNYXAgPSB7XG4gICAgYWxpY2VibHVlOiAgICAgICAgICAgICcjRjBGOEZGJyxcbiAgICBhbnRpcXVld2hpdGU6ICAgICAgICAgJyNGQUVCRDcnLFxuICAgIGFxdWE6ICAgICAgICAgICAgICAgICAnIzAwRkZGRicsXG4gICAgYXF1YW1hcmluZTogICAgICAgICAgICcjN0ZGRkQ0JyxcbiAgICBhenVyZTogICAgICAgICAgICAgICAgJyNGMEZGRkYnLFxuICAgIGJlaWdlOiAgICAgICAgICAgICAgICAnI0Y1RjVEQycsXG4gICAgYmlzcXVlOiAgICAgICAgICAgICAgICcjRkZFNEM0JyxcbiAgICBibGFjazogICAgICAgICAgICAgICAgJyMwMDAwMDAnLFxuICAgIGJsYW5jaGVkYWxtb25kOiAgICAgICAnI0ZGRUJDRCcsXG4gICAgYmx1ZTogICAgICAgICAgICAgICAgICcjMDAwMEZGJyxcbiAgICBibHVldmlvbGV0OiAgICAgICAgICAgJyM4QTJCRTInLFxuICAgIGJyb3duOiAgICAgICAgICAgICAgICAnI0E1MkEyQScsXG4gICAgYnVybHl3b29kOiAgICAgICAgICAgICcjREVCODg3JyxcbiAgICBjYWRldGJsdWU6ICAgICAgICAgICAgJyM1RjlFQTAnLFxuICAgIGNoYXJ0cmV1c2U6ICAgICAgICAgICAnIzdGRkYwMCcsXG4gICAgY2hvY29sYXRlOiAgICAgICAgICAgICcjRDI2OTFFJyxcbiAgICBjb3JhbDogICAgICAgICAgICAgICAgJyNGRjdGNTAnLFxuICAgIGNvcm5mbG93ZXJibHVlOiAgICAgICAnIzY0OTVFRCcsXG4gICAgY29ybnNpbGs6ICAgICAgICAgICAgICcjRkZGOERDJyxcbiAgICBjcmltc29uOiAgICAgICAgICAgICAgJyNEQzE0M0MnLFxuICAgIGN5YW46ICAgICAgICAgICAgICAgICAnIzAwRkZGRicsXG4gICAgZGFya2JsdWU6ICAgICAgICAgICAgICcjMDAwMDhCJyxcbiAgICBkYXJrY3lhbjogICAgICAgICAgICAgJyMwMDhCOEInLFxuICAgIGRhcmtnb2xkZW5yb2Q6ICAgICAgICAnI0I4ODYwQicsXG4gICAgZGFya2dyYXk6ICAgICAgICAgICAgICcjQTlBOUE5JyxcbiAgICBkYXJrZ3JleTogICAgICAgICAgICAgJyNBOUE5QTknLFxuICAgIGRhcmtncmVlbjogICAgICAgICAgICAnIzAwNjQwMCcsXG4gICAgZGFya2toYWtpOiAgICAgICAgICAgICcjQkRCNzZCJyxcbiAgICBkYXJrbWFnZW50YTogICAgICAgICAgJyM4QjAwOEInLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiAgICAgICAnIzU1NkIyRicsXG4gICAgZGFya29yYW5nZTogICAgICAgICAgICcjRkY4QzAwJyxcbiAgICBkYXJrb3JjaGlkOiAgICAgICAgICAgJyM5OTMyQ0MnLFxuICAgIGRhcmtyZWQ6ICAgICAgICAgICAgICAnIzhCMDAwMCcsXG4gICAgZGFya3NhbG1vbjogICAgICAgICAgICcjRTk5NjdBJyxcbiAgICBkYXJrc2VhZ3JlZW46ICAgICAgICAgJyM4RkJDOEYnLFxuICAgIGRhcmtzbGF0ZWJsdWU6ICAgICAgICAnIzQ4M0Q4QicsXG4gICAgZGFya3NsYXRlZ3JheTogICAgICAgICcjMkY0RjRGJyxcbiAgICBkYXJrc2xhdGVncmV5OiAgICAgICAgJyMyRjRGNEYnLFxuICAgIGRhcmt0dXJxdW9pc2U6ICAgICAgICAnIzAwQ0VEMScsXG4gICAgZGFya3Zpb2xldDogICAgICAgICAgICcjOTQwMEQzJyxcbiAgICBkZWVwcGluazogICAgICAgICAgICAgJyNGRjE0OTMnLFxuICAgIGRlZXBza3libHVlOiAgICAgICAgICAnIzAwQkZGRicsXG4gICAgZGltZ3JheTogICAgICAgICAgICAgICcjNjk2OTY5JyxcbiAgICBkaW1ncmV5OiAgICAgICAgICAgICAgJyM2OTY5NjknLFxuICAgIGRvZGdlcmJsdWU6ICAgICAgICAgICAnIzFFOTBGRicsXG4gICAgZmlyZWJyaWNrOiAgICAgICAgICAgICcjQjIyMjIyJyxcbiAgICBmbG9yYWx3aGl0ZTogICAgICAgICAgJyNGRkZBRjAnLFxuICAgIGZvcmVzdGdyZWVuOiAgICAgICAgICAnIzIyOEIyMicsXG4gICAgZnVjaHNpYTogICAgICAgICAgICAgICcjRkYwMEZGJyxcbiAgICBnYWluc2Jvcm86ICAgICAgICAgICAgJyNEQ0RDREMnLFxuICAgIGdob3N0d2hpdGU6ICAgICAgICAgICAnI0Y4RjhGRicsXG4gICAgZ29sZDogICAgICAgICAgICAgICAgICcjRkZENzAwJyxcbiAgICBnb2xkZW5yb2Q6ICAgICAgICAgICAgJyNEQUE1MjAnLFxuICAgIGdyYXk6ICAgICAgICAgICAgICAgICAnIzgwODA4MCcsXG4gICAgZ3JleTogICAgICAgICAgICAgICAgICcjODA4MDgwJyxcbiAgICBncmVlbjogICAgICAgICAgICAgICAgJyMwMDgwMDAnLFxuICAgIGdyZWVueWVsbG93OiAgICAgICAgICAnI0FERkYyRicsXG4gICAgaG9uZXlkZXc6ICAgICAgICAgICAgICcjRjBGRkYwJyxcbiAgICBob3RwaW5rOiAgICAgICAgICAgICAgJyNGRjY5QjQnLFxuICAgIGluZGlhbnJlZDogICAgICAgICAgICAnI0NENUM1QycsXG4gICAgaW5kaWdvOiAgICAgICAgICAgICAgICcjNEIwMDgyJyxcbiAgICBpdm9yeTogICAgICAgICAgICAgICAgJyNGRkZGRjAnLFxuICAgIGtoYWtpOiAgICAgICAgICAgICAgICAnI0YwRTY4QycsXG4gICAgbGF2ZW5kZXI6ICAgICAgICAgICAgICcjRTZFNkZBJyxcbiAgICBsYXZlbmRlcmJsdXNoOiAgICAgICAgJyNGRkYwRjUnLFxuICAgIGxhd25ncmVlbjogICAgICAgICAgICAnIzdDRkMwMCcsXG4gICAgbGVtb25jaGlmZm9uOiAgICAgICAgICcjRkZGQUNEJyxcbiAgICBsaWdodGJsdWU6ICAgICAgICAgICAgJyNBREQ4RTYnLFxuICAgIGxpZ2h0Y29yYWw6ICAgICAgICAgICAnI0YwODA4MCcsXG4gICAgbGlnaHRjeWFuOiAgICAgICAgICAgICcjRTBGRkZGJyxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNGQUZBRDInLFxuICAgIGxpZ2h0Z3JheTogICAgICAgICAgICAnI0QzRDNEMycsXG4gICAgbGlnaHRncmV5OiAgICAgICAgICAgICcjRDNEM0QzJyxcbiAgICBsaWdodGdyZWVuOiAgICAgICAgICAgJyM5MEVFOTAnLFxuICAgIGxpZ2h0cGluazogICAgICAgICAgICAnI0ZGQjZDMScsXG4gICAgbGlnaHRzYWxtb246ICAgICAgICAgICcjRkZBMDdBJyxcbiAgICBsaWdodHNlYWdyZWVuOiAgICAgICAgJyMyMEIyQUEnLFxuICAgIGxpZ2h0c2t5Ymx1ZTogICAgICAgICAnIzg3Q0VGQScsXG4gICAgbGlnaHRzbGF0ZWdyYXk6ICAgICAgICcjNzc4ODk5JyxcbiAgICBsaWdodHNsYXRlZ3JleTogICAgICAgJyM3Nzg4OTknLFxuICAgIGxpZ2h0c3RlZWxibHVlOiAgICAgICAnI0IwQzRERScsXG4gICAgbGlnaHR5ZWxsb3c6ICAgICAgICAgICcjRkZGRkUwJyxcbiAgICBsaW1lOiAgICAgICAgICAgICAgICAgJyMwMEZGMDAnLFxuICAgIGxpbWVncmVlbjogICAgICAgICAgICAnIzMyQ0QzMicsXG4gICAgbGluZW46ICAgICAgICAgICAgICAgICcjRkFGMEU2JyxcbiAgICBtYWdlbnRhOiAgICAgICAgICAgICAgJyNGRjAwRkYnLFxuICAgIG1hcm9vbjogICAgICAgICAgICAgICAnIzgwMDAwMCcsXG4gICAgbWVkaXVtYXF1YW1hcmluZTogICAgICcjNjZDREFBJyxcbiAgICBtZWRpdW1ibHVlOiAgICAgICAgICAgJyMwMDAwQ0QnLFxuICAgIG1lZGl1bW9yY2hpZDogICAgICAgICAnI0JBNTVEMycsXG4gICAgbWVkaXVtcHVycGxlOiAgICAgICAgICcjOTM3MERCJyxcbiAgICBtZWRpdW1zZWFncmVlbjogICAgICAgJyMzQ0IzNzEnLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogICAgICAnIzdCNjhFRScsXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46ICAgICcjMDBGQTlBJyxcbiAgICBtZWRpdW10dXJxdW9pc2U6ICAgICAgJyM0OEQxQ0MnLFxuICAgIG1lZGl1bXZpb2xldHJlZDogICAgICAnI0M3MTU4NScsXG4gICAgbWlkbmlnaHRibHVlOiAgICAgICAgICcjMTkxOTcwJyxcbiAgICBtaW50Y3JlYW06ICAgICAgICAgICAgJyNGNUZGRkEnLFxuICAgIG1pc3R5cm9zZTogICAgICAgICAgICAnI0ZGRTRFMScsXG4gICAgbW9jY2FzaW46ICAgICAgICAgICAgICcjRkZFNEI1JyxcbiAgICBuYXZham93aGl0ZTogICAgICAgICAgJyNGRkRFQUQnLFxuICAgIG5hdnk6ICAgICAgICAgICAgICAgICAnIzAwMDA4MCcsXG4gICAgb2xkbGFjZTogICAgICAgICAgICAgICcjRkRGNUU2JyxcbiAgICBvbGl2ZTogICAgICAgICAgICAgICAgJyM4MDgwMDAnLFxuICAgIG9saXZlZHJhYjogICAgICAgICAgICAnIzZCOEUyMycsXG4gICAgb3JhbmdlOiAgICAgICAgICAgICAgICcjRkZBNTAwJyxcbiAgICBvcmFuZ2VyZWQ6ICAgICAgICAgICAgJyNGRjQ1MDAnLFxuICAgIG9yY2hpZDogICAgICAgICAgICAgICAnI0RBNzBENicsXG4gICAgcGFsZWdvbGRlbnJvZDogICAgICAgICcjRUVFOEFBJyxcbiAgICBwYWxlZ3JlZW46ICAgICAgICAgICAgJyM5OEZCOTgnLFxuICAgIHBhbGV0dXJxdW9pc2U6ICAgICAgICAnI0FGRUVFRScsXG4gICAgcGFsZXZpb2xldHJlZDogICAgICAgICcjREI3MDkzJyxcbiAgICBwYXBheWF3aGlwOiAgICAgICAgICAgJyNGRkVGRDUnLFxuICAgIHBlYWNocHVmZjogICAgICAgICAgICAnI0ZGREFCOScsXG4gICAgcGVydTogICAgICAgICAgICAgICAgICcjQ0Q4NTNGJyxcbiAgICBwaW5rOiAgICAgICAgICAgICAgICAgJyNGRkMwQ0InLFxuICAgIHBsdW06ICAgICAgICAgICAgICAgICAnI0REQTBERCcsXG4gICAgcG93ZGVyYmx1ZTogICAgICAgICAgICcjQjBFMEU2JyxcbiAgICBwdXJwbGU6ICAgICAgICAgICAgICAgJyM4MDAwODAnLFxuICAgIHJlYmVjY2FwdXJwbGU6ICAgICAgICAnIzY2MzM5OScsXG4gICAgcmVkOiAgICAgICAgICAgICAgICAgICcjRkYwMDAwJyxcbiAgICByb3N5YnJvd246ICAgICAgICAgICAgJyNCQzhGOEYnLFxuICAgIHJveWFsYmx1ZTogICAgICAgICAgICAnIzQxNjlFMScsXG4gICAgc2FkZGxlYnJvd246ICAgICAgICAgICcjOEI0NTEzJyxcbiAgICBzYWxtb246ICAgICAgICAgICAgICAgJyNGQTgwNzInLFxuICAgIHNhbmR5YnJvd246ICAgICAgICAgICAnI0Y0QTQ2MCcsXG4gICAgc2VhZ3JlZW46ICAgICAgICAgICAgICcjMkU4QjU3JyxcbiAgICBzZWFzaGVsbDogICAgICAgICAgICAgJyNGRkY1RUUnLFxuICAgIHNpZW5uYTogICAgICAgICAgICAgICAnI0EwNTIyRCcsXG4gICAgc2lsdmVyOiAgICAgICAgICAgICAgICcjQzBDMEMwJyxcbiAgICBza3libHVlOiAgICAgICAgICAgICAgJyM4N0NFRUInLFxuICAgIHNsYXRlYmx1ZTogICAgICAgICAgICAnIzZBNUFDRCcsXG4gICAgc2xhdGVncmF5OiAgICAgICAgICAgICcjNzA4MDkwJyxcbiAgICBzbGF0ZWdyZXk6ICAgICAgICAgICAgJyM3MDgwOTAnLFxuICAgIHNub3c6ICAgICAgICAgICAgICAgICAnI0ZGRkFGQScsXG4gICAgc3ByaW5nZ3JlZW46ICAgICAgICAgICcjMDBGRjdGJyxcbiAgICBzdGVlbGJsdWU6ICAgICAgICAgICAgJyM0NjgyQjQnLFxuICAgIHRhbjogICAgICAgICAgICAgICAgICAnI0QyQjQ4QycsXG4gICAgdGVhbDogICAgICAgICAgICAgICAgICcjMDA4MDgwJyxcbiAgICB0aGlzdGxlOiAgICAgICAgICAgICAgJyNEOEJGRDgnLFxuICAgIHRvbWF0bzogICAgICAgICAgICAgICAnI0ZGNjM0NycsXG4gICAgdHVycXVvaXNlOiAgICAgICAgICAgICcjNDBFMEQwJyxcbiAgICB2aW9sZXQ6ICAgICAgICAgICAgICAgJyNFRTgyRUUnLFxuICAgIHdoZWF0OiAgICAgICAgICAgICAgICAnI0Y1REVCMycsXG4gICAgd2hpdGU6ICAgICAgICAgICAgICAgICcjRkZGRkZGJyxcbiAgICB3aGl0ZXNtb2tlOiAgICAgICAgICAgJyNGNUY1RjUnLFxuICAgIHllbGxvdzogICAgICAgICAgICAgICAnI0ZGRkYwMCcsXG4gICAgeWVsbG93Z3JlZW46ICAgICAgICAgICcjOUFDRDMyJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcFxuICAgKiBAcGFyYW0ge051bWJlcn0gcVxuICAgKiBAcGFyYW0ge051bWJlcn0gdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApIHtcbiAgICAgIHQgKz0gMTtcbiAgICB9XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB0IC09IDE7XG4gICAgfVxuICAgIGlmICh0IDwgMSAvIDYpIHtcbiAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8IDEgLyAyKSB7XG4gICAgICByZXR1cm4gcTtcbiAgICB9XG4gICAgaWYgKHQgPCAyIC8gMykge1xuICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBSR0IgZm9ybWF0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlIGV4OiByZ2IoMC0yNTUsMC0yNTUsMC0yNTUpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tUmdiID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gQ29sb3IuZnJvbVNvdXJjZShDb2xvci5zb3VyY2VGcm9tUmdiKGNvbG9yKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMTAwLCAxMDAsIDIwMCwgMV0pIG9mIGEgY29sb3IgdGhhdCdzIGluIFJHQiBvciBSR0JBIGZvcm1hdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KSwgcmdiKDAlLTEwMCUsMCUtMTAwJSwwJS0xMDAlKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gc291cmNlXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbVJnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgdmFyIG1hdGNoID0gY29sb3IubWF0Y2goQ29sb3IucmVSR0JhKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciByID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSAvICgvJSQvLnRlc3QobWF0Y2hbMV0pID8gMTAwIDogMSkgKiAoLyUkLy50ZXN0KG1hdGNoWzFdKSA/IDI1NSA6IDEpLFxuICAgICAgICAgIGcgPSBwYXJzZUludChtYXRjaFsyXSwgMTApIC8gKC8lJC8udGVzdChtYXRjaFsyXSkgPyAxMDAgOiAxKSAqICgvJSQvLnRlc3QobWF0Y2hbMl0pID8gMjU1IDogMSksXG4gICAgICAgICAgYiA9IHBhcnNlSW50KG1hdGNoWzNdLCAxMCkgLyAoLyUkLy50ZXN0KG1hdGNoWzNdKSA/IDEwMCA6IDEpICogKC8lJC8udGVzdChtYXRjaFszXSkgPyAyNTUgOiAxKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcGFyc2VJbnQociwgMTApLFxuICAgICAgICBwYXJzZUludChnLCAxMCksXG4gICAgICAgIHBhcnNlSW50KGIsIDEwKSxcbiAgICAgICAgbWF0Y2hbNF0gPyBwYXJzZUZsb2F0KG1hdGNoWzRdKSA6IDFcbiAgICAgIF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBSR0JBIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVJnYmEgPSBDb2xvci5mcm9tUmdiO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIU0wgZm9ybWF0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogaHNsKDAtMjYwLDAlLTEwMCUsMCUtMTAwJSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhzbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbUhzbChjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBIU0wgb3IgSFNMQSBmb3JtYXQuXG4gICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cHM6Ly9yYXdnaXRodWIuY29tL21qaWphY2tzb24vbWppamFja3Nvbi5naXRodWIuY29tL21hc3Rlci8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHQuaHRtbFwiPmh0dHBzOi8vZ2l0aHViLmNvbS9tamlqYWNrc29uPC9hPlxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogaHNsKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSkgb3IgaHNsYSgwLTM2MCwwJS0xMDAlLDAlLTEwMCUsIDAtMSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKiBAc2VlIGh0dHA6Ly9odHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNoc2wtY29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5zb3VyY2VGcm9tSHNsID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICB2YXIgbWF0Y2ggPSBjb2xvci5tYXRjaChDb2xvci5yZUhTTGEpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQobWF0Y2hbMV0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwLFxuICAgICAgICBzID0gcGFyc2VGbG9hdChtYXRjaFsyXSkgLyAoLyUkLy50ZXN0KG1hdGNoWzJdKSA/IDEwMCA6IDEpLFxuICAgICAgICBsID0gcGFyc2VGbG9hdChtYXRjaFszXSkgLyAoLyUkLy50ZXN0KG1hdGNoWzNdKSA/IDEwMCA6IDEpLFxuICAgICAgICByLCBnLCBiO1xuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHEgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcyxcbiAgICAgICAgICBwID0gbCAqIDIgLSBxO1xuXG4gICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBNYXRoLnJvdW5kKHIgKiAyNTUpLFxuICAgICAgTWF0aC5yb3VuZChnICogMjU1KSxcbiAgICAgIE1hdGgucm91bmQoYiAqIDI1NSksXG4gICAgICBtYXRjaFs0XSA/IHBhcnNlRmxvYXQobWF0Y2hbNF0pIDogMVxuICAgIF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIEhTTEEgZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tSHNsYSA9IENvbG9yLmZyb21Ic2w7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIEhFWCBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogRkY1NTU1XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tSGV4ID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gQ29sb3IuZnJvbVNvdXJjZShDb2xvci5zb3VyY2VGcm9tSGV4KGNvbG9yKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMTAwLCAxMDAsIDIwMCwgMV0pIG9mIGEgY29sb3IgdGhhdCdzIGluIEhFWCBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBleDogRkY1NTU1IG9yIEZGNTU0NENDIChSR0JhKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gc291cmNlXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbUhleCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yLm1hdGNoKENvbG9yLnJlSGV4KSkge1xuICAgICAgdmFyIHZhbHVlID0gY29sb3Iuc2xpY2UoY29sb3IuaW5kZXhPZignIycpICsgMSksXG4gICAgICAgICAgaXNTaG9ydE5vdGF0aW9uID0gKHZhbHVlLmxlbmd0aCA9PT0gMyB8fCB2YWx1ZS5sZW5ndGggPT09IDQpLFxuICAgICAgICAgIGlzUkdCYSA9ICh2YWx1ZS5sZW5ndGggPT09IDggfHwgdmFsdWUubGVuZ3RoID09PSA0KSxcbiAgICAgICAgICByID0gaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgwKSArIHZhbHVlLmNoYXJBdCgwKSkgOiB2YWx1ZS5zdWJzdHJpbmcoMCwgMiksXG4gICAgICAgICAgZyA9IGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMSkgKyB2YWx1ZS5jaGFyQXQoMSkpIDogdmFsdWUuc3Vic3RyaW5nKDIsIDQpLFxuICAgICAgICAgIGIgPSBpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDIpICsgdmFsdWUuY2hhckF0KDIpKSA6IHZhbHVlLnN1YnN0cmluZyg0LCA2KSxcbiAgICAgICAgICBhID0gaXNSR0JhID8gKGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMykgKyB2YWx1ZS5jaGFyQXQoMykpIDogdmFsdWUuc3Vic3RyaW5nKDYsIDgpKSA6ICdGRic7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHBhcnNlSW50KHIsIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoZywgMTYpLFxuICAgICAgICBwYXJzZUludChiLCAxNiksXG4gICAgICAgIHBhcnNlRmxvYXQoKHBhcnNlSW50KGEsIDE2KSAvIDI1NSkudG9GaXhlZCgyKSlcbiAgICAgIF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gY29sb3IgaW4gYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMjAwLCAxMDAsIDEwMCwgMC41XSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHZhciBvQ29sb3IgPSBuZXcgQ29sb3IoKTtcbiAgICBvQ29sb3Iuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgcmV0dXJuIG9Db2xvcjtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIGZ1bmN0aW9uIGdldENvbG9yU3RvcChlbCkge1xuICAgIHZhciBzdHlsZSA9IGVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSxcbiAgICAgICAgb2Zmc2V0ID0gZWwuZ2V0QXR0cmlidXRlKCdvZmZzZXQnKSB8fCAwLFxuICAgICAgICBjb2xvciwgY29sb3JBbHBoYSwgb3BhY2l0eSwgaTtcblxuICAgIC8vIGNvbnZlcnQgcGVyY2VudHMgdG8gYWJzb2x1dGUgdmFsdWVzXG4gICAgb2Zmc2V0ID0gcGFyc2VGbG9hdChvZmZzZXQpIC8gKC8lJC8udGVzdChvZmZzZXQpID8gMTAwIDogMSk7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IDwgMCA/IDAgOiBvZmZzZXQgPiAxID8gMSA6IG9mZnNldDtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHZhciBrZXlWYWx1ZVBhaXJzID0gc3R5bGUuc3BsaXQoL1xccyo7XFxzKi8pO1xuXG4gICAgICBpZiAoa2V5VmFsdWVQYWlyc1trZXlWYWx1ZVBhaXJzLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgICBrZXlWYWx1ZVBhaXJzLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBrZXlWYWx1ZVBhaXJzLmxlbmd0aDsgaS0tOyApIHtcblxuICAgICAgICB2YXIgc3BsaXQgPSBrZXlWYWx1ZVBhaXJzW2ldLnNwbGl0KC9cXHMqOlxccyovKSxcbiAgICAgICAgICAgIGtleSA9IHNwbGl0WzBdLnRyaW0oKSxcbiAgICAgICAgICAgIHZhbHVlID0gc3BsaXRbMV0udHJpbSgpO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdzdG9wLWNvbG9yJykge1xuICAgICAgICAgIGNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3RvcC1vcGFjaXR5Jykge1xuICAgICAgICAgIG9wYWNpdHkgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY29sb3IpIHtcbiAgICAgIGNvbG9yID0gZWwuZ2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJykgfHwgJ3JnYigwLDAsMCknO1xuICAgIH1cbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIG9wYWNpdHkgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0b3Atb3BhY2l0eScpO1xuICAgIH1cblxuICAgIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvcik7XG4gICAgY29sb3JBbHBoYSA9IGNvbG9yLmdldEFscGhhKCk7XG4gICAgb3BhY2l0eSA9IGlzTmFOKHBhcnNlRmxvYXQob3BhY2l0eSkpID8gMSA6IHBhcnNlRmxvYXQob3BhY2l0eSk7XG4gICAgb3BhY2l0eSAqPSBjb2xvckFscGhhO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgY29sb3I6IGNvbG9yLnRvUmdiKCksXG4gICAgICBvcGFjaXR5OiBvcGFjaXR5XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpbmVhckNvb3JkcyhlbCkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogZWwuZ2V0QXR0cmlidXRlKCd4MScpIHx8IDAsXG4gICAgICB5MTogZWwuZ2V0QXR0cmlidXRlKCd5MScpIHx8IDAsXG4gICAgICB4MjogZWwuZ2V0QXR0cmlidXRlKCd4MicpIHx8ICcxMDAlJyxcbiAgICAgIHkyOiBlbC5nZXRBdHRyaWJ1dGUoJ3kyJykgfHwgMFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSYWRpYWxDb29yZHMoZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IGVsLmdldEF0dHJpYnV0ZSgnZngnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2N4JykgfHwgJzUwJScsXG4gICAgICB5MTogZWwuZ2V0QXR0cmlidXRlKCdmeScpIHx8IGVsLmdldEF0dHJpYnV0ZSgnY3knKSB8fCAnNTAlJyxcbiAgICAgIHIxOiAwLFxuICAgICAgeDI6IGVsLmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAnNTAlJyxcbiAgICAgIHkyOiBlbC5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgJzUwJScsXG4gICAgICByMjogZWwuZ2V0QXR0cmlidXRlKCdyJykgfHwgJzUwJSdcbiAgICB9O1xuICB9XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgdmFyIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIC8qKlxuICAgKiBHcmFkaWVudCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkdyYWRpZW50XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2dyYWRpZW50c31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkdyYWRpZW50I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuR3JhZGllbnQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5HcmFkaWVudC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBvZmZzZXQgZm9yIGFsaWduaW5nIGdyYWRpZW50cyBjb21pbmcgZnJvbSBTVkcgd2hlbiBvdXRzaWRlIHBhdGhncm91cHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIG9mZnNldCBmb3IgYWxpZ25pbmcgZ3JhZGllbnRzIGNvbWluZyBmcm9tIFNWRyB3aGVuIG91dHNpZGUgcGF0aGdyb3Vwc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IHdpdGggdHlwZSwgY29vcmRzLCBncmFkaWVudFVuaXRzIGFuZCBjb2xvclN0b3BzXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyYWRpZW50fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBjb29yZHMgPSB7IH07XG5cbiAgICAgIHRoaXMuaWQgPSBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUgfHwgJ2xpbmVhcic7XG5cbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDE6IG9wdGlvbnMuY29vcmRzLngxIHx8IDAsXG4gICAgICAgIHkxOiBvcHRpb25zLmNvb3Jkcy55MSB8fCAwLFxuICAgICAgICB4Mjogb3B0aW9ucy5jb29yZHMueDIgfHwgMCxcbiAgICAgICAgeTI6IG9wdGlvbnMuY29vcmRzLnkyIHx8IDBcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIGNvb3Jkcy5yMSA9IG9wdGlvbnMuY29vcmRzLnIxIHx8IDA7XG4gICAgICAgIGNvb3Jkcy5yMiA9IG9wdGlvbnMuY29vcmRzLnIyIHx8IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmNvb3JkcyA9IGNvb3JkcztcbiAgICAgIHRoaXMuY29sb3JTdG9wcyA9IG9wdGlvbnMuY29sb3JTdG9wcy5zbGljZSgpO1xuICAgICAgaWYgKG9wdGlvbnMuZ3JhZGllbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5ncmFkaWVudFRyYW5zZm9ybSA9IG9wdGlvbnMuZ3JhZGllbnRUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgICB0aGlzLm9mZnNldFggPSBvcHRpb25zLm9mZnNldFggfHwgdGhpcy5vZmZzZXRYO1xuICAgICAgdGhpcy5vZmZzZXRZID0gb3B0aW9ucy5vZmZzZXRZIHx8IHRoaXMub2Zmc2V0WTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbm90aGVyIGNvbG9yU3RvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvclN0b3AgT2JqZWN0IHdpdGggb2Zmc2V0IGFuZCBjb2xvclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGFkZENvbG9yU3RvcDogZnVuY3Rpb24oY29sb3JTdG9wcykge1xuICAgICAgZm9yICh2YXIgcG9zaXRpb24gaW4gY29sb3JTdG9wcykge1xuICAgICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGNvbG9yU3RvcHNbcG9zaXRpb25dKTtcbiAgICAgICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgICAgIG9mZnNldDogcGFyc2VGbG9hdChwb3NpdGlvbiksXG4gICAgICAgICAgY29sb3I6IGNvbG9yLnRvUmdiKCksXG4gICAgICAgICAgb3BhY2l0eTogY29sb3IuZ2V0QWxwaGEoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIGdyYWRpZW50XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9iamVjdCA9IHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBjb29yZHM6IHRoaXMuY29vcmRzLFxuICAgICAgICBjb2xvclN0b3BzOiB0aGlzLmNvbG9yU3RvcHMsXG4gICAgICAgIG9mZnNldFg6IHRoaXMub2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WTogdGhpcy5vZmZzZXRZLFxuICAgICAgICBncmFkaWVudFRyYW5zZm9ybTogdGhpcy5ncmFkaWVudFRyYW5zZm9ybSA/IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0uY29uY2F0KCkgOiB0aGlzLmdyYWRpZW50VHJhbnNmb3JtXG4gICAgICB9O1xuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBvYmplY3QsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGdyYWRpZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JhZGllbnQgZm9yXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYW4gZ3JhZGllbnQgKGxpbmVhci9yYWRpYWwpXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGNvb3JkcyA9IGNsb25lKHRoaXMuY29vcmRzLCB0cnVlKSwgaSwgbGVuLFxuICAgICAgICAgIG1hcmt1cCwgY29tbW9uQXR0cmlidXRlcywgY29sb3JTdG9wcyA9IGNsb25lKHRoaXMuY29sb3JTdG9wcywgdHJ1ZSksXG4gICAgICAgICAgbmVlZHNTd2FwID0gY29vcmRzLnIxID4gY29vcmRzLnIyLFxuICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPyB0aGlzLmdyYWRpZW50VHJhbnNmb3JtLmNvbmNhdCgpIDogZmFicmljLmlNYXRyaXguY29uY2F0KCksXG4gICAgICAgICAgb2Zmc2V0WCA9IG9iamVjdC53aWR0aCAvIDIgLSB0aGlzLm9mZnNldFgsIG9mZnNldFkgPSBvYmplY3QuaGVpZ2h0IC8gMiAtIHRoaXMub2Zmc2V0WTtcbiAgICAgIC8vIGNvbG9yU3RvcHMgbXVzdCBiZSBzb3J0ZWQgYXNjZW5kaW5nXG4gICAgICBjb2xvclN0b3BzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYS5vZmZzZXQgLSBiLm9mZnNldDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob2JqZWN0LnR5cGUgPT09ICdwYXRoJykge1xuICAgICAgICBvZmZzZXRYIC09IG9iamVjdC5wYXRoT2Zmc2V0Lng7XG4gICAgICAgIG9mZnNldFkgLT0gb2JqZWN0LnBhdGhPZmZzZXQueTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNmb3JtWzRdIC09IG9mZnNldFg7XG4gICAgICB0cmFuc2Zvcm1bNV0gLT0gb2Zmc2V0WTtcblxuICAgICAgY29tbW9uQXR0cmlidXRlcyA9ICdpZD1cIlNWR0lEXycgKyB0aGlzLmlkICtcbiAgICAgICAgICAgICAgICAgICAgICdcIiBncmFkaWVudFVuaXRzPVwidXNlclNwYWNlT25Vc2VcIic7XG4gICAgICBjb21tb25BdHRyaWJ1dGVzICs9ICcgZ3JhZGllbnRUcmFuc2Zvcm09XCJtYXRyaXgoJyArIHRyYW5zZm9ybS5qb2luKCcgJykgKyAnKVwiICc7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgICAnPGxpbmVhckdyYWRpZW50ICcsXG4gICAgICAgICAgY29tbW9uQXR0cmlidXRlcyxcbiAgICAgICAgICAnIHgxPVwiJywgY29vcmRzLngxLFxuICAgICAgICAgICdcIiB5MT1cIicsIGNvb3Jkcy55MSxcbiAgICAgICAgICAnXCIgeDI9XCInLCBjb29yZHMueDIsXG4gICAgICAgICAgJ1wiIHkyPVwiJywgY29vcmRzLnkyLFxuICAgICAgICAgICdcIj5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIC8vIHN2ZyByYWRpYWwgZ3JhZGllbnQgaGFzIGp1c3QgMSByYWRpdXMuIHRoZSBiaWdnZXN0LlxuICAgICAgICBtYXJrdXAgPSBbXG4gICAgICAgICAgJzxyYWRpYWxHcmFkaWVudCAnLFxuICAgICAgICAgIGNvbW1vbkF0dHJpYnV0ZXMsXG4gICAgICAgICAgJyBjeD1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy54MSA6IGNvb3Jkcy54MixcbiAgICAgICAgICAnXCIgY3k9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueTEgOiBjb29yZHMueTIsXG4gICAgICAgICAgJ1wiIHI9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMucjEgOiBjb29yZHMucjIsXG4gICAgICAgICAgJ1wiIGZ4PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLngyIDogY29vcmRzLngxLFxuICAgICAgICAgICdcIiBmeT1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy55MiA6IGNvb3Jkcy55MSxcbiAgICAgICAgICAnXCI+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBpZiAobmVlZHNTd2FwKSB7XG4gICAgICAgICAgLy8gc3ZnIGdvZXMgZnJvbSBpbnRlcm5hbCB0byBleHRlcm5hbCByYWRpdXMuIGlmIHJhZGl1cyBhcmUgaW52ZXJ0ZWQsIHN3YXAgY29sb3Igc3RvcHMuXG4gICAgICAgICAgY29sb3JTdG9wcyA9IGNvbG9yU3RvcHMuY29uY2F0KCk7XG4gICAgICAgICAgY29sb3JTdG9wcy5yZXZlcnNlKCk7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29sb3JTdG9wc1tpXS5vZmZzZXQgPSAxIC0gY29sb3JTdG9wc1tpXS5vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtaW5SYWRpdXMgPSBNYXRoLm1pbihjb29yZHMucjEsIGNvb3Jkcy5yMik7XG4gICAgICAgIGlmIChtaW5SYWRpdXMgPiAwKSB7XG4gICAgICAgICAgLy8gaSBoYXZlIHRvIHNoaWZ0IGFsbCBjb2xvclN0b3BzIGFuZCBhZGQgbmV3IG9uZSBpbiAwLlxuICAgICAgICAgIHZhciBtYXhSYWRpdXMgPSBNYXRoLm1heChjb29yZHMucjEsIGNvb3Jkcy5yMiksXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2VTaGlmdCA9IG1pblJhZGl1cyAvIG1heFJhZGl1cztcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb2xvclN0b3BzW2ldLm9mZnNldCArPSBwZXJjZW50YWdlU2hpZnQgKiAoMSAtIGNvbG9yU3RvcHNbaV0ub2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY29sb3JTdG9wID0gY29sb3JTdG9wc1tpXTtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxzdG9wICcsXG4gICAgICAgICAgJ29mZnNldD1cIicsIChjb2xvclN0b3Aub2Zmc2V0ICogMTAwKSArICclJyxcbiAgICAgICAgICAnXCIgc3R5bGU9XCJzdG9wLWNvbG9yOicsIGNvbG9yU3RvcC5jb2xvcixcbiAgICAgICAgICAodHlwZW9mIGNvbG9yU3RvcC5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyA/ICc7c3RvcC1vcGFjaXR5OiAnICsgY29sb3JTdG9wLm9wYWNpdHkgOiAnOycpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBtYXJrdXAucHVzaCgodGhpcy50eXBlID09PSAnbGluZWFyJyA/ICc8L2xpbmVhckdyYWRpZW50PlxcbicgOiAnPC9yYWRpYWxHcmFkaWVudD5cXG4nKSk7XG5cbiAgICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgQ2FudmFzR3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHJldHVybiB7Q2FudmFzR3JhZGllbnR9XG4gICAgICovXG4gICAgdG9MaXZlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBncmFkaWVudCwgY29vcmRzID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKHRoaXMuY29vcmRzKSwgaSwgbGVuO1xuXG4gICAgICBpZiAoIXRoaXMudHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxuICAgICAgICAgIGNvb3Jkcy54MSwgY29vcmRzLnkxLCBjb29yZHMueDIsIGNvb3Jkcy55Mik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgICAgIGNvb3Jkcy54MSwgY29vcmRzLnkxLCBjb29yZHMucjEsIGNvb3Jkcy54MiwgY29vcmRzLnkyLCBjb29yZHMucjIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLmNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5jb2xvclN0b3BzW2ldLmNvbG9yLFxuICAgICAgICAgICAgb3BhY2l0eSA9IHRoaXMuY29sb3JTdG9wc1tpXS5vcGFjaXR5LFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5jb2xvclN0b3BzW2ldLm9mZnNldDtcblxuICAgICAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGNvbG9yKS5zZXRBbHBoYShvcGFjaXR5KS50b1JnYmEoKTtcbiAgICAgICAgfVxuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aob2Zmc2V0LCBjb2xvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG4gIH0pO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkdyYWRpZW50LCB7XG5cbiAgICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkdyYWRpZW50fSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuR3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge1NWR0dyYWRpZW50RWxlbWVudH0gZWwgU1ZHIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGluc3RhbmNlXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyYWRpZW50fSBHcmFkaWVudCBpbnN0YW5jZVxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BzZXJ2ZXJzLmh0bWwjTGluZWFyR3JhZGllbnRFbGVtZW50XG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcHNlcnZlcnMuaHRtbCNSYWRpYWxHcmFkaWVudEVsZW1lbnRcbiAgICAgKi9cbiAgICBmcm9tRWxlbWVudDogZnVuY3Rpb24oZWwsIGluc3RhbmNlKSB7XG4gICAgICAvKipcbiAgICAgICAqICBAZXhhbXBsZTpcbiAgICAgICAqXG4gICAgICAgKiAgPGxpbmVhckdyYWRpZW50IGlkPVwibGluZWFyR3JhZDFcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjAlXCIgc3RvcC1jb2xvcj1cIndoaXRlXCIvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMTAwJVwiIHN0b3AtY29sb3I9XCJibGFja1wiLz5cbiAgICAgICAqICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8bGluZWFyR3JhZGllbnQgaWQ9XCJsaW5lYXJHcmFkMlwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0eWxlPVwic3RvcC1jb2xvcjpyZ2IoMjU1LDI1NSwyNTUpXCIvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMVwiIHN0eWxlPVwic3RvcC1jb2xvcjpyZ2IoMCwwLDApXCIvPlxuICAgICAgICogIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICogIE9SXG4gICAgICAgKlxuICAgICAgICogIDxyYWRpYWxHcmFkaWVudCBpZD1cInJhZGlhbEdyYWQxXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3AtY29sb3I9XCJ3aGl0ZVwiIHN0b3Atb3BhY2l0eT1cIjFcIiAvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiNTAlXCIgc3RvcC1jb2xvcj1cImJsYWNrXCIgc3RvcC1vcGFjaXR5PVwiMC41XCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjEwMCVcIiBzdG9wLWNvbG9yPVwid2hpdGVcIiBzdG9wLW9wYWNpdHk9XCIxXCIgLz5cbiAgICAgICAqICA8L3JhZGlhbEdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8cmFkaWFsR3JhZGllbnQgaWQ9XCJyYWRpYWxHcmFkMlwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0b3AtY29sb3I9XCJyZ2IoMjU1LDI1NSwyNTUpXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjAuNVwiIHN0b3AtY29sb3I9XCJyZ2IoMCwwLDApXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdG9wLWNvbG9yPVwicmdiKDI1NSwyNTUsMjU1KVwiIC8+XG4gICAgICAgKiAgPC9yYWRpYWxHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgdmFyIGNvbG9yU3RvcEVscyA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdG9wJyksXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBncmFkaWVudFVuaXRzID0gZWwuZ2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJykgfHwgJ29iamVjdEJvdW5kaW5nQm94JyxcbiAgICAgICAgICBncmFkaWVudFRyYW5zZm9ybSA9IGVsLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKSxcbiAgICAgICAgICBjb2xvclN0b3BzID0gW10sXG4gICAgICAgICAgY29vcmRzLCBlbGxpcHNlTWF0cml4LCBpO1xuXG4gICAgICBpZiAoZWwubm9kZU5hbWUgPT09ICdsaW5lYXJHcmFkaWVudCcgfHwgZWwubm9kZU5hbWUgPT09ICdMSU5FQVJHUkFESUVOVCcpIHtcbiAgICAgICAgdHlwZSA9ICdsaW5lYXInO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHR5cGUgPSAncmFkaWFsJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIGNvb3JkcyA9IGdldExpbmVhckNvb3JkcyhlbCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBjb29yZHMgPSBnZXRSYWRpYWxDb29yZHMoZWwpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBjb2xvclN0b3BFbHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICBjb2xvclN0b3BzLnB1c2goZ2V0Q29sb3JTdG9wKGNvbG9yU3RvcEVsc1tpXSkpO1xuICAgICAgfVxuXG4gICAgICBlbGxpcHNlTWF0cml4ID0gX2NvbnZlcnRQZXJjZW50VW5pdHNUb1ZhbHVlcyhpbnN0YW5jZSwgY29vcmRzLCBncmFkaWVudFVuaXRzKTtcblxuICAgICAgdmFyIGdyYWRpZW50ID0gbmV3IGZhYnJpYy5HcmFkaWVudCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICBjb2xvclN0b3BzOiBjb2xvclN0b3BzLFxuICAgICAgICBvZmZzZXRYOiAtaW5zdGFuY2UubGVmdCxcbiAgICAgICAgb2Zmc2V0WTogLWluc3RhbmNlLnRvcFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChncmFkaWVudFRyYW5zZm9ybSB8fCBlbGxpcHNlTWF0cml4ICE9PSAnJykge1xuICAgICAgICBncmFkaWVudC5ncmFkaWVudFRyYW5zZm9ybSA9IGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSgoZ3JhZGllbnRUcmFuc2Zvcm0gfHwgJycpICsgZWxsaXBzZU1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9LFxuICAgIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuR3JhZGllbnR9IGluc3RhbmNlIGZyb20gaXRzIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkdyYWRpZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBmb3JPYmplY3Q6IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICBfY29udmVydFBlcmNlbnRVbml0c1RvVmFsdWVzKG9iaiwgb3B0aW9ucy5jb29yZHMsICd1c2VyU3BhY2VPblVzZScpO1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuR3JhZGllbnQob3B0aW9ucyk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMob2JqZWN0LCBvcHRpb25zLCBncmFkaWVudFVuaXRzKSB7XG4gICAgdmFyIHByb3BWYWx1ZSwgYWRkRmFjdG9yID0gMCwgbXVsdEZhY3RvciA9IDEsIGVsbGlwc2VNYXRyaXggPSAnJztcbiAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zW3Byb3BdID09PSAnSW5maW5pdHknKSB7XG4gICAgICAgIG9wdGlvbnNbcHJvcF0gPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3B0aW9uc1twcm9wXSA9PT0gJy1JbmZpbml0eScpIHtcbiAgICAgICAgb3B0aW9uc1twcm9wXSA9IDA7XG4gICAgICB9XG4gICAgICBwcm9wVmFsdWUgPSBwYXJzZUZsb2F0KG9wdGlvbnNbcHJvcF0sIDEwKTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1twcm9wXSA9PT0gJ3N0cmluZycgJiYgL14oXFxkK1xcLlxcZCspJXwoXFxkKyklJC8udGVzdChvcHRpb25zW3Byb3BdKSkge1xuICAgICAgICBtdWx0RmFjdG9yID0gMC4wMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtdWx0RmFjdG9yID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wID09PSAneDEnIHx8IHByb3AgPT09ICd4MicgfHwgcHJvcCA9PT0gJ3IyJykge1xuICAgICAgICBtdWx0RmFjdG9yICo9IGdyYWRpZW50VW5pdHMgPT09ICdvYmplY3RCb3VuZGluZ0JveCcgPyBvYmplY3Qud2lkdGggOiAxO1xuICAgICAgICBhZGRGYWN0b3IgPSBncmFkaWVudFVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnID8gb2JqZWN0LmxlZnQgfHwgMCA6IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcm9wID09PSAneTEnIHx8IHByb3AgPT09ICd5MicpIHtcbiAgICAgICAgbXVsdEZhY3RvciAqPSBncmFkaWVudFVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnID8gb2JqZWN0LmhlaWdodCA6IDE7XG4gICAgICAgIGFkZEZhY3RvciA9IGdyYWRpZW50VW5pdHMgPT09ICdvYmplY3RCb3VuZGluZ0JveCcgPyBvYmplY3QudG9wIHx8IDAgOiAwO1xuICAgICAgfVxuICAgICAgb3B0aW9uc1twcm9wXSA9IHByb3BWYWx1ZSAqIG11bHRGYWN0b3IgKyBhZGRGYWN0b3I7XG4gICAgfVxuICAgIGlmIChvYmplY3QudHlwZSA9PT0gJ2VsbGlwc2UnICYmXG4gICAgICAgIG9wdGlvbnMucjIgIT09IG51bGwgJiZcbiAgICAgICAgZ3JhZGllbnRVbml0cyA9PT0gJ29iamVjdEJvdW5kaW5nQm94JyAmJlxuICAgICAgICBvYmplY3QucnggIT09IG9iamVjdC5yeSkge1xuXG4gICAgICB2YXIgc2NhbGVGYWN0b3IgPSBvYmplY3QucnkgLyBvYmplY3Qucng7XG4gICAgICBlbGxpcHNlTWF0cml4ID0gJyBzY2FsZSgxLCAnICsgc2NhbGVGYWN0b3IgKyAnKSc7XG4gICAgICBpZiAob3B0aW9ucy55MSkge1xuICAgICAgICBvcHRpb25zLnkxIC89IHNjYWxlRmFjdG9yO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMueTIpIHtcbiAgICAgICAgb3B0aW9ucy55MiAvPSBzY2FsZUZhY3RvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsbGlwc2VNYXRyaXg7XG4gIH1cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgLyoqXG4gICAqIFBhdHRlcm4gY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QYXR0ZXJuXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vcGF0dGVybnN8UGF0dGVybiBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2R5bmFtaWMtcGF0dGVybnN8RHluYW1pY1BhdHRlcm4gZGVtb31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBhdHRlcm4jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG5cblxuICBmYWJyaWMuUGF0dGVybiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLlBhdHRlcm4ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJlcGVhdCBwcm9wZXJ0eSBvZiBhIHBhdHRlcm4gKG9uZSBvZiByZXBlYXQsIHJlcGVhdC14LCByZXBlYXQteSBvciBuby1yZXBlYXQpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZXBlYXQ6ICdyZXBlYXQnLFxuXG4gICAgLyoqXG4gICAgICogUGF0dGVybiBob3Jpem9udGFsIG9mZnNldCBmcm9tIG9iamVjdCdzIGxlZnQvdG9wIGNvcm5lclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gdmVydGljYWwgb2Zmc2V0IGZyb20gb2JqZWN0J3MgbGVmdC90b3AgY29ybmVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogY3Jvc3NPcmlnaW4gdmFsdWUgKG9uZSBvZiBcIlwiLCBcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiKVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Jvc3NPcmlnaW46ICcnLFxuXG4gICAgLyoqXG4gICAgICogdHJhbnNmb3JtIG1hdHJpeCB0byBjaGFuZ2UgdGhlIHBhdHRlcm4sIGltcG9ydGVkIGZyb20gc3Zncy5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0dGVyblRyYW5zZm9ybTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIGNhbGxiYWNrIGluaXQuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBhdHRlcm59IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHRoaXMuaWQgPSBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdGlvbnMuc291cmNlIHx8IChvcHRpb25zLnNvdXJjZSAmJiB0eXBlb2Ygb3B0aW9ucy5zb3VyY2UgIT09ICdzdHJpbmcnKSkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZnVuY3Rpb24gc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGZhYnJpYy51dGlsLmdldEZ1bmN0aW9uQm9keShvcHRpb25zLnNvdXJjZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gbmV3IEZ1bmN0aW9uKGZhYnJpYy51dGlsLmdldEZ1bmN0aW9uQm9keShvcHRpb25zLnNvdXJjZSkpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBpbWcgc3JjIHN0cmluZ1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUltYWdlKCk7XG4gICAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShvcHRpb25zLnNvdXJjZSwgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgX3RoaXMuc291cmNlID0gaW1nO1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKF90aGlzKTtcbiAgICAgICAgfSwgbnVsbCwgdGhpcy5jcm9zc09yaWdpbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVyblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMsXG4gICAgICAgICAgc291cmNlLCBvYmplY3Q7XG5cbiAgICAgIC8vIGNhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNvdXJjZSA9IFN0cmluZyh0aGlzLnNvdXJjZSk7XG4gICAgICB9XG4gICAgICAvLyA8aW1nPiBlbGVtZW50XG4gICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5zb3VyY2Uuc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICBzb3VyY2UgPSB0aGlzLnNvdXJjZS5zcmM7XG4gICAgICB9XG4gICAgICAvLyA8Y2FudmFzPiBlbGVtZW50XG4gICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgPT09ICdvYmplY3QnICYmIHRoaXMuc291cmNlLnRvRGF0YVVSTCkge1xuICAgICAgICBzb3VyY2UgPSB0aGlzLnNvdXJjZS50b0RhdGFVUkwoKTtcbiAgICAgIH1cblxuICAgICAgb2JqZWN0ID0ge1xuICAgICAgICB0eXBlOiAncGF0dGVybicsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICByZXBlYXQ6IHRoaXMucmVwZWF0LFxuICAgICAgICBjcm9zc09yaWdpbjogdGhpcy5jcm9zc09yaWdpbixcbiAgICAgICAgb2Zmc2V0WDogdG9GaXhlZCh0aGlzLm9mZnNldFgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICBvZmZzZXRZOiB0b0ZpeGVkKHRoaXMub2Zmc2V0WSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgIHBhdHRlcm5UcmFuc2Zvcm06IHRoaXMucGF0dGVyblRyYW5zZm9ybSA/IHRoaXMucGF0dGVyblRyYW5zZm9ybS5jb25jYXQoKSA6IG51bGxcbiAgICAgIH07XG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIG9iamVjdCwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm5cbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcGF0dGVyblNvdXJjZSA9IHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuc291cmNlKCkgOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICBwYXR0ZXJuV2lkdGggPSBwYXR0ZXJuU291cmNlLndpZHRoIC8gb2JqZWN0LndpZHRoLFxuICAgICAgICAgIHBhdHRlcm5IZWlnaHQgPSBwYXR0ZXJuU291cmNlLmhlaWdodCAvIG9iamVjdC5oZWlnaHQsXG4gICAgICAgICAgcGF0dGVybk9mZnNldFggPSB0aGlzLm9mZnNldFggLyBvYmplY3Qud2lkdGgsXG4gICAgICAgICAgcGF0dGVybk9mZnNldFkgPSB0aGlzLm9mZnNldFkgLyBvYmplY3QuaGVpZ2h0LFxuICAgICAgICAgIHBhdHRlcm5JbWdTcmMgPSAnJztcbiAgICAgIGlmICh0aGlzLnJlcGVhdCA9PT0gJ3JlcGVhdC14JyB8fCB0aGlzLnJlcGVhdCA9PT0gJ25vLXJlcGVhdCcpIHtcbiAgICAgICAgcGF0dGVybkhlaWdodCA9IDE7XG4gICAgICAgIGlmIChwYXR0ZXJuT2Zmc2V0WSkge1xuICAgICAgICAgIHBhdHRlcm5IZWlnaHQgKz0gTWF0aC5hYnMocGF0dGVybk9mZnNldFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZXBlYXQgPT09ICdyZXBlYXQteScgfHwgdGhpcy5yZXBlYXQgPT09ICduby1yZXBlYXQnKSB7XG4gICAgICAgIHBhdHRlcm5XaWR0aCA9IDE7XG4gICAgICAgIGlmIChwYXR0ZXJuT2Zmc2V0WCkge1xuICAgICAgICAgIHBhdHRlcm5XaWR0aCArPSBNYXRoLmFicyhwYXR0ZXJuT2Zmc2V0WCk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgaWYgKHBhdHRlcm5Tb3VyY2Uuc3JjKSB7XG4gICAgICAgIHBhdHRlcm5JbWdTcmMgPSBwYXR0ZXJuU291cmNlLnNyYztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHBhdHRlcm5Tb3VyY2UudG9EYXRhVVJMKSB7XG4gICAgICAgIHBhdHRlcm5JbWdTcmMgPSBwYXR0ZXJuU291cmNlLnRvRGF0YVVSTCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxwYXR0ZXJuIGlkPVwiU1ZHSURfJyArIHRoaXMuaWQgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgeD1cIicgKyBwYXR0ZXJuT2Zmc2V0WCArXG4gICAgICAgICAgICAgICAgICAgICdcIiB5PVwiJyArIHBhdHRlcm5PZmZzZXRZICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIHdpZHRoPVwiJyArIHBhdHRlcm5XaWR0aCArXG4gICAgICAgICAgICAgICAgICAgICdcIiBoZWlnaHQ9XCInICsgcGF0dGVybkhlaWdodCArICdcIj5cXG4nICtcbiAgICAgICAgICAgICAgICc8aW1hZ2UgeD1cIjBcIiB5PVwiMFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgJyB3aWR0aD1cIicgKyBwYXR0ZXJuU291cmNlLndpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyArIHBhdHRlcm5Tb3VyY2UuaGVpZ2h0ICtcbiAgICAgICAgICAgICAgICAgICAgICAnXCIgeGxpbms6aHJlZj1cIicgKyBwYXR0ZXJuSW1nU3JjICtcbiAgICAgICAgICAgICAgICdcIj48L2ltYWdlPlxcbicgK1xuICAgICAgICAgICAgICc8L3BhdHRlcm4+XFxuJztcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIENhbnZhc1BhdHRlcm5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gY3JlYXRlIHBhdHRlcm5cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNQYXR0ZXJufVxuICAgICAqL1xuICAgIHRvTGl2ZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgc291cmNlID0gdHlwZW9mIHRoaXMuc291cmNlID09PSAnZnVuY3Rpb24nID8gdGhpcy5zb3VyY2UoKSA6IHRoaXMuc291cmNlO1xuXG4gICAgICAvLyBpZiB0aGUgaW1hZ2UgZmFpbGVkIHRvIGxvYWQsIHJldHVybiwgYW5kIGFsbG93IHJlc3QgdG8gY29udGludWUgbG9hZGluZ1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbiBpbWFnZVxuICAgICAgaWYgKHR5cGVvZiBzb3VyY2Uuc3JjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIXNvdXJjZS5jb21wbGV0ZSkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlLm5hdHVyYWxXaWR0aCA9PT0gMCB8fCBzb3VyY2UubmF0dXJhbEhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHNvdXJjZSwgdGhpcy5yZXBlYXQpO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgaWYgKGZhYnJpYy5TaGFkb3cpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlNoYWRvdyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoYWRvdyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlNoYWRvd1xuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL3NoYWRvd3N8U2hhZG93IGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5TaGFkb3cjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5TaGFkb3cgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5TaGFkb3cucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBjb2xvclxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29sb3I6ICdyZ2IoMCwwLDApJyxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBibHVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgYmx1cjogMCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBob3Jpem9udGFsIG9mZnNldFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyB2ZXJ0aWNhbCBvZmZzZXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBzaGFkb3cgc2hvdWxkIGFmZmVjdCBzdHJva2Ugb3BlcmF0aW9uc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFmZmVjdFN0cm9rZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0b09iamVjdCBzaG91bGQgaW5jbHVkZSBkZWZhdWx0IHZhbHVlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB3aXRoIGFueSBvZiBjb2xvciwgYmx1ciwgb2Zmc2V0WCwgb2Zmc2V0WSBwcm9wZXJ0aWVzIG9yIHN0cmluZyAoZS5nLiBcInJnYmEoMCwwLDAsMC4yKSAycHggMnB4IDEwcHhcIilcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuU2hhZG93fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJzZVNoYWRvdyhvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFkb3cgU2hhZG93IHZhbHVlIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBTaGFkb3cgb2JqZWN0IHdpdGggY29sb3IsIG9mZnNldFgsIG9mZnNldFkgYW5kIGJsdXJcbiAgICAgKi9cbiAgICBfcGFyc2VTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgdmFyIHNoYWRvd1N0ciA9IHNoYWRvdy50cmltKCksXG4gICAgICAgICAgb2Zmc2V0c0FuZEJsdXIgPSBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIuZXhlYyhzaGFkb3dTdHIpIHx8IFtdLFxuICAgICAgICAgIGNvbG9yID0gc2hhZG93U3RyLnJlcGxhY2UoZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyLCAnJykgfHwgJ3JnYigwLDAsMCknO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xvcjogY29sb3IudHJpbSgpLFxuICAgICAgICBvZmZzZXRYOiBwYXJzZUludChvZmZzZXRzQW5kQmx1clsxXSwgMTApIHx8IDAsXG4gICAgICAgIG9mZnNldFk6IHBhcnNlSW50KG9mZnNldHNBbmRCbHVyWzJdLCAxMCkgfHwgMCxcbiAgICAgICAgYmx1cjogcGFyc2VJbnQob2Zmc2V0c0FuZEJsdXJbM10sIDEwKSB8fCAwXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MtdGV4dC1kZWNvci0zLyN0ZXh0LXNoYWRvd1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBDU1MzIHRleHQtc2hhZG93IGRlY2xhcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLm9mZnNldFgsIHRoaXMub2Zmc2V0WSwgdGhpcy5ibHVyLCB0aGlzLmNvbG9yXS5qb2luKCdweCAnKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgZkJveFggPSA0MCwgZkJveFkgPSA0MCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBvZmZzZXQgPSBmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IoXG4gICAgICAgICAgICB7IHg6IHRoaXMub2Zmc2V0WCwgeTogdGhpcy5vZmZzZXRZIH0sXG4gICAgICAgICAgICBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKC1vYmplY3QuYW5nbGUpKSxcbiAgICAgICAgICBCTFVSX0JPWCA9IDIwLCBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcik7XG5cbiAgICAgIGlmIChvYmplY3Qud2lkdGggJiYgb2JqZWN0LmhlaWdodCkge1xuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9maWx0ZXJzLmh0bWwjRmlsdGVyRWZmZWN0c1JlZ2lvblxuICAgICAgICAvLyB3ZSBhZGQgc29tZSBleHRyYSBzcGFjZSB0byBmaWx0ZXIgYm94IHRvIGNvbnRhaW4gdGhlIGJsdXIgKCAyMCApXG4gICAgICAgIGZCb3hYID0gdG9GaXhlZCgoTWF0aC5hYnMob2Zmc2V0LngpICsgdGhpcy5ibHVyKSAvIG9iamVjdC53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKiAxMDAgKyBCTFVSX0JPWDtcbiAgICAgICAgZkJveFkgPSB0b0ZpeGVkKChNYXRoLmFicyhvZmZzZXQueSkgKyB0aGlzLmJsdXIpIC8gb2JqZWN0LmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKiAxMDAgKyBCTFVSX0JPWDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZmxpcFgpIHtcbiAgICAgICAgb2Zmc2V0LnggKj0gLTE7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZsaXBZKSB7XG4gICAgICAgIG9mZnNldC55ICo9IC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAnPGZpbHRlciBpZD1cIlNWR0lEXycgKyB0aGlzLmlkICsgJ1wiIHk9XCItJyArIGZCb3hZICsgJyVcIiBoZWlnaHQ9XCInICsgKDEwMCArIDIgKiBmQm94WSkgKyAnJVwiICcgK1xuICAgICAgICAgICd4PVwiLScgKyBmQm94WCArICclXCIgd2lkdGg9XCInICsgKDEwMCArIDIgKiBmQm94WCkgKyAnJVwiICcgKyAnPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVHYXVzc2lhbkJsdXIgaW49XCJTb3VyY2VBbHBoYVwiIHN0ZERldmlhdGlvbj1cIicgK1xuICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmJsdXIgPyB0aGlzLmJsdXIgLyAyIDogMCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCI+PC9mZUdhdXNzaWFuQmx1cj5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlT2Zmc2V0IGR4PVwiJyArIHRvRml4ZWQob2Zmc2V0LngsIE5VTV9GUkFDVElPTl9ESUdJVFMpICtcbiAgICAgICAgICAnXCIgZHk9XCInICsgdG9GaXhlZChvZmZzZXQueSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgcmVzdWx0PVwib0JsdXJcIiA+PC9mZU9mZnNldD5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlRmxvb2QgZmxvb2QtY29sb3I9XCInICsgY29sb3IudG9SZ2IoKSArICdcIiBmbG9vZC1vcGFjaXR5PVwiJyArIGNvbG9yLmdldEFscGhhKCkgKyAnXCIvPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVDb21wb3NpdGUgaW4yPVwib0JsdXJcIiBvcGVyYXRvcj1cImluXCIgLz5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlTWVyZ2U+XFxuJyArXG4gICAgICAgICAgICAnXFx0XFx0PGZlTWVyZ2VOb2RlPjwvZmVNZXJnZU5vZGU+XFxuJyArXG4gICAgICAgICAgICAnXFx0XFx0PGZlTWVyZ2VOb2RlIGluPVwiU291cmNlR3JhcGhpY1wiPjwvZmVNZXJnZU5vZGU+XFxuJyArXG4gICAgICAgICAgJ1xcdDwvZmVNZXJnZT5cXG4nICtcbiAgICAgICAgJzwvZmlsdGVyPlxcbicpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhZG93IGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICBibHVyOiB0aGlzLmJsdXIsXG4gICAgICAgICAgb2Zmc2V0WDogdGhpcy5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WSxcbiAgICAgICAgICBhZmZlY3RTdHJva2U6IHRoaXMuYWZmZWN0U3Ryb2tlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0geyB9LCBwcm90byA9IGZhYnJpYy5TaGFkb3cucHJvdG90eXBlO1xuXG4gICAgICBbJ2NvbG9yJywgJ2JsdXInLCAnb2Zmc2V0WCcsICdvZmZzZXRZJywgJ2FmZmVjdFN0cm9rZSddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBpZiAodGhpc1twcm9wXSAhPT0gcHJvdG9bcHJvcF0pIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBzaGFkb3cgb2Zmc2V0WCwgb2Zmc2V0WSBhbmQgYmx1ciAoZXg6IFwiMnB4IDJweCAxMHB4IHJnYmEoMCwwLDAsMC4yKVwiLCBcInJnYigwLDI1NSwwKSAycHggMnB4XCIpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuU2hhZG93XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIgPSAvKD86XFxzfF4pKC0/XFxkKyg/OnB4KT8oPzpcXHM/fCQpKT8oLT9cXGQrKD86cHgpPyg/Olxccz98JCkpPyhcXGQrKD86cHgpPyk/KD86XFxzP3wkKSg/OiR8XFxzKS87XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoZmFicmljLlN0YXRpY0NhbnZhcykge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuU3RhdGljQ2FudmFzIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhbGlhc2VzIGZvciBmYXN0ZXIgcmVzb2x1dGlvblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGdldEVsZW1lbnRPZmZzZXQgPSBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0LFxuICAgICAgcmVtb3ZlRnJvbUFycmF5ID0gZmFicmljLnV0aWwucmVtb3ZlRnJvbUFycmF5LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICB0cmFuc2Zvcm1Qb2ludCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50LFxuICAgICAgaW52ZXJ0VHJhbnNmb3JtID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtLFxuICAgICAgZ2V0Tm9kZUNhbnZhcyA9IGZhYnJpYy51dGlsLmdldE5vZGVDYW52YXMsXG4gICAgICBjcmVhdGVDYW52YXNFbGVtZW50ID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCxcblxuICAgICAgQ0FOVkFTX0lOSVRfRVJST1IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBpbml0aWFsaXplIGBjYW52YXNgIGVsZW1lbnQnKTtcblxuICAvKipcbiAgICogU3RhdGljIGNhbnZhcyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlN0YXRpY0NhbnZhc1xuICAgKiBAbWl4ZXMgZmFicmljLkNvbGxlY3Rpb25cbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vc3RhdGljX2NhbnZhc3xTdGF0aWNDYW52YXMgZGVtb31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAZmlyZXMgYmVmb3JlOnJlbmRlclxuICAgKiBAZmlyZXMgYWZ0ZXI6cmVuZGVyXG4gICAqIEBmaXJlcyBjYW52YXM6Y2xlYXJlZFxuICAgKiBAZmlyZXMgb2JqZWN0OmFkZGVkXG4gICAqIEBmaXJlcyBvYmplY3Q6cmVtb3ZlZFxuICAgKi9cbiAgZmFicmljLlN0YXRpY0NhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Db21tb25NZXRob2RzLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCA9IHRoaXMucmVuZGVyQW5kUmVzZXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kID0gdGhpcy5yZXF1ZXN0UmVuZGVyQWxsLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9pbml0U3RhdGljKGVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0QmFja2dyb3VuZENvbG9yfS5cbiAgICAgKiBAdHlwZSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBpbWFnZSBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0QmFja2dyb3VuZEltYWdlfS5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGUgXCJiYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5XCJcbiAgICAgKiBhbmQgXCJiYWNrZ3JvdW5kSW1hZ2VTdHJldGNoXCIgcHJvcGVydGllcyBhcmUgZGVwcmVjYXRlZCBzaW5jZSAxLjMuOS5cbiAgICAgKiBVc2Uge0BsaW5rIGZhYnJpYy5JbWFnZSNvcGFjaXR5fSwge0BsaW5rIGZhYnJpYy5JbWFnZSN3aWR0aH0gYW5kIHtAbGluayBmYWJyaWMuSW1hZ2UjaGVpZ2h0fS5cbiAgICAgKiBzaW5jZSAyLjQuMCBpbWFnZSBjYWNoaW5nIGlzIGFjdGl2ZSwgcGxlYXNlIHdoZW4gcHV0dGluZyBhbiBpbWFnZSBhcyBiYWNrZ3JvdW5kLCBhZGQgdG8gdGhlXG4gICAgICogY2FudmFzIHByb3BlcnR5IGEgcmVmZXJlbmNlIHRvIHRoZSBjYW52YXMgaXQgaXMgb24uIE90aGVyd2lzZSB0aGUgaW1hZ2UgY2Fubm90IGRldGVjdCB0aGUgem9vbVxuICAgICAqIHZhbGUuIEFzIGFuIGFsdGVybmF0aXZlIHlvdSBjYW4gZGlzYWJsZSBpbWFnZSBvYmplY3RDYWNoaW5nXG4gICAgICogQHR5cGUgZmFicmljLkltYWdlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5IGNvbG9yIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRPdmVybGF5Q29sb3J9XG4gICAgICogQHNpbmNlIDEuMy45XG4gICAgICogQHR5cGUgeyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxheUNvbG9yOiAnJyxcblxuICAgIC8qKlxuICAgICAqIE92ZXJsYXkgaW1hZ2Ugb2YgY2FudmFzIGluc3RhbmNlLlxuICAgICAqIFNob3VsZCBiZSBzZXQgdmlhIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI3NldE92ZXJsYXlJbWFnZX0uXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhlIFwib3ZlcmxheUltYWdlTGVmdFwiXG4gICAgICogYW5kIFwib3ZlcmxheUltYWdlVG9wXCIgcHJvcGVydGllcyBhcmUgZGVwcmVjYXRlZCBzaW5jZSAxLjMuOS5cbiAgICAgKiBVc2Uge0BsaW5rIGZhYnJpYy5JbWFnZSNsZWZ0fSBhbmQge0BsaW5rIGZhYnJpYy5JbWFnZSN0b3B9LlxuICAgICAqIHNpbmNlIDIuNC4wIGltYWdlIGNhY2hpbmcgaXMgYWN0aXZlLCBwbGVhc2Ugd2hlbiBwdXR0aW5nIGFuIGltYWdlIGFzIG92ZXJsYXksIGFkZCB0byB0aGVcbiAgICAgKiBjYW52YXMgcHJvcGVydHkgYSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyBpdCBpcyBvbi4gT3RoZXJ3aXNlIHRoZSBpbWFnZSBjYW5ub3QgZGV0ZWN0IHRoZSB6b29tXG4gICAgICogdmFsZS4gQXMgYW4gYWx0ZXJuYXRpdmUgeW91IGNhbiBkaXNhYmxlIGltYWdlIG9iamVjdENhY2hpbmdcbiAgICAgKiBAdHlwZSBmYWJyaWMuSW1hZ2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlJbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRvT2JqZWN0L3RvRGF0YWxlc3NPYmplY3Qgc2hvdWxkIGluY2x1ZGUgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBpZiBzZXQgdG8gZmFsc2UsIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGUgb2JqZWN0IHZhbHVlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb2JqZWN0cycgc3RhdGUgc2hvdWxkIGJlIHNhdmVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3RhdGVmdWw6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIge0BsaW5rIGZhYnJpYy5Db2xsZWN0aW9uLmFkZH0sIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5pbnNlcnRBdH0gYW5kIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5yZW1vdmV9LFxuICAgICAqIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzLm1vdmVUb30sIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzLmNsZWFyfSBhbmQgbWFueSBtb3JlLCBzaG91bGQgYWxzbyByZS1yZW5kZXIgY2FudmFzLlxuICAgICAqIERpc2FibGluZyB0aGlzIG9wdGlvbiB3aWxsIG5vdCBnaXZlIGEgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBhZGRpbmcvcmVtb3ZpbmcgYSBsb3Qgb2Ygb2JqZWN0cyB0by9mcm9tIGNhbnZhcyBhdCBvbmNlXG4gICAgICogc2luY2UgdGhlIHJlbmRlcnMgYXJlIHF1ZXF1ZWQgYW5kIGV4ZWN1dGVkIG9uZSBwZXIgZnJhbWUuXG4gICAgICogRGlzYWJsaW5nIGlzIHN1Z2dlc3RlZCBhbnl3YXkgYW5kIG1hbmFnaW5nIHRoZSByZW5kZXJzIG9mIHRoZSBhcHAgbWFudWFsbHkgaXMgbm90IGEgYmlnIGVmZm9ydCAoIGNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCkgKVxuICAgICAqIExlZnQgZGVmYXVsdCB0byB0cnVlIHRvIGRvIG5vdCBicmVhayBkb2N1bWVudGF0aW9uIGFuZCBvbGQgYXBwLCBmaWRkbGVzLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJlbmRlck9uQWRkUmVtb3ZlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIGNsaXBwaW5nIG9mIGVudGlyZSBjYW52YXMgYXJlYVxuICAgICAqIEJlaW5nIHBhc3NlZCBjb250ZXh0IGFzIGZpcnN0IGFyZ3VtZW50LlxuICAgICAqIElmIHlvdSBhcmUgdXNpbmcgY29kZSBtaW5pZmljYXRpb24sIGN0eCBhcmd1bWVudCBjYW4gYmUgbWluaWZpZWQvbWFuZ2xpZWQgeW91IHNob3VsZCB1c2VcbiAgICAgKiBhcyBhIHdvcmthcm91bmQgYHZhciBjdHggPSBhcmd1bWVudHNbMF07YCBpbiB0aGUgZnVuY3Rpb247XG4gICAgICogU2VlIGNsaXBwaW5nIGNhbnZhcyBhcmVhIGluIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy93aWtpL0ZBUX1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjbGlwVG86IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3QgY29udHJvbHMgKGJvcmRlcnMvY29udHJvbHMpIGFyZSByZW5kZXJlZCBhYm92ZSBvdmVybGF5IGltYWdlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29udHJvbHNBYm92ZU92ZXJsYXk6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJyb3dzZXIgY2FuIGJlIHNjcm9sbGVkIHdoZW4gdXNpbmcgYSB0b3VjaHNjcmVlbiBhbmQgZHJhZ2dpbmcgb24gdGhlIGNhbnZhc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsbG93VG91Y2hTY3JvbGxpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjYW52YXMgd2lsbCB1c2UgaW1hZ2Ugc21vb3RoaW5nLCB0aGlzIGlzIG9uIGJ5IGRlZmF1bHQgaW4gYnJvd3NlcnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbWFnZVNtb290aGluZ0VuYWJsZWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNmb3JtYXRpb24gKGluIHRoZSBmb3JtYXQgb2YgQ2FudmFzIHRyYW5zZm9ybSkgd2hpY2ggZm9jdXNlcyB0aGUgdmlld3BvcnRcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlld3BvcnRUcmFuc2Zvcm06IGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpLFxuXG4gICAgLyoqXG4gICAgICogaWYgc2V0IHRvIGZhbHNlIGJhY2tncm91bmQgaW1hZ2UgaXMgbm90IGFmZmVjdGVkIGJ5IHZpZXdwb3J0IHRyYW5zZm9ybVxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRWcHQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXQgdG8gZmFsc2Ugb3Zlcmx5YSBpbWFnZSBpcyBub3QgYWZmZWN0ZWQgYnkgdmlld3BvcnQgdHJhbnNmb3JtXG4gICAgICogQHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxheVZwdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrOyBpbnZva2VkIHJpZ2h0IGJlZm9yZSBvYmplY3QgaXMgYWJvdXQgdG8gYmUgc2NhbGVkL3JvdGF0ZWRcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSAyLjMuMFxuICAgICAqIFVzZSBiZWZvcmU6dHJhbnNmb3JtIGV2ZW50XG4gICAgICovXG4gICAgb25CZWZvcmVTY2FsZVJvdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgLyogTk9PUCAqL1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGNhbnZhcyBpcyBzY2FsZWQgYnkgZGV2aWNlUGl4ZWxSYXRpbyBmb3IgYmV0dGVyIHJlbmRlcmluZyBvbiByZXRpbmEgc2NyZWVuc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVuYWJsZVJldGluYVNjYWxpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBjYW52YXMgZWxlbWVudCBleHRlbnNpb24gb3ZlciBkZXNpZ25cbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSB0bCx0cixibCxici5cbiAgICAgKiBpZiBjYW52YXMgaXMgbm90IHpvb21lZC9wYW5uZWQgdGhvc2UgcG9pbnRzIGFyZSB0aGUgZm91ciBjb3JuZXIgb2YgY2FudmFzXG4gICAgICogaWYgY2FudmFzIGlzIHZpZXdwb3J0VHJhbnNmb3JtZWQgeW91IHRob3NlIHBvaW50cyBpbmRpY2F0ZSB0aGUgZXh0ZW5zaW9uXG4gICAgICogb2YgY2FudmFzIGVsZW1lbnQgaW4gcGxhaW4gdW50cmFzZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGdldCB1cGRhdGVkIHdpdGggQG1ldGhvZCBjYWxjVmlld3BvcnRCb3VuZGFyaWVzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHZwdENvb3JkczogeyB9LFxuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gdnB0Q29vcmRzIGFuZCBvYmplY3QuYUNvb3Jkcywgc2tpcCByZW5kZXJpbmcgb2Ygb2JqZWN0cyB0aGF0XG4gICAgICogYXJlIG5vdCBpbmNsdWRlZCBpbiBjdXJyZW50IHZpZXdwb3J0LlxuICAgICAqIE1heSBncmVhdGx5IGhlbHAgaW4gYXBwbGljYXRpb25zIHdpdGggY3Jvd2RlZCBjYW52YXMgYW5kIHVzZSBvZiB6b29tL3BhblxuICAgICAqIElmIE9uZSBvZiB0aGUgY29ybmVyIG9mIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIG9iamVjdCBpcyBvbiB0aGUgY2FudmFzXG4gICAgICogdGhlIG9iamVjdHMgZ2V0IHJlbmRlcmVkLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNraXBPZmZzY3JlZW46IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBhIGZhYnJpY09iamVjdCB0aGF0LCB3aXRob3V0IHN0cm9rZSBkZWZpbmUgYSBjbGlwcGluZyBhcmVhIHdpdGggdGhlaXIgc2hhcGUuIGZpbGxlZCBpbiBibGFja1xuICAgICAqIHRoZSBjbGlwUGF0aCBvYmplY3QgZ2V0cyB1c2VkIHdoZW4gdGhlIGNhbnZhcyBoYXMgcmVuZGVyZWQsIGFuZCB0aGUgY29udGV4dCBpcyBwbGFjZWQgaW4gdGhlXG4gICAgICogdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXMuXG4gICAgICogY2xpcFBhdGggd2lsbCBjbGlwIGF3YXkgY29udHJvbHMsIGlmIHlvdSBkbyBub3Qgd2FudCB0aGlzIHRvIGhhcHBlbiB1c2UgY29udHJvbHNBYm92ZU92ZXJsYXkgPSB0cnVlXG4gICAgICogQHR5cGUgZmFicmljLk9iamVjdFxuICAgICAqL1xuICAgIGNsaXBQYXRoOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdFN0YXRpYzogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYiA9IHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgdGhpcy5fY3JlYXRlTG93ZXJDYW52YXMoZWwpO1xuICAgICAgdGhpcy5faW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRJbWFnZVNtb290aGluZygpO1xuICAgICAgLy8gb25seSBpbml0aWFsaXplIHJldGluYSBzY2FsaW5nIG9uY2VcbiAgICAgIGlmICghdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vdmVybGF5SW1hZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRPdmVybGF5SW1hZ2Uob3B0aW9ucy5vdmVybGF5SW1hZ2UsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmRJbWFnZShvcHRpb25zLmJhY2tncm91bmRJbWFnZSwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vdmVybGF5Q29sb3IpIHtcbiAgICAgICAgdGhpcy5zZXRPdmVybGF5Q29sb3Iob3B0aW9ucy5vdmVybGF5Q29sb3IsIGNiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1JldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gMSAmJiB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gcmV0aW5hU2NhbGluZyBpZiBhcHBsaWVkLCBvdGhlcndpc2UgMTtcbiAgICAgKi9cbiAgICBnZXRSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1JldGluYVNjYWxpbmcoKSA/IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGggKiBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmhlaWdodCAqIGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyLnNjYWxlKGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvLCBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgY2FudmFzIGVsZW1lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsc28gYXR0YWNoZWQgYXMgXCJyZXNpemVcIiBldmVudCBoYW5kbGVyIG9mIHdpbmRvd1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNhbGNPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29mZnNldCA9IGdldEVsZW1lbnRPZmZzZXQodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlJbWFnZXxvdmVybGF5IGltYWdlfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nKX0gaW1hZ2UgZmFicmljLkltYWdlIGluc3RhbmNlIG9yIFVSTCBvZiBhbiBpbWFnZSB0byBzZXQgb3ZlcmxheSB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGFuIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxvdmVybGF5IGltYWdlfS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvTW56SFQvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIG92ZXJsYXlJbWFnZSB3aXRoIGxlZnQvdG9wID0gMDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIG92ZXJsYXlJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+b3ZlcmxheUltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMxIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBmYWJyaWMuSW1hZ2UuZnJvbVVSTCgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgZnVuY3Rpb24oaW1nKSB7XG4gICAgICogICAgaW1nLnNldCh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LCBvcmlnaW5YOiAnbGVmdCcsIG9yaWdpblk6ICd0b3AnfSk7XG4gICAgICogICAgY2FudmFzLnNldE92ZXJsYXlJbWFnZShpbWcsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMyIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBvdmVybGF5SW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPm92ZXJsYXlJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICogICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPdmVybGF5SW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5SW1hZ2UoJ292ZXJsYXlJbWFnZScsIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmQgaW1hZ2V9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmcpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2Ugb3IgVVJMIG9mIGFuIGltYWdlIHRvIHNldCBiYWNrZ3JvdW5kIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgbG9hZGVkIGFuZCBzZXQgYXMgYmFja2dyb3VuZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfGJhY2tncm91bmQgaW1hZ2V9LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9kam5yOG83YS8yOC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgYmFja2dyb3VuZEltYWdlIHdpdGggbGVmdC90b3AgPSAwPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIGJhY2tncm91bmRJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+YmFja2dyb3VuZEltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIGJhY2tncm91bmRJbWFnZSAjMSAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogZmFicmljLkltYWdlLmZyb21VUkwoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgKiAgICBpbWcuc2V0KHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsIG9yaWdpblg6ICdsZWZ0Jywgb3JpZ2luWTogJ3RvcCd9KTtcbiAgICAgKiAgICBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKGltZywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBiYWNrZ3JvdW5kSW1hZ2UgIzIgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBiYWNrZ3JvdW5kSW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmJhY2tncm91bmRJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAqICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgLy8gVE9ETzogZml4IHN0cmV0Y2hlZCBleGFtcGxlc1xuICAgIHNldEJhY2tncm91bmRJbWFnZTogZnVuY3Rpb24gKGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlJbWFnZSgnYmFja2dyb3VuZEltYWdlJywgaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5Q29sb3J8Zm9yZWdyb3VuZCBjb2xvcn0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX0gb3ZlcmxheUNvbG9yIENvbG9yIG9yIHBhdHRlcm4gdG8gc2V0IGZvcmVncm91bmQgY29sb3IgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBmb3JlZ3JvdW5kIGNvbG9yIGlzIHNldFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9wQjU1aC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgb3ZlcmxheUNvbG9yIC0gY29sb3IgdmFsdWU8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlDb2xvcigncmdiYSgyNTUsIDczLCA2NCwgMC42KScsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIG92ZXJsYXlDb2xvcjwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUNvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgb3ZlcmxheUNvbG9yIHdpdGggcmVwZWF0IGFuZCBvZmZzZXQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJyxcbiAgICAgKiAgIHJlcGVhdDogJ3JlcGVhdCcsXG4gICAgICogICBvZmZzZXRYOiAyMDAsXG4gICAgICogICBvZmZzZXRZOiAxMDBcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICovXG4gICAgc2V0T3ZlcmxheUNvbG9yOiBmdW5jdGlvbihvdmVybGF5Q29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUNvbG9yKCdvdmVybGF5Q29sb3InLCBvdmVybGF5Q29sb3IsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kQ29sb3J8YmFja2dyb3VuZCBjb2xvcn0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX0gYmFja2dyb3VuZENvbG9yIENvbG9yIG9yIHBhdHRlcm4gdG8gc2V0IGJhY2tncm91bmQgY29sb3IgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBiYWNrZ3JvdW5kIGNvbG9yIGlzIHNldFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9oWHp2ay98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgYmFja2dyb3VuZENvbG9yIC0gY29sb3IgdmFsdWU8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRDb2xvcigncmdiYSgyNTUsIDczLCA2NCwgMC42KScsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIGJhY2tncm91bmRDb2xvcjwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgYmFja2dyb3VuZENvbG9yIHdpdGggcmVwZWF0IGFuZCBvZmZzZXQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJyxcbiAgICAgKiAgIHJlcGVhdDogJ3JlcGVhdCcsXG4gICAgICogICBvZmZzZXRYOiAyMDAsXG4gICAgICogICBvZmZzZXRZOiAxMDBcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICovXG4gICAgc2V0QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbihiYWNrZ3JvdW5kQ29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUNvbG9yKCdiYWNrZ3JvdW5kQ29sb3InLCBiYWNrZ3JvdW5kQ29sb3IsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNkb20tY29udGV4dC0yZC1pbWFnZXNtb290aGluZ2VuYWJsZWR8V2hhdFdHIENhbnZhcyBTdGFuZGFyZH1cbiAgICAgKi9cbiAgICBfc2V0SW1hZ2VTbW9vdGhpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0Q29udGV4dCgpO1xuXG4gICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkXG4gICAgICAgIHx8IGN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY3R4Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGN0eC5vSW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xuICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRoaXMuaW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBzZXQgKHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2JhY2tncm91bmRJbWFnZXxiYWNrZ3JvdW5kSW1hZ2V9XG4gICAgICogb3Ige0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjb3ZlcmxheUltYWdlfG92ZXJsYXlJbWFnZX0pXG4gICAgICogQHBhcmFtIHsoZmFicmljLkltYWdlfFN0cmluZ3xudWxsKX0gaW1hZ2UgZmFicmljLkltYWdlIGluc3RhbmNlLCBVUkwgb2YgYW4gaW1hZ2Ugb3IgbnVsbCB0byBzZXQgYmFja2dyb3VuZCBvciBvdmVybGF5IHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgbG9hZGVkIGFuZCBzZXQgYXMgYmFja2dyb3VuZCBvciBvdmVybGF5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zIHRvIHNldCBmb3IgdGhlIHtAbGluayBmYWJyaWMuSW1hZ2V8aW1hZ2V9LlxuICAgICAqL1xuICAgIF9fc2V0QmdPdmVybGF5SW1hZ2U6IGZ1bmN0aW9uKHByb3BlcnR5LCBpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShpbWFnZSwgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgaWYgKGltZykge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IGZhYnJpYy5JbWFnZShpbWcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIGluc3RhbmNlLmNhbnZhcyA9IHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGltZyk7XG4gICAgICAgIH0sIHRoaXMsIG9wdGlvbnMgJiYgb3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyAmJiBpbWFnZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGltYWdlO1xuICAgICAgICBpbWFnZSAmJiAoaW1hZ2UuY2FudmFzID0gdGhpcyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGltYWdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoe0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZENvbG9yfGJhY2tncm91bmRDb2xvcn1cbiAgICAgKiBvciB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5Q29sb3J8b3ZlcmxheUNvbG9yfSlcbiAgICAgKiBAcGFyYW0geyhPYmplY3R8U3RyaW5nfG51bGwpfSBjb2xvciBPYmplY3Qgd2l0aCBwYXR0ZXJuIGluZm9ybWF0aW9uLCBjb2xvciB2YWx1ZSBvciBudWxsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBpcyBpbnZva2VkIHdoZW4gY29sb3IgaXMgc2V0XG4gICAgICovXG4gICAgX19zZXRCZ092ZXJsYXlDb2xvcjogZnVuY3Rpb24ocHJvcGVydHksIGNvbG9yLCBjYWxsYmFjaykge1xuICAgICAgdGhpc1twcm9wZXJ0eV0gPSBjb2xvcjtcbiAgICAgIHRoaXMuX2luaXRHcmFkaWVudChjb2xvciwgcHJvcGVydHkpO1xuICAgICAgdGhpcy5faW5pdFBhdHRlcm4oY29sb3IsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQ2FudmFzRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB0aHJvdyBDQU5WQVNfSU5JVF9FUlJPUjtcbiAgICAgIH1cbiAgICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlID0geyB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50LmdldENvbnRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IENBTlZBU19JTklUX0VSUk9SO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBsb3dlckNhbnZhc0VsID0gdGhpcy5sb3dlckNhbnZhc0VsO1xuICAgICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggfHwgcGFyc2VJbnQobG93ZXJDYW52YXNFbC53aWR0aCwgMTApIHx8IDA7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuaGVpZ2h0IHx8IHBhcnNlSW50KGxvd2VyQ2FudmFzRWwuaGVpZ2h0LCAxMCkgfHwgMDtcblxuICAgICAgaWYgKCF0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb3dlckNhbnZhc0VsLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIGxvd2VyQ2FudmFzRWwuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIGxvd2VyQ2FudmFzRWwuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4JztcbiAgICAgIGxvd2VyQ2FudmFzRWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuXG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYm90dG9tIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NhbnZhc0VsXVxuICAgICAqL1xuICAgIF9jcmVhdGVMb3dlckNhbnZhczogZnVuY3Rpb24gKGNhbnZhc0VsKSB7XG4gICAgICAvLyBjYW52YXNFbCA9PT0gJ0hUTUxDYW52YXNFbGVtZW50JyBkb2VzIG5vdCB3b3JrIG9uIGpzZG9tL25vZGVcbiAgICAgIGlmIChjYW52YXNFbCAmJiBjYW52YXNFbC5nZXRDb250ZXh0KSB7XG4gICAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IGNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IGZhYnJpYy51dGlsLmdldEJ5SWQoY2FudmFzRWwpIHx8IHRoaXMuX2NyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5sb3dlckNhbnZhc0VsLCAnbG93ZXItY2FudmFzJyk7XG5cbiAgICAgIGlmICh0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gdGhpcy5sb3dlckNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIHdpZHRoIChpbiBweClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyBoZWlnaHQgKGluIHB4KVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aWR0aCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWUgdG8gc2V0IHdpZHRoIHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IHdpZHRoOiB2YWx1ZSB9LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBoZWlnaHQgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlIHRvIHNldCBoZWlnaHQgdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IGhlaWdodDogdmFsdWUgfSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZGltZW5zaW9ucyAod2lkdGgsIGhlaWdodCkgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2UuIHdoZW4gb3B0aW9ucy5jc3NPbmx5IGZsYWcgYWN0aXZlIHlvdSBzaG91bGQgYWxzbyBzdXBwbHkgdGhlIHVuaXQgb2YgbWVhc3VyZSAocHgvJS9lbSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIGRpbWVuc2lvbnMgICAgICAgICAgICAgICAgICAgIE9iamVjdCB3aXRoIHdpZHRoL2hlaWdodCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbZGltZW5zaW9ucy53aWR0aF0gICAgICAgICAgICBXaWR0aCBvZiBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2RpbWVuc2lvbnMuaGVpZ2h0XSAgICAgICAgICAgSGVpZ2h0IG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RGltZW5zaW9uczogZnVuY3Rpb24gKGRpbWVuc2lvbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjc3NWYWx1ZTtcblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gZGltZW5zaW9ucykge1xuICAgICAgICBjc3NWYWx1ZSA9IGRpbWVuc2lvbnNbcHJvcF07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRCYWNrc3RvcmVEaW1lbnNpb24ocHJvcCwgZGltZW5zaW9uc1twcm9wXSk7XG4gICAgICAgICAgY3NzVmFsdWUgKz0gJ3B4JztcbiAgICAgICAgICB0aGlzLmhhc0xvc3RDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5iYWNrc3RvcmVPbmx5KSB7XG4gICAgICAgICAgdGhpcy5fc2V0Q3NzRGltZW5zaW9uKHByb3AsIGNzc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggJiYgdGhpcy5mcmVlRHJhd2luZ0JydXNoLl9zZXRCcnVzaFN0eWxlcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcbiAgICAgIHRoaXMuX3NldEltYWdlU21vb3RoaW5nKCk7XG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcblxuICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZm9yIHNldHRpbmcgd2lkdGgvaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBwcm9wZXJ0eSAod2lkdGh8aGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB2YWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIF9zZXRCYWNrc3RvcmVEaW1lbnNpb246IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhY2hlQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmb3Igc2V0dGluZyBjc3Mgd2lkdGgvaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBwcm9wZXJ0eSAod2lkdGh8aGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB2YWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIF9zZXRDc3NEaW1lbnNpb246IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLndyYXBwZXJFbCkge1xuICAgICAgICB0aGlzLndyYXBwZXJFbC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYW52YXMgem9vbSBsZXZlbFxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRab29tOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVswXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB2aWV3cG9ydCB0cmFuc2Zvcm0gb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2cHQgdGhlIHRyYW5zZm9ybSBpbiB0aGUgZm9ybSBvZiBjb250ZXh0LnRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0Vmlld3BvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uICh2cHQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3QsIG9iamVjdCwgaWdub3JlVnB0ID0gZmFsc2UsIHNraXBBYnNvbHV0ZSA9IHRydWUsIGksIGxlbjtcbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB2cHQ7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuX29iamVjdHNbaV07XG4gICAgICAgIG9iamVjdC5ncm91cCB8fCBvYmplY3Quc2V0Q29vcmRzKGlnbm9yZVZwdCwgc2tpcEFic29sdXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIGFjdGl2ZU9iamVjdC5zZXRDb29yZHMoaWdub3JlVnB0LCBza2lwQWJzb2x1dGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgem9vbSBsZXZlbCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZSwgem9vbSBjZW50ZXJlZCBhcm91bmQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgdG8gem9vbSB3aXRoIHJlc3BlY3QgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdG8gc2V0IHpvb20gdG8sIGxlc3MgdGhhbiAxIHpvb21zIG91dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgem9vbVRvUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCwgdmFsdWUpIHtcbiAgICAgIC8vIFRPRE86IGp1c3QgY2hhbmdlIHRoZSBzY2FsZSwgcHJlc2VydmUgb3RoZXIgdHJhbnNmb3JtYXRpb25zXG4gICAgICB2YXIgYmVmb3JlID0gcG9pbnQsIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0uc2xpY2UoMCk7XG4gICAgICBwb2ludCA9IHRyYW5zZm9ybVBvaW50KHBvaW50LCBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSkpO1xuICAgICAgdnB0WzBdID0gdmFsdWU7XG4gICAgICB2cHRbM10gPSB2YWx1ZTtcbiAgICAgIHZhciBhZnRlciA9IHRyYW5zZm9ybVBvaW50KHBvaW50LCB2cHQpO1xuICAgICAgdnB0WzRdICs9IGJlZm9yZS54IC0gYWZ0ZXIueDtcbiAgICAgIHZwdFs1XSArPSBiZWZvcmUueSAtIGFmdGVyLnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybSh2cHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHpvb20gbGV2ZWwgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdG8gc2V0IHpvb20gdG8sIGxlc3MgdGhhbiAxIHpvb21zIG91dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0Wm9vbTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnpvb21Ub1BvaW50KG5ldyBmYWJyaWMuUG9pbnQoMCwgMCksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW4gdmlld3BvcnQgc28gYXMgdG8gcGxhY2UgcG9pbnQgYXQgdG9wIGxlZnQgY29ybmVyIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCB0byBtb3ZlIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBhYnNvbHV0ZVBhbjogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgwKTtcbiAgICAgIHZwdFs0XSA9IC1wb2ludC54O1xuICAgICAgdnB0WzVdID0gLXBvaW50Lnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybSh2cHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW5zIHZpZXdwb2ludCByZWxhdGl2ZWx5XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IChwb3NpdGlvbiB2ZWN0b3IpIHRvIG1vdmUgYnlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHJlbGF0aXZlUGFuOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFic29sdXRlUGFuKG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgIC1wb2ludC54IC0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVs0XSxcbiAgICAgICAgLXBvaW50LnkgLSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzVdXG4gICAgICApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAmbHQ7Y2FudmFzPiBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvd2VyQ2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIGFkZGVkXG4gICAgICovXG4gICAgX29uT2JqZWN0QWRkZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdGhpcy5zdGF0ZWZ1bCAmJiBvYmouc2V0dXBTdGF0ZSgpO1xuICAgICAgb2JqLl9zZXQoJ2NhbnZhcycsIHRoaXMpO1xuICAgICAgb2JqLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5maXJlKCdvYmplY3Q6YWRkZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgb2JqLmZpcmUoJ2FkZGVkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RSZW1vdmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OnJlbW92ZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgb2JqLmZpcmUoJ3JlbW92ZWQnKTtcbiAgICAgIGRlbGV0ZSBvYmouY2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgc3BlY2lmaWVkIGNvbnRleHQgb2YgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gY2xlYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyQ29udGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRleHQgb2YgY2FudmFzIHdoZXJlIG9iamVjdHMgYXJlIGRyYXduXG4gICAgICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY29udGV4dHMgKGJhY2tncm91bmQsIG1haW4sIHRvcCkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vYmplY3RzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLm92ZXJsYXlJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICcnO1xuICAgICAgdGhpcy5vdmVybGF5Q29sb3IgPSAnJztcbiAgICAgIGlmICh0aGlzLl9oYXNJVGV4dEhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMub2ZmKCdtb3VzZTp1cCcsIHRoaXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9pVGV4dEluc3RhbmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hhc0lUZXh0SGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICB0aGlzLmZpcmUoJ2NhbnZhczpjbGVhcmVkJyk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbnZhc1RvRHJhd09uID0gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoY2FudmFzVG9EcmF3T24sIHRoaXMuX29iamVjdHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNyZWF0ZWQgdG8gYmUgaW5zdGFuY2UgYm91bmQgYXQgaW5pdGlhbGl6YXRpb25cbiAgICAgKiB1c2VkIGluIHJlcXVlc3RBbmltYXRpb25GcmFtZSByZW5kZXJpbmdcbiAgICAgKiBMZXQgdGhlIGZhYnJpY0pTIGNhbGwgaXQuIElmIHlvdSBjYWxsIGl0IG1hbnVhbGx5IHlvdSBjb3VsZCBoYXZlIG1vcmVcbiAgICAgKiBhbmltYXRpb25GcmFtZSBzdGFja2luZyBvbiB0byBvZiBlYWNoIG90aGVyXG4gICAgICogZm9yIGFuIGltcGVyYXRpdmUgcmVuZGVyaW5nLCB1c2UgY2FudmFzLnJlbmRlckFsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQW5kUmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IDA7XG4gICAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYSByZW5kZXJBbGwgcmVxdWVzdCB0byBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgKiB1bmxlc3Mgb25lIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIGluIHRoYXQgY2FzZSBub3RoaW5nIGlzIGRvbmVcbiAgICAgKiBhIGJvb2xlYW4gZmxhZyB3aWxsIGF2b2lkIGFwcGVuZGluZyBtb3JlLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlcXVlc3RSZW5kZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gZmFicmljLnV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLnJlbmRlckFuZFJlc2V0Qm91bmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIDQgY29ybmVyIG9mIGNhbnZhcyB3aXRoIGN1cnJlbnQgdmlld3BvcnRUcmFuc2Zvcm0uXG4gICAgICogaGVscHMgdG8gZGV0ZXJtaW5hdGUgd2hlbiBhbiBvYmplY3QgaXMgaW4gdGhlIGN1cnJlbnQgcmVuZGVyaW5nIHZpZXdwb3J0IHVzaW5nXG4gICAgICogb2JqZWN0IGFic29sdXRlIGNvb3JkaW5hdGVzICggYUNvb3JkcyApXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwb2ludHMudGxcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2FsY1ZpZXdwb3J0Qm91bmRhcmllczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9pbnRzID0geyB9LCB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIGlWcHQgPSBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICBwb2ludHMudGwgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IDAsIHk6IDAgfSwgaVZwdCk7XG4gICAgICBwb2ludHMuYnIgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSwgaVZwdCk7XG4gICAgICBwb2ludHMudHIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50cy5ici54LCBwb2ludHMudGwueSk7XG4gICAgICBwb2ludHMuYmwgPSBuZXcgZmFicmljLlBvaW50KHBvaW50cy50bC54LCBwb2ludHMuYnIueSk7XG4gICAgICB0aGlzLnZwdENvb3JkcyA9IHBvaW50cztcbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfSxcblxuICAgIGNhbmNlbFJlcXVlc3RlZFJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICBmYWJyaWMudXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5pc1JlbmRlcmluZyk7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGJhY2tncm91bmQsIG9iamVjdHMsIG92ZXJsYXkgYW5kIGNvbnRyb2xzLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIHRvIHJlbmRlclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckNhbnZhczogZnVuY3Rpb24oY3R4LCBvYmplY3RzKSB7XG4gICAgICB2YXIgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIHBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgdGhpcy5jYW5jZWxSZXF1ZXN0ZWRSZW5kZXIoKTtcbiAgICAgIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnJlbmRlcicsIHsgY3R4OiBjdHgsIH0pO1xuICAgICAgaWYgKHRoaXMuY2xpcFRvKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNsaXBDb250ZXh0KHRoaXMsIGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGN0eCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvL2FwcGx5IHZpZXdwb3J0IHRyYW5zZm9ybSBvbmNlIGZvciBhbGwgcmVuZGVyaW5nIHByb2Nlc3NcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICB0aGlzLl9yZW5kZXJPYmplY3RzKGN0eCwgb2JqZWN0cyk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgaWYgKCF0aGlzLmNvbnRyb2xzQWJvdmVPdmVybGF5ICYmIHRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5kcmF3Q29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsaXBUbykge1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgcGF0aC5jYW52YXMgPSB0aGlzO1xuICAgICAgICAvLyBuZWVkZWQgdG8gc2V0dXAgYSBjb3VwbGUgb2YgdmFyaWFibGVzXG4gICAgICAgIHBhdGguc2hvdWxkQ2FjaGUoKTtcbiAgICAgICAgcGF0aC5fdHJhbnNmb3JtRG9uZSA9IHRydWU7XG4gICAgICAgIHBhdGgucmVuZGVyQ2FjaGUoeyBmb3JDbGlwcGluZzogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5kcmF3Q2xpcFBhdGhPbkNhbnZhcyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyT3ZlcmxheShjdHgpO1xuICAgICAgaWYgKHRoaXMuY29udHJvbHNBYm92ZU92ZXJsYXkgJiYgdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmRyYXdDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdhZnRlcjpyZW5kZXInLCB7IGN0eDogY3R4LCB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFpbnQgdGhlIGNhY2hlZCBjbGlwUGF0aCBvbiB0aGUgbG93ZXJDYW52YXNFbFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2xpcFBhdGhPbkNhbnZhczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIHBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICAvLyBERUJVRzogdW5jb21tZW50IHRoaXMgbGluZSwgY29tbWVudCB0aGUgZm9sbG93aW5nXG4gICAgICAvLyBjdHguZ2xvYmFsQWxwaGEgPSAwLjQ7XG4gICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgIHBhdGgudHJhbnNmb3JtKGN0eCk7XG4gICAgICBjdHguc2NhbGUoMSAvIHBhdGguem9vbVgsIDEgLyBwYXRoLnpvb21ZKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UocGF0aC5fY2FjaGVDYW52YXMsIC1wYXRoLmNhY2hlVHJhbnNsYXRpb25YLCAtcGF0aC5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIHRvIHJlbmRlclxuICAgICAqL1xuICAgIF9yZW5kZXJPYmplY3RzOiBmdW5jdGlvbihjdHgsIG9iamVjdHMpIHtcbiAgICAgIHZhciBpLCBsZW47XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIG9iamVjdHNbaV0gJiYgb2JqZWN0c1tpXS5yZW5kZXIoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5ICdiYWNrZ3JvdW5kJyBvciAnb3ZlcmxheSdcbiAgICAgKi9cbiAgICBfcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheTogZnVuY3Rpb24oY3R4LCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXNbcHJvcGVydHkgKyAnQ29sb3InXSwgdjtcbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9iamVjdC50b0xpdmVcbiAgICAgICAgICA/IG9iamVjdC50b0xpdmUoY3R4LCB0aGlzKVxuICAgICAgICAgIDogb2JqZWN0O1xuXG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICBvYmplY3Qub2Zmc2V0WCB8fCAwLFxuICAgICAgICAgIG9iamVjdC5vZmZzZXRZIHx8IDAsXG4gICAgICAgICAgdGhpcy53aWR0aCxcbiAgICAgICAgICB0aGlzLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSB0aGlzW3Byb3BlcnR5ICsgJ0ltYWdlJ107XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGlmICh0aGlzW3Byb3BlcnR5ICsgJ1ZwdCddKSB7XG4gICAgICAgICAgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5yZW5kZXIoY3R4KTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eSArICdWcHQnXSAmJiBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kT3JPdmVybGF5KGN0eCwgJ2JhY2tncm91bmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlck92ZXJsYXk6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheShjdHgsICdvdmVybGF5Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgYSBjZW50ZXIgb2YgY2FudmFzLlxuICAgICAqIFJldHVybmVkIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIHRvcCBhbmQgbGVmdCBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInRvcFwiIGFuZCBcImxlZnRcIiBudW1iZXIgdmFsdWVzXG4gICAgICovXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgbGVmdDogdGhpcy53aWR0aCAvIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBpbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICovXG4gICAgY2VudGVyT2JqZWN0SDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQodGhpcy5nZXRDZW50ZXIoKS5sZWZ0LCBvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVyT2JqZWN0VjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQob2JqZWN0LmdldENlbnRlclBvaW50KCkueCwgdGhpcy5nZXRDZW50ZXIoKS50b3ApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IGluIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVyT2JqZWN0OiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludChjZW50ZXIubGVmdCwgY2VudGVyLnRvcCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgaW4gdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0OiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIHZwQ2VudGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IGluIHRoZSB2aWV3cG9ydCwgb2JqZWN0LnRvcCBpcyB1bmNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJPYmplY3RIOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcbiAgICAgIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQodnBDZW50ZXIueCwgb2JqZWN0LmdldENlbnRlclBvaW50KCkueSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IFZlcnRpY2FsbHkgaW4gdGhlIHZpZXdwb3J0LCBvYmplY3QudG9wIGlzIHVuY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlck9iamVjdFY6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHZwQ2VudGVyID0gdGhpcy5nZXRWcENlbnRlcigpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludChvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS54LCB2cENlbnRlci55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9pbnQgaW4gY2FudmFzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgY2VudGVyIG9mIGFjdHVhbCB2aWV3cG9ydC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHZwQ2VudGVyLCB2aWV3cG9ydCBjZW50ZXJcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZ2V0VnBDZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXG4gICAgICAgICAgaVZwdCA9IGludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1Qb2ludCh7IHg6IGNlbnRlci5sZWZ0LCB5OiBjZW50ZXIudG9wIH0sIGlWcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gY2VudGVyIENlbnRlciBwb2ludFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX2NlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0LCBjZW50ZXIpIHtcbiAgICAgIG9iamVjdC5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJzIGRhdGFsZXNzIEpTT04gcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30ganNvbiBzdHJpbmdcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzSlNPTjogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvRGF0YWxlc3NPYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiAocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0TWV0aG9kKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGFsZXNzIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzT2JqZWN0OiBmdW5jdGlvbiAocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0TWV0aG9kKCd0b0RhdGFsZXNzT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0TWV0aG9kOiBmdW5jdGlvbiAobWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuXG4gICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoLCBkYXRhID0ge1xuICAgICAgICB2ZXJzaW9uOiBmYWJyaWMudmVyc2lvbixcbiAgICAgICAgb2JqZWN0czogdGhpcy5fdG9PYmplY3RzKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpLFxuICAgICAgfTtcbiAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICBkYXRhLmNsaXBQYXRoID0gdGhpcy5fdG9PYmplY3RNZXRob2QoY2xpcFBhdGgsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfVxuICAgICAgZXh0ZW5kKGRhdGEsIHRoaXMuX19zZXJpYWxpemVCZ092ZXJsYXkobWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkpO1xuXG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIGRhdGEsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3RzOiBmdW5jdGlvbihtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5maWx0ZXIoZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiAhb2JqZWN0LmV4Y2x1ZGVGcm9tRXhwb3J0O1xuICAgICAgfSkubWFwKGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b09iamVjdChpbnN0YW5jZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgb3JpZ2luYWxWYWx1ZTtcblxuICAgICAgaWYgKCF0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIG9yaWdpbmFsVmFsdWUgPSBpbnN0YW5jZS5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgaW5zdGFuY2UuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9iamVjdCA9IGluc3RhbmNlW21ldGhvZE5hbWVdKHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgaWYgKCF0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIGluc3RhbmNlLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gb3JpZ2luYWxWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX19zZXJpYWxpemVCZ092ZXJsYXk6IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBkYXRhID0geyB9LCBiZ0ltYWdlID0gdGhpcy5iYWNrZ3JvdW5kSW1hZ2UsIG92ZXJsYXkgPSB0aGlzLm92ZXJsYXlJbWFnZTtcblxuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIGRhdGEuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZENvbG9yLnRvT2JqZWN0XG4gICAgICAgICAgPyB0aGlzLmJhY2tncm91bmRDb2xvci50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKVxuICAgICAgICAgIDogdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm92ZXJsYXlDb2xvcikge1xuICAgICAgICBkYXRhLm92ZXJsYXkgPSB0aGlzLm92ZXJsYXlDb2xvci50b09iamVjdFxuICAgICAgICAgID8gdGhpcy5vdmVybGF5Q29sb3IudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSlcbiAgICAgICAgICA6IHRoaXMub3ZlcmxheUNvbG9yO1xuICAgICAgfVxuICAgICAgaWYgKGJnSW1hZ2UgJiYgIWJnSW1hZ2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgZGF0YS5iYWNrZ3JvdW5kSW1hZ2UgPSB0aGlzLl90b09iamVjdChiZ0ltYWdlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVybGF5ICYmICFvdmVybGF5LmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgIGRhdGEub3ZlcmxheUltYWdlID0gdGhpcy5fdG9PYmplY3Qob3ZlcmxheSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgZ2V0U3ZnVHJhbnNmb3JtKCkgd2lsbCBhcHBseSB0aGUgU3RhdGljQ2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtIHRvIHRoZSBTVkcgdHJhbnNmb3JtYXRpb24uIFdoZW4gdHJ1ZSxcbiAgICAgKiBhIHpvb21lZCBjYW52YXMgd2lsbCB0aGVuIHByb2R1Y2Ugem9vbWVkIFNWRyBvdXRwdXQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3ZnVmlld3BvcnRUcmFuc2Zvcm1hdGlvbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3QgZm9yIFNWRyBvdXRwdXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN1cHByZXNzUHJlYW1ibGU9ZmFsc2VdIElmIHRydWUgeG1sIHRhZyBpcyBub3QgaW5jbHVkZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudmlld0JveF0gU1ZHIHZpZXdib3ggb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3gueF0geC1jb29yaWRuYXRlIG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC55XSB5LWNvb3JkaW5hdGUgb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LndpZHRoXSBXaWR0aCBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3guaGVpZ2h0XSBIZWlnaHQgb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1VVEYtOF0gRW5jb2Rpbmcgb2YgU1ZHIG91dHB1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53aWR0aF0gZGVzaXJlZCB3aWR0aCBvZiBzdmcgd2l0aCBvciB3aXRob3V0IHVuaXRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhlaWdodF0gZGVzaXJlZCBoZWlnaHQgb2Ygc3ZnIHdpdGggb3Igd2l0aG91dCB1bml0c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY29udmVydGVkIGludG8gc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHN0cmluZ1xuICAgICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI3NlcmlhbGl6YXRpb259XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9qUTNaWi98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgU1ZHIG91dHB1dDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKCk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U1ZHIG91dHB1dCB3aXRob3V0IHByZWFtYmxlICh3aXRob3V0ICZsdDs/eG1sIC4uLz4pPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoe3N1cHByZXNzUHJlYW1ibGU6IHRydWV9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TVkcgb3V0cHV0IHdpdGggdmlld0JveCBhdHRyaWJ1dGU8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyh7XG4gICAgICogICB2aWV3Qm94OiB7XG4gICAgICogICAgIHg6IDEwMCxcbiAgICAgKiAgICAgeTogMTAwLFxuICAgICAqICAgICB3aWR0aDogMjAwLFxuICAgICAqICAgICBoZWlnaHQ6IDMwMFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNWRyBvdXRwdXQgd2l0aCBkaWZmZXJlbnQgZW5jb2RpbmcgKGRlZmF1bHQ6IFVURi04KTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKHtlbmNvZGluZzogJ0lTTy04ODU5LTEnfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+TW9kaWZ5IFNWRyBvdXRwdXQgd2l0aCByZXZpdmVyIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcobnVsbCwgZnVuY3Rpb24oc3ZnKSB7XG4gICAgICogICByZXR1cm4gc3ZnLnJlcGxhY2UoJ3N0cm9rZS1kYXNoYXJyYXk6IDsgc3Ryb2tlLWxpbmVjYXA6IGJ1dHQ7IHN0cm9rZS1saW5lam9pbjogbWl0ZXI7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgJywgJycpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvcHRpb25zLCByZXZpdmVyKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIG9wdGlvbnMucmV2aXZlciA9IHJldml2ZXI7XG4gICAgICB2YXIgbWFya3VwID0gW107XG5cbiAgICAgIHRoaXMuX3NldFNWR1ByZWFtYmxlKG1hcmt1cCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRTVkdIZWFkZXIobWFya3VwLCBvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKCc8ZyBjbGlwLXBhdGg9XCJ1cmwoIycgKyB0aGlzLmNsaXBQYXRoLmNsaXBQYXRoSWQgKyAnKVwiID5cXG4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUNvbG9yKG1hcmt1cCwgJ2JhY2tncm91bmRDb2xvcicpO1xuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5SW1hZ2UobWFya3VwLCAnYmFja2dyb3VuZEltYWdlJywgcmV2aXZlcik7XG4gICAgICB0aGlzLl9zZXRTVkdPYmplY3RzKG1hcmt1cCwgcmV2aXZlcik7XG4gICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaCgnPC9nPlxcbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5Q29sb3IobWFya3VwLCAnb3ZlcmxheUNvbG9yJyk7XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlJbWFnZShtYXJrdXAsICdvdmVybGF5SW1hZ2UnLCByZXZpdmVyKTtcblxuICAgICAgbWFya3VwLnB1c2goJzwvc3ZnPicpO1xuXG4gICAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdQcmVhbWJsZTogZnVuY3Rpb24obWFya3VwLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdXBwcmVzc1ByZWFtYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiJywgKG9wdGlvbnMuZW5jb2RpbmcgfHwgJ1VURi04JyksICdcIiBzdGFuZGFsb25lPVwibm9cIiA/PlxcbicsXG4gICAgICAgICc8IURPQ1RZUEUgc3ZnIFBVQkxJQyBcIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOXCIgJyxcbiAgICAgICAgJ1wiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkXCI+XFxuJ1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHSGVhZGVyOiBmdW5jdGlvbihtYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgdGhpcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCB0aGlzLmhlaWdodCxcbiAgICAgICAgICB2cHQsIHZpZXdCb3ggPSAndmlld0JveD1cIjAgMCAnICsgdGhpcy53aWR0aCArICcgJyArIHRoaXMuaGVpZ2h0ICsgJ1wiICcsXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcblxuICAgICAgaWYgKG9wdGlvbnMudmlld0JveCkge1xuICAgICAgICB2aWV3Qm94ID0gJ3ZpZXdCb3g9XCInICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3gueCArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LnkgKyAnICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC53aWR0aCArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LmhlaWdodCArICdcIiAnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnN2Z1ZpZXdwb3J0VHJhbnNmb3JtYXRpb24pIHtcbiAgICAgICAgICB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgICAgIHZpZXdCb3ggPSAndmlld0JveD1cIicgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCgtdnB0WzRdIC8gdnB0WzBdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcgJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKC12cHRbNV0gLyB2cHRbM10sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy53aWR0aCAvIHZwdFswXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCAvIHZwdFszXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxzdmcgJyxcbiAgICAgICAgJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnLFxuICAgICAgICAneG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgJyxcbiAgICAgICAgJ3ZlcnNpb249XCIxLjFcIiAnLFxuICAgICAgICAnd2lkdGg9XCInLCB3aWR0aCwgJ1wiICcsXG4gICAgICAgICdoZWlnaHQ9XCInLCBoZWlnaHQsICdcIiAnLFxuICAgICAgICB2aWV3Qm94LFxuICAgICAgICAneG1sOnNwYWNlPVwicHJlc2VydmVcIj5cXG4nLFxuICAgICAgICAnPGRlc2M+Q3JlYXRlZCB3aXRoIEZhYnJpYy5qcyAnLCBmYWJyaWMudmVyc2lvbiwgJzwvZGVzYz5cXG4nLFxuICAgICAgICAnPGRlZnM+XFxuJyxcbiAgICAgICAgdGhpcy5jcmVhdGVTVkdGb250RmFjZXNNYXJrdXAoKSxcbiAgICAgICAgdGhpcy5jcmVhdGVTVkdSZWZFbGVtZW50c01hcmt1cCgpLFxuICAgICAgICB0aGlzLmNyZWF0ZVNWR0NsaXBQYXRoTWFya3VwKG9wdGlvbnMpLFxuICAgICAgICAnPC9kZWZzPlxcbidcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVNWR0NsaXBQYXRoTWFya3VwOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgIGNsaXBQYXRoLmNsaXBQYXRoSWQgPSAnQ0xJUFBBVEhfJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgICAgcmV0dXJuICAnPGNsaXBQYXRoIGlkPVwiJyArIGNsaXBQYXRoLmNsaXBQYXRoSWQgKyAnXCIgPlxcbicgK1xuICAgICAgICAgIHRoaXMuY2xpcFBhdGgudG9DbGlwUGF0aFNWRyhvcHRpb25zLnJldml2ZXIpICtcbiAgICAgICAgICAnPC9jbGlwUGF0aD5cXG4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG1hcmt1cCBjb250YWluaW5nIFNWRyByZWZlcmVuY2VkIGVsZW1lbnRzIGxpa2UgcGF0dGVybnMsIGdyYWRpZW50cyBldGMuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgbWFya3VwID0gWydiYWNrZ3JvdW5kQ29sb3InLCAnb3ZlcmxheUNvbG9yJ10ubWFwKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gX3RoaXNbcHJvcF07XG4gICAgICAgICAgICBpZiAoZmlsbCAmJiBmaWxsLnRvTGl2ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmlsbC50b1NWRyhfdGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtYXJrdXAgY29udGFpbmluZyBTVkcgZm9udCBmYWNlcyxcbiAgICAgKiBmb250IFVSTHMgZm9yIGZvbnQgZmFjZXMgbXVzdCBiZSBjb2xsZWN0ZWQgYnkgZGV2ZWxvcGVyc1xuICAgICAqIGFuZCBhcmUgbm90IGV4dHJhY3RlZCBmcm9tIHRoZSBET00gYnkgZmFicmljanNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIEFycmF5IG9mIGZhYnJpYyBvYmplY3RzXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFya3VwID0gJycsIGZvbnRMaXN0ID0geyB9LCBvYmosIGZvbnRGYW1pbHksXG4gICAgICAgICAgc3R5bGUsIHJvdywgcm93SW5kZXgsIF9jaGFyLCBjaGFySW5kZXgsIGksIGxlbixcbiAgICAgICAgICBmb250UGF0aHMgPSBmYWJyaWMuZm9udFBhdGhzLCBvYmplY3RzID0gdGhpcy5fb2JqZWN0cztcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvYmogPSBvYmplY3RzW2ldO1xuICAgICAgICBmb250RmFtaWx5ID0gb2JqLmZvbnRGYW1pbHk7XG4gICAgICAgIGlmIChvYmoudHlwZS5pbmRleE9mKCd0ZXh0JykgPT09IC0xIHx8IGZvbnRMaXN0W2ZvbnRGYW1pbHldIHx8ICFmb250UGF0aHNbZm9udEZhbWlseV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb250TGlzdFtmb250RmFtaWx5XSA9IHRydWU7XG4gICAgICAgIGlmICghb2JqLnN0eWxlcykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlID0gb2JqLnN0eWxlcztcbiAgICAgICAgZm9yIChyb3dJbmRleCBpbiBzdHlsZSkge1xuICAgICAgICAgIHJvdyA9IHN0eWxlW3Jvd0luZGV4XTtcbiAgICAgICAgICBmb3IgKGNoYXJJbmRleCBpbiByb3cpIHtcbiAgICAgICAgICAgIF9jaGFyID0gcm93W2NoYXJJbmRleF07XG4gICAgICAgICAgICBmb250RmFtaWx5ID0gX2NoYXIuZm9udEZhbWlseTtcbiAgICAgICAgICAgIGlmICghZm9udExpc3RbZm9udEZhbWlseV0gJiYgZm9udFBhdGhzW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgICAgICAgIGZvbnRMaXN0W2ZvbnRGYW1pbHldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiBpbiBmb250TGlzdCkge1xuICAgICAgICBtYXJrdXAgKz0gW1xuICAgICAgICAgICdcXHRcXHRAZm9udC1mYWNlIHtcXG4nLFxuICAgICAgICAgICdcXHRcXHRcXHRmb250LWZhbWlseTogXFwnJywgaiwgJ1xcJztcXG4nLFxuICAgICAgICAgICdcXHRcXHRcXHRzcmM6IHVybChcXCcnLCBmb250UGF0aHNbal0sICdcXCcpO1xcbicsXG4gICAgICAgICAgJ1xcdFxcdH1cXG4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgbWFya3VwID0gW1xuICAgICAgICAgICdcXHQ8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+JyxcbiAgICAgICAgICAnPCFbQ0RBVEFbXFxuJyxcbiAgICAgICAgICBtYXJrdXAsXG4gICAgICAgICAgJ11dPicsXG4gICAgICAgICAgJzwvc3R5bGU+XFxuJ1xuICAgICAgICBdLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdPYmplY3RzOiBmdW5jdGlvbihtYXJrdXAsIHJldml2ZXIpIHtcbiAgICAgIHZhciBpbnN0YW5jZSwgaSwgbGVuLCBvYmplY3RzID0gdGhpcy5fb2JqZWN0cztcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYmplY3RzW2ldO1xuICAgICAgICBpZiAoaW5zdGFuY2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRTVkdPYmplY3QobWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdDogZnVuY3Rpb24obWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcikge1xuICAgICAgbWFya3VwLnB1c2goaW5zdGFuY2UudG9TVkcocmV2aXZlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24obWFya3VwLCBwcm9wZXJ0eSwgcmV2aXZlcikge1xuICAgICAgaWYgKHRoaXNbcHJvcGVydHldICYmICF0aGlzW3Byb3BlcnR5XS5leGNsdWRlRnJvbUV4cG9ydCAmJiB0aGlzW3Byb3BlcnR5XS50b1NWRykge1xuICAgICAgICBtYXJrdXAucHVzaCh0aGlzW3Byb3BlcnR5XS50b1NWRyhyZXZpdmVyKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR0JnT3ZlcmxheUNvbG9yOiBmdW5jdGlvbihtYXJrdXAsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgZmlsbGVyID0gdGhpc1twcm9wZXJ0eV0sIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIGZpbmFsV2lkdGggPSB0aGlzLndpZHRoIC8gdnB0WzBdLFxuICAgICAgICAgIGZpbmFsSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyB2cHRbM107XG4gICAgICBpZiAoIWZpbGxlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZmlsbGVyLnRvTGl2ZSkge1xuICAgICAgICB2YXIgcmVwZWF0ID0gZmlsbGVyLnJlcGVhdDtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxyZWN0IHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgnLCBmaW5hbFdpZHRoIC8gMiwgJywnLCBmaW5hbEhlaWdodCAvIDIsICcpXCInLFxuICAgICAgICAgICcgeD1cIicsIGZpbGxlci5vZmZzZXRYIC0gZmluYWxXaWR0aCAvIDIsICdcIiB5PVwiJywgZmlsbGVyLm9mZnNldFkgLSBmaW5hbEhlaWdodCAvIDIsICdcIiAnLFxuICAgICAgICAgICd3aWR0aD1cIicsXG4gICAgICAgICAgKHJlcGVhdCA9PT0gJ3JlcGVhdC15JyB8fCByZXBlYXQgPT09ICduby1yZXBlYXQnXG4gICAgICAgICAgICA/IGZpbGxlci5zb3VyY2Uud2lkdGhcbiAgICAgICAgICAgIDogZmluYWxXaWR0aCApLFxuICAgICAgICAgICdcIiBoZWlnaHQ9XCInLFxuICAgICAgICAgIChyZXBlYXQgPT09ICdyZXBlYXQteCcgfHwgcmVwZWF0ID09PSAnbm8tcmVwZWF0J1xuICAgICAgICAgICAgPyBmaWxsZXIuc291cmNlLmhlaWdodFxuICAgICAgICAgICAgOiBmaW5hbEhlaWdodCksXG4gICAgICAgICAgJ1wiIGZpbGw9XCJ1cmwoI1NWR0lEXycgKyBmaWxsZXIuaWQgKyAnKVwiJyxcbiAgICAgICAgICAnPjwvcmVjdD5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxyZWN0IHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgJyxcbiAgICAgICAgICAnZmlsbD1cIicsIHRoaXNbcHJvcGVydHldLCAnXCInLFxuICAgICAgICAgICc+PC9yZWN0PlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIHRoZSBvYmplY3RzIG9mIGEgbXVsdGlwbGUgc2VsZWN0aW9uXG4gICAgICogdG8gdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kIHRvIGJhY2tcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbmRUb0JhY2s6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIG9ianM7XG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IG9ianMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnVuc2hpZnQob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICB0aGlzLl9vYmplY3RzLnVuc2hpZnQob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIHRoZSBvYmplY3RzIG9mIGEgbXVsdGlwbGUgc2VsZWN0aW9uXG4gICAgICogdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIG9ianM7XG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIGEgc2VsZWN0aW9uIGRvd24gaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEFuIG9wdGlvbmFsIHBhcmFtdGVyLCBpbnRlcnNlY3RpbmcgYWxsb3dlcyB0byBtb3ZlIHRoZSBvYmplY3QgaW4gYmVoaW5kXG4gICAgICogdGhlIGZpcnN0IGludGVyc2VjdGluZyBvYmplY3QuIFdoZXJlIGludGVyc2VjdGlvbiBpcyBjYWxjdWxhdGVkIHdpdGhcbiAgICAgKiBib3VuZGluZyBib3guIElmIG5vIGludGVyc2VjdGlvbiBpcyBmb3VuZCwgdGhlcmUgd2lsbCBub3QgYmUgY2hhbmdlIGluIHRoZVxuICAgICAqIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJzZWN0aW5nXSBJZiBgdHJ1ZWAsIHNlbmQgb2JqZWN0IGJlaGluZCBuZXh0IGxvd2VyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbmRCYWNrd2FyZHM6IGZ1bmN0aW9uIChvYmplY3QsIGludGVyc2VjdGluZykge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgaWR4LCBuZXdJZHgsIG9ianMsIG9ianNNb3ZlZCA9IDA7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmopO1xuICAgICAgICAgIGlmIChpZHggPiAwICsgb2Jqc01vdmVkKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpZHggLSAxO1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iaik7XG4gICAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ianNNb3ZlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgICAgIGlmIChpZHggIT09IDApIHtcbiAgICAgICAgICAvLyBpZiBvYmplY3QgaXMgbm90IG9uIHRoZSBib3R0b20gb2Ygc3RhY2tcbiAgICAgICAgICBuZXdJZHggPSB0aGlzLl9maW5kTmV3TG93ZXJJbmRleChvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZE5ld0xvd2VySW5kZXg6IGZ1bmN0aW9uKG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIHZhciBuZXdJZHgsIGk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4O1xuXG4gICAgICAgIC8vIHRyYXZlcnNlIGRvd24gdGhlIHN0YWNrIGxvb2tpbmcgZm9yIHRoZSBuZWFyZXN0IGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgICAgZm9yIChpID0gaWR4IC0gMTsgaSA+PSAwOyAtLWkpIHtcblxuICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IG9iamVjdC5pbnRlcnNlY3RzV2l0aE9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uaXNDb250YWluZWRXaXRoaW5PYmplY3Qob2JqZWN0KTtcblxuICAgICAgICAgIGlmIChpc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgbmV3SWR4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJZHg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCBvciBhIHNlbGVjdGlvbiB1cCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQW4gb3B0aW9uYWwgcGFyYW10ZXIsIGludGVyc2VjdGluZyBhbGxvd2VzIHRvIG1vdmUgdGhlIG9iamVjdCBpbiBmcm9udFxuICAgICAqIG9mIHRoZSBmaXJzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0LiBXaGVyZSBpbnRlcnNlY3Rpb24gaXMgY2FsY3VsYXRlZCB3aXRoXG4gICAgICogYm91bmRpbmcgYm94LiBJZiBubyBpbnRlcnNlY3Rpb24gaXMgZm91bmQsIHRoZXJlIHdpbGwgbm90IGJlIGNoYW5nZSBpbiB0aGVcbiAgICAgKiBzdGFjay5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVyc2VjdGluZ10gSWYgYHRydWVgLCBzZW5kIG9iamVjdCBpbiBmcm9udCBvZiBuZXh0IHVwcGVyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGJyaW5nRm9yd2FyZDogZnVuY3Rpb24gKG9iamVjdCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgaSwgb2JqLCBpZHgsIG5ld0lkeCwgb2Jqcywgb2Jqc01vdmVkID0gMDtcblxuICAgICAgaWYgKG9iamVjdCA9PT0gYWN0aXZlU2VsZWN0aW9uICYmIG9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICBvYmpzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzO1xuICAgICAgICBmb3IgKGkgPSBvYmpzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iaik7XG4gICAgICAgICAgaWYgKGlkeCA8IHRoaXMuX29iamVjdHMubGVuZ3RoIC0gMSAtIG9ianNNb3ZlZCkge1xuICAgICAgICAgICAgbmV3SWR4ID0gaWR4ICsgMTtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UobmV3SWR4LCAwLCBvYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpzTW92ZWQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgICAgICBpZiAoaWR4ICE9PSB0aGlzLl9vYmplY3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBpZiBvYmplY3QgaXMgbm90IG9uIHRvcCBvZiBzdGFjayAobGFzdCBpdGVtIGluIGFuIGFycmF5KVxuICAgICAgICAgIG5ld0lkeCA9IHRoaXMuX2ZpbmROZXdVcHBlckluZGV4KG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTmV3VXBwZXJJbmRleDogZnVuY3Rpb24ob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZykge1xuICAgICAgdmFyIG5ld0lkeCwgaSwgbGVuO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeDtcblxuICAgICAgICAvLyB0cmF2ZXJzZSB1cCB0aGUgc3RhY2sgbG9va2luZyBmb3IgdGhlIG5lYXJlc3QgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAgICBmb3IgKGkgPSBpZHggKyAxLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgICB2YXIgaXNJbnRlcnNlY3RpbmcgPSBvYmplY3QuaW50ZXJzZWN0c1dpdGhPYmplY3QodGhpcy5fb2JqZWN0c1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuaXNDb250YWluZWRXaXRoaW5PYmplY3QodGhpcy5fb2JqZWN0c1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgICBpZiAoaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdJZHggPSBpZHggKyAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3SWR4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gc3BlY2lmaWVkIGxldmVsIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBQb3NpdGlvbiB0byBtb3ZlIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBtb3ZlVG86IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4KSB7XG4gICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKGluZGV4LCAwLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhIGNhbnZhcyBlbGVtZW50IGFuZCBkaXNwb3NlIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNhbmNlbCBldmVudHVhbGx5IG9uZ29pbmcgcmVuZGVyc1xuICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuaXNSZW5kZXJpbmcpO1xuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9yRWFjaE9iamVjdChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LmRpc3Bvc2UgJiYgb2JqZWN0LmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZEltYWdlICYmIHRoaXMuYmFja2dyb3VuZEltYWdlLmRpc3Bvc2UpIHtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UgPSBudWxsO1xuICAgICAgaWYgKHRoaXMub3ZlcmxheUltYWdlICYmIHRoaXMub3ZlcmxheUltYWdlLmRpc3Bvc2UpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5SW1hZ2UuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vdmVybGF5SW1hZ2UgPSBudWxsO1xuICAgICAgdGhpcy5faVRleHRJbnN0YW5jZXMgPSBudWxsO1xuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gbnVsbDtcbiAgICAgIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5DYW52YXMgKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArICcpOiAnICtcbiAgICAgICAgICAgICAgICd7IG9iamVjdHM6ICcgKyB0aGlzLl9vYmplY3RzLmxlbmd0aCArICcgfT4nO1xuICAgIH1cbiAgfSk7XG5cbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCBmYWJyaWMuT2JzZXJ2YWJsZSk7XG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgZmFicmljLkNvbGxlY3Rpb24pO1xuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIGZhYnJpYy5EYXRhVVJMRXhwb3J0ZXIpO1xuXG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgRU1QVFlfSlNPTjogJ3tcIm9iamVjdHNcIjogW10sIFwiYmFja2dyb3VuZFwiOiBcIndoaXRlXCJ9JyxcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgd2F5IHRvIGNoZWNrIHN1cHBvcnQgb2Ygc29tZSBvZiB0aGUgY2FudmFzIG1ldGhvZHNcbiAgICAgKiAoZWl0aGVyIHRob3NlIG9mIEhUTUxDYW52YXNFbGVtZW50IGl0c2VsZiwgb3IgcmVuZGVyaW5nIGNvbnRleHQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZSBNZXRob2QgdG8gY2hlY2sgc3VwcG9ydCBmb3I7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgQ291bGQgYmUgb25lIG9mIFwic2V0TGluZURhc2hcIlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW4gfCBudWxsfSBgdHJ1ZWAgaWYgbWV0aG9kIGlzIHN1cHBvcnRlZCAob3IgYXQgbGVhc3QgZXhpc3RzKSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYG51bGxgIGlmIGNhbnZhcyBlbGVtZW50IG9yIGNvbnRleHQgY2FuIG5vdCBiZSBpbml0aWFsaXplZFxuICAgICAqL1xuICAgIHN1cHBvcnRzOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGVsID0gY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuXG4gICAgICBpZiAoIWVsIHx8ICFlbC5nZXRDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gZWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcblxuICAgICAgICBjYXNlICdzZXRMaW5lRGFzaCc6XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBjdHguc2V0TGluZURhc2ggIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEpTT04gc3RyaW5nXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI3NlcmlhbGl6YXRpb259XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvcGVjODYvfGpzRmlkZGxlIGRlbW99XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkpTT04gd2l0aG91dCBhZGRpdGlvbmFsIHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAqIHZhciBqc29uID0gY2FudmFzLnRvSlNPTigpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5KU09OIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGluY2x1ZGVkPC9jYXB0aW9uPlxuICAgKiB2YXIganNvbiA9IGNhbnZhcy50b0pTT04oWydsb2NrTW92ZW1lbnRYJywgJ2xvY2tNb3ZlbWVudFknLCAnbG9ja1JvdGF0aW9uJywgJ2xvY2tTY2FsaW5nWCcsICdsb2NrU2NhbGluZ1knLCAnbG9ja1VuaVNjYWxpbmcnXSk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkpTT04gd2l0aG91dCBkZWZhdWx0IHZhbHVlczwvY2FwdGlvbj5cbiAgICogY2FudmFzLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gZmFsc2U7XG4gICAqIHZhciBqc29uID0gY2FudmFzLnRvSlNPTigpO1xuICAgKi9cbiAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUudG9KU09OID0gZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUudG9PYmplY3Q7XG5cbiAgaWYgKGZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVQTkdTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbXBsID0gZ2V0Tm9kZUNhbnZhcyh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgcmV0dXJuIGltcGwgJiYgaW1wbC5jcmVhdGVQTkdTdHJlYW0oKTtcbiAgICB9O1xuICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmNyZWF0ZUpQRUdTdHJlYW0gPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgICB2YXIgaW1wbCA9IGdldE5vZGVDYW52YXModGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiBpbXBsICYmIGltcGwuY3JlYXRlSlBFR1N0cmVhbShvcHRzKTtcbiAgICB9O1xuICB9XG59KSgpO1xuXG5cbi8qKlxuICogQmFzZUJydXNoIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLkJhc2VCcnVzaFxuICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mcmVlZHJhd2luZ3xGcmVlZHJhd2luZyBkZW1vfVxuICovXG5mYWJyaWMuQmFzZUJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuQmFzZUJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIENvbG9yIG9mIGEgYnJ1c2hcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBjb2xvcjogJ3JnYigwLCAwLCAwKScsXG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIGEgYnJ1c2gsIGhhcyB0byBiZSBhIE51bWJlciwgbm8gc3RyaW5nIGxpdGVyYWxzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6IDEsXG5cbiAgLyoqXG4gICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlLlxuICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwic2hhZG93Q29sb3JcIiAoU3RyaW5nKSwgXCJzaGFkb3dPZmZzZXRYXCIgKE51bWJlciksXG4gICAqIFwic2hhZG93T2Zmc2V0WVwiIChOdW1iZXIpIGFuZCBcInNoYWRvd0JsdXJcIiAoTnVtYmVyKSBzaW5jZSB2MS4yLjEyXG4gICAqIEB0eXBlIGZhYnJpYy5TaGFkb3dcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHNoYWRvdzogbnVsbCxcblxuICAvKipcbiAgICogTGluZSBlbmRpbmdzIHN0eWxlIG9mIGEgYnJ1c2ggKG9uZSBvZiBcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiKVxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZUxpbmVDYXA6ICdyb3VuZCcsXG5cbiAgLyoqXG4gICAqIENvcm5lciBzdHlsZSBvZiBhIGJydXNoIChvbmUgb2YgXCJiZXZlbFwiLCBcInJvdW5kXCIsIFwibWl0ZXJcIilcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VMaW5lSm9pbjogJ3JvdW5kJyxcblxuICAvKipcbiAgICogTWF4aW11bSBtaXRlciBsZW5ndGggKHVzZWQgZm9yIHN0cm9rZUxpbmVKb2luID0gXCJtaXRlclwiKSBvZiBhIGJydXNoJ3NcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VNaXRlckxpbWl0OiAgICAgICAgIDEwLFxuXG4gIC8qKlxuICAgKiBTdHJva2UgRGFzaCBBcnJheS5cbiAgICogQHR5cGUgQXJyYXlcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZURhc2hBcnJheTogbnVsbCxcblxuICAvKipcbiAgICogU2V0cyBzaGFkb3cgb2YgYW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IG9yIHN0cmluZyAoZS5nLiBcIjJweCAycHggMTBweCByZ2JhKDAsMCwwLDAuMilcIilcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzZXRTaGFkb3c6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBmYWJyaWMuU2hhZG93KG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGJydXNoIHN0eWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldEJydXNoU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGN0eC5saW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwO1xuICAgIGN0eC5taXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0O1xuICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW47XG4gICAgaWYgKGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJykpIHtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLnN0cm9rZURhc2hBcnJheSB8fCBbXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0cmFuc2Zvcm1hdGlvbiBvbiBnaXZlbiBjb250ZXh0XG4gICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dDJkfSBjdHggY29udGV4dCB0byByZW5kZXIgb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zYXZlQW5kVHJhbnNmb3JtOiBmdW5jdGlvbihjdHgpIHtcbiAgICB2YXIgdiA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBicnVzaCBzaGFkb3cgc3R5bGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuc2hhZG93KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsXG4gICAgICAgIHpvb20gPSB0aGlzLmNhbnZhcy5nZXRab29tKCk7XG5cbiAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLnNoYWRvdy5jb2xvcjtcbiAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMuc2hhZG93LmJsdXIgKiB6b29tO1xuICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdGhpcy5zaGFkb3cub2Zmc2V0WCAqIHpvb207XG4gICAgY3R4LnNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvdy5vZmZzZXRZICogem9vbTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBicnVzaCBzaGFkb3cgc3R5bGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gJyc7XG4gICAgY3R4LnNoYWRvd0JsdXIgPSBjdHguc2hhZG93T2Zmc2V0WCA9IGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBQZW5jaWxCcnVzaCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBlbmNpbEJydXNoXG4gICAqIEBleHRlbmRzIGZhYnJpYy5CYXNlQnJ1c2hcbiAgICovXG4gIGZhYnJpYy5QZW5jaWxCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5CYXNlQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLlBlbmNpbEJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNhbnZhc30gY2FudmFzXG4gICAgICogQHJldHVybiB7ZmFicmljLlBlbmNpbEJydXNofSBJbnN0YW5jZSBvZiBhIHBlbmNpbCBicnVzaFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLl9wb2ludHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBpbnNpZGUgb24gbW91c2UgZG93biBhbmQgbW91c2UgbW92ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAgICovXG4gICAgX2RyYXdTZWdtZW50OiBmdW5jdGlvbiAoY3R4LCBwMSwgcDIpIHtcbiAgICAgIHZhciBtaWRQb2ludCA9IHAxLm1pZFBvaW50RnJvbShwMik7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhwMS54LCBwMS55LCBtaWRQb2ludC54LCBtaWRQb2ludC55KTtcbiAgICAgIHJldHVybiBtaWRQb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5vdm9rZWQgb24gbW91c2UgZG93blxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAgICovXG4gICAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIHRoaXMuX3ByZXBhcmVGb3JEcmF3aW5nKHBvaW50ZXIpO1xuICAgICAgLy8gY2FwdHVyZSBjb29yZGluYXRlcyBpbW1lZGlhdGVseVxuICAgICAgLy8gdGhpcyBhbGxvd3MgdG8gZHJhdyBkb3RzICh3aGVuIG1vdmVtZW50IG5ldmVyIG9jY3VycylcbiAgICAgIHRoaXMuX2NhcHR1cmVEcmF3aW5nUGF0aChwb2ludGVyKTtcbiAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbm92b2tlZCBvbiBtb3VzZSBtb3ZlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgaWYgKHRoaXMuX2NhcHR1cmVEcmF3aW5nUGF0aChwb2ludGVyKSAmJiB0aGlzLl9wb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAodGhpcy5uZWVkc0Z1bGxSZW5kZXIpIHtcbiAgICAgICAgICAvLyByZWRyYXcgY3VydmVcbiAgICAgICAgICAvLyBjbGVhciB0b3AgY2FudmFzXG4gICAgICAgICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLl9wb2ludHMsIGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICAgICAgLy8gZHJhdyB0aGUgY3VydmUgdXBkYXRlXG4gICAgICAgICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuICAgICAgICAgIGlmICh0aGlzLm9sZEVuZCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLm9sZEVuZC54LCB0aGlzLm9sZEVuZC55KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vbGRFbmQgPSB0aGlzLl9kcmF3U2VnbWVudChjdHgsIHBvaW50c1tsZW5ndGggLSAyXSwgcG9pbnRzW2xlbmd0aCAtIDFdLCB0cnVlKTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAgICovXG4gICAgb25Nb3VzZVVwOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMub2xkRW5kID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fZmluYWxpemVBbmRBZGRQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgQWN0dWFsIG1vdXNlIHBvc2l0aW9uIHJlbGF0ZWQgdG8gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfcHJlcGFyZUZvckRyYXdpbmc6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcblxuICAgICAgdmFyIHAgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcblxuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIHRoaXMuX2FkZFBvaW50KHApO1xuICAgICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBiZSBhZGRlZCB0byBwb2ludHMgYXJyYXlcbiAgICAgKi9cbiAgICBfYWRkUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICBpZiAodGhpcy5fcG9pbnRzLmxlbmd0aCA+IDEgJiYgcG9pbnQuZXEodGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5fcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHBvaW50cyBhcnJheSBhbmQgc2V0IGNvbnRleHRUb3AgY2FudmFzIHN0eWxlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3BvaW50cy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5fc2V0QnJ1c2hTdHlsZXMoKTtcbiAgICAgIHZhciBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcik7XG4gICAgICB0aGlzLm5lZWRzRnVsbFJlbmRlciA9IChjb2xvci5nZXRBbHBoYSgpIDwgMSk7XG4gICAgICB0aGlzLl9zZXRTaGFkb3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciBBY3R1YWwgbW91c2UgcG9zaXRpb24gcmVsYXRlZCB0byB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIF9jYXB0dXJlRHJhd2luZ1BhdGg6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIHZhciBwb2ludGVyUG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRQb2ludChwb2ludGVyUG9pbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgc21vb3RoIHBhdGggb24gdGhlIHRvcENhbnZhcyB1c2luZyBxdWFkcmF0aWNDdXJ2ZVRvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgbGVuLFxuICAgICAgICAgIHAxID0gdGhpcy5fcG9pbnRzWzBdLFxuICAgICAgICAgIHAyID0gdGhpcy5fcG9pbnRzWzFdO1xuXG4gICAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAvL2lmIHdlIG9ubHkgaGF2ZSAyIHBvaW50cyBpbiB0aGUgcGF0aCBhbmQgdGhleSBhcmUgdGhlIHNhbWVcbiAgICAgIC8vaXQgbWVhbnMgdGhhdCB0aGUgdXNlciBvbmx5IGNsaWNrZWQgdGhlIGNhbnZhcyB3aXRob3V0IG1vdmluZyB0aGUgbW91c2VcbiAgICAgIC8vdGhlbiB3ZSBzaG91bGQgYmUgZHJhd2luZyBhIGRvdC4gQSBwYXRoIGlzbid0IGRyYXduIGJldHdlZW4gdHdvIGlkZW50aWNhbCBkb3RzXG4gICAgICAvL3RoYXQncyB3aHkgd2Ugc2V0IHRoZW0gYXBhcnQgYSBiaXRcbiAgICAgIGlmICh0aGlzLl9wb2ludHMubGVuZ3RoID09PSAyICYmIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueSkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoIC8gMTAwMDtcbiAgICAgICAgcDEgPSBuZXcgZmFicmljLlBvaW50KHAxLngsIHAxLnkpO1xuICAgICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocDIueCwgcDIueSk7XG4gICAgICAgIHAxLnggLT0gd2lkdGg7XG4gICAgICAgIHAyLnggKz0gd2lkdGg7XG4gICAgICB9XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuXG4gICAgICBmb3IgKGkgPSAxLCBsZW4gPSB0aGlzLl9wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gd2UgcGljayB0aGUgcG9pbnQgYmV0d2VlbiBwaSArIDEgJiBwaSArIDIgYXMgdGhlXG4gICAgICAgIC8vIGVuZCBwb2ludCBhbmQgcDEgYXMgb3VyIGNvbnRyb2wgcG9pbnQuXG4gICAgICAgIHRoaXMuX2RyYXdTZWdtZW50KGN0eCwgcDEsIHAyKTtcbiAgICAgICAgcDEgPSB0aGlzLl9wb2ludHNbaV07XG4gICAgICAgIHAyID0gdGhpcy5fcG9pbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIERyYXcgbGFzdCBsaW5lIGFzIGEgc3RyYWlnaHQgbGluZSB3aGlsZVxuICAgICAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgcG9pbnQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGVcbiAgICAgIC8vIHRoZSBiZXppZXIgY29udHJvbCBwb2ludFxuICAgICAgY3R4LmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHBvaW50cyB0byBTVkcgcGF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyBwYXRoXG4gICAgICovXG4gICAgY29udmVydFBvaW50c1RvU1ZHUGF0aDogZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgICB2YXIgcGF0aCA9IFtdLCBpLCB3aWR0aCA9IHRoaXMud2lkdGggLyAxMDAwLFxuICAgICAgICAgIHAxID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpLFxuICAgICAgICAgIHAyID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpLFxuICAgICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsIG11bHRTaWduWCA9IDEsIG11bHRTaWduWSA9IDEsIG1hbnlQb2ludHMgPSBsZW4gPiAyO1xuXG4gICAgICBpZiAobWFueVBvaW50cykge1xuICAgICAgICBtdWx0U2lnblggPSBwb2ludHNbMl0ueCA8IHAyLnggPyAtMSA6IHBvaW50c1syXS54ID09PSBwMi54ID8gMCA6IDE7XG4gICAgICAgIG11bHRTaWduWSA9IHBvaW50c1syXS55IDwgcDIueSA/IC0xIDogcG9pbnRzWzJdLnkgPT09IHAyLnkgPyAwIDogMTtcbiAgICAgIH1cbiAgICAgIHBhdGgucHVzaCgnTSAnLCBwMS54IC0gbXVsdFNpZ25YICogd2lkdGgsICcgJywgcDEueSAtIG11bHRTaWduWSAqIHdpZHRoLCAnICcpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghcDEuZXEocDIpKSB7XG4gICAgICAgICAgdmFyIG1pZFBvaW50ID0gcDEubWlkUG9pbnRGcm9tKHAyKTtcbiAgICAgICAgICAvLyBwMSBpcyBvdXIgYmV6aWVyIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAvLyBtaWRwb2ludCBpcyBvdXIgZW5kcG9pbnRcbiAgICAgICAgICAvLyBzdGFydCBwb2ludCBpcyBwKGktMSkgdmFsdWUuXG4gICAgICAgICAgcGF0aC5wdXNoKCdRICcsIHAxLngsICcgJywgcDEueSwgJyAnLCBtaWRQb2ludC54LCAnICcsIG1pZFBvaW50LnksICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcDEgPSBwb2ludHNbaV07XG4gICAgICAgIGlmICgoaSArIDEpIDwgcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHAyID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hbnlQb2ludHMpIHtcbiAgICAgICAgbXVsdFNpZ25YID0gcDEueCA+IHBvaW50c1tpIC0gMl0ueCA/IDEgOiBwMS54ID09PSBwb2ludHNbaSAtIDJdLnggPyAwIDogLTE7XG4gICAgICAgIG11bHRTaWduWSA9IHAxLnkgPiBwb2ludHNbaSAtIDJdLnkgPyAxIDogcDEueSA9PT0gcG9pbnRzW2kgLSAyXS55ID8gMCA6IC0xO1xuICAgICAgfVxuICAgICAgcGF0aC5wdXNoKCdMICcsIHAxLnggKyBtdWx0U2lnblggKiB3aWR0aCwgJyAnLCBwMS55ICsgbXVsdFNpZ25ZICogd2lkdGgpO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgZmFicmljLlBhdGggb2JqZWN0IHRvIGFkZCBvbiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aERhdGEgUGF0aCBkYXRhXG4gICAgICogQHJldHVybiB7ZmFicmljLlBhdGh9IFBhdGggdG8gYWRkIG9uIGNhbnZhc1xuICAgICAqL1xuICAgIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgICB2YXIgcGF0aCA9IG5ldyBmYWJyaWMuUGF0aChwYXRoRGF0YSwge1xuICAgICAgICBmaWxsOiBudWxsLFxuICAgICAgICBzdHJva2U6IHRoaXMuY29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBzdHJva2VMaW5lQ2FwOiB0aGlzLnN0cm9rZUxpbmVDYXAsXG4gICAgICAgIHN0cm9rZU1pdGVyTGltaXQ6IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCxcbiAgICAgICAgc3Ryb2tlTGluZUpvaW46IHRoaXMuc3Ryb2tlTGluZUpvaW4sXG4gICAgICAgIHN0cm9rZURhc2hBcnJheTogdGhpcy5zdHJva2VEYXNoQXJyYXksXG4gICAgICB9KTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IG5ldyBmYWJyaWMuUG9pbnQocGF0aC5sZWZ0ICsgcGF0aC53aWR0aCAvIDIsIHBhdGgudG9wICsgcGF0aC5oZWlnaHQgLyAyKTtcbiAgICAgIHBvc2l0aW9uID0gcGF0aC50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKHBvc2l0aW9uLCAnY2VudGVyJywgJ2NlbnRlcicsIHBhdGgub3JpZ2luWCwgcGF0aC5vcmlnaW5ZKTtcbiAgICAgIHBhdGgudG9wID0gcG9zaXRpb24ueTtcbiAgICAgIHBhdGgubGVmdCA9IHBvc2l0aW9uLng7XG4gICAgICBpZiAodGhpcy5zaGFkb3cpIHtcbiAgICAgICAgdGhpcy5zaGFkb3cuYWZmZWN0U3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgcGF0aC5zZXRTaGFkb3codGhpcy5zaGFkb3cpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2V1cCBhZnRlciBkcmF3aW5nIHRoZSBwYXRoIG9uIGNvbnRleHRUb3AgY2FudmFzXG4gICAgICogd2UgdXNlIHRoZSBwb2ludHMgY2FwdHVyZWQgdG8gY3JlYXRlIGFuIG5ldyBmYWJyaWMgcGF0aCBvYmplY3RcbiAgICAgKiBhbmQgYWRkIGl0IHRvIHRoZSBmYWJyaWMgY2FudmFzLlxuICAgICAqL1xuICAgIF9maW5hbGl6ZUFuZEFkZFBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMuY29udmVydFBvaW50c1RvU1ZHUGF0aCh0aGlzLl9wb2ludHMpLmpvaW4oJycpO1xuICAgICAgaWYgKHBhdGhEYXRhID09PSAnTSAwIDAgUSAwIDAgMCAwIEwgMCAwJykge1xuICAgICAgICAvLyBkbyBub3QgY3JlYXRlIDAgd2lkdGgvaGVpZ2h0IHBhdGhzLCBhcyB0aGV5IGFyZVxuICAgICAgICAvLyByZW5kZXJlZCBpbmNvbnNpc3RlbnRseSBhY3Jvc3MgYnJvd3NlcnNcbiAgICAgICAgLy8gRmlyZWZveCA0LCBmb3IgZXhhbXBsZSwgcmVuZGVycyBhIGRvdCxcbiAgICAgICAgLy8gd2hlcmVhcyBDaHJvbWUgMTAgcmVuZGVycyBub3RoaW5nXG4gICAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IHRoaXMuY3JlYXRlUGF0aChwYXRoRGF0YSk7XG4gICAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgICB0aGlzLmNhbnZhcy5hZGQocGF0aCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgIHBhdGguc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLl9yZXNldFNoYWRvdygpO1xuXG5cbiAgICAgIC8vIGZpcmUgZXZlbnQgJ3BhdGgnIGNyZWF0ZWRcbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogcGF0aCB9KTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4vKipcbiAqIENpcmNsZUJydXNoIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLkNpcmNsZUJydXNoXG4gKi9cbmZhYnJpYy5DaXJjbGVCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5CYXNlQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLkNpcmNsZUJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIGEgYnJ1c2hcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB3aWR0aDogMTAsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7ZmFicmljLkNhbnZhc30gY2FudmFzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DaXJjbGVCcnVzaH0gSW5zdGFuY2Ugb2YgYSBjaXJjbGUgYnJ1c2hcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgaW5zaWRlIG9uIG1vdXNlIGRvd24gYW5kIG1vdXNlIG1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIGRyYXdEb3Q6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB2YXIgcG9pbnQgPSB0aGlzLmFkZFBvaW50KHBvaW50ZXIpLFxuICAgICAgICBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICBjdHguZmlsbFN0eWxlID0gcG9pbnQuZmlsbDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBwb2ludC5yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIGRvd25cbiAgICovXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5wb2ludHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fc2V0U2hhZG93KCk7XG4gICAgdGhpcy5kcmF3RG90KHBvaW50ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGZ1bGwgc3RhdGUgb2YgdGhlIGJydXNoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4ICA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIGksIGxlbixcbiAgICAgICAgcG9pbnRzID0gdGhpcy5wb2ludHMsIHBvaW50O1xuICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHBvaW50LmZpbGw7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIHBvaW50LnJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLmRyYXdEb3QocG9pbnRlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgdXBcbiAgICovXG4gIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmUgPSB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSwgaSwgbGVuO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gZmFsc2U7XG5cbiAgICB2YXIgY2lyY2xlcyA9IFtdO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMucG9pbnRzW2ldLFxuICAgICAgICAgIGNpcmNsZSA9IG5ldyBmYWJyaWMuQ2lyY2xlKHtcbiAgICAgICAgICAgIHJhZGl1czogcG9pbnQucmFkaXVzLFxuICAgICAgICAgICAgbGVmdDogcG9pbnQueCxcbiAgICAgICAgICAgIHRvcDogcG9pbnQueSxcbiAgICAgICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgICAgICBmaWxsOiBwb2ludC5maWxsXG4gICAgICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2hhZG93ICYmIGNpcmNsZS5zZXRTaGFkb3codGhpcy5zaGFkb3cpO1xuXG4gICAgICBjaXJjbGVzLnB1c2goY2lyY2xlKTtcbiAgICB9XG4gICAgdmFyIGdyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChjaXJjbGVzKTtcbiAgICBncm91cC5jYW52YXMgPSB0aGlzLmNhbnZhcztcblxuICAgIHRoaXMuY2FudmFzLmFkZChncm91cCk7XG4gICAgdGhpcy5jYW52YXMuZmlyZSgncGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcblxuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9yZXNldFNoYWRvdygpO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZTtcbiAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gSnVzdCBhZGRlZCBwb2ludGVyIHBvaW50XG4gICAqL1xuICBhZGRQb2ludDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHZhciBwb2ludGVyUG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KSxcblxuICAgICAgICBjaXJjbGVSYWRpdXMgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoXG4gICAgICAgICAgTWF0aC5tYXgoMCwgdGhpcy53aWR0aCAtIDIwKSwgdGhpcy53aWR0aCArIDIwKSAvIDIsXG5cbiAgICAgICAgY2lyY2xlQ29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpXG4gICAgICAgICAgLnNldEFscGhhKGZhYnJpYy51dGlsLmdldFJhbmRvbUludCgwLCAxMDApIC8gMTAwKVxuICAgICAgICAgIC50b1JnYmEoKTtcblxuICAgIHBvaW50ZXJQb2ludC5yYWRpdXMgPSBjaXJjbGVSYWRpdXM7XG4gICAgcG9pbnRlclBvaW50LmZpbGwgPSBjaXJjbGVDb2xvcjtcblxuICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnRlclBvaW50KTtcblxuICAgIHJldHVybiBwb2ludGVyUG9pbnQ7XG4gIH1cbn0pO1xuXG5cbi8qKlxuICogU3ByYXlCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5TcHJheUJydXNoXG4gKi9cbmZhYnJpYy5TcHJheUJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoIGZhYnJpYy5CYXNlQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLlNwcmF5QnJ1c2gucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogV2lkdGggb2YgYSBzcHJheVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHdpZHRoOiAgICAgICAgICAgICAgMTAsXG5cbiAgLyoqXG4gICAqIERlbnNpdHkgb2YgYSBzcHJheSAobnVtYmVyIG9mIGRvdHMgcGVyIGNodW5rKVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGRlbnNpdHk6ICAgICAgICAgICAgMjAsXG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIHNwcmF5IGRvdHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBkb3RXaWR0aDogICAgICAgICAgIDEsXG5cbiAgLyoqXG4gICAqIFdpZHRoIHZhcmlhbmNlIG9mIHNwcmF5IGRvdHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBkb3RXaWR0aFZhcmlhbmNlOiAgIDEsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3BhY2l0eSBvZiBhIGRvdCBzaG91bGQgYmUgcmFuZG9tXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHJhbmRvbU9wYWNpdHk6ICAgICAgICBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciBvdmVybGFwcGluZyBkb3RzIChyZWN0YW5nbGVzKSBzaG91bGQgYmUgcmVtb3ZlZCAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICogQGRlZmF1bHRcbiAgICovXG4gIG9wdGltaXplT3ZlcmxhcHBpbmc6ICB0cnVlLFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuU3ByYXlCcnVzaH0gSW5zdGFuY2Ugb2YgYSBzcHJheSBicnVzaFxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5zcHJheUNodW5rcyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIGRvd25cbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5zcHJheUNodW5rcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9zZXRTaGFkb3coKTtcblxuICAgIHRoaXMuYWRkU3ByYXlDaHVuayhwb2ludGVyKTtcbiAgICB0aGlzLnJlbmRlcih0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIG1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5hZGRTcHJheUNodW5rKHBvaW50ZXIpO1xuICAgIHRoaXMucmVuZGVyKHRoaXMuc3ByYXlDaHVua1BvaW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgdXBcbiAgICovXG4gIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmUgPSB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHJlY3RzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWxlbiA9IHRoaXMuc3ByYXlDaHVua3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YXIgc3ByYXlDaHVuayA9IHRoaXMuc3ByYXlDaHVua3NbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gc3ByYXlDaHVuay5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcblxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBmYWJyaWMuUmVjdCh7XG4gICAgICAgICAgd2lkdGg6IHNwcmF5Q2h1bmtbal0ud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzcHJheUNodW5rW2pdLndpZHRoLFxuICAgICAgICAgIGxlZnQ6IHNwcmF5Q2h1bmtbal0ueCArIDEsXG4gICAgICAgICAgdG9wOiBzcHJheUNodW5rW2pdLnkgKyAxLFxuICAgICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW1pemVPdmVybGFwcGluZykge1xuICAgICAgcmVjdHMgPSB0aGlzLl9nZXRPcHRpbWl6ZWRSZWN0cyhyZWN0cyk7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChyZWN0cyk7XG4gICAgdGhpcy5zaGFkb3cgJiYgZ3JvdXAuc2V0U2hhZG93KHRoaXMuc2hhZG93KTtcbiAgICB0aGlzLmNhbnZhcy5hZGQoZ3JvdXApO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZWN0c1xuICAgKi9cbiAgX2dldE9wdGltaXplZFJlY3RzOiBmdW5jdGlvbihyZWN0cykge1xuXG4gICAgLy8gYXZvaWQgY3JlYXRpbmcgZHVwbGljYXRlIHJlY3RzIGF0IHRoZSBzYW1lIGNvb3JkaW5hdGVzXG4gICAgdmFyIHVuaXF1ZVJlY3RzID0geyB9LCBrZXksIGksIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSByZWN0c1tpXS5sZWZ0ICsgJycgKyByZWN0c1tpXS50b3A7XG4gICAgICBpZiAoIXVuaXF1ZVJlY3RzW2tleV0pIHtcbiAgICAgICAgdW5pcXVlUmVjdHNba2V5XSA9IHJlY3RzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdW5pcXVlUmVjdHNBcnJheSA9IFtdO1xuICAgIGZvciAoa2V5IGluIHVuaXF1ZVJlY3RzKSB7XG4gICAgICB1bmlxdWVSZWN0c0FycmF5LnB1c2godW5pcXVlUmVjdHNba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXF1ZVJlY3RzQXJyYXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBuZXcgY2h1bmsgb2Ygc3ByYXkgYnJ1c2hcbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24oc3ByYXlDaHVuaykge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBpLCBsZW47XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG5cbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzcHJheUNodW5rLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBzcHJheUNodW5rW2ldO1xuICAgICAgaWYgKHR5cGVvZiBwb2ludC5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBwb2ludC5vcGFjaXR5O1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxSZWN0KHBvaW50LngsIHBvaW50LnksIHBvaW50LndpZHRoLCBwb2ludC53aWR0aCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhbGwgc3ByYXkgY2h1bmtzXG4gICAqL1xuICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgaWxlbjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcblxuICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGhpcy5yZW5kZXIodGhpcy5zcHJheUNodW5rc1tpXSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBhZGRTcHJheUNodW5rOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5zcHJheUNodW5rUG9pbnRzID0gW107XG5cbiAgICB2YXIgeCwgeSwgd2lkdGgsIHJhZGl1cyA9IHRoaXMud2lkdGggLyAyLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGVuc2l0eTsgaSsrKSB7XG5cbiAgICAgIHggPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQocG9pbnRlci54IC0gcmFkaXVzLCBwb2ludGVyLnggKyByYWRpdXMpO1xuICAgICAgeSA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChwb2ludGVyLnkgLSByYWRpdXMsIHBvaW50ZXIueSArIHJhZGl1cyk7XG5cbiAgICAgIGlmICh0aGlzLmRvdFdpZHRoVmFyaWFuY2UpIHtcbiAgICAgICAgd2lkdGggPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoXG4gICAgICAgICAgLy8gYm90dG9tIGNsYW1wIHdpZHRoIHRvIDFcbiAgICAgICAgICBNYXRoLm1heCgxLCB0aGlzLmRvdFdpZHRoIC0gdGhpcy5kb3RXaWR0aFZhcmlhbmNlKSxcbiAgICAgICAgICB0aGlzLmRvdFdpZHRoICsgdGhpcy5kb3RXaWR0aFZhcmlhbmNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aWR0aCA9IHRoaXMuZG90V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoeCwgeSk7XG4gICAgICBwb2ludC53aWR0aCA9IHdpZHRoO1xuXG4gICAgICBpZiAodGhpcy5yYW5kb21PcGFjaXR5KSB7XG4gICAgICAgIHBvaW50Lm9wYWNpdHkgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoMCwgMTAwKSAvIDEwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zcHJheUNodW5rUG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH1cblxuICAgIHRoaXMuc3ByYXlDaHVua3MucHVzaCh0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9XG59KTtcblxuXG4vKipcbiAqIFBhdHRlcm5CcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5QYXR0ZXJuQnJ1c2hcbiAqIEBleHRlbmRzIGZhYnJpYy5CYXNlQnJ1c2hcbiAqL1xuZmFicmljLlBhdHRlcm5CcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5QZW5jaWxCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuUGF0dGVybkJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgZ2V0UGF0dGVyblNyYzogZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZG90V2lkdGggPSAyMCxcbiAgICAgICAgZG90RGlzdGFuY2UgPSA1LFxuICAgICAgICBwYXR0ZXJuQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICBwYXR0ZXJuQ3R4ID0gcGF0dGVybkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgcGF0dGVybkNhbnZhcy53aWR0aCA9IHBhdHRlcm5DYW52YXMuaGVpZ2h0ID0gZG90V2lkdGggKyBkb3REaXN0YW5jZTtcblxuICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICBwYXR0ZXJuQ3R4LmJlZ2luUGF0aCgpO1xuICAgIHBhdHRlcm5DdHguYXJjKGRvdFdpZHRoIC8gMiwgZG90V2lkdGggLyAyLCBkb3RXaWR0aCAvIDIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgcGF0dGVybkN0eC5jbG9zZVBhdGgoKTtcbiAgICBwYXR0ZXJuQ3R4LmZpbGwoKTtcblxuICAgIHJldHVybiBwYXR0ZXJuQ2FudmFzO1xuICB9LFxuXG4gIGdldFBhdHRlcm5TcmNGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLmdldFBhdHRlcm5TcmMpLnJlcGxhY2UoJ3RoaXMuY29sb3InLCAnXCInICsgdGhpcy5jb2xvciArICdcIicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFwicGF0dGVyblwiIGluc3RhbmNlIHByb3BlcnR5XG4gICAqL1xuICBnZXRQYXR0ZXJuOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuY29udGV4dFRvcC5jcmVhdGVQYXR0ZXJuKHRoaXMuc291cmNlIHx8IHRoaXMuZ2V0UGF0dGVyblNyYygpLCAncmVwZWF0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc3R5bGVzXG4gICAqL1xuICBfc2V0QnJ1c2hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0QnJ1c2hTdHlsZXMnKTtcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLnN0cm9rZVN0eWxlID0gdGhpcy5nZXRQYXR0ZXJuKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgcGF0aFxuICAgKi9cbiAgY3JlYXRlUGF0aDogZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMuY2FsbFN1cGVyKCdjcmVhdGVQYXRoJywgcGF0aERhdGEpLFxuICAgICAgICB0b3BMZWZ0ID0gcGF0aC5fZ2V0TGVmdFRvcENvb3JkcygpLnNjYWxhckFkZChwYXRoLnN0cm9rZVdpZHRoIC8gMik7XG5cbiAgICBwYXRoLnN0cm9rZSA9IG5ldyBmYWJyaWMuUGF0dGVybih7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlIHx8IHRoaXMuZ2V0UGF0dGVyblNyY0Z1bmN0aW9uKCksXG4gICAgICBvZmZzZXRYOiAtdG9wTGVmdC54LFxuICAgICAgb2Zmc2V0WTogLXRvcExlZnQueVxuICAgIH0pO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGdldFBvaW50ZXIgPSBmYWJyaWMudXRpbC5nZXRQb2ludGVyLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICByYWRpYW5zVG9EZWdyZWVzID0gZmFicmljLnV0aWwucmFkaWFuc1RvRGVncmVlcyxcbiAgICAgIGF0YW4yID0gTWF0aC5hdGFuMixcbiAgICAgIGFicyA9IE1hdGguYWJzLFxuICAgICAgc3VwcG9ydExpbmVEYXNoID0gZmFicmljLlN0YXRpY0NhbnZhcy5zdXBwb3J0cygnc2V0TGluZURhc2gnKSxcblxuICAgICAgU1RST0tFX09GRlNFVCA9IDAuNTtcblxuICAvKipcbiAgICogQ2FudmFzIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuQ2FudmFzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXNcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjY2FudmFzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQ2FudmFzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBmaXJlcyBvYmplY3Q6bW9kaWZpZWRcbiAgICogQGZpcmVzIG9iamVjdDpyb3RhdGVkXG4gICAqIEBmaXJlcyBvYmplY3Q6c2NhbGVkXG4gICAqIEBmaXJlcyBvYmplY3Q6bW92ZWRcbiAgICogQGZpcmVzIG9iamVjdDpza2V3ZWRcbiAgICogQGZpcmVzIG9iamVjdDpyb3RhdGluZ1xuICAgKiBAZmlyZXMgb2JqZWN0OnNjYWxpbmdcbiAgICogQGZpcmVzIG9iamVjdDptb3ZpbmdcbiAgICogQGZpcmVzIG9iamVjdDpza2V3aW5nXG4gICAqIEBmaXJlcyBvYmplY3Q6c2VsZWN0ZWQgdGhpcyBldmVudCBpcyBkZXByZWNhdGVkLiB1c2Ugc2VsZWN0aW9uOmNyZWF0ZWRcbiAgICpcbiAgICogQGZpcmVzIGJlZm9yZTp0cmFuc2Zvcm1cbiAgICogQGZpcmVzIGJlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOmNsZWFyZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjp1cGRhdGVkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y3JlYXRlZFxuICAgKlxuICAgKiBAZmlyZXMgcGF0aDpjcmVhdGVkXG4gICAqIEBmaXJlcyBtb3VzZTpkb3duXG4gICAqIEBmaXJlcyBtb3VzZTptb3ZlXG4gICAqIEBmaXJlcyBtb3VzZTp1cFxuICAgKiBAZmlyZXMgbW91c2U6ZG93bjpiZWZvcmVcbiAgICogQGZpcmVzIG1vdXNlOm1vdmU6YmVmb3JlXG4gICAqIEBmaXJlcyBtb3VzZTp1cDpiZWZvcmVcbiAgICogQGZpcmVzIG1vdXNlOm92ZXJcbiAgICogQGZpcmVzIG1vdXNlOm91dFxuICAgKiBAZmlyZXMgbW91c2U6ZGJsY2xpY2tcbiAgICpcbiAgICogQGZpcmVzIGRyYWdvdmVyXG4gICAqIEBmaXJlcyBkcmFnZW50ZXJcbiAgICogQGZpcmVzIGRyYWdsZWF2ZVxuICAgKiBAZmlyZXMgZHJvcFxuICAgKlxuICAgKi9cbiAgZmFicmljLkNhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5TdGF0aWNDYW52YXMsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBlbCAmbHQ7Y2FudmFzPiBlbGVtZW50IHRvIGluaXRpYWxpemUgaW5zdGFuY2Ugb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5yZW5kZXJBbmRSZXNldEJvdW5kID0gdGhpcy5yZW5kZXJBbmRSZXNldC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmQgPSB0aGlzLnJlcXVlc3RSZW5kZXJBbGwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRTdGF0aWMoZWwsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEludGVyYWN0aXZlKCk7XG4gICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgY2FuIGJlIHRyYW5zZm9ybWVkIGJ5IG9uZSBzaWRlICh1bnByb3BvcnRpb25hbGx5KVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuaVNjYWxlVHJhbnNmb3JtOiAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgdW5wcm9wb3J0aW9uYWwgc2NhbGluZ1xuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB1bmlTY2FsZUtleTogICAgICAgICAgICdzaGlmdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHNjYWxlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRTY2FsaW5nOiAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHJvdGF0ZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkUm90YXRpb246ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgY2VudGVyZWQgVHJhbnNmb3JtXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQgZmVhdHVyZSBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkS2V5OiAgICAgICAgICAgJ2FsdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IGVuYWJsZSBhbHRlcm5hdGUgYWN0aW9uIG9uIGNvcm5lclxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbHRBY3Rpb25LZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgY2FudmFzIGlzIGludGVyYWN0aXZlLiBUaGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgY2hhbmdlZC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbnRlcmFjdGl2ZTogICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgZ3JvdXAgc2VsZWN0aW9uIHNob3VsZCBiZSBlbmFibGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgb3Iga2V5cyBlbmFibGUgbXVsdGlwbGUgY2xpY2sgc2VsZWN0aW9uXG4gICAgICogUGFzcyB2YWx1ZSBhcyBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciBlbXB0eSBvciBjb250YWluaW5nIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ3xBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uS2V5OiAgICAgICAgICAgJ3NoaWZ0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIGFsdGVybmF0aXZlIHNlbGVjdGlvblxuICAgICAqIGluIGNhc2Ugb2YgdGFyZ2V0IG92ZXJsYXBwaW5nIHdpdGggYWN0aXZlIG9iamVjdFxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBGb3IgYSBzZXJpZXMgb2YgcmVhc29uIHRoYXQgY29tZSBmcm9tIHRoZSBnZW5lcmFsIGV4cGVjdGF0aW9ucyBvbiBob3dcbiAgICAgKiB0aGluZ3Mgc2hvdWxkIHdvcmssIHRoaXMgZmVhdHVyZSB3b3JrcyBvbmx5IGZvciBwcmVzZXJ2ZU9iamVjdFN0YWNraW5nIHRydWUuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAdHlwZSBudWxsfFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWx0U2VsZWN0aW9uS2V5OiAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHNlbGVjdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQ29sb3I6ICAgICAgICAgJ3JnYmEoMTAwLCAxMDAsIDI1NSwgMC4zKScsIC8vIGJsdWVcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZGFzaCBhcnJheSBwYXR0ZXJuXG4gICAgICogSWYgbm90IGVtcHR5IHRoZSBzZWxlY3Rpb24gYm9yZGVyIGlzIGRhc2hlZFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc2VsZWN0aW9uRGFzaEFycmF5OiAgICAgW10sXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiB0aGUgYm9yZGVyIG9mIHNlbGVjdGlvbiAodXN1YWxseSBzbGlnaHRseSBkYXJrZXIgdGhhbiBjb2xvciBvZiBzZWxlY3Rpb24gaXRzZWxmKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQm9yZGVyQ29sb3I6ICAgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIGxpbmUgdXNlZCBpbiBvYmplY3QvZ3JvdXAgc2VsZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25MaW5lV2lkdGg6ICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IG9ubHkgc2hhcGVzIHRoYXQgYXJlIGZ1bGx5IGNvbnRhaW5lZCBpbiB0aGUgZHJhZ2dlZCBzZWxlY3Rpb24gcmVjdGFuZ2xlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkZ1bGx5Q29udGFpbmVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBob3ZlcmluZyBvdmVyIGFuIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhvdmVyQ3Vyc29yOiAgICAgICAgICAgICdtb3ZlJyxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBtb3ZpbmcgYW4gb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW92ZUN1cnNvcjogICAgICAgICAgICAgJ21vdmUnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCBmb3IgdGhlIGVudGlyZSBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGRlZmF1bHRDdXJzb3I6ICAgICAgICAgICdkZWZhdWx0JyxcblxuICAgIC8qKlxuICAgICAqIEN1cnNvciB2YWx1ZSB1c2VkIGR1cmluZyBmcmVlIGRyYXdpbmdcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZyZWVEcmF3aW5nQ3Vyc29yOiAgICAgICdjcm9zc2hhaXInLFxuXG4gICAgLyoqXG4gICAgICogQ3Vyc29yIHZhbHVlIHVzZWQgZm9yIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByb3RhdGlvbkN1cnNvcjogICAgICAgICAnY3Jvc3NoYWlyJyxcblxuICAgIC8qKlxuICAgICAqIEN1cnNvciB2YWx1ZSB1c2VkIGZvciBkaXNhYmxlZCBlbGVtZW50cyAoIGNvcm5lcnMgd2l0aCBkaXNhYmxlZCBhY3Rpb24gKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbm90QWxsb3dlZEN1cnNvcjogICAgICAgICAnbm90LWFsbG93ZWQnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBlbGVtZW50IGNsYXNzIHRoYXQncyBnaXZlbiB0byB3cmFwcGVyIChkaXYpIGVsZW1lbnQgb2YgY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb250YWluZXJDbGFzczogICAgICAgICAnY2FudmFzLWNvbnRhaW5lcicsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdCBkZXRlY3Rpb24gaGFwcGVucyBvbiBwZXItcGl4ZWwgYmFzaXMgcmF0aGVyIHRoYW4gb24gcGVyLWJvdW5kaW5nLWJveFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBlclBpeGVsVGFyZ2V0RmluZDogICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyBhcm91bmQgdGFyZ2V0IHBpeGVsIHRvIHRvbGVyYXRlIChjb25zaWRlciBhY3RpdmUpIGR1cmluZyBvYmplY3QgZGV0ZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0YXJnZXRGaW5kVG9sZXJhbmNlOiAgICAwLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0YXJnZXQgZGV0ZWN0aW9uIGlzIHNraXBwZWQgd2hlbiBob3ZlcmluZyBvdmVyIGNhbnZhcy4gVGhpcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNraXBUYXJnZXRGaW5kOiAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBtb3VzZSBldmVudHMgb24gY2FudmFzIChtb3VzZWRvd24vbW91c2Vtb3ZlL21vdXNldXApIHJlc3VsdCBpbiBmcmVlIGRyYXdpbmcuXG4gICAgICogQWZ0ZXIgbW91c2Vkb3duLCBtb3VzZW1vdmUgY3JlYXRlcyBhIHNoYXBlLFxuICAgICAqIGFuZCB0aGVuIG1vdXNldXAgZmluYWxpemVzIGl0IGFuZCBhZGRzIGFuIGluc3RhbmNlIG9mIGBmYWJyaWMuUGF0aGAgb250byBjYW52YXMuXG4gICAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTQjZnJlZV9kcmF3aW5nfVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGlzRHJhd2luZ01vZGU6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb2JqZWN0cyBzaG91bGQgcmVtYWluIGluIGN1cnJlbnQgc3RhY2sgcG9zaXRpb24gd2hlbiBzZWxlY3RlZC5cbiAgICAgKiBXaGVuIGZhbHNlIG9iamVjdHMgYXJlIGJyb3VnaHQgdG8gdG9wIGFuZCByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBzZWxlY3Rpb24gZ3JvdXBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwcmVzZXJ2ZU9iamVjdFN0YWNraW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgYW5nbGUgdGhhdCBhbiBvYmplY3Qgd2lsbCBsb2NrIHRvIHdoaWxlIHJvdGF0aW5nLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBzaW5jZSAxLjYuN1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc25hcEFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBzbmFwQW5nbGUgdGhlIHJvdGF0aW9uIHdpbGwgbG9jayB0byB0aGUgc25hcEFuZ2xlLlxuICAgICAqIFdoZW4gYG51bGxgLCB0aGUgc25hcFRocmVzaG9sZCB3aWxsIGRlZmF1bHQgdG8gdGhlIHNuYXBBbmdsZS5cbiAgICAgKiBAdHlwZSBudWxsfE51bWJlclxuICAgICAqIEBzaW5jZSAxLjYuN1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc25hcFRocmVzaG9sZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgcmlnaHQgY2xpY2sgb24gY2FudmFzIGNhbiBvdXRwdXQgdGhlIGNvbnRleHQgbWVudSBvciBub3RcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDEuNi41XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdG9wQ29udGV4dE1lbnU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBjYW52YXMgY2FuIGZpcmUgcmlnaHQgY2xpY2sgZXZlbnRzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAxLjYuNVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlyZVJpZ2h0Q2xpY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBjYW52YXMgY2FuIGZpcmUgbWlkZGxlIGNsaWNrIGV2ZW50c1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMS43LjhcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpcmVNaWRkbGVDbGljazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0SW50ZXJhY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IG51bGw7XG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX2luaXRXcmFwcGVyRWxlbWVudCgpO1xuICAgICAgdGhpcy5fY3JlYXRlVXBwZXJDYW52YXMoKTtcbiAgICAgIHRoaXMuX2luaXRFdmVudExpc3RlbmVycygpO1xuXG4gICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuXG4gICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggPSBmYWJyaWMuUGVuY2lsQnJ1c2ggJiYgbmV3IGZhYnJpYy5QZW5jaWxCcnVzaCh0aGlzKTtcblxuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgb2JqZWN0cyBpbiB0d28gZ3JvdXBzLCBvbmUgdG8gcmVuZGVyIGltbWVkaWF0ZWx5XG4gICAgICogYW5kIG9uZSB0byByZW5kZXIgYXMgYWN0aXZlR3JvdXAuXG4gICAgICogQHJldHVybiB7QXJyYXl9IG9iamVjdHMgdG8gcmVuZGVyIGltbWVkaWF0ZWx5IGFuZCBwdXNoZXMgdGhlIG90aGVyIGluIHRoZSBhY3RpdmVHcm91cC5cbiAgICAgKi9cbiAgICBfY2hvb3NlT2JqZWN0c1RvUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3RzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksXG4gICAgICAgICAgb2JqZWN0LCBvYmpzVG9SZW5kZXIsIGFjdGl2ZUdyb3VwT2JqZWN0cztcblxuICAgICAgaWYgKGFjdGl2ZU9iamVjdHMubGVuZ3RoID4gMCAmJiAhdGhpcy5wcmVzZXJ2ZU9iamVjdFN0YWNraW5nKSB7XG4gICAgICAgIG9ianNUb1JlbmRlciA9IFtdO1xuICAgICAgICBhY3RpdmVHcm91cE9iamVjdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICAgIGlmIChhY3RpdmVPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEgKSB7XG4gICAgICAgICAgICBvYmpzVG9SZW5kZXIucHVzaChvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZUdyb3VwT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVPYmplY3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QuX29iamVjdHMgPSBhY3RpdmVHcm91cE9iamVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgb2Jqc1RvUmVuZGVyLnB1c2guYXBwbHkob2Jqc1RvUmVuZGVyLCBhY3RpdmVHcm91cE9iamVjdHMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9ianNUb1JlbmRlciA9IHRoaXMuX29iamVjdHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Jqc1RvUmVuZGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGJvdGggdGhlIHRvcCBjYW52YXMgYW5kIHRoZSBzZWNvbmRhcnkgY29udGFpbmVyIGNhbnZhcy5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRUb3BEaXJ0eSAmJiAhdGhpcy5fZ3JvdXBTZWxlY3RvciAmJiAhdGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dFRvcCk7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcERpcnR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNMb3N0Q29udGV4dCkge1xuICAgICAgICB0aGlzLnJlbmRlclRvcExheWVyKHRoaXMuY29udGV4dFRvcCk7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzVG9EcmF3T24gPSB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhjYW52YXNUb0RyYXdPbiwgdGhpcy5fY2hvb3NlT2JqZWN0c1RvUmVuZGVyKCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbmRlclRvcExheWVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlICYmIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggJiYgdGhpcy5mcmVlRHJhd2luZ0JydXNoLl9yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0VG9wRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gd2UgcmVuZGVyIHRoZSB0b3AgY29udGV4dCAtIGxhc3Qgb2JqZWN0XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgdGhpcy5fZ3JvdXBTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl9kcmF3U2VsZWN0aW9uKGN0eCk7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcERpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byByZW5kZXIgb25seSB0aGUgdG9wIGNhbnZhcy5cbiAgICAgKiBBbHNvIHVzZWQgdG8gcmVuZGVyIHRoZSBncm91cCBzZWxlY3Rpb24gYm94LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyVG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0VG9wO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMucmVuZGVyVG9wTGF5ZXIoY3R4KTtcbiAgICAgIHRoaXMuZmlyZSgnYWZ0ZXI6cmVuZGVyJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybSB0byBpdHMgb3JpZ2luYWwgdmFsdWVzIGFuZCBjaG9vc2VzIHRoZSB0eXBlIG9mIHJlc2l6aW5nIGJhc2VkIG9uIHRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0Q3VycmVudFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm07XG5cbiAgICAgIHQudGFyZ2V0LnNldCh7XG4gICAgICAgIHNjYWxlWDogdC5vcmlnaW5hbC5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdC5vcmlnaW5hbC5zY2FsZVksXG4gICAgICAgIHNrZXdYOiB0Lm9yaWdpbmFsLnNrZXdYLFxuICAgICAgICBza2V3WTogdC5vcmlnaW5hbC5za2V3WSxcbiAgICAgICAgbGVmdDogdC5vcmlnaW5hbC5sZWZ0LFxuICAgICAgICB0b3A6IHQub3JpZ2luYWwudG9wXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENlbnRlclRyYW5zZm9ybSh0LnRhcmdldCkpIHtcbiAgICAgICAgaWYgKHQub3JpZ2luWCAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICBpZiAodC5vcmlnaW5YID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB0Lm1vdXNlWFNpZ24gPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0Lm1vdXNlWFNpZ24gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodC5vcmlnaW5ZICE9PSAnY2VudGVyJykge1xuICAgICAgICAgIGlmICh0Lm9yaWdpblkgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0Lm1vdXNlWVNpZ24gPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0Lm1vdXNlWVNpZ24gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHQub3JpZ2luWCA9ICdjZW50ZXInO1xuICAgICAgICB0Lm9yaWdpblkgPSAnY2VudGVyJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0Lm9yaWdpblggPSB0Lm9yaWdpbmFsLm9yaWdpblg7XG4gICAgICAgIHQub3JpZ2luWSA9IHQub3JpZ2luYWwub3JpZ2luWTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYW4gYXJlYSBvZiBnaXZlbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IE9iamVjdCB0byB0ZXN0IGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BvaW50XSB4LHkgb2JqZWN0IG9mIHBvaW50IGNvb3JkaW5hdGVzIHdlIHdhbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGFuIGFyZWEgb2YgZ2l2ZW4gb2JqZWN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKGUsIHRhcmdldCwgcG9pbnQpIHtcbiAgICAgIHZhciBpZ25vcmVab29tID0gdHJ1ZSxcbiAgICAgICAgICBwb2ludGVyID0gcG9pbnQgfHwgdGhpcy5nZXRQb2ludGVyKGUsIGlnbm9yZVpvb20pLFxuICAgICAgICAgIHh5O1xuXG4gICAgICBpZiAodGFyZ2V0Lmdyb3VwICYmIHRhcmdldC5ncm91cCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIHRhcmdldC5ncm91cC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICB4eSA9IHRoaXMuX25vcm1hbGl6ZVBvaW50ZXIodGFyZ2V0Lmdyb3VwLCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB4eSA9IHsgeDogcG9pbnRlci54LCB5OiBwb2ludGVyLnkgfTtcbiAgICAgIH1cbiAgICAgIC8vIGh0dHA6Ly93d3cuZ2VvZy51YmMuY2EvY291cnNlcy9rbGluay9naXMubm90ZXMvbmNnaWEvdTMyLmh0bWxcbiAgICAgIC8vIGh0dHA6Ly9pZGF2LnVjZGF2aXMuZWR1L35va3JleWxvcy9UQXNoaXAvU3ByaW5nMjAwMC9Qb2ludEluUG9seWdvbi5odG1sXG4gICAgICByZXR1cm4gKHRhcmdldC5jb250YWluc1BvaW50KHh5KSB8fCB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIocG9pbnRlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVQb2ludGVyOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludGVyKSB7XG4gICAgICB2YXIgbSA9IG9iamVjdC5jYWxjVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgaW52ZXJ0ZWRNID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKG0pLFxuICAgICAgICAgIHZwdFBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHZwdFBvaW50ZXIsIGludmVydGVkTSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgdHJhbnNwYXJlbnQgYXQgYSBjZXJ0YWluIGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVG9wIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVGFyZ2V0VHJhbnNwYXJlbnQ6IGZ1bmN0aW9uICh0YXJnZXQsIHgsIHkpIHtcbiAgICAgIC8vIGluIGNhc2UgdGhlIHRhcmdldCBpcyB0aGUgYWN0aXZlT2JqZWN0LCB3ZSBjYW5ub3QgZXhlY3V0ZSB0aGlzIG9wdGltaXphdGlvblxuICAgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGRyYXcgY29udHJvbHMgdG9vLlxuICAgICAgaWYgKHRhcmdldC5zaG91bGRDYWNoZSgpICYmIHRhcmdldC5fY2FjaGVDYW52YXMgJiYgdGFyZ2V0ICE9PSB0aGlzLl9hY3RpdmVPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRQb2ludGVyID0gdGhpcy5fbm9ybWFsaXplUG9pbnRlcih0YXJnZXQsIHt4OiB4LCB5OiB5fSksXG4gICAgICAgICAgICB0YXJnZXRSZWxhdGl2ZVggPSBNYXRoLm1heCh0YXJnZXQuY2FjaGVUcmFuc2xhdGlvblggKyAobm9ybWFsaXplZFBvaW50ZXIueCAqIHRhcmdldC56b29tWCksIDApLFxuICAgICAgICAgICAgdGFyZ2V0UmVsYXRpdmVZID0gTWF0aC5tYXgodGFyZ2V0LmNhY2hlVHJhbnNsYXRpb25ZICsgKG5vcm1hbGl6ZWRQb2ludGVyLnkgKiB0YXJnZXQuem9vbVkpLCAwKTtcblxuICAgICAgICB2YXIgaXNUcmFuc3BhcmVudCA9IGZhYnJpYy51dGlsLmlzVHJhbnNwYXJlbnQoXG4gICAgICAgICAgdGFyZ2V0Ll9jYWNoZUNvbnRleHQsIE1hdGgucm91bmQodGFyZ2V0UmVsYXRpdmVYKSwgTWF0aC5yb3VuZCh0YXJnZXRSZWxhdGl2ZVkpLCB0aGlzLnRhcmdldEZpbmRUb2xlcmFuY2UpO1xuXG4gICAgICAgIHJldHVybiBpc1RyYW5zcGFyZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0Q2FjaGUsXG4gICAgICAgICAgb3JpZ2luYWxDb2xvciA9IHRhcmdldC5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IsIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuXG4gICAgICB0YXJnZXQuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yID0gJyc7XG5cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgdGFyZ2V0LnJlbmRlcihjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgdGFyZ2V0ID09PSB0aGlzLl9hY3RpdmVPYmplY3QgJiYgdGFyZ2V0Ll9yZW5kZXJDb250cm9scyhjdHgsIHtcbiAgICAgICAgaGFzQm9yZGVyczogZmFsc2UsXG4gICAgICAgIHRyYW5zcGFyZW50Q29ybmVyczogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgaGFzQm9yZGVyczogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgdGFyZ2V0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciA9IG9yaWdpbmFsQ29sb3I7XG5cbiAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gZmFicmljLnV0aWwuaXNUcmFuc3BhcmVudChcbiAgICAgICAgY3R4LCB4LCB5LCB0aGlzLnRhcmdldEZpbmRUb2xlcmFuY2UpO1xuXG4gICAgICByZXR1cm4gaXNUcmFuc3BhcmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGFrZXMgYW4gZXZlbnQgYW5kIGRldGVybWlucyBpZiBzZWxlY3Rpb24ga2V5IGhhcyBiZWVuIHByZXNzZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX2lzU2VsZWN0aW9uS2V5UHJlc3NlZDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHNlbGVjdGlvbktleVByZXNzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzLnNlbGVjdGlvbktleSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgc2VsZWN0aW9uS2V5UHJlc3NlZCA9ICEhdGhpcy5zZWxlY3Rpb25LZXkuZmluZChmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGVba2V5XSA9PT0gdHJ1ZTsgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uS2V5UHJlc3NlZCA9IGVbdGhpcy5zZWxlY3Rpb25LZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0aW9uS2V5UHJlc3NlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX3Nob3VsZENsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgIXRhcmdldFxuICAgICAgICB8fFxuICAgICAgICAodGFyZ2V0ICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0cy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0cy5pbmRleE9mKHRhcmdldCkgPT09IC0xICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQgJiZcbiAgICAgICAgICAhdGhpcy5faXNTZWxlY3Rpb25LZXlQcmVzc2VkKGUpKVxuICAgICAgICB8fFxuICAgICAgICAodGFyZ2V0ICYmICF0YXJnZXQuZXZlbnRlZClcbiAgICAgICAgfHxcbiAgICAgICAgKHRhcmdldCAmJlxuICAgICAgICAgICF0YXJnZXQuc2VsZWN0YWJsZSAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0KVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2VudGVyZWRTY2FsaW5nIGZyb20gb2JqZWN0IGNhbid0IG92ZXJyaWRlIGNlbnRlcmVkU2NhbGluZyBmcm9tIGNhbnZhcy5cbiAgICAgKiB0aGlzIHNob3VsZCBiZSBmaXhlZCwgc2luY2Ugb2JqZWN0IHNldHRpbmcgc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIGNhbnZhcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX3Nob3VsZENlbnRlclRyYW5zZm9ybTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgY2VudGVyVHJhbnNmb3JtO1xuXG4gICAgICBpZiAodC5hY3Rpb24gPT09ICdzY2FsZScgfHwgdC5hY3Rpb24gPT09ICdzY2FsZVgnIHx8IHQuYWN0aW9uID09PSAnc2NhbGVZJykge1xuICAgICAgICBjZW50ZXJUcmFuc2Zvcm0gPSB0aGlzLmNlbnRlcmVkU2NhbGluZyB8fCB0YXJnZXQuY2VudGVyZWRTY2FsaW5nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodC5hY3Rpb24gPT09ICdyb3RhdGUnKSB7XG4gICAgICAgIGNlbnRlclRyYW5zZm9ybSA9IHRoaXMuY2VudGVyZWRSb3RhdGlvbiB8fCB0YXJnZXQuY2VudGVyZWRSb3RhdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNlbnRlclRyYW5zZm9ybSA/ICF0LmFsdEtleSA6IHQuYWx0S2V5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRPcmlnaW5Gcm9tQ29ybmVyOiBmdW5jdGlvbih0YXJnZXQsIGNvcm5lcikge1xuICAgICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgICAgeDogdGFyZ2V0Lm9yaWdpblgsXG4gICAgICAgIHk6IHRhcmdldC5vcmlnaW5ZXG4gICAgICB9O1xuXG4gICAgICBpZiAoY29ybmVyID09PSAnbWwnIHx8IGNvcm5lciA9PT0gJ3RsJyB8fCBjb3JuZXIgPT09ICdibCcpIHtcbiAgICAgICAgb3JpZ2luLnggPSAncmlnaHQnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnbXInIHx8IGNvcm5lciA9PT0gJ3RyJyB8fCBjb3JuZXIgPT09ICdicicpIHtcbiAgICAgICAgb3JpZ2luLnggPSAnbGVmdCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3JuZXIgPT09ICd0bCcgfHwgY29ybmVyID09PSAnbXQnIHx8IGNvcm5lciA9PT0gJ3RyJykge1xuICAgICAgICBvcmlnaW4ueSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnYmwnIHx8IGNvcm5lciA9PT0gJ21iJyB8fCBjb3JuZXIgPT09ICdicicpIHtcbiAgICAgICAgb3JpZ2luLnkgPSAndG9wJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QWN0aW9uRnJvbUNvcm5lcjogZnVuY3Rpb24oYWxyZWFkeVNlbGVjdGVkLCBjb3JuZXIsIGUpIHtcbiAgICAgIGlmICghY29ybmVyIHx8ICFhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuICdkcmFnJztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb3JuZXIpIHtcbiAgICAgICAgY2FzZSAnbXRyJzpcbiAgICAgICAgICByZXR1cm4gJ3JvdGF0ZSc7XG4gICAgICAgIGNhc2UgJ21sJzpcbiAgICAgICAgY2FzZSAnbXInOlxuICAgICAgICAgIHJldHVybiBlW3RoaXMuYWx0QWN0aW9uS2V5XSA/ICdza2V3WScgOiAnc2NhbGVYJztcbiAgICAgICAgY2FzZSAnbXQnOlxuICAgICAgICBjYXNlICdtYic6XG4gICAgICAgICAgcmV0dXJuIGVbdGhpcy5hbHRBY3Rpb25LZXldID8gJ3NrZXdYJyA6ICdzY2FsZVknO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAnc2NhbGUnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2V0dXBDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbiAoZSwgdGFyZ2V0LCBhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksXG4gICAgICAgICAgY29ybmVyID0gdGFyZ2V0Ll9maW5kVGFyZ2V0Q29ybmVyKHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKSksXG4gICAgICAgICAgYWN0aW9uID0gdGhpcy5fZ2V0QWN0aW9uRnJvbUNvcm5lcihhbHJlYWR5U2VsZWN0ZWQsIGNvcm5lciwgZSksXG4gICAgICAgICAgb3JpZ2luID0gdGhpcy5fZ2V0T3JpZ2luRnJvbUNvcm5lcih0YXJnZXQsIGNvcm5lcik7XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgY29ybmVyOiBjb3JuZXIsXG4gICAgICAgIHNjYWxlWDogdGFyZ2V0LnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0YXJnZXQuc2NhbGVZLFxuICAgICAgICBza2V3WDogdGFyZ2V0LnNrZXdYLFxuICAgICAgICBza2V3WTogdGFyZ2V0LnNrZXdZLFxuICAgICAgICAvLyB1c2VkIGJ5IHRyYW5zYXRpb25cbiAgICAgICAgb2Zmc2V0WDogcG9pbnRlci54IC0gdGFyZ2V0LmxlZnQsXG4gICAgICAgIG9mZnNldFk6IHBvaW50ZXIueSAtIHRhcmdldC50b3AsXG4gICAgICAgIG9yaWdpblg6IG9yaWdpbi54LFxuICAgICAgICBvcmlnaW5ZOiBvcmlnaW4ueSxcbiAgICAgICAgZXg6IHBvaW50ZXIueCxcbiAgICAgICAgZXk6IHBvaW50ZXIueSxcbiAgICAgICAgbGFzdFg6IHBvaW50ZXIueCxcbiAgICAgICAgbGFzdFk6IHBvaW50ZXIueSxcbiAgICAgICAgLy8gdW5zdXJlIHRoZXkgYXJlIHVzZWZ1bGwgYW55bW9yZS5cbiAgICAgICAgLy8gbGVmdDogdGFyZ2V0LmxlZnQsXG4gICAgICAgIC8vIHRvcDogdGFyZ2V0LnRvcCxcbiAgICAgICAgdGhldGE6IGRlZ3JlZXNUb1JhZGlhbnModGFyZ2V0LmFuZ2xlKSxcbiAgICAgICAgLy8gZW5kIG9mIHVuc3VyZVxuICAgICAgICB3aWR0aDogdGFyZ2V0LndpZHRoICogdGFyZ2V0LnNjYWxlWCxcbiAgICAgICAgbW91c2VYU2lnbjogMSxcbiAgICAgICAgbW91c2VZU2lnbjogMSxcbiAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXksXG4gICAgICAgIGFsdEtleTogZVt0aGlzLmNlbnRlcmVkS2V5XSxcbiAgICAgICAgb3JpZ2luYWw6IGZhYnJpYy51dGlsLnNhdmVPYmplY3RUcmFuc2Zvcm0odGFyZ2V0KSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0ub3JpZ2luYWwub3JpZ2luWCA9IG9yaWdpbi54O1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybS5vcmlnaW5hbC5vcmlnaW5ZID0gb3JpZ2luLnk7XG5cbiAgICAgIHRoaXMuX3Jlc2V0Q3VycmVudFRyYW5zZm9ybSgpO1xuICAgICAgdGhpcy5fYmVmb3JlVHJhbnNmb3JtKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIG9iamVjdCBieSBcInNldHRpbmdcIiBpdHMgbGVmdC90b3BcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHBvaW50ZXIncyB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBwb2ludGVyJ3MgeSBjb29yZGluYXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHJhbnNsYXRpb24gb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfdHJhbnNsYXRlT2JqZWN0OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgICBuZXdMZWZ0ID0geCAtIHRyYW5zZm9ybS5vZmZzZXRYLFxuICAgICAgICAgIG5ld1RvcCA9IHkgLSB0cmFuc2Zvcm0ub2Zmc2V0WSxcbiAgICAgICAgICBtb3ZlWCA9ICF0YXJnZXQuZ2V0KCdsb2NrTW92ZW1lbnRYJykgJiYgdGFyZ2V0LmxlZnQgIT09IG5ld0xlZnQsXG4gICAgICAgICAgbW92ZVkgPSAhdGFyZ2V0LmdldCgnbG9ja01vdmVtZW50WScpICYmIHRhcmdldC50b3AgIT09IG5ld1RvcDtcblxuICAgICAgbW92ZVggJiYgdGFyZ2V0LnNldCgnbGVmdCcsIG5ld0xlZnQpO1xuICAgICAgbW92ZVkgJiYgdGFyZ2V0LnNldCgndG9wJywgbmV3VG9wKTtcbiAgICAgIHJldHVybiBtb3ZlWCB8fCBtb3ZlWTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgd2UgYXJlIGluY3JlYXNpbmcgYSBwb3NpdGl2ZSBza2V3IG9yIGxvd2VyIGl0LFxuICAgICAqIGNoZWNraW5nIG1vdXNlIGRpcmVjdGlvbiBhbmQgcHJlc3NlZCBjb3JuZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hhbmdlU2tld1RyYW5zZm9ybU9yaWdpbjogZnVuY3Rpb24obW91c2VNb3ZlLCB0LCBieSkge1xuICAgICAgdmFyIHByb3BlcnR5ID0gJ29yaWdpblgnLCBvcmlnaW5zID0geyAwOiAnY2VudGVyJyB9LFxuICAgICAgICAgIHNrZXcgPSB0LnRhcmdldC5za2V3WCwgb3JpZ2luQSA9ICdsZWZ0Jywgb3JpZ2luQiA9ICdyaWdodCcsXG4gICAgICAgICAgY29ybmVyID0gdC5jb3JuZXIgPT09ICdtdCcgfHwgdC5jb3JuZXIgPT09ICdtbCcgPyAxIDogLTEsXG4gICAgICAgICAgZmxpcFNpZ24gPSAxO1xuXG4gICAgICBtb3VzZU1vdmUgPSBtb3VzZU1vdmUgPiAwID8gMSA6IC0xO1xuICAgICAgaWYgKGJ5ID09PSAneScpIHtcbiAgICAgICAgc2tldyA9IHQudGFyZ2V0LnNrZXdZO1xuICAgICAgICBvcmlnaW5BID0gJ3RvcCc7XG4gICAgICAgIG9yaWdpbkIgPSAnYm90dG9tJztcbiAgICAgICAgcHJvcGVydHkgPSAnb3JpZ2luWSc7XG4gICAgICB9XG4gICAgICBvcmlnaW5zWy0xXSA9IG9yaWdpbkE7XG4gICAgICBvcmlnaW5zWzFdID0gb3JpZ2luQjtcblxuICAgICAgdC50YXJnZXQuZmxpcFggJiYgKGZsaXBTaWduICo9IC0xKTtcbiAgICAgIHQudGFyZ2V0LmZsaXBZICYmIChmbGlwU2lnbiAqPSAtMSk7XG5cbiAgICAgIGlmIChza2V3ID09PSAwKSB7XG4gICAgICAgIHQuc2tld1NpZ24gPSAtY29ybmVyICogbW91c2VNb3ZlICogZmxpcFNpZ247XG4gICAgICAgIHRbcHJvcGVydHldID0gb3JpZ2luc1stbW91c2VNb3ZlXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBza2V3ID0gc2tldyA+IDAgPyAxIDogLTE7XG4gICAgICAgIHQuc2tld1NpZ24gPSBza2V3O1xuICAgICAgICB0W3Byb3BlcnR5XSA9IG9yaWdpbnNbc2tldyAqIGNvcm5lciAqIGZsaXBTaWduXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2tldyBvYmplY3QgYnkgbW91c2UgZXZlbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBwb2ludGVyJ3MgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgcG9pbnRlcidzIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBieSBFaXRoZXIgJ3gnIG9yICd5J1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNrZXdpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfc2tld09iamVjdDogZnVuY3Rpb24gKHgsIHksIGJ5KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdC50YXJnZXQsIHNrZXdlZCA9IGZhbHNlLFxuICAgICAgICAgIGxvY2tTa2V3aW5nWCA9IHRhcmdldC5nZXQoJ2xvY2tTa2V3aW5nWCcpLFxuICAgICAgICAgIGxvY2tTa2V3aW5nWSA9IHRhcmdldC5nZXQoJ2xvY2tTa2V3aW5nWScpO1xuXG4gICAgICBpZiAoKGxvY2tTa2V3aW5nWCAmJiBieSA9PT0gJ3gnKSB8fCAobG9ja1NrZXdpbmdZICYmIGJ5ID09PSAneScpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBjb25zdHJhaW50IHBvaW50XG4gICAgICB2YXIgY2VudGVyID0gdGFyZ2V0LmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgYWN0dWFsTW91c2VCeUNlbnRlciA9IHRhcmdldC50b0xvY2FsUG9pbnQobmV3IGZhYnJpYy5Qb2ludCh4LCB5KSwgJ2NlbnRlcicsICdjZW50ZXInKVtieV0sXG4gICAgICAgICAgbGFzdE1vdXNlQnlDZW50ZXIgPSB0YXJnZXQudG9Mb2NhbFBvaW50KG5ldyBmYWJyaWMuUG9pbnQodC5sYXN0WCwgdC5sYXN0WSksICdjZW50ZXInLCAnY2VudGVyJylbYnldLFxuICAgICAgICAgIGFjdHVhbE1vdXNlQnlPcmlnaW4sIGNvbnN0cmFpbnRQb3NpdGlvbiwgZGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcblxuICAgICAgdGhpcy5fY2hhbmdlU2tld1RyYW5zZm9ybU9yaWdpbihhY3R1YWxNb3VzZUJ5Q2VudGVyIC0gbGFzdE1vdXNlQnlDZW50ZXIsIHQsIGJ5KTtcbiAgICAgIGFjdHVhbE1vdXNlQnlPcmlnaW4gPSB0YXJnZXQudG9Mb2NhbFBvaW50KG5ldyBmYWJyaWMuUG9pbnQoeCwgeSksIHQub3JpZ2luWCwgdC5vcmlnaW5ZKVtieV07XG4gICAgICBjb25zdHJhaW50UG9zaXRpb24gPSB0YXJnZXQudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcbiAgICAgIC8vIEFjdHVhbGx5IHNrZXcgdGhlIG9iamVjdFxuICAgICAgc2tld2VkID0gdGhpcy5fc2V0T2JqZWN0U2tldyhhY3R1YWxNb3VzZUJ5T3JpZ2luLCB0LCBieSwgZGltKTtcbiAgICAgIHQubGFzdFggPSB4O1xuICAgICAgdC5sYXN0WSA9IHk7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnN0cmFpbnRzIGFwcGx5XG4gICAgICB0YXJnZXQuc2V0UG9zaXRpb25CeU9yaWdpbihjb25zdHJhaW50UG9zaXRpb24sIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcbiAgICAgIHJldHVybiBza2V3ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBvYmplY3Qgc2tld1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2tld2luZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zZXRPYmplY3RTa2V3OiBmdW5jdGlvbihsb2NhbE1vdXNlLCB0cmFuc2Zvcm0sIGJ5LCBfZGltKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgbmV3VmFsdWUsIHNrZXdlZCA9IGZhbHNlLFxuICAgICAgICAgIHNrZXdTaWduID0gdHJhbnNmb3JtLnNrZXdTaWduLCBuZXdEaW0sIGRpbU5vU2tldyxcbiAgICAgICAgICBvdGhlckJ5LCBfb3RoZXJCeSwgX2J5LCBuZXdEaW1Nb3VzZSwgc2tld1gsIHNrZXdZO1xuXG4gICAgICBpZiAoYnkgPT09ICd4Jykge1xuICAgICAgICBvdGhlckJ5ID0gJ3knO1xuICAgICAgICBfb3RoZXJCeSA9ICdZJztcbiAgICAgICAgX2J5ID0gJ1gnO1xuICAgICAgICBza2V3WCA9IDA7XG4gICAgICAgIHNrZXdZID0gdGFyZ2V0LnNrZXdZO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG90aGVyQnkgPSAneCc7XG4gICAgICAgIF9vdGhlckJ5ID0gJ1gnO1xuICAgICAgICBfYnkgPSAnWSc7XG4gICAgICAgIHNrZXdYID0gdGFyZ2V0LnNrZXdYO1xuICAgICAgICBza2V3WSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGRpbU5vU2tldyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKHNrZXdYLCBza2V3WSk7XG4gICAgICBuZXdEaW1Nb3VzZSA9IDIgKiBNYXRoLmFicyhsb2NhbE1vdXNlKSAtIGRpbU5vU2tld1tieV07XG4gICAgICBpZiAobmV3RGltTW91c2UgPD0gMikge1xuICAgICAgICBuZXdWYWx1ZSA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBza2V3U2lnbiAqIE1hdGguYXRhbigobmV3RGltTW91c2UgLyB0YXJnZXRbJ3NjYWxlJyArIF9ieV0pIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGltTm9Ta2V3W290aGVyQnldIC8gdGFyZ2V0WydzY2FsZScgKyBfb3RoZXJCeV0pKTtcbiAgICAgICAgbmV3VmFsdWUgPSBmYWJyaWMudXRpbC5yYWRpYW5zVG9EZWdyZWVzKG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHNrZXdlZCA9IHRhcmdldFsnc2tldycgKyBfYnldICE9PSBuZXdWYWx1ZTtcbiAgICAgIHRhcmdldC5zZXQoJ3NrZXcnICsgX2J5LCBuZXdWYWx1ZSk7XG4gICAgICBpZiAodGFyZ2V0Wydza2V3JyArIF9vdGhlckJ5XSAhPT0gMCkge1xuICAgICAgICBuZXdEaW0gPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgICBuZXdWYWx1ZSA9IChfZGltW290aGVyQnldIC8gbmV3RGltW290aGVyQnldKSAqIHRhcmdldFsnc2NhbGUnICsgX290aGVyQnldO1xuICAgICAgICB0YXJnZXQuc2V0KCdzY2FsZScgKyBfb3RoZXJCeSwgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNrZXdlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIG9iamVjdCBieSBpbnZva2luZyBpdHMgc2NhbGVYL3NjYWxlWSBtZXRob2RzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBwb2ludGVyJ3MgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgcG9pbnRlcidzIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBieSBFaXRoZXIgJ3gnIG9yICd5JyAtIHNwZWNpZmllcyBkaW1lbnNpb24gY29uc3RyYWludCBieSB3aGljaCB0byBzY2FsZSBhbiBvYmplY3QuXG4gICAgICogICAgICAgICAgICAgICAgICAgIFdoZW4gbm90IHByb3ZpZGVkLCBhbiBvYmplY3QgaXMgc2NhbGVkIGJ5IGJvdGggZGltZW5zaW9ucyBlcXVhbGx5XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2NhbGluZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zY2FsZU9iamVjdDogZnVuY3Rpb24gKHgsIHksIGJ5KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdC50YXJnZXQsXG4gICAgICAgICAgbG9ja1NjYWxpbmdYID0gdGFyZ2V0LmxvY2tTY2FsaW5nWCxcbiAgICAgICAgICBsb2NrU2NhbGluZ1kgPSB0YXJnZXQubG9ja1NjYWxpbmdZLFxuICAgICAgICAgIGxvY2tTY2FsaW5nRmxpcCA9IHRhcmdldC5sb2NrU2NhbGluZ0ZsaXA7XG5cbiAgICAgIGlmIChsb2NrU2NhbGluZ1ggJiYgbG9ja1NjYWxpbmdZKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBjb25zdHJhaW50IHBvaW50XG4gICAgICB2YXIgY29uc3RyYWludFBvc2l0aW9uID0gdGFyZ2V0LnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGFyZ2V0LmdldENlbnRlclBvaW50KCksIHQub3JpZ2luWCwgdC5vcmlnaW5ZKSxcbiAgICAgICAgICBsb2NhbE1vdXNlID0gdGFyZ2V0LnRvTG9jYWxQb2ludChuZXcgZmFicmljLlBvaW50KHgsIHkpLCB0Lm9yaWdpblgsIHQub3JpZ2luWSksXG4gICAgICAgICAgZGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSwgc2NhbGVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3NldExvY2FsTW91c2UobG9jYWxNb3VzZSwgdCk7XG5cbiAgICAgIC8vIEFjdHVhbGx5IHNjYWxlIHRoZSBvYmplY3RcbiAgICAgIHNjYWxlZCA9IHRoaXMuX3NldE9iamVjdFNjYWxlKGxvY2FsTW91c2UsIHQsIGxvY2tTY2FsaW5nWCwgbG9ja1NjYWxpbmdZLCBieSwgbG9ja1NjYWxpbmdGbGlwLCBkaW0pO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnN0cmFpbnRzIGFwcGx5XG4gICAgICB0YXJnZXQuc2V0UG9zaXRpb25CeU9yaWdpbihjb25zdHJhaW50UG9zaXRpb24sIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcbiAgICAgIHJldHVybiBzY2FsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2NhbGluZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zZXRPYmplY3RTY2FsZTogZnVuY3Rpb24obG9jYWxNb3VzZSwgdHJhbnNmb3JtLCBsb2NrU2NhbGluZ1gsIGxvY2tTY2FsaW5nWSwgYnksIGxvY2tTY2FsaW5nRmxpcCwgX2RpbSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGZvcmJpZFNjYWxpbmdYID0gZmFsc2UsIGZvcmJpZFNjYWxpbmdZID0gZmFsc2UsIHNjYWxlZCA9IGZhbHNlLFxuICAgICAgICAgIHNjYWxlWCA9IGxvY2FsTW91c2UueCAqIHRhcmdldC5zY2FsZVggLyBfZGltLngsXG4gICAgICAgICAgc2NhbGVZID0gbG9jYWxNb3VzZS55ICogdGFyZ2V0LnNjYWxlWSAvIF9kaW0ueSxcbiAgICAgICAgICBjaGFuZ2VYID0gdGFyZ2V0LnNjYWxlWCAhPT0gc2NhbGVYLFxuICAgICAgICAgIGNoYW5nZVkgPSB0YXJnZXQuc2NhbGVZICE9PSBzY2FsZVk7XG5cbiAgICAgIGlmIChsb2NrU2NhbGluZ0ZsaXAgJiYgc2NhbGVYIDw9IDAgJiYgc2NhbGVYIDwgdGFyZ2V0LnNjYWxlWCkge1xuICAgICAgICBmb3JiaWRTY2FsaW5nWCA9IHRydWU7XG4gICAgICAgIGxvY2FsTW91c2UueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2NrU2NhbGluZ0ZsaXAgJiYgc2NhbGVZIDw9IDAgJiYgc2NhbGVZIDwgdGFyZ2V0LnNjYWxlWSkge1xuICAgICAgICBmb3JiaWRTY2FsaW5nWSA9IHRydWU7XG4gICAgICAgIGxvY2FsTW91c2UueSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChieSA9PT0gJ2VxdWFsbHknICYmICFsb2NrU2NhbGluZ1ggJiYgIWxvY2tTY2FsaW5nWSkge1xuICAgICAgICBzY2FsZWQgPSB0aGlzLl9zY2FsZU9iamVjdEVxdWFsbHkobG9jYWxNb3VzZSwgdGFyZ2V0LCB0cmFuc2Zvcm0sIF9kaW0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWJ5KSB7XG4gICAgICAgIGZvcmJpZFNjYWxpbmdYIHx8IGxvY2tTY2FsaW5nWCB8fCAodGFyZ2V0LnNldCgnc2NhbGVYJywgc2NhbGVYKSAmJiAoc2NhbGVkID0gc2NhbGVkIHx8IGNoYW5nZVgpKTtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1kgfHwgbG9ja1NjYWxpbmdZIHx8ICh0YXJnZXQuc2V0KCdzY2FsZVknLCBzY2FsZVkpICYmIChzY2FsZWQgPSBzY2FsZWQgfHwgY2hhbmdlWSkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYnkgPT09ICd4JyAmJiAhdGFyZ2V0LmdldCgnbG9ja1VuaVNjYWxpbmcnKSkge1xuICAgICAgICBmb3JiaWRTY2FsaW5nWCB8fCBsb2NrU2NhbGluZ1ggfHwgKHRhcmdldC5zZXQoJ3NjYWxlWCcsIHNjYWxlWCkgJiYgKHNjYWxlZCA9IGNoYW5nZVgpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJ5ID09PSAneScgJiYgIXRhcmdldC5nZXQoJ2xvY2tVbmlTY2FsaW5nJykpIHtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1kgfHwgbG9ja1NjYWxpbmdZIHx8ICh0YXJnZXQuc2V0KCdzY2FsZVknLCBzY2FsZVkpICYmIChzY2FsZWQgPSBjaGFuZ2VZKSk7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0ubmV3U2NhbGVYID0gc2NhbGVYO1xuICAgICAgdHJhbnNmb3JtLm5ld1NjYWxlWSA9IHNjYWxlWTtcbiAgICAgIGZvcmJpZFNjYWxpbmdYIHx8IGZvcmJpZFNjYWxpbmdZIHx8IHRoaXMuX2ZsaXBPYmplY3QodHJhbnNmb3JtLCBieSk7XG4gICAgICByZXR1cm4gc2NhbGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNjYWxpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfc2NhbGVPYmplY3RFcXVhbGx5OiBmdW5jdGlvbihsb2NhbE1vdXNlLCB0YXJnZXQsIHRyYW5zZm9ybSwgX2RpbSkge1xuXG4gICAgICB2YXIgZGlzdCA9IGxvY2FsTW91c2UueSArIGxvY2FsTW91c2UueCxcbiAgICAgICAgICBsYXN0RGlzdCA9IF9kaW0ueSAqIHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVkgLyB0YXJnZXQuc2NhbGVZICtcbiAgICAgICAgICAgICAgICAgICAgIF9kaW0ueCAqIHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVggLyB0YXJnZXQuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlZCwgc2lnblggPSBsb2NhbE1vdXNlLnggPCAwID8gLTEgOiAxLFxuICAgICAgICAgIHNpZ25ZID0gbG9jYWxNb3VzZS55IDwgMCA/IC0xIDogMSwgbmV3U2NhbGVYLCBuZXdTY2FsZVk7XG5cbiAgICAgIC8vIFdlIHVzZSB0cmFuc2Zvcm0uc2NhbGVYL1kgaW5zdGVhZCBvZiB0YXJnZXQuc2NhbGVYL1lcbiAgICAgIC8vIGJlY2F1c2UgdGhlIG9iamVjdCBtYXkgaGF2ZSBhIG1pbiBzY2FsZSBhbmQgd2UnbGwgbG9vc2UgdGhlIHByb3BvcnRpb25zXG4gICAgICBuZXdTY2FsZVggPSBzaWduWCAqIE1hdGguYWJzKHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVggKiBkaXN0IC8gbGFzdERpc3QpO1xuICAgICAgbmV3U2NhbGVZID0gc2lnblkgKiBNYXRoLmFicyh0cmFuc2Zvcm0ub3JpZ2luYWwuc2NhbGVZICogZGlzdCAvIGxhc3REaXN0KTtcbiAgICAgIHNjYWxlZCA9IG5ld1NjYWxlWCAhPT0gdGFyZ2V0LnNjYWxlWCB8fCBuZXdTY2FsZVkgIT09IHRhcmdldC5zY2FsZVk7XG4gICAgICB0YXJnZXQuc2V0KCdzY2FsZVgnLCBuZXdTY2FsZVgpO1xuICAgICAgdGFyZ2V0LnNldCgnc2NhbGVZJywgbmV3U2NhbGVZKTtcbiAgICAgIHJldHVybiBzY2FsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZsaXBPYmplY3Q6IGZ1bmN0aW9uKHRyYW5zZm9ybSwgYnkpIHtcbiAgICAgIGlmICh0cmFuc2Zvcm0ubmV3U2NhbGVYIDwgMCAmJiBieSAhPT0gJ3knKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdHJhbnNmb3JtLm9yaWdpblggPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdHJhbnNmb3JtLm9yaWdpblggPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zZm9ybS5uZXdTY2FsZVkgPCAwICYmIGJ5ICE9PSAneCcpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5ZID09PSAndG9wJykge1xuICAgICAgICAgIHRyYW5zZm9ybS5vcmlnaW5ZID0gJ2JvdHRvbSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJhbnNmb3JtLm9yaWdpblkgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgdHJhbnNmb3JtLm9yaWdpblkgPSAndG9wJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRMb2NhbE1vdXNlOiBmdW5jdGlvbihsb2NhbE1vdXNlLCB0KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdC50YXJnZXQsIHpvb20gPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICBwYWRkaW5nID0gdGFyZ2V0LnBhZGRpbmcgLyB6b29tO1xuXG4gICAgICBpZiAodC5vcmlnaW5YID09PSAncmlnaHQnKSB7XG4gICAgICAgIGxvY2FsTW91c2UueCAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHQub3JpZ2luWCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgbG9jYWxNb3VzZS54ICo9IHQubW91c2VYU2lnbiAqIDI7XG4gICAgICAgIGlmIChsb2NhbE1vdXNlLnggPCAwKSB7XG4gICAgICAgICAgdC5tb3VzZVhTaWduID0gLXQubW91c2VYU2lnbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodC5vcmlnaW5ZID09PSAnYm90dG9tJykge1xuICAgICAgICBsb2NhbE1vdXNlLnkgKj0gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0Lm9yaWdpblkgPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGxvY2FsTW91c2UueSAqPSB0Lm1vdXNlWVNpZ24gKiAyO1xuICAgICAgICBpZiAobG9jYWxNb3VzZS55IDwgMCkge1xuICAgICAgICAgIHQubW91c2VZU2lnbiA9IC10Lm1vdXNlWVNpZ247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYWRqdXN0IHRoZSBtb3VzZSBjb29yZGluYXRlcyB3aGVuIGRlYWxpbmcgd2l0aCBwYWRkaW5nXG4gICAgICBpZiAoYWJzKGxvY2FsTW91c2UueCkgPiBwYWRkaW5nKSB7XG4gICAgICAgIGlmIChsb2NhbE1vdXNlLnggPCAwKSB7XG4gICAgICAgICAgbG9jYWxNb3VzZS54ICs9IHBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbG9jYWxNb3VzZS54IC09IHBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgeyAvLyBtb3VzZSBpcyB3aXRoaW4gdGhlIHBhZGRpbmcsIHNldCB0byAwXG4gICAgICAgIGxvY2FsTW91c2UueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhYnMobG9jYWxNb3VzZS55KSA+IHBhZGRpbmcpIHtcbiAgICAgICAgaWYgKGxvY2FsTW91c2UueSA8IDApIHtcbiAgICAgICAgICBsb2NhbE1vdXNlLnkgKz0gcGFkZGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsb2NhbE1vdXNlLnkgLT0gcGFkZGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxvY2FsTW91c2UueSA9IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgb2JqZWN0IGJ5IGludm9raW5nIGl0cyByb3RhdGUgbWV0aG9kXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBwb2ludGVyJ3MgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgcG9pbnRlcidzIHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHJvdGF0aW9uIG9jY3VycmVkXG4gICAgICovXG4gICAgX3JvdGF0ZU9iamVjdDogZnVuY3Rpb24gKHgsIHkpIHtcblxuICAgICAgdmFyIHQgPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLFxuICAgICAgICAgIHRhcmdldCA9IHQudGFyZ2V0LCBjb25zdHJhaW50UG9zaXRpb24sXG4gICAgICAgICAgY29uc3RyYWludFBvc2l0aW9uID0gdGFyZ2V0LnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGFyZ2V0LmdldENlbnRlclBvaW50KCksIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcblxuICAgICAgaWYgKHRhcmdldC5sb2NrUm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEFuZ2xlID0gYXRhbjIodC5leSAtIGNvbnN0cmFpbnRQb3NpdGlvbi55LCB0LmV4IC0gY29uc3RyYWludFBvc2l0aW9uLngpLFxuICAgICAgICAgIGN1ckFuZ2xlID0gYXRhbjIoeSAtIGNvbnN0cmFpbnRQb3NpdGlvbi55LCB4IC0gY29uc3RyYWludFBvc2l0aW9uLngpLFxuICAgICAgICAgIGFuZ2xlID0gcmFkaWFuc1RvRGVncmVlcyhjdXJBbmdsZSAtIGxhc3RBbmdsZSArIHQudGhldGEpLFxuICAgICAgICAgIGhhc1JvdGF0ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAodGFyZ2V0LnNuYXBBbmdsZSA+IDApIHtcbiAgICAgICAgdmFyIHNuYXBBbmdsZSAgPSB0YXJnZXQuc25hcEFuZ2xlLFxuICAgICAgICAgICAgc25hcFRocmVzaG9sZCAgPSB0YXJnZXQuc25hcFRocmVzaG9sZCB8fCBzbmFwQW5nbGUsXG4gICAgICAgICAgICByaWdodEFuZ2xlTG9ja2VkID0gTWF0aC5jZWlsKGFuZ2xlIC8gc25hcEFuZ2xlKSAqIHNuYXBBbmdsZSxcbiAgICAgICAgICAgIGxlZnRBbmdsZUxvY2tlZCA9IE1hdGguZmxvb3IoYW5nbGUgLyBzbmFwQW5nbGUpICogc25hcEFuZ2xlO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhhbmdsZSAtIGxlZnRBbmdsZUxvY2tlZCkgPCBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgICAgYW5nbGUgPSBsZWZ0QW5nbGVMb2NrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoYW5nbGUgLSByaWdodEFuZ2xlTG9ja2VkKSA8IHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgICBhbmdsZSA9IHJpZ2h0QW5nbGVMb2NrZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbm9ybWFsaXplIGFuZ2xlIHRvIHBvc2l0aXZlIHZhbHVlXG4gICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgIGFuZ2xlID0gMzYwICsgYW5nbGU7XG4gICAgICB9XG4gICAgICBhbmdsZSAlPSAzNjA7XG5cbiAgICAgIGlmICh0YXJnZXQuYW5nbGUgPT09IGFuZ2xlKSB7XG4gICAgICAgIGhhc1JvdGF0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyByb3RhdGlvbiBvbmx5IGhhcHBlbiBoZXJlXG4gICAgICAgIHRhcmdldC5hbmdsZSA9IGFuZ2xlO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnN0cmFpbnRzIGFwcGx5XG4gICAgICAgIHRhcmdldC5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNvbnN0cmFpbnRQb3NpdGlvbiwgdC5vcmlnaW5YLCB0Lm9yaWdpblkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzUm90YXRlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJzb3IgdHlwZSBvZiB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgQ3Vyc29yIHR5cGUgb2YgdGhlIGNhbnZhcyBlbGVtZW50LlxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy11aS8jY3Vyc29yXG4gICAgICovXG4gICAgc2V0Q3Vyc29yOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMudXBwZXJDYW52YXNFbC5zdHlsZS5jdXJzb3IgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRvIGRyYXcgdGhlIHNlbGVjdGlvbiBvblxuICAgICAqL1xuICAgIF9kcmF3U2VsZWN0aW9uOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICB2YXIgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3IsXG4gICAgICAgICAgbGVmdCA9IGdyb3VwU2VsZWN0b3IubGVmdCxcbiAgICAgICAgICB0b3AgPSBncm91cFNlbGVjdG9yLnRvcCxcbiAgICAgICAgICBhbGVmdCA9IGFicyhsZWZ0KSxcbiAgICAgICAgICBhdG9wID0gYWJzKHRvcCk7XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkNvbG9yKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkNvbG9yO1xuXG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICBncm91cFNlbGVjdG9yLmV4IC0gKChsZWZ0ID4gMCkgPyAwIDogLWxlZnQpLFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IuZXkgLSAoKHRvcCA+IDApID8gMCA6IC10b3ApLFxuICAgICAgICAgIGFsZWZ0LFxuICAgICAgICAgIGF0b3BcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbkxpbmVXaWR0aCB8fCAhdGhpcy5zZWxlY3Rpb25Cb3JkZXJDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zZWxlY3Rpb25MaW5lV2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkJvcmRlckNvbG9yO1xuXG4gICAgICAvLyBzZWxlY3Rpb24gYm9yZGVyXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25EYXNoQXJyYXkubGVuZ3RoID4gMSAmJiAhc3VwcG9ydExpbmVEYXNoKSB7XG5cbiAgICAgICAgdmFyIHB4ID0gZ3JvdXBTZWxlY3Rvci5leCArIFNUUk9LRV9PRkZTRVQgLSAoKGxlZnQgPiAwKSA/IDAgOiBhbGVmdCksXG4gICAgICAgICAgICBweSA9IGdyb3VwU2VsZWN0b3IuZXkgKyBTVFJPS0VfT0ZGU0VUIC0gKCh0b3AgPiAwKSA/IDAgOiBhdG9wKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBweCwgcHksIHB4ICsgYWxlZnQsIHB5LCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHgsIHB5ICsgYXRvcCAtIDEsIHB4ICsgYWxlZnQsIHB5ICsgYXRvcCAtIDEsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBweCwgcHksIHB4LCBweSArIGF0b3AsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBweCArIGFsZWZ0IC0gMSwgcHksIHB4ICsgYWxlZnQgLSAxLCBweSArIGF0b3AsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5fc2V0TGluZURhc2guY2FsbCh0aGlzLCBjdHgsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgICAgZ3JvdXBTZWxlY3Rvci5leCArIFNUUk9LRV9PRkZTRVQgLSAoKGxlZnQgPiAwKSA/IDAgOiBhbGVmdCksXG4gICAgICAgICAgZ3JvdXBTZWxlY3Rvci5leSArIFNUUk9LRV9PRkZTRVQgLSAoKHRvcCA+IDApID8gMCA6IGF0b3ApLFxuICAgICAgICAgIGFsZWZ0LFxuICAgICAgICAgIGF0b3BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGV0ZXJtaW5lcyB3aGF0IG9iamVjdCB3ZSBhcmUgY2xpY2tpbmcgb25cbiAgICAgKiB0aGUgc2tpcEdyb3VwIHBhcmFtZXRlciBpcyBmb3IgaW50ZXJuYWwgdXNlLCBpcyBuZWVkZWQgZm9yIHNoaWZ0K2NsaWNrIGFjdGlvblxuICAgICAqIDExLzA5LzIwMTggVE9ETzogd291bGQgYmUgY29vbCBpZiBmaW5kVGFyZ2V0IGNvdWxkIGRpc2Nlcm4gYmV0d2VlbiBiZWluZyBhIGZ1bGwgdGFyZ2V0XG4gICAgICogb3IgdGhlIG91dHNpZGUgcGFydCBvZiB0aGUgY29ybmVyLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBHcm91cCB3aGVuIHRydWUsIGFjdGl2ZUdyb3VwIGlzIHNraXBwZWQgYW5kIG9ubHkgb2JqZWN0cyBhcmUgdHJhdmVyc2VkIHRocm91Z2hcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGUgdGFyZ2V0IGZvdW5kXG4gICAgICovXG4gICAgZmluZFRhcmdldDogZnVuY3Rpb24gKGUsIHNraXBHcm91cCkge1xuICAgICAgaWYgKHRoaXMuc2tpcFRhcmdldEZpbmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWdub3JlWm9vbSA9IHRydWUsXG4gICAgICAgICAgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlLCBpZ25vcmVab29tKSxcbiAgICAgICAgICBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgYU9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBhY3RpdmVUYXJnZXQsIGFjdGl2ZVRhcmdldFN1YnM7XG5cbiAgICAgIC8vIGZpcnN0IGNoZWNrIGN1cnJlbnQgZ3JvdXAgKGlmIG9uZSBleGlzdHMpXG4gICAgICAvLyBhY3RpdmUgZ3JvdXAgZG9lcyBub3QgY2hlY2sgc3ViIHRhcmdldHMgbGlrZSBub3JtYWwgZ3JvdXBzLlxuICAgICAgLy8gaWYgYWN0aXZlIGdyb3VwIGp1c3QgZXhpdHMuXG4gICAgICB0aGlzLnRhcmdldHMgPSBbXTtcblxuICAgICAgaWYgKGFPYmplY3RzLmxlbmd0aCA+IDEgJiYgIXNraXBHcm91cCAmJiBhY3RpdmVPYmplY3QgPT09IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyhbYWN0aXZlT2JqZWN0XSwgcG9pbnRlcikpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGhpdCB0aGUgY29ybmVyIG9mIGFuIGFjdGl2ZU9iamVjdCwgbGV0J3MgcmV0dXJuIHRoYXQuXG4gICAgICBpZiAoYU9iamVjdHMubGVuZ3RoID09PSAxICYmIGFjdGl2ZU9iamVjdC5fZmluZFRhcmdldENvcm5lcihwb2ludGVyKSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuICAgICAgaWYgKGFPYmplY3RzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBhY3RpdmVPYmplY3QgPT09IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyhbYWN0aXZlT2JqZWN0XSwgcG9pbnRlcikpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlT2JqZWN0U3RhY2tpbmcpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlT2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFjdGl2ZVRhcmdldCA9IGFjdGl2ZU9iamVjdDtcbiAgICAgICAgICBhY3RpdmVUYXJnZXRTdWJzID0gdGhpcy50YXJnZXRzO1xuICAgICAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKHRoaXMuX29iamVjdHMsIHBvaW50ZXIpO1xuICAgICAgaWYgKGVbdGhpcy5hbHRTZWxlY3Rpb25LZXldICYmIHRhcmdldCAmJiBhY3RpdmVUYXJnZXQgJiYgdGFyZ2V0ICE9PSBhY3RpdmVUYXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0ID0gYWN0aXZlVGFyZ2V0O1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBhY3RpdmVUYXJnZXRTdWJzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcG9pbnRlcl0geCx5IG9iamVjdCBvZiBwb2ludCBjb29yZGluYXRlcyB3ZSB3YW50IHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0byB0ZXN0IGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2dsb2JhbFBvaW50ZXJdIHgseSBvYmplY3Qgb2YgcG9pbnQgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gY2FudmFzIHVzZWQgdG8gc2VhcmNoIHBlciBwaXhlbCB0YXJnZXQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGFuIGFyZWEgb2YgZ2l2ZW4gb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tUYXJnZXQ6IGZ1bmN0aW9uKHBvaW50ZXIsIG9iaiwgZ2xvYmFsUG9pbnRlcikge1xuICAgICAgaWYgKG9iaiAmJlxuICAgICAgICAgIG9iai52aXNpYmxlICYmXG4gICAgICAgICAgb2JqLmV2ZW50ZWQgJiZcbiAgICAgICAgICB0aGlzLmNvbnRhaW5zUG9pbnQobnVsbCwgb2JqLCBwb2ludGVyKSl7XG4gICAgICAgIGlmICgodGhpcy5wZXJQaXhlbFRhcmdldEZpbmQgfHwgb2JqLnBlclBpeGVsVGFyZ2V0RmluZCkgJiYgIW9iai5pc0VkaXRpbmcpIHtcbiAgICAgICAgICB2YXIgaXNUcmFuc3BhcmVudCA9IHRoaXMuaXNUYXJnZXRUcmFuc3BhcmVudChvYmosIGdsb2JhbFBvaW50ZXIueCwgZ2xvYmFsUG9pbnRlci55KTtcbiAgICAgICAgICBpZiAoIWlzVHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIHNlYXJjaCBpbnNpZGUgb2JqZWN0cyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBwb2ludGVyIGluIGJvdW5kaW5nIGJveCBvciB0aGF0IGNvbnRhaW5zIHBvaW50ZXJPbkNhbnZhcyB3aGVuIHBhaW50ZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb2JqZWN0c10gb2JqZWN0cyBhcnJheSB0byBsb29rIGludG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BvaW50ZXJdIHgseSBvYmplY3Qgb2YgcG9pbnQgY29vcmRpbmF0ZXMgd2Ugd2FudCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgdGhhdCBjb250YWlucyBwb2ludGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VhcmNoUG9zc2libGVUYXJnZXRzOiBmdW5jdGlvbihvYmplY3RzLCBwb2ludGVyKSB7XG4gICAgICAvLyBDYWNoZSBhbGwgdGFyZ2V0cyB3aGVyZSB0aGVpciBib3VuZGluZyBib3ggY29udGFpbnMgcG9pbnQuXG4gICAgICB2YXIgdGFyZ2V0LCBpID0gb2JqZWN0cy5sZW5ndGgsIHN1YlRhcmdldDtcbiAgICAgIC8vIERvIG5vdCBjaGVjayBmb3IgY3VycmVudGx5IGdyb3VwZWQgb2JqZWN0cywgc2luY2Ugd2UgY2hlY2sgdGhlIHBhcmVudCBncm91cCBpdHNlbGYuXG4gICAgICAvLyB1bnRpbCB3ZSBjYWxsIHRoaXMgZnVuY3Rpb24gc3BlY2lmaWNhbGx5IHRvIHNlYXJjaCBpbnNpZGUgdGhlIGFjdGl2ZUdyb3VwXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBvYmpUb0NoZWNrID0gb2JqZWN0c1tpXTtcbiAgICAgICAgdmFyIHBvaW50ZXJUb1VzZSA9IG9ialRvQ2hlY2suZ3JvdXAgJiYgb2JqVG9DaGVjay5ncm91cC50eXBlICE9PSAnYWN0aXZlU2VsZWN0aW9uJyA/XG4gICAgICAgICAgdGhpcy5fbm9ybWFsaXplUG9pbnRlcihvYmpUb0NoZWNrLmdyb3VwLCBwb2ludGVyKSA6IHBvaW50ZXI7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja1RhcmdldChwb2ludGVyVG9Vc2UsIG9ialRvQ2hlY2ssIHBvaW50ZXIpKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gb2JqZWN0c1tpXTtcbiAgICAgICAgICBpZiAodGFyZ2V0LnN1YlRhcmdldENoZWNrICYmIHRhcmdldCBpbnN0YW5jZW9mIGZhYnJpYy5Hcm91cCkge1xuICAgICAgICAgICAgc3ViVGFyZ2V0ID0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKHRhcmdldC5fb2JqZWN0cywgcG9pbnRlcik7XG4gICAgICAgICAgICBzdWJUYXJnZXQgJiYgdGhpcy50YXJnZXRzLnB1c2goc3ViVGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcG9pbnRlciBjb29yZGluYXRlcyB3aXRob3V0IHRoZSBlZmZlY3Qgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ4XCIgYW5kIFwieVwiIG51bWJlciB2YWx1ZXNcbiAgICAgKi9cbiAgICByZXN0b3JlUG9pbnRlclZwdDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KFxuICAgICAgICBwb2ludGVyLFxuICAgICAgICBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcG9pbnRlciBjb29yZGluYXRlcyByZWxhdGl2ZSB0byBjYW52YXMuXG4gICAgICogQ2FuIHJldHVybiBjb29yZGluYXRlcyB3aXRoIG9yIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm0uXG4gICAgICogaWdub3JlWm9vbSBmYWxzZSBnaXZlcyBiYWNrIGNvb3JkaW5hdGVzIHRoYXQgcmVwcmVzZW50XG4gICAgICogdGhlIHBvaW50IGNsaWNrZWQgb24gY2FudmFzIGVsZW1lbnQuXG4gICAgICogaWdub3JlWm9vbSB0cnVlIGdpdmVzIGJhY2sgY29vcmRpbmF0ZXMgYWZ0ZXIgYmVpbmcgcHJvY2Vzc2VkXG4gICAgICogYnkgdGhlIHZpZXdwb3J0VHJhbnNmb3JtICggc29ydCBvZiBjb29yZGluYXRlcyBvZiB3aGF0IGlzIGRpc3BsYXllZFxuICAgICAqIG9uIHRoZSBjYW52YXMgd2hlcmUgeW91IGFyZSBjbGlja2luZy5cbiAgICAgKiBpZ25vcmVab29tIHRydWUgPSBIVE1MRWxlbWVudCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0b3AsbGVmdFxuICAgICAqIGlnbm9yZVpvb20gZmFsc2UsIGRlZmF1bHQgPSBmYWJyaWMgc3BhY2UgY29vcmRpbmF0ZXMsIHRoZSBzYW1lIHVzZWQgZm9yIHNoYXBlIHBvc2l0aW9uXG4gICAgICogVG8gaW50ZXJhY3Qgd2l0aCB5b3VyIHNoYXBlcyB0b3AgYW5kIGxlZnQgeW91IHdhbnQgdG8gdXNlIGlnbm9yZVpvb20gdHJ1ZVxuICAgICAqIG1vc3Qgb2YgdGhlIHRpbWUsIHdoaWxlIGlnbm9yZVpvb20gZmFsc2Ugd2lsbCBnaXZlIHlvdSBjb29yZGluYXRlc1xuICAgICAqIGNvbXBhdGlibGUgd2l0aCB0aGUgb2JqZWN0Lm9Db29yZHMgc3lzdGVtLlxuICAgICAqIG9mIHRoZSB0aW1lLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVpvb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIFwieFwiIGFuZCBcInlcIiBudW1iZXIgdmFsdWVzXG4gICAgICovXG4gICAgZ2V0UG9pbnRlcjogZnVuY3Rpb24gKGUsIGlnbm9yZVpvb20pIHtcbiAgICAgIC8vIHJldHVybiBjYWNoZWQgdmFsdWVzIGlmIHdlIGFyZSBpbiB0aGUgZXZlbnQgcHJvY2Vzc2luZyBjaGFpblxuICAgICAgaWYgKHRoaXMuX2Fic29sdXRlUG9pbnRlciAmJiAhaWdub3JlWm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVQb2ludGVyO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BvaW50ZXIgJiYgaWdub3JlWm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlcjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSBnZXRQb2ludGVyKGUpLFxuICAgICAgICAgIHVwcGVyQ2FudmFzRWwgPSB0aGlzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgYm91bmRzID0gdXBwZXJDYW52YXNFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICBib3VuZHNXaWR0aCA9IGJvdW5kcy53aWR0aCB8fCAwLFxuICAgICAgICAgIGJvdW5kc0hlaWdodCA9IGJvdW5kcy5oZWlnaHQgfHwgMCxcbiAgICAgICAgICBjc3NTY2FsZTtcblxuICAgICAgaWYgKCFib3VuZHNXaWR0aCB8fCAhYm91bmRzSGVpZ2h0ICkge1xuICAgICAgICBpZiAoJ3RvcCcgaW4gYm91bmRzICYmICdib3R0b20nIGluIGJvdW5kcykge1xuICAgICAgICAgIGJvdW5kc0hlaWdodCA9IE1hdGguYWJzKCBib3VuZHMudG9wIC0gYm91bmRzLmJvdHRvbSApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgncmlnaHQnIGluIGJvdW5kcyAmJiAnbGVmdCcgaW4gYm91bmRzKSB7XG4gICAgICAgICAgYm91bmRzV2lkdGggPSBNYXRoLmFicyggYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcbiAgICAgIHBvaW50ZXIueCA9IHBvaW50ZXIueCAtIHRoaXMuX29mZnNldC5sZWZ0O1xuICAgICAgcG9pbnRlci55ID0gcG9pbnRlci55IC0gdGhpcy5fb2Zmc2V0LnRvcDtcbiAgICAgIGlmICghaWdub3JlWm9vbSkge1xuICAgICAgICBwb2ludGVyID0gdGhpcy5yZXN0b3JlUG9pbnRlclZwdChwb2ludGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kc1dpZHRoID09PSAwIHx8IGJvdW5kc0hlaWdodCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBib3VuZHMgYXJlIG5vdCBhdmFpbGFibGUgKGkuZS4gbm90IHZpc2libGUpLCBkbyBub3QgYXBwbHkgc2NhbGUuXG4gICAgICAgIGNzc1NjYWxlID0geyB3aWR0aDogMSwgaGVpZ2h0OiAxIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3NzU2NhbGUgPSB7XG4gICAgICAgICAgd2lkdGg6IHVwcGVyQ2FudmFzRWwud2lkdGggLyBib3VuZHNXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHVwcGVyQ2FudmFzRWwuaGVpZ2h0IC8gYm91bmRzSGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvaW50ZXIueCAqIGNzc1NjYWxlLndpZHRoLFxuICAgICAgICB5OiBwb2ludGVyLnkgKiBjc3NTY2FsZS5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHRocm93cyB7Q0FOVkFTX0lOSVRfRVJST1J9IElmIGNhbnZhcyBjYW4gbm90IGJlIGluaXRpYWxpemVkXG4gICAgICovXG4gICAgX2NyZWF0ZVVwcGVyQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbG93ZXJDYW52YXNDbGFzcyA9IHRoaXMubG93ZXJDYW52YXNFbC5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmxvd2VyLWNhbnZhc1xccyovLCAnJyk7XG5cbiAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHVwcGVyQ2FudmFzIGVsZW1lbnQgaWYgd2UgaGF2ZSBhbHJlYWR5IG9uZS5cbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsLmNsYXNzTmFtZSA9ICcnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMudXBwZXJDYW52YXNFbCA9IHRoaXMuX2NyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy51dGlsLmFkZENsYXNzKHRoaXMudXBwZXJDYW52YXNFbCwgJ3VwcGVyLWNhbnZhcyAnICsgbG93ZXJDYW52YXNDbGFzcyk7XG5cbiAgICAgIHRoaXMud3JhcHBlckVsLmFwcGVuZENoaWxkKHRoaXMudXBwZXJDYW52YXNFbCk7XG5cbiAgICAgIHRoaXMuX2NvcHlDYW52YXNTdHlsZSh0aGlzLmxvd2VyQ2FudmFzRWwsIHRoaXMudXBwZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLl9hcHBseUNhbnZhc1N0eWxlKHRoaXMudXBwZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSB0aGlzLnVwcGVyQ2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FjaGVDYW52YXNFbCA9IHRoaXMuX2NyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIHRoaXMuY2FjaGVDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy53aWR0aCk7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLmNvbnRleHRDYWNoZSA9IHRoaXMuY2FjaGVDYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0V3JhcHBlckVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMud3JhcHBlckVsID0gZmFicmljLnV0aWwud3JhcEVsZW1lbnQodGhpcy5sb3dlckNhbnZhc0VsLCAnZGl2Jywge1xuICAgICAgICAnY2xhc3MnOiB0aGlzLmNvbnRhaW5lckNsYXNzXG4gICAgICB9KTtcbiAgICAgIGZhYnJpYy51dGlsLnNldFN0eWxlKHRoaXMud3JhcHBlckVsLCB7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoICsgJ3B4JyxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCArICdweCcsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICB9KTtcbiAgICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKHRoaXMud3JhcHBlckVsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IGNhbnZhcyBlbGVtZW50IHRvIGFwcGx5IHN0eWxlcyBvblxuICAgICAqL1xuICAgIF9hcHBseUNhbnZhc1N0eWxlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCB8fCBlbGVtZW50LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0O1xuXG4gICAgICBmYWJyaWMudXRpbC5zZXRTdHlsZShlbGVtZW50LCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB3aWR0aDogd2lkdGggKyAncHgnLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArICdweCcsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgJ3RvdWNoLWFjdGlvbic6IHRoaXMuYWxsb3dUb3VjaFNjcm9sbGluZyA/ICdtYW5pcHVsYXRpb24nIDogJ25vbmUnXG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQud2lkdGggPSB3aWR0aDtcbiAgICAgIGVsZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRVbnNlbGVjdGFibGUoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvcHkgdGhlIGVudGlyZSBpbmxpbmUgc3R5bGUgZnJvbSBvbmUgZWxlbWVudCAoZnJvbUVsKSB0byBhbm90aGVyICh0b0VsKVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBmcm9tRWwgRWxlbWVudCBzdHlsZSBpcyBjb3BpZWQgZnJvbVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdG9FbCBFbGVtZW50IGNvcGllZCBzdHlsZSBpcyBhcHBsaWVkIHRvXG4gICAgICovXG4gICAgX2NvcHlDYW52YXNTdHlsZTogZnVuY3Rpb24gKGZyb21FbCwgdG9FbCkge1xuICAgICAgdG9FbC5zdHlsZS5jc3NUZXh0ID0gZnJvbUVsLnN0eWxlLmNzc1RleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udGV4dCBvZiBjYW52YXMgd2hlcmUgb2JqZWN0IHNlbGVjdGlvbiBpcyBkcmF3blxuICAgICAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25Db250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRUb3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgJmx0O2NhbnZhcz4gZWxlbWVudCBvbiB3aGljaCBvYmplY3Qgc2VsZWN0aW9uIGlzIGRyYXduXG4gICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudXBwZXJDYW52YXNFbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50bHkgYWN0aXZlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IGFjdGl2ZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgY3VycmVudCBzZWxlY3RlZCBvYmplY3RzXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gYWN0aXZlIG9iamVjdFxuICAgICAqL1xuICAgIGdldEFjdGl2ZU9iamVjdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhY3RpdmUgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIGlmIChhY3RpdmUudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicgJiYgYWN0aXZlLl9vYmplY3RzKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZS5fb2JqZWN0cy5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW2FjdGl2ZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBPYmplY3QgdGhhdCB3YXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgLy8gcmVtb3ZpbmcgYWN0aXZlIG9iamVjdCBzaG91bGQgZmlyZSBcInNlbGVjdGlvbjpjbGVhcmVkXCIgZXZlbnRzXG4gICAgICBpZiAob2JqID09PSB0aGlzLl9hY3RpdmVPYmplY3QpIHtcbiAgICAgICAgdGhpcy5maXJlKCdiZWZvcmU6c2VsZWN0aW9uOmNsZWFyZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgICB0aGlzLl9kaXNjYXJkQWN0aXZlT2JqZWN0KCk7XG4gICAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNsZWFyZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgICBvYmouZmlyZSgnZGVzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2hvdmVyZWRUYXJnZXQgPT09IG9iaikge1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfb25PYmplY3RSZW1vdmVkJywgb2JqKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBDb21wYXJlcyB0aGUgb2xkIGFjdGl2ZU9iamVjdCB3aXRoIHRoZSBjdXJyZW50IG9uZSBhbmQgZmlyZXMgY29ycmVjdCBldmVudHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBvbGQgYWN0aXZlT2JqZWN0XG4gICAgICovXG4gICAgX2ZpcmVTZWxlY3Rpb25FdmVudHM6IGZ1bmN0aW9uKG9sZE9iamVjdHMsIGUpIHtcbiAgICAgIHZhciBzb21ldGhpbmdDaGFuZ2VkID0gZmFsc2UsIG9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBhZGRlZCA9IFtdLCByZW1vdmVkID0gW10sIG9wdCA9IHsgZTogZSB9O1xuICAgICAgb2xkT2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9sZE9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0cy5pbmRleE9mKG9sZE9iamVjdCkgPT09IC0xKSB7XG4gICAgICAgICAgc29tZXRoaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgb2xkT2JqZWN0LmZpcmUoJ2Rlc2VsZWN0ZWQnLCBvcHQpO1xuICAgICAgICAgIHJlbW92ZWQucHVzaChvbGRPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9sZE9iamVjdHMuaW5kZXhPZihvYmplY3QpID09PSAtMSkge1xuICAgICAgICAgIHNvbWV0aGluZ0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIG9iamVjdC5maXJlKCdzZWxlY3RlZCcsIG9wdCk7XG4gICAgICAgICAgYWRkZWQucHVzaChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChvbGRPYmplY3RzLmxlbmd0aCA+IDAgJiYgb2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9wdC5zZWxlY3RlZCA9IGFkZGVkO1xuICAgICAgICBvcHQuZGVzZWxlY3RlZCA9IHJlbW92ZWQ7XG4gICAgICAgIC8vIGFkZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgIG9wdC51cGRhdGVkID0gYWRkZWRbMF0gfHwgcmVtb3ZlZFswXTtcbiAgICAgICAgb3B0LnRhcmdldCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgICAgc29tZXRoaW5nQ2hhbmdlZCAmJiB0aGlzLmZpcmUoJ3NlbGVjdGlvbjp1cGRhdGVkJywgb3B0KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBkZXByZWNhdGVkIGV2ZW50XG4gICAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG9wdC50YXJnZXQgPSBhZGRlZFswXTtcbiAgICAgICAgICB0aGlzLmZpcmUoJ29iamVjdDpzZWxlY3RlZCcsIG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0LnNlbGVjdGVkID0gYWRkZWQ7XG4gICAgICAgIC8vIGFkZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgIG9wdC50YXJnZXQgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNyZWF0ZWQnLCBvcHQpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2xkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9wdC5kZXNlbGVjdGVkID0gcmVtb3ZlZDtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIG9wdCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZ2l2ZW4gb2JqZWN0IGFzIHRoZSBvbmx5IGFjdGl2ZSBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNldCBhcyBhbiBhY3RpdmUgb25lXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IChwYXNzZWQgYWxvbmcgd2hlbiBmaXJpbmcgXCJvYmplY3Q6c2VsZWN0ZWRcIilcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKG9iamVjdCwgZSkge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCk7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVPYmplY3Qob2JqZWN0LCBlKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZXMsIGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZXQgYXMgYWN0aXZlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IChwYXNzZWQgYWxvbmcgd2hlbiBmaXJpbmcgXCJvYmplY3Q6c2VsZWN0ZWRcIilcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzZWxlY3Rpb24gaGFwcGVuZWRcbiAgICAgKi9cbiAgICBfc2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIGUpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVPYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoZSwgb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm9uU2VsZWN0KHsgZTogZSB9KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9hY3RpdmVPYmplY3QgPSBvYmplY3Q7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzY2FyZEFjdGl2ZU9iamVjdDogZnVuY3Rpb24oZSwgb2JqZWN0KSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgaWYgKG9iaikge1xuICAgICAgICAvLyBvbkRlc2VsZWN0IHJldHVybiBUUlVFIHRvIGNhbmNlbCBzZWxlY3Rpb247XG4gICAgICAgIGlmIChvYmoub25EZXNlbGVjdCh7IGU6IGUsIG9iamVjdDogb2JqZWN0IH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzY2FyZHMgY3VycmVudGx5IGFjdGl2ZSBvYmplY3QgYW5kIGZpcmUgZXZlbnRzLiBJZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGZhYnJpY1xuICAgICAqIGFzIGEgY29uc2VxdWVuY2Ugb2YgYSBtb3VzZSBldmVudCwgdGhlIGV2ZW50IGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBhbmRcbiAgICAgKiBzZW50IHRvIHRoZSBmaXJlIGZ1bmN0aW9uIGZvciB0aGUgY3VzdG9tIGV2ZW50cy4gV2hlbiB1c2VkIGFzIGEgbWV0aG9kIHRoZVxuICAgICAqIGUgcGFyYW0gZG9lcyBub3QgaGF2ZSBhbnkgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtldmVudH0gZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzY2FyZEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjdXJyZW50QWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpO1xuICAgICAgaWYgKGN1cnJlbnRBY3RpdmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBjdXJyZW50QWN0aXZlc1swXSwgZTogZSB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoZSk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKGN1cnJlbnRBY3RpdmVzLCBlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYSBjYW52YXMgZWxlbWVudCBhbmQgcmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRoaXMud3JhcHBlckVsO1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuY29udGV4dENhY2hlID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dFRvcCA9IG51bGw7XG4gICAgICBbJ3VwcGVyQ2FudmFzRWwnLCAnY2FjaGVDYW52YXNFbCddLmZvckVhY2goKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2xlYW5VcEpzZG9tTm9kZSh0aGlzW2VsZW1lbnRdKTtcbiAgICAgICAgdGhpc1tlbGVtZW50XSA9IHVuZGVmaW5lZDtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgICAgaWYgKHdyYXBwZXIucGFyZW50Tm9kZSkge1xuICAgICAgICB3cmFwcGVyLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy53cmFwcGVyRWwpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMud3JhcHBlckVsO1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY29udGV4dHMgKGJhY2tncm91bmQsIG1haW4sIHRvcCkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB0aGlzLmRpc2NhcmRBY3RpdmVHcm91cCgpO1xuICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dCh0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdjbGVhcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBvYmplY3RzJyBjb250cm9scyAoYm9yZGVycy9jb250cm9scylcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIGNvbnRyb2xzIG9uXG4gICAgICovXG4gICAgZHJhd0NvbnRyb2xzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIGlmIChhY3RpdmVPYmplY3QpIHtcbiAgICAgICAgYWN0aXZlT2JqZWN0Ll9yZW5kZXJDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vSWYgdGhlIG9iamVjdCBpcyBwYXJ0IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBncm91cCwgaXQgc2hvdWxkXG4gICAgICAvL2JlIHRyYW5zZm9ybWVkIGFwcHJvcHJpYXRlbHlcbiAgICAgIC8vaS5lLiBpdCBzaG91bGQgYmUgc2VyaWFsaXNlZCBhcyBpdCB3b3VsZCBhcHBlYXIgaWYgdGhlIHNlbGVjdGlvbiBncm91cFxuICAgICAgLy93ZXJlIHRvIGJlIGRlc3Ryb3llZC5cbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXMgPSB0aGlzLl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSksXG4gICAgICAgICAgb2JqZWN0ID0gdGhpcy5jYWxsU3VwZXIoJ190b09iamVjdCcsIGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIC8vVW5kbyB0aGUgZGFtYWdlIHdlIGRpZCBieSBjaGFuZ2luZyBhbGwgb2YgaXRzIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UsIG9yaWdpbmFsUHJvcGVydGllcyk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFsaXNlcyBhbiBvYmplY3QncyBncm91cCB0cmFuc2Zvcm1hdGlvbiBvbiBpdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbaW5zdGFuY2VdIHRoZSBvYmplY3QgdG8gdHJhbnNmb3JtIChnZXRzIG11dGF0ZWQpXG4gICAgICogQHJldHVybnMgdGhlIG9yaWdpbmFsIHZhbHVlcyBvZiBpbnN0YW5jZSB3aGljaCB3ZXJlIGNoYW5nZWRcbiAgICAgKi9cbiAgICBfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuZ3JvdXAgJiYgaW5zdGFuY2UuZ3JvdXAudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicgJiYgdGhpcy5fYWN0aXZlT2JqZWN0ID09PSBpbnN0YW5jZS5ncm91cCkge1xuICAgICAgICB2YXIgbGF5b3V0UHJvcHMgPSBbJ2FuZ2xlJywgJ2ZsaXBYJywgJ2ZsaXBZJywgJ2xlZnQnLCAnc2NhbGVYJywgJ3NjYWxlWScsICdza2V3WCcsICdza2V3WScsICd0b3AnXTtcbiAgICAgICAgLy9Db3B5IGFsbCB0aGUgcG9zaXRpb25hbGx5IHJlbGV2YW50IHByb3BlcnRpZXMgYWNyb3NzIG5vd1xuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZXMgPSB7fTtcbiAgICAgICAgbGF5b3V0UHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgb3JpZ2luYWxWYWx1ZXNbcHJvcF0gPSBpbnN0YW5jZVtwcm9wXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5yZWFsaXplVHJhbnNmb3JtKGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsVmFsdWVzO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyB0aGUgY2hhbmdlZCBwcm9wZXJ0aWVzIG9mIGluc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IFtpbnN0YW5jZV0gdGhlIG9iamVjdCB0byB1bi10cmFuc2Zvcm0gKGdldHMgbXV0YXRlZClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29yaWdpbmFsVmFsdWVzXSB0aGUgb3JpZ2luYWwgdmFsdWVzIG9mIGluc3RhbmNlLCBhcyByZXR1cm5lZCBieSBfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3RcbiAgICAgKi9cbiAgICBfdW53aW5kR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG9yaWdpbmFsVmFsdWVzKSB7XG4gICAgICBpZiAob3JpZ2luYWxWYWx1ZXMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0KG9yaWdpbmFsVmFsdWVzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHT2JqZWN0OiBmdW5jdGlvbihtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKSB7XG4gICAgICAvL0lmIHRoZSBvYmplY3QgaXMgaW4gYSBzZWxlY3Rpb24gZ3JvdXAsIHNpbXVsYXRlIHdoYXQgd291bGQgaGFwcGVuIHRvIHRoYXRcbiAgICAgIC8vb2JqZWN0IHdoZW4gdGhlIGdyb3VwIGlzIGRlc2VsZWN0ZWRcbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXMgPSB0aGlzLl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldFNWR09iamVjdCcsIG1hcmt1cCwgaW5zdGFuY2UsIHJldml2ZXIpO1xuICAgICAgdGhpcy5fdW53aW5kR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSwgb3JpZ2luYWxQcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgc2V0Vmlld3BvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uICh2cHQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMuX2FjdGl2ZU9iamVjdCAmJiB0aGlzLl9hY3RpdmVPYmplY3QuaXNFZGl0aW5nKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnNldFZpZXdwb3J0VHJhbnNmb3JtLmNhbGwodGhpcywgdnB0KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNvcHlpbmcgc3RhdGljIHByb3BlcnRpZXMgbWFudWFsbHkgdG8gd29yayBhcm91bmQgT3BlcmEncyBidWcsXG4gIC8vIHdoZXJlIFwicHJvdG90eXBlXCIgcHJvcGVydHkgaXMgZW51bWVyYWJsZSBhbmQgb3ZlcnJpZGVzIGV4aXN0aW5nIHByb3RvdHlwZVxuICBmb3IgKHZhciBwcm9wIGluIGZhYnJpYy5TdGF0aWNDYW52YXMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIGZhYnJpYy5DYW52YXNbcHJvcF0gPSBmYWJyaWMuU3RhdGljQ2FudmFzW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCkge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgZmFicmljLkNhbnZhcy5wcm90b3R5cGUuX3NldEN1cnNvckZyb21FdmVudCA9IGZ1bmN0aW9uKCkgeyB9O1xuICB9XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY3Vyc29yT2Zmc2V0ID0ge1xuICAgICAgICBtdDogMCwgLy8gblxuICAgICAgICB0cjogMSwgLy8gbmVcbiAgICAgICAgbXI6IDIsIC8vIGVcbiAgICAgICAgYnI6IDMsIC8vIHNlXG4gICAgICAgIG1iOiA0LCAvLyBzXG4gICAgICAgIGJsOiA1LCAvLyBzd1xuICAgICAgICBtbDogNiwgLy8gd1xuICAgICAgICB0bDogNyAvLyBud1xuICAgICAgfSxcbiAgICAgIGFkZExpc3RlbmVyID0gZmFicmljLnV0aWwuYWRkTGlzdGVuZXIsXG4gICAgICByZW1vdmVMaXN0ZW5lciA9IGZhYnJpYy51dGlsLnJlbW92ZUxpc3RlbmVyLFxuICAgICAgUklHSFRfQ0xJQ0sgPSAzLCBNSURETEVfQ0xJQ0sgPSAyLCBMRUZUX0NMSUNLID0gMSxcbiAgICAgIGFkZEV2ZW50T3B0aW9ucyA9IHsgcGFzc2l2ZTogZmFsc2UgfTtcblxuICBmdW5jdGlvbiBjaGVja0NsaWNrKGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuICd3aGljaCcgaW4gZSA/IGUud2hpY2ggPT09IHZhbHVlIDogZS5idXR0b24gPT09IHZhbHVlIC0gMTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogTWFwIG9mIGN1cnNvciBzdHlsZSB2YWx1ZXMgZm9yIGVhY2ggb2YgdGhlIG9iamVjdCBjb250cm9sc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3Vyc29yTWFwOiBbXG4gICAgICAnbi1yZXNpemUnLFxuICAgICAgJ25lLXJlc2l6ZScsXG4gICAgICAnZS1yZXNpemUnLFxuICAgICAgJ3NlLXJlc2l6ZScsXG4gICAgICAncy1yZXNpemUnLFxuICAgICAgJ3N3LXJlc2l6ZScsXG4gICAgICAndy1yZXNpemUnLFxuICAgICAgJ253LXJlc2l6ZSdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBtb3VzZSBsaXN0ZW5lcnMgdG8gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpbiBjYXNlIHdlIGluaXRpYWxpemVkIHRoZSBjbGFzcyB0d2ljZS4gVGhpcyBzaG91bGQgbm90IGhhcHBlbiBub3JtYWxseVxuICAgICAgLy8gYnV0IGluIHNvbWUga2luZCBvZiBhcHBsaWNhdGlvbnMgd2hlcmUgdGhlIGNhbnZhcyBlbGVtZW50IG1heSBiZSBjaGFuZ2VkXG4gICAgICAvLyB0aGlzIGlzIGEgd29ya2Fyb3VuZCB0byBoYXZpbmcgZG91YmxlIGxpc3RlbmVycy5cbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlKGFkZExpc3RlbmVyLCAnYWRkJyk7XG4gICAgfSxcblxuICAgIGFkZE9yUmVtb3ZlOiBmdW5jdGlvbihmdW5jdG9yLCBldmVudGpzRnVuY3Rvcikge1xuICAgICAgZnVuY3RvcihmYWJyaWMud2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICBmdW5jdG9yKHRoaXMudXBwZXJDYW52YXNFbCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZW91dCcsIHRoaXMuX29uTW91c2VPdXQpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZWVudGVyJywgdGhpcy5fb25Nb3VzZUVudGVyKTtcbiAgICAgIGZ1bmN0b3IodGhpcy51cHBlckNhbnZhc0VsLCAnd2hlZWwnLCB0aGlzLl9vbk1vdXNlV2hlZWwpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2spO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Nb3VzZURvd24sIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICBmdW5jdG9yKHRoaXMudXBwZXJDYW52YXNFbCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdkcmFnb3ZlcicsIHRoaXMuX29uRHJhZ092ZXIpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdkcmFnZW50ZXInLCB0aGlzLl9vbkRyYWdFbnRlcik7XG4gICAgICBmdW5jdG9yKHRoaXMudXBwZXJDYW52YXNFbCwgJ2RyYWdsZWF2ZScsIHRoaXMuX29uRHJhZ0xlYXZlKTtcbiAgICAgIGZ1bmN0b3IodGhpcy51cHBlckNhbnZhc0VsLCAnZHJvcCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICBpZiAodHlwZW9mIGV2ZW50anMgIT09ICd1bmRlZmluZWQnICYmIGV2ZW50anNGdW5jdG9yIGluIGV2ZW50anMpIHtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0odGhpcy51cHBlckNhbnZhc0VsLCAnZ2VzdHVyZScsIHRoaXMuX29uR2VzdHVyZSk7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKHRoaXMudXBwZXJDYW52YXNFbCwgJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXSh0aGlzLnVwcGVyQ2FudmFzRWwsICdvcmllbnRhdGlvbicsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXSh0aGlzLnVwcGVyQ2FudmFzRWwsICdzaGFrZScsIHRoaXMuX29uU2hha2UpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXSh0aGlzLnVwcGVyQ2FudmFzRWwsICdsb25ncHJlc3MnLCB0aGlzLl9vbkxvbmdQcmVzcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlKHJlbW92ZUxpc3RlbmVyLCAncmVtb3ZlJyk7XG4gICAgICAvLyBpZiB5b3UgZGlzcG9zZSBvbiBhIG1vdXNlRG93biwgYmVmb3JlIG1vdXNlIHVwLCB5b3UgbmVlZCB0byBjbGVhbiBkb2N1bWVudCB0by4uLlxuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uTW91c2VVcCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZXZlbnRzQm91bmQpIHtcbiAgICAgICAgLy8gZm9yIGFueSByZWFzb24gd2UgcGFzcyBoZXJlIHR3aWNlIHdlIGRvIG5vdCB3YW50IHRvIGJpbmQgZXZlbnRzIHR3aWNlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9vbk1vdXNlRG93biA9IHRoaXMuX29uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlVXAgPSB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uUmVzaXplID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uR2VzdHVyZSA9IHRoaXMuX29uR2VzdHVyZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblNoYWtlID0gdGhpcy5fb25TaGFrZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Mb25nUHJlc3MgPSB0aGlzLl9vbkxvbmdQcmVzcy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSA9IHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VXaGVlbCA9IHRoaXMuX29uTW91c2VXaGVlbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3VzZU91dCA9IHRoaXMuX29uTW91c2VPdXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VFbnRlciA9IHRoaXMuX29uTW91c2VFbnRlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Db250ZXh0TWVudSA9IHRoaXMuX29uQ29udGV4dE1lbnUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRG91YmxlQ2xpY2sgPSB0aGlzLl9vbkRvdWJsZUNsaWNrLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkRyYWdPdmVyID0gdGhpcy5fb25EcmFnT3Zlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnRW50ZXIgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIuYmluZCh0aGlzLCAnZHJhZ2VudGVyJyk7XG4gICAgICB0aGlzLl9vbkRyYWdMZWF2ZSA9IHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlci5iaW5kKHRoaXMsICdkcmFnbGVhdmUnKTtcbiAgICAgIHRoaXMuX29uRHJvcCA9IHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlci5iaW5kKHRoaXMsICdkcm9wJyk7XG4gICAgICB0aGlzLmV2ZW50c0JvdW5kID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uR2VzdHVyZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uVHJhbnNmb3JtR2VzdHVyZSAmJiB0aGlzLl9fb25UcmFuc2Zvcm1HZXN0dXJlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgZHJhZ1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25EcmFnOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25EcmFnICYmIHRoaXMuX19vbkRyYWcoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiB3aGVlbCBldmVudFxuICAgICAqL1xuICAgIF9vbk1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX19vbk1vdXNlV2hlZWwoZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VPdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0O1xuICAgICAgdGhpcy5maXJlKCdtb3VzZTpvdXQnLCB7IHRhcmdldDogdGFyZ2V0LCBlOiBlIH0pO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IG51bGw7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlb3V0JywgeyBlOiBlIH0pO1xuICAgICAgaWYgKHRoaXMuX2lUZXh0SW5zdGFuY2VzKSB7XG4gICAgICAgIHRoaXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIG9iai5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2VlbnRlclxuICAgICAqL1xuICAgIF9vbk1vdXNlRW50ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghdGhpcy5maW5kVGFyZ2V0KGUpKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnbW91c2U6b3ZlcicsIHsgdGFyZ2V0OiBudWxsLCBlOiBlIH0pO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIG9yaWVudGF0aW9uIGNoYW5nZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25PcmllbnRhdGlvbkNoYW5nZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uT3JpZW50YXRpb25DaGFuZ2UgJiYgdGhpcy5fX29uT3JpZW50YXRpb25DaGFuZ2UoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25TaGFrZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uU2hha2UgJiYgdGhpcy5fX29uU2hha2UoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25Mb25nUHJlc3M6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vbkxvbmdQcmVzcyAmJiB0aGlzLl9fb25Mb25nUHJlc3MoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHByZXZlbnQgZGVmYXVsdCB0byBhbGxvdyBkcm9wIGV2ZW50IHRvIGJlIGZpcmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIHNoYWtlXG4gICAgICovXG4gICAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIoJ2RyYWdvdmVyJywgZSk7XG4gICAgICB0aGlzLl9maXJlRW50ZXJMZWF2ZUV2ZW50cyh0YXJnZXQsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbkNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHRoaXMuc3RvcENvbnRleHRNZW51KSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2RibGNsaWNrJyk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZURvd24oZSk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXAsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcblxuICAgICAgcmVtb3ZlTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICByZW1vdmVMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIC8vIFVuYmluZCBtb3VzZWRvd24gdG8gcHJldmVudCBkb3VibGUgdHJpZ2dlcnMgZnJvbSB0b3VjaCBkZXZpY2VzXG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZVVwKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXAsIGFkZEV2ZW50T3B0aW9ucyk7XG5cbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG5cbiAgICAgIGFkZExpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgYWRkTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgLy8gV2FpdCA0MDBtcyBiZWZvcmUgcmViaW5kaW5nIG1vdXNlZG93biB0byBwcmV2ZW50IGRvdWJsZSB0cmlnZ2Vyc1xuICAgICAgICAvLyBmcm9tIHRvdWNoIGRldmljZXNcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBhZGRMaXN0ZW5lcihfdGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vkb3duJywgX3RoaXMuX29uTW91c2VEb3duKTtcbiAgICAgICAgfSwgNDAwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAhdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nICYmIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fX29uTW91c2VNb3ZlKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZXMgd2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBiZSByZWRyYXduIGluIG1vdXNldXAgYW5kIG1vdXNlZG93biBldmVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX3Nob3VsZFJlbmRlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuXG4gICAgICBpZiAoXG4gICAgICAgICEhYWN0aXZlT2JqZWN0ICE9PSAhIXRhcmdldCB8fFxuICAgICAgICAoYWN0aXZlT2JqZWN0ICYmIHRhcmdldCAmJiAoYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQpKVxuICAgICAgKSB7XG4gICAgICAgIC8vIHRoaXMgY292ZXJzOiBzd2l0Y2ggb2YgdGFyZ2V0LCBmcm9tIHRhcmdldCB0byBubyB0YXJnZXQsIHNlbGVjdGlvbiBvZiB0YXJnZXRcbiAgICAgICAgLy8gbXVsdGlTZWxlY3Rpb24gd2l0aCBrZXkgYW5kIG1vdXNlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aXZlT2JqZWN0ICYmIGFjdGl2ZU9iamVjdC5pc0VkaXRpbmcpIHtcbiAgICAgICAgLy8gaWYgd2UgbW91c2UgdXAvZG93biBvdmVyIGEgZWRpdGluZyB0ZXh0Ym94IGEgY3Vyc29yIGNoYW5nZSxcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCB0byByZSByZW5kZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIHRoZSBhY3Rpb25zIHdoZW4gbW91c2UgaXMgcmVsZWFzZWQgb24gY2FudmFzLlxuICAgICAqIFRoZSBtZXRob2QgcmVzZXRzIHRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlcnMsIHN0b3JlIHRoZSBpbWFnZSBjb3JuZXJcbiAgICAgKiBwb3NpdGlvbiBpbiB0aGUgaW1hZ2Ugb2JqZWN0IGFuZCByZW5kZXIgdGhlIGNhbnZhcyBvbiB0b3AuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX19vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdGFyZ2V0LCB0cmFuc2Zvcm0gPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IgPSB0aGlzLl9ncm91cFNlbGVjdG9yLCBzaG91bGRSZW5kZXIgPSBmYWxzZSxcbiAgICAgICAgICBpc0NsaWNrID0gKCFncm91cFNlbGVjdG9yIHx8IChncm91cFNlbGVjdG9yLmxlZnQgPT09IDAgJiYgZ3JvdXBTZWxlY3Rvci50b3AgPT09IDApKTtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwOmJlZm9yZScpO1xuICAgICAgLy8gaWYgcmlnaHQvbWlkZGxlIGNsaWNrIGp1c3QgZmlyZSBldmVudHMgYW5kIHJldHVyblxuICAgICAgLy8gdGFyZ2V0IHVuZGVmaW5lZCB3aWxsIG1ha2UgdGhlIF9oYW5kbGVFdmVudCBzZWFyY2ggdGhlIHRhcmdldFxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgUklHSFRfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVSaWdodENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJywgUklHSFRfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgTUlERExFX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlTWlkZGxlQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnLCBNSURETEVfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSAmJiB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZVVwSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybShlKTtcbiAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0NsaWNrKSB7XG4gICAgICAgIHRoaXMuX21heWJlR3JvdXBPYmplY3RzKGUpO1xuICAgICAgICBzaG91bGRSZW5kZXIgfHwgKHNob3VsZFJlbmRlciA9IHRoaXMuX3Nob3VsZFJlbmRlcih0YXJnZXQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LmlzTW92aW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRDdXJzb3JGcm9tRXZlbnQoZSwgdGFyZ2V0KTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcsIExFRlRfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IG51bGw7XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gbnVsbDtcbiAgICAgIC8vIHJlc2V0IHRoZSB0YXJnZXQgaW5mb3JtYXRpb24gYWJvdXQgd2hpY2ggY29ybmVyIGlzIHNlbGVjdGVkXG4gICAgICB0YXJnZXQgJiYgKHRhcmdldC5fX2Nvcm5lciA9IDApO1xuICAgICAgaWYgKHNob3VsZFJlbmRlcikge1xuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc0NsaWNrKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVG9wKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogSGFuZGxlIGV2ZW50IGZpcmluZyBmb3IgdGFyZ2V0IGFuZCBzdWJ0YXJnZXRzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBldmVudCBmcm9tIG1vdXNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBldmVudCB0byBmaXJlICh1cCwgZG93biBvciBtb3ZlKVxuICAgICAqIEByZXR1cm4ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCByZXR1cm4gdGhlIHRoZSB0YXJnZXQgZm91bmQsIGZvciBpbnRlcm5hbCByZWFzb25zLlxuICAgICAqL1xuICAgIF9zaW1wbGVFdmVudEhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlKSxcbiAgICAgICAgICB0YXJnZXRzID0gdGhpcy50YXJnZXRzLFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBzdWJUYXJnZXRzOiB0YXJnZXRzLFxuICAgICAgICAgIH07XG4gICAgICB0aGlzLmZpcmUoZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIHRhcmdldCAmJiB0YXJnZXQuZmlyZShldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgaWYgKCF0YXJnZXRzKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0c1tpXS5maXJlKGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEhhbmRsZSBldmVudCBmaXJpbmcgZm9yIHRhcmdldCBhbmQgc3VidGFyZ2V0c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgZXZlbnQgZnJvbSBtb3VzZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgZXZlbnQgdG8gZmlyZSAodXAsIGRvd24gb3IgbW92ZSlcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldE9iaiByZWNlaXZpbmcgZXZlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2J1dHRvbl0gYnV0dG9uIHVzZWQgaW4gdGhlIGV2ZW50IDEgPSBsZWZ0LCAyID0gbWlkZGxlLCAzID0gcmlnaHRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2xpY2sgZm9yIGxlZnQgYnV0dG9uIG9ubHksIGluZGljYXRlcyB0aGF0IHRoZSBtb3VzZSB1cCBoYXBwZW5lZCB3aXRob3V0IG1vdmUuXG4gICAgICovXG4gICAgX2hhbmRsZUV2ZW50OiBmdW5jdGlvbihlLCBldmVudFR5cGUsIGJ1dHRvbiwgaXNDbGljaykge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCxcbiAgICAgICAgICB0YXJnZXRzID0gdGhpcy50YXJnZXRzIHx8IFtdLFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBzdWJUYXJnZXRzOiB0YXJnZXRzLFxuICAgICAgICAgICAgYnV0dG9uOiBidXR0b24gfHwgTEVGVF9DTElDSyxcbiAgICAgICAgICAgIGlzQ2xpY2s6IGlzQ2xpY2sgfHwgZmFsc2UsXG4gICAgICAgICAgICBwb2ludGVyOiB0aGlzLl9wb2ludGVyLFxuICAgICAgICAgICAgYWJzb2x1dGVQb2ludGVyOiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm1cbiAgICAgICAgICB9O1xuICAgICAgdGhpcy5maXJlKCdtb3VzZTonICsgZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIHRhcmdldCAmJiB0YXJnZXQuZmlyZSgnbW91c2UnICsgZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0YXJnZXRzW2ldLmZpcmUoJ21vdXNlJyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBzZW5kIHRoZSBtb3VzZSBldmVudCB0aGF0IGdlbmVyYXRlIHRoZSBmaW5hbGl6ZSBkb3duLCBzbyBpdCBjYW4gYmUgdXNlZCBpbiB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBfZmluYWxpemVDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbihlKSB7XG5cbiAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLFxuICAgICAgICAgIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgICB9O1xuXG4gICAgICBpZiAodGFyZ2V0Ll9zY2FsaW5nKSB7XG4gICAgICAgIHRhcmdldC5fc2NhbGluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQuc2V0Q29vcmRzKCk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkIHx8ICh0aGlzLnN0YXRlZnVsICYmIHRhcmdldC5oYXNTdGF0ZUNoYW5nZWQoKSkpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQpIHtcbiAgICAgICAgICBldmVudE5hbWUgPSB0aGlzLl9hZGRFdmVudE9wdGlvbnMob3B0aW9ucywgdHJhbnNmb3JtKTtcbiAgICAgICAgICB0aGlzLl9maXJlKGV2ZW50TmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlyZSgnbW9kaWZpZWQnLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXV0YXRlIG9wdGlvbiBvYmplY3QgaW4gb3JkZXIgdG8gYWRkIGJ5IHByb3BlcnR5IGFuZCBnaXZlIGJhY2sgdGhlIGV2ZW50IG5hbWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0byBtdXRhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIHRvIGluc3BlY3QgYWN0aW9uIGZyb21cbiAgICAgKi9cbiAgICBfYWRkRXZlbnRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zLCB0cmFuc2Zvcm0pIHtcbiAgICAgIC8vIHdlIGNhbiBwcm9iYWJseSBhZGQgbW9yZSBkZXRhaWxzIGF0IGxvdyBjb3N0XG4gICAgICAvLyBzY2FsZSBjaGFuZ2UsIHJvdGF0aW9uIGNoYW5nZXMsIHRyYW5zbGF0aW9uIGNoYW5nZXNcbiAgICAgIHZhciBldmVudE5hbWUsIGJ5O1xuICAgICAgc3dpdGNoICh0cmFuc2Zvcm0uYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3NjYWxlWCc6XG4gICAgICAgICAgZXZlbnROYW1lID0gJ3NjYWxlZCc7XG4gICAgICAgICAgYnkgPSAneCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NjYWxlWSc6XG4gICAgICAgICAgZXZlbnROYW1lID0gJ3NjYWxlZCc7XG4gICAgICAgICAgYnkgPSAneSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NrZXdYJzpcbiAgICAgICAgICBldmVudE5hbWUgPSAnc2tld2VkJztcbiAgICAgICAgICBieSA9ICd4JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2tld1knOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdza2V3ZWQnO1xuICAgICAgICAgIGJ5ID0gJ3knO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgZXZlbnROYW1lID0gJ3NjYWxlZCc7XG4gICAgICAgICAgYnkgPSAnZXF1YWxseSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgZXZlbnROYW1lID0gJ3JvdGF0ZWQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkcmFnJzpcbiAgICAgICAgICBldmVudE5hbWUgPSAnbW92ZWQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5ieSA9IGJ5O1xuICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZURvd25JbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuZ2V0QWN0aXZlT2JqZWN0KCkpIHtcbiAgICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KGUpLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsaXBUbykge1xuICAgICAgICBmYWJyaWMudXRpbC5jbGlwQ29udGV4dCh0aGlzLCB0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZURvd24ocG9pbnRlcik7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF9vbk1vdXNlTW92ZUluRHJhd2luZ01vZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlTW92ZShwb2ludGVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZnJlZURyYXdpbmdDdXJzb3IpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX29uTW91c2VVcEluRHJhd2luZ01vZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuY2xpcFRvKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZVVwKCk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIGNsaWNrZWQgb24gY2FudmFzLlxuICAgICAqIFRoZSBtZXRob2QgaW5pdHMgdGhlIGN1cnJlbnRUcmFuc2Zvcm0gcGFyYW1ldGVycyBhbmQgcmVuZGVycyBhbGwgdGhlXG4gICAgICogY2FudmFzIHNvIHRoZSBjdXJyZW50IGltYWdlIGNhbiBiZSBwbGFjZWQgb24gdGhlIHRvcCBjYW52YXMgYW5kIHRoZSByZXN0XG4gICAgICogaW4gb24gdGhlIGNvbnRhaW5lciBvbmUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfX29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bjpiZWZvcmUnKTtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQ7XG4gICAgICAvLyBpZiByaWdodCBjbGljayBqdXN0IGZpcmUgZXZlbnRzXG4gICAgICBpZiAoY2hlY2tDbGljayhlLCBSSUdIVF9DTElDSykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyZVJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicsIFJJR0hUX0NMSUNLKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0NsaWNrKGUsIE1JRERMRV9DTElDSykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyZU1pZGRsZUNsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nLCBNSURETEVfQ0xJQ0spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSkge1xuICAgICAgICB0aGlzLl9vbk1vdXNlRG93bkluRHJhd2luZ01vZGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWdub3JlIGlmIHNvbWUgb2JqZWN0IGlzIGJlaW5nIHRyYW5zZm9ybWVkIGF0IHRoaXMgbW9tZW50XG4gICAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5fcG9pbnRlcjtcbiAgICAgIC8vIHNhdmUgcG9pbnRlciBmb3IgY2hlY2sgaW4gX19vbk1vdXNlVXAgZXZlbnRcbiAgICAgIHRoaXMuX3ByZXZpb3VzUG9pbnRlciA9IHBvaW50ZXI7XG4gICAgICB2YXIgc2hvdWxkUmVuZGVyID0gdGhpcy5fc2hvdWxkUmVuZGVyKHRhcmdldCksXG4gICAgICAgICAgc2hvdWxkR3JvdXAgPSB0aGlzLl9zaG91bGRHcm91cChlLCB0YXJnZXQpO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyU2VsZWN0aW9uKGUsIHRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2hvdWxkR3JvdXApIHtcbiAgICAgICAgdGhpcy5faGFuZGxlR3JvdXBpbmcoZSwgdGFyZ2V0KTtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgKCF0YXJnZXQgfHxcbiAgICAgICAgKCF0YXJnZXQuc2VsZWN0YWJsZSAmJiAhdGFyZ2V0LmlzRWRpdGluZyAmJiB0YXJnZXQgIT09IHRoaXMuX2FjdGl2ZU9iamVjdCkpKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSB7XG4gICAgICAgICAgZXg6IHBvaW50ZXIueCxcbiAgICAgICAgICBleTogcG9pbnRlci55LFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIGFscmVhZHlTZWxlY3RlZCA9IHRhcmdldCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgICBpZiAodGFyZ2V0LnNlbGVjdGFibGUpIHtcbiAgICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdCh0YXJnZXQsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdCAmJiAodGFyZ2V0Ll9fY29ybmVyIHx8ICFzaG91bGRHcm91cCkpIHtcbiAgICAgICAgICB0aGlzLl9zZXR1cEN1cnJlbnRUcmFuc2Zvcm0oZSwgdGFyZ2V0LCBhbHJlYWR5U2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicpO1xuICAgICAgLy8gd2UgbXVzdCByZW5kZXJBbGwgc28gdGhhdCB3ZSB1cGRhdGUgdGhlIHZpc3VhbHNcbiAgICAgIChzaG91bGRSZW5kZXIgfHwgc2hvdWxkR3JvdXApICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXNldCBjYWNoZSBmb3JtIGNvbW1vbiBpbmZvcm1hdGlvbiBuZWVkZWQgZHVyaW5nIGV2ZW50IHByb2Nlc3NpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5fcG9pbnRlciA9IG51bGw7XG4gICAgICB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZSBjb21tb24gaW5mb3JtYXRpb24gbmVlZGVkIGR1cmluZyBldmVudCBwcm9jZXNzaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBldmVudFxuICAgICAqL1xuICAgIF9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YTogZnVuY3Rpb24oZSkge1xuICAgICAgLy8gcmVzZXQgaW4gb3JkZXIgdG8gYXZvaWQgc3RhbGUgY2FjaGluZ1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHRoaXMuX3BvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHRoaXMuX3BvaW50ZXIpO1xuICAgICAgdGhpcy5fdGFyZ2V0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSA/IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0udGFyZ2V0IDogdGhpcy5maW5kVGFyZ2V0KGUpIHx8IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JlZm9yZVRyYW5zZm9ybTogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtO1xuICAgICAgdGhpcy5zdGF0ZWZ1bCAmJiB0LnRhcmdldC5zYXZlU3RhdGUoKTtcbiAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnRyYW5zZm9ybScsIHtcbiAgICAgICAgZTogZSxcbiAgICAgICAgdHJhbnNmb3JtOiB0LFxuICAgICAgfSk7XG4gICAgICAvLyBkZXRlcm1pbmUgaWYgaXQncyBhIGRyYWcgb3Igcm90YXRlIGNhc2VcbiAgICAgIGlmICh0LmNvcm5lcikge1xuICAgICAgICB0aGlzLm9uQmVmb3JlU2NhbGVSb3RhdGUodC50YXJnZXQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIHRoZSBhY3Rpb25zIHdoZW4gbW91c2UgaXMgaG92ZXJpbmcgdGhlIGNhbnZhcy5cbiAgICAgKiBUaGUgY3VycmVudFRyYW5zZm9ybSBwYXJhbWV0ZXIgd2lsbCBkZWZpbmRlIHdoZXRoZXIgdGhlIHVzZXIgaXMgcm90YXRpbmcvc2NhbGluZy90cmFuc2xhdGluZ1xuICAgICAqIGFuIGltYWdlIG9yIG5laXRoZXIgb2YgdGhlbSAob25seSBob3ZlcmluZykuIEEgZ3JvdXAgc2VsZWN0aW9uIGlzIGFsc28gcG9zc2libGUgYW5kIHdvdWxkIGNhbmNlbFxuICAgICAqIGFsbCBhbnkgb3RoZXIgdHlwZSBvZiBhY3Rpb24uXG4gICAgICogSW4gY2FzZSBvZiBhbiBpbWFnZSB0cmFuc2Zvcm1hdGlvbiBvbmx5IHRoZSB0b3AgY2FudmFzIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmU6YmVmb3JlJyk7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHZhciB0YXJnZXQsIHBvaW50ZXI7XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGUudG91Y2hlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3I7XG5cbiAgICAgIC8vIFdlIGluaXRpYWxseSBjbGlja2VkIGluIGFuIGVtcHR5IGFyZWEsIHNvIHdlIGRyYXcgYSBib3ggZm9yIG11bHRpcGxlIHNlbGVjdGlvblxuICAgICAgaWYgKGdyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgcG9pbnRlciA9IHRoaXMuX3BvaW50ZXI7XG5cbiAgICAgICAgZ3JvdXBTZWxlY3Rvci5sZWZ0ID0gcG9pbnRlci54IC0gZ3JvdXBTZWxlY3Rvci5leDtcbiAgICAgICAgZ3JvdXBTZWxlY3Rvci50b3AgPSBwb2ludGVyLnkgLSBncm91cFNlbGVjdG9yLmV5O1xuXG4gICAgICAgIHRoaXMucmVuZGVyVG9wKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghdGhpcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICB0YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSkgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fc2V0Q3Vyc29yRnJvbUV2ZW50KGUsIHRhcmdldCk7XG4gICAgICAgIHRoaXMuX2ZpcmVPdmVyT3V0RXZlbnRzKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtT2JqZWN0KGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmUnKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZSB0aGUgbW91c2VvdXQsIG1vdXNlb3ZlciBldmVudHMgZm9yIHRoZSBmYWJyaWMgb2JqZWN0IG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCB0aGUgdGFyZ2V0IHdoZXJlIHRoZSB0YXJnZXQgZnJvbSB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZU92ZXJPdXRFdmVudHM6IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdGhpcy5maXJlU3ludGV0aWNJbk91dEV2ZW50cyh0YXJnZXQsIGUsIHtcbiAgICAgICAgdGFyZ2V0TmFtZTogJ19ob3ZlcmVkVGFyZ2V0JyxcbiAgICAgICAgY2FudmFzRXZ0T3V0OiAnbW91c2U6b3V0JyxcbiAgICAgICAgZXZ0T3V0OiAnbW91c2VvdXQnLFxuICAgICAgICBjYW52YXNFdnRJbjogJ21vdXNlOm92ZXInLFxuICAgICAgICBldnRJbjogJ21vdXNlb3ZlcicsXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFuYWdlIHRoZSBkcmFnRW50ZXIsIGRyYWdMZWF2ZSBldmVudHMgZm9yIHRoZSBmYWJyaWMgb2JqZWN0cyBvbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtGYWJyaWMuT2JqZWN0fSB0YXJnZXQgdGhlIHRhcmdldCB3aGVyZSB0aGUgdGFyZ2V0IGZyb20gdGhlIG9uRHJhZyBldmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG9uZHJhZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVFbnRlckxlYXZlRXZlbnRzOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHRoaXMuZmlyZVN5bnRldGljSW5PdXRFdmVudHModGFyZ2V0LCBlLCB7XG4gICAgICAgIHRhcmdldE5hbWU6ICdfZHJhZ2dlZG92ZXJUYXJnZXQnLFxuICAgICAgICBldnRPdXQ6ICdkcmFnbGVhdmUnLFxuICAgICAgICBldnRJbjogJ2RyYWdlbnRlcicsXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFuYWdlIHRoZSBzeW50ZXRpYyBpbi9vdXQgZXZlbnRzIGZvciB0aGUgZmFicmljIG9iamVjdHMgb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RmFicmljLk9iamVjdH0gdGFyZ2V0IHRoZSB0YXJnZXQgd2hlcmUgdGhlIHRhcmdldCBmcm9tIHRoZSBzdXBwb3J0ZWQgZXZlbnRzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBmdW5jdGlvbiB0byB3b3JrXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy50YXJnZXROYW1lIHByb3BlcnR5IG9uIHRoZSBjYW52YXMgd2hlcmUgdGhlIG9sZCB0YXJnZXQgaXMgc3RvcmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuY2FudmFzRXZ0T3V0XSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIGF0IGNhbnZhcyBsZXZlbCBmb3Igb3V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5ldnRPdXQgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBmb3Igb3V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuY2FudmFzRXZ0SW5dIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgYXQgY2FudmFzIGxldmVsIGZvciBpblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZ0SW4gbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBmb3IgaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZpcmVTeW50ZXRpY0luT3V0RXZlbnRzOiBmdW5jdGlvbih0YXJnZXQsIGUsIGNvbmZpZykge1xuICAgICAgdmFyIGluT3B0LCBvdXRPcHQsIG9sZFRhcmdldCA9IHRoaXNbY29uZmlnLnRhcmdldE5hbWVdLCBvdXRGaXJlcywgaW5GaXJlcyxcbiAgICAgICAgICB0YXJnZXRDaGFuZ2VkID0gb2xkVGFyZ2V0ICE9PSB0YXJnZXQsIGNhbnZhc0V2dEluID0gY29uZmlnLmNhbnZhc0V2dEluLCBjYW52YXNFdnRPdXQgPSBjb25maWcuY2FudmFzRXZ0T3V0O1xuICAgICAgaWYgKHRhcmdldENoYW5nZWQpIHtcbiAgICAgICAgaW5PcHQgPSB7IGU6IGUsIHRhcmdldDogdGFyZ2V0LCBwcmV2aW91c1RhcmdldDogb2xkVGFyZ2V0IH07XG4gICAgICAgIG91dE9wdCA9IHsgZTogZSwgdGFyZ2V0OiBvbGRUYXJnZXQsIG5leHRUYXJnZXQ6IHRhcmdldCB9O1xuICAgICAgICB0aGlzW2NvbmZpZy50YXJnZXROYW1lXSA9IHRhcmdldDtcbiAgICAgIH1cbiAgICAgIGluRmlyZXMgPSB0YXJnZXQgJiYgdGFyZ2V0Q2hhbmdlZDtcbiAgICAgIG91dEZpcmVzID0gb2xkVGFyZ2V0ICYmIHRhcmdldENoYW5nZWQ7XG4gICAgICBpZiAob3V0RmlyZXMpIHtcbiAgICAgICAgY2FudmFzRXZ0T3V0ICYmIHRoaXMuZmlyZShjYW52YXNFdnRPdXQsIG91dE9wdCk7XG4gICAgICAgIG9sZFRhcmdldC5maXJlKGNvbmZpZy5ldnRPdXQsIG91dE9wdCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5GaXJlcykge1xuICAgICAgICBjYW52YXNFdnRJbiAmJiB0aGlzLmZpcmUoY2FudmFzRXZ0SW4sIGluT3B0KTtcbiAgICAgICAgdGFyZ2V0LmZpcmUoY29uZmlnLmV2dEluLCBpbk9wdCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgYWN0aW9ucyB3aGVuIGFuIEV2ZW50IE1vdXNlIFdoZWVsXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9fb25Nb3VzZVdoZWVsOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd3aGVlbCcpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF90cmFuc2Zvcm1PYmplY3Q6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpLFxuICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm07XG5cbiAgICAgIHRyYW5zZm9ybS5yZXNldCA9IGZhbHNlO1xuICAgICAgdHJhbnNmb3JtLnRhcmdldC5pc01vdmluZyA9IHRydWU7XG4gICAgICB0cmFuc2Zvcm0uc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuICAgICAgdHJhbnNmb3JtLmFsdEtleSA9IGVbdGhpcy5jZW50ZXJlZEtleV07XG5cbiAgICAgIHRoaXMuX2JlZm9yZVNjYWxlVHJhbnNmb3JtKGUsIHRyYW5zZm9ybSk7XG4gICAgICB0aGlzLl9wZXJmb3JtVHJhbnNmb3JtQWN0aW9uKGUsIHRyYW5zZm9ybSwgcG9pbnRlcik7XG5cbiAgICAgIHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BlcmZvcm1UcmFuc2Zvcm1BY3Rpb246IGZ1bmN0aW9uKGUsIHRyYW5zZm9ybSwgcG9pbnRlcikge1xuICAgICAgdmFyIHggPSBwb2ludGVyLngsXG4gICAgICAgICAgeSA9IHBvaW50ZXIueSxcbiAgICAgICAgICBhY3Rpb24gPSB0cmFuc2Zvcm0uYWN0aW9uLFxuICAgICAgICAgIGFjdGlvblBlcmZvcm1lZCA9IGZhbHNlLFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICBwb2ludGVyOiBwb2ludGVyXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgKGFjdGlvblBlcmZvcm1lZCA9IHRoaXMuX3JvdGF0ZU9iamVjdCh4LCB5KSkgJiYgdGhpcy5fZmlyZSgncm90YXRpbmcnLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3NjYWxlJykge1xuICAgICAgICAoYWN0aW9uUGVyZm9ybWVkID0gdGhpcy5fb25TY2FsZShlLCB0cmFuc2Zvcm0sIHgsIHkpKSAmJiB0aGlzLl9maXJlKCdzY2FsaW5nJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzY2FsZVgnKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9zY2FsZU9iamVjdCh4LCB5LCAneCcpKSAmJiB0aGlzLl9maXJlKCdzY2FsaW5nJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzY2FsZVknKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9zY2FsZU9iamVjdCh4LCB5LCAneScpKSAmJiB0aGlzLl9maXJlKCdzY2FsaW5nJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdza2V3WCcpIHtcbiAgICAgICAgKGFjdGlvblBlcmZvcm1lZCA9IHRoaXMuX3NrZXdPYmplY3QoeCwgeSwgJ3gnKSkgJiYgdGhpcy5fZmlyZSgnc2tld2luZycsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2tld1knKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9za2V3T2JqZWN0KHgsIHksICd5JykpICYmIHRoaXMuX2ZpcmUoJ3NrZXdpbmcnLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl90cmFuc2xhdGVPYmplY3QoeCwgeSk7XG4gICAgICAgIGlmIChhY3Rpb25QZXJmb3JtZWQpIHtcbiAgICAgICAgICB0aGlzLl9maXJlKCdtb3ZpbmcnLCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLnNldEN1cnNvcihvcHRpb25zLnRhcmdldC5tb3ZlQ3Vyc29yIHx8IHRoaXMubW92ZUN1cnNvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgPSB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkIHx8IGFjdGlvblBlcmZvcm1lZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZTogZnVuY3Rpb24oZXZlbnROYW1lLCBvcHRpb25zKSB7XG4gICAgICB0aGlzLmZpcmUoJ29iamVjdDonICsgZXZlbnROYW1lLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMudGFyZ2V0LmZpcmUoZXZlbnROYW1lLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYmVmb3JlU2NhbGVUcmFuc2Zvcm06IGZ1bmN0aW9uKGUsIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRyYW5zZm9ybS5hY3Rpb24gPT09ICdzY2FsZScgfHwgdHJhbnNmb3JtLmFjdGlvbiA9PT0gJ3NjYWxlWCcgfHwgdHJhbnNmb3JtLmFjdGlvbiA9PT0gJ3NjYWxlWScpIHtcbiAgICAgICAgdmFyIGNlbnRlclRyYW5zZm9ybSA9IHRoaXMuX3Nob3VsZENlbnRlclRyYW5zZm9ybSh0cmFuc2Zvcm0udGFyZ2V0KTtcblxuICAgICAgICAvLyBTd2l0Y2ggZnJvbSBhIG5vcm1hbCByZXNpemUgdG8gY2VudGVyLWJhc2VkXG4gICAgICAgIGlmICgoY2VudGVyVHJhbnNmb3JtICYmICh0cmFuc2Zvcm0ub3JpZ2luWCAhPT0gJ2NlbnRlcicgfHwgdHJhbnNmb3JtLm9yaWdpblkgIT09ICdjZW50ZXInKSkgfHxcbiAgICAgICAgICAgLy8gU3dpdGNoIGZyb20gY2VudGVyLWJhc2VkIHJlc2l6ZSB0byBub3JtYWwgb25lXG4gICAgICAgICAgICghY2VudGVyVHJhbnNmb3JtICYmIHRyYW5zZm9ybS5vcmlnaW5YID09PSAnY2VudGVyJyAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gJ2NlbnRlcicpXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMuX3Jlc2V0Q3VycmVudFRyYW5zZm9ybSgpO1xuICAgICAgICAgIHRyYW5zZm9ybS5yZXNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gY3VycmVudCB0cmFuZm9ybVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IG1vdXNlIHBvc2l0aW9uIHggZnJvbSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBtb3VzZSBwb2lzdGlvbiB5IGZyb20gb3JpZ2luXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2NhbGluZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9vblNjYWxlOiBmdW5jdGlvbihlLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAgIGlmICh0aGlzLl9pc1VuaXNjYWxlUG9zc2libGUoZSwgdHJhbnNmb3JtLnRhcmdldCkpIHtcbiAgICAgICAgdHJhbnNmb3JtLmN1cnJlbnRBY3Rpb24gPSAnc2NhbGUnO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVPYmplY3QoeCwgeSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gU3dpdGNoIGZyb20gYSBub3JtYWwgcmVzaXplIHRvIHByb3BvcnRpb25hbFxuICAgICAgICBpZiAoIXRyYW5zZm9ybS5yZXNldCAmJiB0cmFuc2Zvcm0uY3VycmVudEFjdGlvbiA9PT0gJ3NjYWxlJykge1xuICAgICAgICAgIHRoaXMuX3Jlc2V0Q3VycmVudFRyYW5zZm9ybSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmb3JtLmN1cnJlbnRBY3Rpb24gPSAnc2NhbGVFcXVhbGx5JztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlT2JqZWN0KHgsIHksICdlcXVhbGx5Jyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldCBjdXJyZW50IHRhcmdldFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdW5wcm9wb3J0aW9uYWwgc2NhbGluZyBpcyBwb3NzaWJsZVxuICAgICAqL1xuICAgIF9pc1VuaXNjYWxlUG9zc2libGU6IGZ1bmN0aW9uKGUsIHRhcmdldCkge1xuICAgICAgcmV0dXJuIChlW3RoaXMudW5pU2NhbGVLZXldIHx8IHRoaXMudW5pU2NhbGVUcmFuc2Zvcm0pICYmICF0YXJnZXQuZ2V0KCdsb2NrVW5pU2NhbGluZycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJzb3IgZGVwZW5kaW5nIG9uIHdoZXJlIHRoZSBjYW52YXMgaXMgYmVpbmcgaG92ZXJlZC5cbiAgICAgKiBOb3RlOiB2ZXJ5IGJ1Z2d5IGluIE9wZXJhXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IE9iamVjdCB0aGF0IHRoZSBtb3VzZSBpcyBob3ZlcmluZywgaWYgc28uXG4gICAgICovXG4gICAgX3NldEN1cnNvckZyb21FdmVudDogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5kZWZhdWx0Q3Vyc29yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaG92ZXJDdXJzb3IgPSB0YXJnZXQuaG92ZXJDdXJzb3IgfHwgdGhpcy5ob3ZlckN1cnNvcixcbiAgICAgICAgICBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QgJiYgdGhpcy5fYWN0aXZlT2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nID9cbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA6IG51bGwsXG4gICAgICAgICAgLy8gb25seSBzaG93IHByb3BlciBjb3JuZXIgd2hlbiBncm91cCBzZWxlY3Rpb24gaXMgbm90IGFjdGl2ZVxuICAgICAgICAgIGNvcm5lciA9ICghYWN0aXZlU2VsZWN0aW9uIHx8ICFhY3RpdmVTZWxlY3Rpb24uY29udGFpbnModGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgJiYgdGFyZ2V0Ll9maW5kVGFyZ2V0Q29ybmVyKHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKSk7XG5cbiAgICAgIGlmICghY29ybmVyKSB7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKGhvdmVyQ3Vyc29yKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmdldENvcm5lckN1cnNvcihjb3JuZXIsIHRhcmdldCwgZSkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldENvcm5lckN1cnNvcjogZnVuY3Rpb24oY29ybmVyLCB0YXJnZXQsIGUpIHtcbiAgICAgIGlmICh0aGlzLmFjdGlvbklzRGlzYWJsZWQoY29ybmVyLCB0YXJnZXQsIGUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdEFsbG93ZWRDdXJzb3I7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgaW4gY3Vyc29yT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRSb3RhdGVkQ29ybmVyQ3Vyc29yKGNvcm5lciwgdGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvcm5lciA9PT0gJ210cicgJiYgdGFyZ2V0Lmhhc1JvdGF0aW5nUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm90YXRpb25DdXJzb3I7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEN1cnNvcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWN0aW9uSXNEaXNhYmxlZDogZnVuY3Rpb24oY29ybmVyLCB0YXJnZXQsIGUpIHtcbiAgICAgIGlmIChjb3JuZXIgPT09ICdtdCcgfHwgY29ybmVyID09PSAnbWInKSB7XG4gICAgICAgIHJldHVybiBlW3RoaXMuYWx0QWN0aW9uS2V5XSA/IHRhcmdldC5sb2NrU2tld2luZ1ggOiB0YXJnZXQubG9ja1NjYWxpbmdZO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnbWwnIHx8IGNvcm5lciA9PT0gJ21yJykge1xuICAgICAgICByZXR1cm4gZVt0aGlzLmFsdEFjdGlvbktleV0gPyB0YXJnZXQubG9ja1NrZXdpbmdZIDogdGFyZ2V0LmxvY2tTY2FsaW5nWDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvcm5lciA9PT0gJ210cicpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5sb2NrUm90YXRpb247XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVW5pc2NhbGVQb3NzaWJsZShlLCB0YXJnZXQpID9cbiAgICAgICAgICB0YXJnZXQubG9ja1NjYWxpbmdYICYmIHRhcmdldC5sb2NrU2NhbGluZ1kgOiB0YXJnZXQubG9ja1NjYWxpbmdYIHx8IHRhcmdldC5sb2NrU2NhbGluZ1k7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFJvdGF0ZWRDb3JuZXJDdXJzb3I6IGZ1bmN0aW9uKGNvcm5lciwgdGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgbiA9IE1hdGgucm91bmQoKHRhcmdldC5hbmdsZSAlIDM2MCkgLyA0NSk7XG5cbiAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICBuICs9IDg7IC8vIGZ1bGwgY2lyY2xlIGFoZWFkXG4gICAgICB9XG4gICAgICBuICs9IGN1cnNvck9mZnNldFtjb3JuZXJdO1xuICAgICAgaWYgKGVbdGhpcy5hbHRBY3Rpb25LZXldICYmIGN1cnNvck9mZnNldFtjb3JuZXJdICUgMiA9PT0gMCkge1xuICAgICAgICAvL2lmIHdlIGFyZSBob2xkaW5nIHNoaWZ0IGFuZCB3ZSBhcmUgb24gYSBteCBjb3JuZXIuLi5cbiAgICAgICAgbiArPSAyO1xuICAgICAgfVxuICAgICAgLy8gbm9ybWFsaXplIG4gdG8gYmUgZnJvbSAwIHRvIDdcbiAgICAgIG4gJT0gODtcblxuICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yTWFwW25dO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgbWluID0gTWF0aC5taW4sXG4gICAgICBtYXggPSBNYXRoLm1heDtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5DYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgX3Nob3VsZEdyb3VwOiBmdW5jdGlvbihlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICByZXR1cm4gYWN0aXZlT2JqZWN0ICYmIHRoaXMuX2lzU2VsZWN0aW9uS2V5UHJlc3NlZChlKSAmJiB0YXJnZXQgJiYgdGFyZ2V0LnNlbGVjdGFibGUgJiYgdGhpcy5zZWxlY3Rpb24gJiZcbiAgICAgICAgICAgIChhY3RpdmVPYmplY3QgIT09IHRhcmdldCB8fCBhY3RpdmVPYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpICYmICF0YXJnZXQub25TZWxlY3QoeyBlOiBlIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfaGFuZGxlR3JvdXBpbmc6IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICAvLyBhdm9pZCBtdWx0aSBzZWxlY3Qgd2hlbiBzaGlmdCBjbGljayBvbiBhIGNvcm5lclxuICAgICAgaWYgKGFjdGl2ZU9iamVjdC5fX2Nvcm5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0ID09PSBhY3RpdmVPYmplY3QpIHtcbiAgICAgICAgLy8gaWYgaXQncyBhIGdyb3VwLCBmaW5kIHRhcmdldCBhZ2FpbiwgdXNpbmcgYWN0aXZlR3JvdXAgb2JqZWN0c1xuICAgICAgICB0YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSwgdHJ1ZSk7XG4gICAgICAgIC8vIGlmIGV2ZW4gb2JqZWN0IGlzIG5vdCBmb3VuZCBvciB3ZSBhcmUgb24gYWN0aXZlT2JqZWN0Q29ybmVyLCBiYWlsIG91dFxuICAgICAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0LnNlbGVjdGFibGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZVNlbGVjdGlvbih0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUFjdGl2ZVNlbGVjdGlvbih0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVBY3RpdmVTZWxlY3Rpb246IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBjdXJyZW50QWN0aXZlT2JqZWN0cyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cy5zbGljZSgwKTtcbiAgICAgIGlmIChhY3RpdmVTZWxlY3Rpb24uY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICBhY3RpdmVTZWxlY3Rpb24ucmVtb3ZlV2l0aFVwZGF0ZSh0YXJnZXQpO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBpZiAoYWN0aXZlU2VsZWN0aW9uLnNpemUoKSA9PT0gMSkge1xuICAgICAgICAgIC8vIGFjdGl2YXRlIGxhc3QgcmVtYWluaW5nIG9iamVjdFxuICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChhY3RpdmVTZWxlY3Rpb24uaXRlbSgwKSwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhY3RpdmVTZWxlY3Rpb24uYWRkV2l0aFVwZGF0ZSh0YXJnZXQpO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gYWN0aXZlU2VsZWN0aW9uO1xuICAgICAgfVxuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlT2JqZWN0cywgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUFjdGl2ZVNlbGVjdGlvbjogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgY3VycmVudEFjdGl2ZXMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSwgZ3JvdXAgPSB0aGlzLl9jcmVhdGVHcm91cCh0YXJnZXQpO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IGdyb3VwO1xuICAgICAgdGhpcy5fc2V0QWN0aXZlT2JqZWN0KGdyb3VwLCBlKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZXMsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfY3JlYXRlR3JvdXA6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuICAgICAgICAgIGlzQWN0aXZlTG93ZXIgPSBvYmplY3RzLmluZGV4T2YodGhpcy5fYWN0aXZlT2JqZWN0KSA8IG9iamVjdHMuaW5kZXhPZih0YXJnZXQpLFxuICAgICAgICAgIGdyb3VwT2JqZWN0cyA9IGlzQWN0aXZlTG93ZXJcbiAgICAgICAgICAgID8gW3RoaXMuX2FjdGl2ZU9iamVjdCwgdGFyZ2V0XVxuICAgICAgICAgICAgOiBbdGFyZ2V0LCB0aGlzLl9hY3RpdmVPYmplY3RdO1xuICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0LmlzRWRpdGluZyAmJiB0aGlzLl9hY3RpdmVPYmplY3QuZXhpdEVkaXRpbmcoKTtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLkFjdGl2ZVNlbGVjdGlvbihncm91cE9iamVjdHMsIHtcbiAgICAgICAgY2FudmFzOiB0aGlzXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICovXG4gICAgX2dyb3VwU2VsZWN0ZWRPYmplY3RzOiBmdW5jdGlvbiAoZSkge1xuXG4gICAgICB2YXIgZ3JvdXAgPSB0aGlzLl9jb2xsZWN0T2JqZWN0cyhlKSxcbiAgICAgICAgICBhR3JvdXA7XG5cbiAgICAgIC8vIGRvIG5vdCBjcmVhdGUgZ3JvdXAgZm9yIDEgZWxlbWVudCBvbmx5XG4gICAgICBpZiAoZ3JvdXAubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KGdyb3VwWzBdLCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYUdyb3VwID0gbmV3IGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24oZ3JvdXAucmV2ZXJzZSgpLCB7XG4gICAgICAgICAgY2FudmFzOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdChhR3JvdXAsIGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb2xsZWN0T2JqZWN0czogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGdyb3VwID0gW10sXG4gICAgICAgICAgY3VycmVudE9iamVjdCxcbiAgICAgICAgICB4MSA9IHRoaXMuX2dyb3VwU2VsZWN0b3IuZXgsXG4gICAgICAgICAgeTEgPSB0aGlzLl9ncm91cFNlbGVjdG9yLmV5LFxuICAgICAgICAgIHgyID0geDEgKyB0aGlzLl9ncm91cFNlbGVjdG9yLmxlZnQsXG4gICAgICAgICAgeTIgPSB5MSArIHRoaXMuX2dyb3VwU2VsZWN0b3IudG9wLFxuICAgICAgICAgIHNlbGVjdGlvblgxWTEgPSBuZXcgZmFicmljLlBvaW50KG1pbih4MSwgeDIpLCBtaW4oeTEsIHkyKSksXG4gICAgICAgICAgc2VsZWN0aW9uWDJZMiA9IG5ldyBmYWJyaWMuUG9pbnQobWF4KHgxLCB4MiksIG1heCh5MSwgeTIpKSxcbiAgICAgICAgICBhbGxvd0ludGVyc2VjdCA9ICF0aGlzLnNlbGVjdGlvbkZ1bGx5Q29udGFpbmVkLFxuICAgICAgICAgIGlzQ2xpY2sgPSB4MSA9PT0geDIgJiYgeTEgPT09IHkyO1xuICAgICAgLy8gd2UgaXRlcmF0ZSByZXZlcnNlIG9yZGVyIHRvIGNvbGxlY3QgdG9wIGZpcnN0IGluIGNhc2Ugb2YgY2xpY2suXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIGN1cnJlbnRPYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuXG4gICAgICAgIGlmICghY3VycmVudE9iamVjdCB8fCAhY3VycmVudE9iamVjdC5zZWxlY3RhYmxlIHx8ICFjdXJyZW50T2JqZWN0LnZpc2libGUgfHwgY3VycmVudE9iamVjdC5vblNlbGVjdCh7IGU6IGUgfSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoYWxsb3dJbnRlcnNlY3QgJiYgY3VycmVudE9iamVjdC5pbnRlcnNlY3RzV2l0aFJlY3Qoc2VsZWN0aW9uWDFZMSwgc2VsZWN0aW9uWDJZMikpIHx8XG4gICAgICAgICAgICBjdXJyZW50T2JqZWN0LmlzQ29udGFpbmVkV2l0aGluUmVjdChzZWxlY3Rpb25YMVkxLCBzZWxlY3Rpb25YMlkyKSB8fFxuICAgICAgICAgICAgKGFsbG93SW50ZXJzZWN0ICYmIGN1cnJlbnRPYmplY3QuY29udGFpbnNQb2ludChzZWxlY3Rpb25YMVkxKSkgfHxcbiAgICAgICAgICAgIChhbGxvd0ludGVyc2VjdCAmJiBjdXJyZW50T2JqZWN0LmNvbnRhaW5zUG9pbnQoc2VsZWN0aW9uWDJZMikpXG4gICAgICAgICkge1xuICAgICAgICAgIGdyb3VwLnB1c2goY3VycmVudE9iamVjdCk7XG5cbiAgICAgICAgICAvLyBvbmx5IGFkZCBvbmUgb2JqZWN0IGlmIGl0J3MgYSBjbGlja1xuICAgICAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYXliZUdyb3VwT2JqZWN0czogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmIHRoaXMuX2dyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RlZE9iamVjdHMoZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmRlZmF1bHRDdXJzb3IpO1xuICAgICAgLy8gY2xlYXIgc2VsZWN0aW9uIGFuZCBjdXJyZW50IHRyYW5zZm9ybWF0aW9uXG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICB9XG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRXhwb3J0cyBjYW52YXMgZWxlbWVudCB0byBhIGRhdGF1cmwgaW1hZ2UuIE5vdGUgdGhhdCB3aGVuIG11bHRpcGxpZXIgaXMgdXNlZCwgY3JvcHBpbmcgaXMgc2NhbGVkIGFwcHJvcHJpYXRlbHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZvcm1hdD1wbmddIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCBpbWFnZS4gRWl0aGVyIFwianBlZ1wiIG9yIFwicG5nXCJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucXVhbGl0eT0xXSBRdWFsaXR5IGxldmVsICgwLi4xKS4gT25seSB1c2VkIGZvciBqcGVnLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXBsaWVyPTFdIE11bHRpcGxpZXIgdG8gc2NhbGUgYnksIHRvIGhhdmUgY29uc2lzdGVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAyLjAuMFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGRhdGE6IFVSTCBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBvcHRpb25zLmZvcm1hdFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvTmZaVmIvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUganBlZyBkYXRhVVJMIHdpdGggbG93ZXIgcXVhbGl0eTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAnanBlZycsXG4gICAgICogICBxdWFsaXR5OiAwLjhcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZW5lcmF0ZSBjcm9wcGVkIHBuZyBkYXRhVVJMIChjbGlwcGluZyBvZiBjYW52YXMpPC9jYXB0aW9uPlxuICAgICAqIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCh7XG4gICAgICogICBmb3JtYXQ6ICdwbmcnLFxuICAgICAqICAgbGVmdDogMTAwLFxuICAgICAqICAgdG9wOiAxMDAsXG4gICAgICogICB3aWR0aDogMjAwLFxuICAgICAqICAgaGVpZ2h0OiAyMDBcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZW5lcmF0ZSBkb3VibGUgc2NhbGVkIHBuZyBkYXRhVVJMPC9jYXB0aW9uPlxuICAgICAqIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCh7XG4gICAgICogICBmb3JtYXQ6ICdwbmcnLFxuICAgICAqICAgbXVsdGlwbGllcjogMlxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgJ3BuZycsXG4gICAgICAgICAgcXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eSB8fCAxLFxuICAgICAgICAgIG11bHRpcGxpZXIgPSAob3B0aW9ucy5tdWx0aXBsaWVyIHx8IDEpICogKG9wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZyA/IHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpIDogMSksXG4gICAgICAgICAgY2FudmFzRWwgPSB0aGlzLnRvQ2FudmFzRWxlbWVudChtdWx0aXBsaWVyLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC50b0RhdGFVUkwoY2FudmFzRWwsIGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBIVE1MQ2FudmFzIGVsZW1lbnQgcGFpbnRlZCB3aXRoIHRoZSBjdXJyZW50IGNhbnZhcyBjb250ZW50LlxuICAgICAqIE5vIG5lZWQgdG8gcmVzaXplIHRoZSBhY3R1YWwgb25lIG9yIHJlcGFpbnQgaXQuXG4gICAgICogV2lsbCB0cmFuc2ZlciBvYmplY3Qgb3duZXJzaGlwIHRvIGEgbmV3IGNhbnZhcywgcGFpbnQgaXQsIGFuZCBzZXQgZXZlcnl0aGluZyBiYWNrLlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAgdXNlZCB0byBnZXQgdG8gYSBkYXRhVXJsIGJ1dCBhbHNvIGl0IGlzIHVzZWZ1bGwgdG9cbiAgICAgKiBjcmVhdGUgcXVpY2sgaW1hZ2UgY29waWVzIG9mIGEgY2FudmFzIHdpdGhvdXQgcGFzc2luZyBmb3IgdGhlIGRhdGFVcmwgc3RyaW5nXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFttdWx0aXBsaWVyXSBhIHpvb20gZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3JvcHBpbmddIENyb3BwaW5nIGluZm9ybWF0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY3JvcHBpbmcubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjcm9wcGluZy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjcm9wcGluZy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjcm9wcGluZy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC5cbiAgICAgKi9cbiAgICB0b0NhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKG11bHRpcGxpZXIsIGNyb3BwaW5nKSB7XG4gICAgICBtdWx0aXBsaWVyID0gbXVsdGlwbGllciB8fCAxO1xuICAgICAgY3JvcHBpbmcgPSBjcm9wcGluZyB8fCB7IH07XG4gICAgICB2YXIgc2NhbGVkV2lkdGggPSAoY3JvcHBpbmcud2lkdGggfHwgdGhpcy53aWR0aCkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHNjYWxlZEhlaWdodCA9IChjcm9wcGluZy5oZWlnaHQgfHwgdGhpcy5oZWlnaHQpICogbXVsdGlwbGllcixcbiAgICAgICAgICB6b29tID0gdGhpcy5nZXRab29tKCksXG4gICAgICAgICAgb3JpZ2luYWxXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgb3JpZ2luYWxIZWlnaHQgPSB0aGlzLmhlaWdodCxcbiAgICAgICAgICBuZXdab29tID0gem9vbSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgdnAgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLFxuICAgICAgICAgIHRyYW5zbGF0ZVggPSAodnBbNF0gLSAoY3JvcHBpbmcubGVmdCB8fCAwKSkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHRyYW5zbGF0ZVkgPSAodnBbNV0gLSAoY3JvcHBpbmcudG9wIHx8IDApKSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgb3JpZ2luYWxJbnRlcmFjdGl2ZSA9IHRoaXMuaW50ZXJhY3RpdmUsXG4gICAgICAgICAgb3JpZ2luYWxDb250ZXh0ID0gdGhpcy5jb250ZXh0Q29udGFpbmVyLFxuICAgICAgICAgIG5ld1ZwID0gW25ld1pvb20sIDAsIDAsIG5ld1pvb20sIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldLFxuICAgICAgICAgIGNhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgY2FudmFzRWwud2lkdGggPSBzY2FsZWRXaWR0aDtcbiAgICAgIGNhbnZhc0VsLmhlaWdodCA9IHNjYWxlZEhlaWdodDtcbiAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSBuZXdWcDtcbiAgICAgIHRoaXMud2lkdGggPSBzY2FsZWRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gc2NhbGVkSGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLmNvbnRleHRDb250YWluZXIgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgLy8gd2lsbCBiZSByZW5kZXJBbGxFeHBvcnQoKTtcbiAgICAgIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdnA7XG4gICAgICB0aGlzLndpZHRoID0gb3JpZ2luYWxXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMuY29udGV4dENvbnRhaW5lciA9IG9yaWdpbmFsQ29udGV4dDtcbiAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBvcmlnaW5hbEludGVyYWN0aXZlO1xuICAgICAgcmV0dXJuIGNhbnZhc0VsO1xuICAgIH0sXG4gIH0pO1xuXG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgY2FudmFzIHdpdGggZGF0YSBmcm9tIHRoZSBzcGVjaWZpZWQgZGF0YWxlc3MgSlNPTi5cbiAgICogSlNPTiBmb3JtYXQgbXVzdCBjb25mb3JtIHRvIHRoZSBvbmUgb2Yge0BsaW5rIGZhYnJpYy5DYW52YXMjdG9EYXRhbGVzc0pTT059XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDEuMi4yXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ganNvbiBKU09OIHN0cmluZyBvciBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2ssIGludm9rZWQgd2hlbiBqc29uIGlzIHBhcnNlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgY29ycmVzcG9uZGluZyBvYmplY3RzIChlLmc6IHtAbGluayBmYWJyaWMuSW1hZ2V9KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgaW5pdGlhbGl6ZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIEpTT04gZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICogQGNoYWluYWJsZVxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNkZXNlcmlhbGl6YXRpb259XG4gICAqL1xuICBsb2FkRnJvbURhdGFsZXNzSlNPTjogZnVuY3Rpb24gKGpzb24sIGNhbGxiYWNrLCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZEZyb21KU09OKGpzb24sIGNhbGxiYWNrLCByZXZpdmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUG9wdWxhdGVzIGNhbnZhcyB3aXRoIGRhdGEgZnJvbSB0aGUgc3BlY2lmaWVkIEpTT04uXG4gICAqIEpTT04gZm9ybWF0IG11c3QgY29uZm9ybSB0byB0aGUgb25lIG9mIHtAbGluayBmYWJyaWMuQ2FudmFzI3RvSlNPTn1cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIEpTT04gc3RyaW5nIG9yIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjaywgaW52b2tlZCB3aGVuIGpzb24gaXMgcGFyc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBjb3JyZXNwb25kaW5nIG9iamVjdHMgKGUuZzoge0BsaW5rIGZhYnJpYy5JbWFnZX0pXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBpbml0aWFsaXplZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgSlNPTiBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2Rlc2VyaWFsaXphdGlvbn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9mbWdYdC98anNGaWRkbGUgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bG9hZEZyb21KU09OPC9jYXB0aW9uPlxuICAgKiBjYW52YXMubG9hZEZyb21KU09OKGpzb24sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bG9hZEZyb21KU09OIHdpdGggcmV2aXZlcjwvY2FwdGlvbj5cbiAgICogY2FudmFzLmxvYWRGcm9tSlNPTihqc29uLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwgZnVuY3Rpb24obywgb2JqZWN0KSB7XG4gICAqICAgLy8gYG9gID0ganNvbiBvYmplY3RcbiAgICogICAvLyBgb2JqZWN0YCA9IGZhYnJpYy5PYmplY3QgaW5zdGFuY2VcbiAgICogICAvLyAuLi4gZG8gc29tZSBzdHVmZiAuLi5cbiAgICogfSk7XG4gICAqL1xuICBsb2FkRnJvbUpTT046IGZ1bmN0aW9uIChqc29uLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgIGlmICghanNvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNlcmlhbGl6ZSBpZiBpdCB3YXNuJ3QgYWxyZWFkeVxuICAgIHZhciBzZXJpYWxpemVkID0gKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJylcbiAgICAgID8gSlNPTi5wYXJzZShqc29uKVxuICAgICAgOiBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUoanNvbik7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICByZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMucmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fZW5saXZlbk9iamVjdHMoc2VyaWFsaXplZC5vYmplY3RzLCBmdW5jdGlvbiAoZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgX3RoaXMuY2xlYXIoKTtcbiAgICAgIF90aGlzLl9zZXRCZ092ZXJsYXkoc2VyaWFsaXplZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbmxpdmVuZWRPYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqLCBpbmRleCkge1xuICAgICAgICAgIC8vIHdlIHNwbGljZSB0aGUgYXJyYXkganVzdCBpbiBjYXNlIHNvbWUgY3VzdG9tIGNsYXNzZXMgcmVzdG9yZWQgZnJvbSBKU09OXG4gICAgICAgICAgLy8gd2lsbCBhZGQgbW9yZSBvYmplY3QgdG8gY2FudmFzIGF0IGNhbnZhcyBpbml0LlxuICAgICAgICAgIF90aGlzLmluc2VydEF0KG9iaiwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMucmVuZGVyT25BZGRSZW1vdmUgPSByZW5kZXJPbkFkZFJlbW92ZTtcbiAgICAgICAgLy8gcmVtb3ZlIHBhcnRzIGkgY2Fubm90IHNldCBhcyBvcHRpb25zXG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLm9iamVjdHM7XG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZTtcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlO1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZC5iYWNrZ3JvdW5kO1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZC5vdmVybGF5O1xuICAgICAgICAvLyB0aGlzLl9pbml0T3B0aW9ucyBkb2VzIHRvbyBtYW55IHRoaW5ncyB0byBqdXN0XG4gICAgICAgIC8vIGNhbGwgaXQuIE5vcm1hbGx5IGxvYWRpbmcgYW4gT2JqZWN0IGZyb20gSlNPTlxuICAgICAgICAvLyBjcmVhdGUgdGhlIE9iamVjdCBpbnN0YW5jZS4gSGVyZSB0aGUgQ2FudmFzIGlzXG4gICAgICAgIC8vIGFscmVhZHkgYW4gaW5zdGFuY2UgYW5kIHdlIGFyZSBqdXN0IGxvYWRpbmcgdGhpbmdzIG92ZXIgaXRcbiAgICAgICAgX3RoaXMuX3NldE9wdGlvbnMoc2VyaWFsaXplZCk7XG4gICAgICAgIF90aGlzLnJlbmRlckFsbCgpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfSwgcmV2aXZlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpYWxpemVkIE9iamVjdCB3aXRoIGJhY2tncm91bmQgYW5kIG92ZXJsYXkgaW5mb3JtYXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCBhZnRlciBhbGwgYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbWFnZXMvcGF0dGVybnMgbG9hZGVkXG4gICAqL1xuICBfc2V0QmdPdmVybGF5OiBmdW5jdGlvbihzZXJpYWxpemVkLCBjYWxsYmFjaykge1xuICAgIHZhciBsb2FkZWQgPSB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGZhbHNlLFxuICAgICAgb3ZlcmxheUNvbG9yOiBmYWxzZSxcbiAgICAgIGJhY2tncm91bmRJbWFnZTogZmFsc2UsXG4gICAgICBvdmVybGF5SW1hZ2U6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICghc2VyaWFsaXplZC5iYWNrZ3JvdW5kSW1hZ2UgJiYgIXNlcmlhbGl6ZWQub3ZlcmxheUltYWdlICYmICFzZXJpYWxpemVkLmJhY2tncm91bmQgJiYgIXNlcmlhbGl6ZWQub3ZlcmxheSkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2JJZkxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChsb2FkZWQuYmFja2dyb3VuZEltYWdlICYmIGxvYWRlZC5vdmVybGF5SW1hZ2UgJiYgbG9hZGVkLmJhY2tncm91bmRDb2xvciAmJiBsb2FkZWQub3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ2JhY2tncm91bmRJbWFnZScsIHNlcmlhbGl6ZWQuYmFja2dyb3VuZEltYWdlLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ292ZXJsYXlJbWFnZScsIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ2JhY2tncm91bmRDb2xvcicsIHNlcmlhbGl6ZWQuYmFja2dyb3VuZCwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdvdmVybGF5Q29sb3InLCBzZXJpYWxpemVkLm92ZXJsYXksIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBzZXQgKGJhY2tncm91bmRJbWFnZSwgb3ZlcmxheUltYWdlLCBiYWNrZ3JvdW5kQ29sb3IsIG92ZXJsYXlDb2xvcilcbiAgICogQHBhcmFtIHsoT2JqZWN0fFN0cmluZyl9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9hZGVkIFNldCBsb2FkZWQgcHJvcGVydHkgdG8gdHJ1ZSBpZiBwcm9wZXJ0eSBpcyBzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSBhZnRlciBwcm9wZXJ0eSBpcyBzZXRcbiAgICovXG4gIF9fc2V0QmdPdmVybGF5OiBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUsIGxvYWRlZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2JhY2tncm91bmRJbWFnZScgfHwgcHJvcGVydHkgPT09ICdvdmVybGF5SW1hZ2UnKSB7XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhbdmFsdWVdLCBmdW5jdGlvbihlbmxpdmVkT2JqZWN0KXtcbiAgICAgICAgX3RoaXNbcHJvcGVydHldID0gZW5saXZlZE9iamVjdFswXTtcbiAgICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzWydzZXQnICsgZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUocHJvcGVydHksIHRydWUpXSh2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRlZFtwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXVxuICAgKi9cbiAgX2VubGl2ZW5PYmplY3RzOiBmdW5jdGlvbiAob2JqZWN0cywgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICBpZiAoIW9iamVjdHMgfHwgb2JqZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKFtdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhvYmplY3RzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICB9LCBudWxsLCByZXZpdmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgX3RvRGF0YVVSTDogZnVuY3Rpb24gKGZvcm1hdCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsb25lKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgY2FsbGJhY2soY2xvbmUudG9EYXRhVVJMKGZvcm1hdCkpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtdWx0aXBsaWVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfdG9EYXRhVVJMV2l0aE11bHRpcGxpZXI6IGZ1bmN0aW9uIChmb3JtYXQsIG11bHRpcGxpZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jbG9uZShmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgIGNhbGxiYWNrKGNsb25lLnRvRGF0YVVSTFdpdGhNdWx0aXBsaWVyKGZvcm1hdCwgbXVsdGlwbGllcikpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tdIFJlY2VpdmVzIGNsb25lZCBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzXSBBcnJheSBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgaW4gdGhlIGNsb25lZCBjYW52YXMgYW5kIGNoaWxkcmVuXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTihwcm9wZXJ0aWVzKSk7XG4gICAgdGhpcy5jbG9uZVdpdGhvdXREYXRhKGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICBjbG9uZS5sb2FkRnJvbUpTT04oZGF0YSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlIHdpdGhvdXQgY2xvbmluZyBleGlzdGluZyBkYXRhLlxuICAgKiBUaGlzIGVzc2VudGlhbGx5IGNvcGllcyBjYW52YXMgZGltZW5zaW9ucywgY2xpcHBpbmcgcHJvcGVydGllcywgZXRjLlxuICAgKiBidXQgbGVhdmVzIGRhdGEgZW1wdHkgKHNvIHRoYXQgeW91IGNhbiBwb3B1bGF0ZSBpdCB3aXRoIHlvdXIgb3duKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrXSBSZWNlaXZlcyBjbG9uZWQgaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgY2xvbmVXaXRob3V0RGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgZWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG5cbiAgICBlbC53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgZWwuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICB2YXIgY2xvbmUgPSBuZXcgZmFicmljLkNhbnZhcyhlbCk7XG4gICAgY2xvbmUuY2xpcFRvID0gdGhpcy5jbGlwVG87XG4gICAgaWYgKHRoaXMuYmFja2dyb3VuZEltYWdlKSB7XG4gICAgICBjbG9uZS5zZXRCYWNrZ3JvdW5kSW1hZ2UodGhpcy5iYWNrZ3JvdW5kSW1hZ2Uuc3JjLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xvbmUucmVuZGVyQWxsKCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICAgIH0pO1xuICAgICAgY2xvbmUuYmFja2dyb3VuZEltYWdlT3BhY2l0eSA9IHRoaXMuYmFja2dyb3VuZEltYWdlT3BhY2l0eTtcbiAgICAgIGNsb25lLmJhY2tncm91bmRJbWFnZVN0cmV0Y2ggPSB0aGlzLmJhY2tncm91bmRJbWFnZVN0cmV0Y2g7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2xvbmUpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIGNhcGl0YWxpemUgPSBmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZSxcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgc3VwcG9ydHNMaW5lRGFzaCA9IGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJyksXG4gICAgICBvYmplY3RDYWNoaW5nID0gIWZhYnJpYy5pc0xpa2VseU5vZGUsXG4gICAgICBBTElBU0lOR19MSU1JVCA9IDI7XG5cbiAgaWYgKGZhYnJpYy5PYmplY3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUm9vdCBvYmplY3QgY2xhc3MgZnJvbSB3aGljaCBhbGwgMmQgc2hhcGUgY2xhc3NlcyBpbmhlcml0IGZyb21cbiAgICogQGNsYXNzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjb2JqZWN0c31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLk9iamVjdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAZmlyZXMgYWRkZWRcbiAgICogQGZpcmVzIHJlbW92ZWRcbiAgICpcbiAgICogQGZpcmVzIHNlbGVjdGVkXG4gICAqIEBmaXJlcyBkZXNlbGVjdGVkXG4gICAqIEBmaXJlcyBtb2RpZmllZFxuICAgKiBAZmlyZXMgbW9kaWZpZWRcbiAgICogQGZpcmVzIG1vdmVkXG4gICAqIEBmaXJlcyBzY2FsZWRcbiAgICogQGZpcmVzIHJvdGF0ZWRcbiAgICogQGZpcmVzIHNrZXdlZFxuICAgKlxuICAgKiBAZmlyZXMgcm90YXRpbmdcbiAgICogQGZpcmVzIHNjYWxpbmdcbiAgICogQGZpcmVzIG1vdmluZ1xuICAgKiBAZmlyZXMgc2tld2luZ1xuICAgKlxuICAgKiBAZmlyZXMgbW91c2Vkb3duXG4gICAqIEBmaXJlcyBtb3VzZXVwXG4gICAqIEBmaXJlcyBtb3VzZW92ZXJcbiAgICogQGZpcmVzIG1vdXNlb3V0XG4gICAqIEBmaXJlcyBtb3VzZXdoZWVsXG4gICAqIEBmaXJlcyBtb3VzZWRibGNsaWNrXG4gICAqXG4gICAqIEBmaXJlcyBkcmFnb3ZlclxuICAgKiBAZmlyZXMgZHJhZ2VudGVyXG4gICAqIEBmaXJlcyBkcmFnbGVhdmVcbiAgICogQGZpcmVzIGRyb3BcbiAgICovXG4gIGZhYnJpYy5PYmplY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQ29tbW9uTWV0aG9kcywgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdCAocmVjdCwgY2lyY2xlLCBwYXRoLCBldGMuKS5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBtZWFudCB0byBiZSByZWFkLW9ubHkgYW5kIG5vdCBtZWFudCB0byBiZSBtb2RpZmllZC5cbiAgICAgKiBJZiB5b3UgbW9kaWZ5LCBjZXJ0YWluIHBhcnRzIG9mIEZhYnJpYyAoc3VjaCBhcyBKU09OIGxvYWRpbmcpIHdvbid0IHdvcmsgY29ycmVjdGx5LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogICAgICAgICAgICAgICAgICAgICAnb2JqZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIG9mIGFuIG9iamVjdCAob25lIG9mIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiY2VudGVyXCIpXG4gICAgICogU2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvMW93MDJnZWEvMjQ0LyBvbiBob3cgb3JpZ2luWC9vcmlnaW5ZIGFmZmVjdCBvYmplY3RzIGluIGdyb3Vwc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gb2YgYW4gb2JqZWN0IChvbmUgb2YgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJjZW50ZXJcIilcbiAgICAgKiBTZWUgaHR0cDovL2pzZmlkZGxlLm5ldC8xb3cwMmdlYS8yNDQvIG9uIGhvdyBvcmlnaW5YL29yaWdpblkgYWZmZWN0IG9iamVjdHMgaW4gZ3JvdXBzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgICd0b3AnLFxuXG4gICAgLyoqXG4gICAgICogVG9wIHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQgaXQncyByZWxhdGl2ZSB0byBvYmplY3QgdG9wLiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHNldHRpbmcgb3JpZ2luWT17dG9wL2NlbnRlci9ib3R0b219XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0b3A6ICAgICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBMZWZ0IHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQgaXQncyByZWxhdGl2ZSB0byBvYmplY3QgbGVmdC4gWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBzZXR0aW5nIG9yaWdpblg9e2xlZnQvY2VudGVyL3JpZ2h0fVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGVmdDogICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoZWlnaHQ6ICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgc2NhbGUgZmFjdG9yIChob3Jpem9udGFsKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVYOiAgICAgICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHNjYWxlIGZhY3RvciAodmVydGljYWwpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVk6ICAgICAgICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGFuIG9iamVjdCBpcyByZW5kZXJlZCBhcyBmbGlwcGVkIGhvcml6b250YWxseVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZsaXBYOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGFuIG9iamVjdCBpcyByZW5kZXJlZCBhcyBmbGlwcGVkIHZlcnRpY2FsbHlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmbGlwWTogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogT3BhY2l0eSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHJvdGF0aW9uIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFuZ2xlOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHNrZXcgb24geCBheGVzIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNrZXdYOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHNrZXcgb24geSBheGVzIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNrZXdZOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyU2l6ZTogICAgICAgICAgICAgICAxMyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyBhcmUgcmVuZGVyZWQgYXMgdHJhbnNwYXJlbnQgaW5zaWRlIChpLmUuIHN0cm9rZSBpbnN0ZWFkIG9mIGZpbGwpXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHJhbnNwYXJlbnRDb3JuZXJzOiAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIGhvdmVyaW5nIG92ZXIgdGhpcyBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBob3ZlckN1cnNvcjogICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIHdoZW4gbW92aW5nIHRoaXMgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW92ZUN1cnNvcjogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUGFkZGluZyBiZXR3ZWVuIG9iamVjdCBhbmQgaXRzIGNvbnRyb2xsaW5nIGJvcmRlcnMgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhZGRpbmc6ICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGJvcmRlcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYm9yZGVyQ29sb3I6ICAgICAgICAgICAgICAncmdiYSgxMDIsMTUzLDI1NSwwLjc1KScsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBib3JkZXJzIChoYXNCb3JkZXIgbXVzdCBiZSB0cnVlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgYm9yZGVyRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgY29udHJvbGxpbmcgY29ybmVycyBvZiBhbiBvYmplY3QgKHdoZW4gaXQncyBhY3RpdmUpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJDb2xvcjogICAgICAgICAgICAgICdyZ2JhKDEwMiwxNTMsMjU1LDAuNSknLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgY29udHJvbGxpbmcgY29ybmVycyBvZiBhbiBvYmplY3QgKHdoZW4gaXQncyBhY3RpdmUgYW5kIHRyYW5zcGFyZW50Q29ybmVycyBmYWxzZSlcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvcm5lclN0cm9rZUNvbG9yOiAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgc3R5bGUgb2YgY29udHJvbCwgJ3JlY3QnIG9yICdjaXJjbGUnXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgY29ybmVyU3R5bGU6ICAgICAgICAgICdyZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IHNwZWNpZnlpbmcgZGFzaCBwYXR0ZXJuIG9mIGFuIG9iamVjdCdzIGNvbnRyb2wgKGhhc0JvcmRlciBtdXN0IGJlIHRydWUpXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjb3JuZXJEYXNoQXJyYXk6ICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoaXMgb2JqZWN0IHdpbGwgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uXG4gICAgICogd2hlbiBiZWluZyBzY2FsZWQgdmlhIHRoZSBjb250cm9scy5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkU2NhbGluZzogICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoaXMgb2JqZWN0IHdpbGwgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uXG4gICAgICogd2hlbiBiZWluZyByb3RhdGVkIHZpYSB0aGUgY29udHJvbHMuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFJvdGF0aW9uOiAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBvYmplY3QncyBmaWxsXG4gICAgICogdGFrZXMgY3NzIGNvbG9ycyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTMvXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaWxsOiAgICAgICAgICAgICAgICAgICAgICdyZ2IoMCwwLDApJyxcblxuICAgIC8qKlxuICAgICAqIEZpbGwgcnVsZSB1c2VkIHRvIGZpbGwgYW4gb2JqZWN0XG4gICAgICogYWNjZXB0ZWQgdmFsdWVzIGFyZSBub256ZXJvLCBldmVub2RkXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSB3YXMgdXNlZCBmb3Igc2V0dGluZyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gdW50aWwgdjEuNC4xMiAodXNlIGBmYWJyaWMuT2JqZWN0I2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbmAgaW5zdGVhZClcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpbGxSdWxlOiAgICAgICAgICAgICAgICAgJ25vbnplcm8nLFxuXG4gICAgLyoqXG4gICAgICogQ29tcG9zaXRlIHJ1bGUgdXNlZCBmb3IgY2FudmFzIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOiAnc291cmNlLW92ZXInLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiBhbiBvYmplY3QuXG4gICAgICogdGFrZXMgY3NzIGNvbG9ycyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTMvXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0aW9uIEJhY2tncm91bmQgY29sb3Igb2YgYW4gb2JqZWN0LiBjb2xvcmVkIGxheWVyIGJlaGluZCB0aGUgb2JqZWN0IHdoZW4gaXQgaXMgYWN0aXZlLlxuICAgICAqIGRvZXMgbm90IG1peCBnb29kIHdpdGggZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIG1ldGhvZHMuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkZWZpbmVkLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgdmlhIHN0cm9rZSBhbmQgdGhpcyBwcm9wZXJ0eSBzcGVjaWZpZXMgaXRzIGNvbG9yXG4gICAgICogdGFrZXMgY3NzIGNvbG9ycyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTMvXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2U6ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIHN0cm9rZSB1c2VkIHRvIHJlbmRlciB0aGlzIG9iamVjdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlIChzdHJva2UgbXVzdCBiZSBkZWZpbmVkKVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBvZmZzZXQgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VEYXNoT2Zmc2V0OiAwLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBlbmRpbmdzIHN0eWxlIG9mIGFuIG9iamVjdCdzIHN0cm9rZSAob25lIG9mIFwiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgICdidXR0JyxcblxuICAgIC8qKlxuICAgICAqIENvcm5lciBzdHlsZSBvZiBhbiBvYmplY3QncyBzdHJva2UgKG9uZSBvZiBcImJldmlsXCIsIFwicm91bmRcIiwgXCJtaXRlclwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlTGluZUpvaW46ICAgICAgICAgICAnbWl0ZXInLFxuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBtaXRlciBsZW5ndGggKHVzZWQgZm9yIHN0cm9rZUxpbmVKb2luID0gXCJtaXRlclwiKSBvZiBhbiBvYmplY3QncyBzdHJva2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgNCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlXG4gICAgICogQHR5cGUgZmFicmljLlNoYWRvd1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2hhZG93OiAgICAgICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT3BhY2l0eSBvZiBvYmplY3QncyBjb250cm9sbGluZyBib3JkZXJzIHdoZW4gb2JqZWN0IGlzIGFjdGl2ZSBhbmQgbW92aW5nXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBib3JkZXJPcGFjaXR5V2hlbk1vdmluZzogIDAuNCxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGZhY3RvciBvZiBvYmplY3QncyBjb250cm9sbGluZyBib3JkZXJzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBib3JkZXJTY2FsZUZhY3RvcjogICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gbWF0cml4IChzaW1pbGFyIHRvIFNWRydzIHRyYW5zZm9ybSBtYXRyaXgpXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1NYXRyaXg6ICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGFsbG93ZWQgc2NhbGUgdmFsdWUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5TY2FsZUxpbWl0OiAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBhbiBvYmplY3QgY2FuIG5vdCBiZSBzZWxlY3RlZCBmb3IgbW9kaWZpY2F0aW9uICh1c2luZyBlaXRoZXIgcG9pbnQtY2xpY2stYmFzZWQgb3IgZ3JvdXAtYmFzZWQgc2VsZWN0aW9uKS5cbiAgICAgKiBCdXQgZXZlbnRzIHN0aWxsIGZpcmUgb24gaXQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0YWJsZTogICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgYW4gb2JqZWN0IGNhbiBub3QgYmUgYSB0YXJnZXQgb2YgZXZlbnRzLiBBbGwgZXZlbnRzIHByb3BhZ2F0ZSB0aHJvdWdoIGl0LiBJbnRyb2R1Y2VkIGluIHYxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGV2ZW50ZWQ6ICAgICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGFuIG9iamVjdCBpcyBub3QgcmVuZGVyZWQgb24gY2FudmFzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlzaWJsZTogICAgICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgb2JqZWN0J3MgY29udHJvbHMgYXJlIG5vdCBkaXNwbGF5ZWQgYW5kIGNhbiBub3QgYmUgdXNlZCB0byBtYW5pcHVsYXRlIG9iamVjdFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc0NvbnRyb2xzOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnMgYXJlIG5vdCByZW5kZXJlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc0JvcmRlcnM6ICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9iamVjdCdzIGNvbnRyb2xsaW5nIHJvdGF0aW5nIHBvaW50IHdpbGwgbm90IGJlIHZpc2libGUgb3Igc2VsZWN0YWJsZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc1JvdGF0aW5nUG9pbnQ6ICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIE9mZnNldCBmb3Igb2JqZWN0J3MgY29udHJvbGxpbmcgcm90YXRpbmcgcG9pbnQgKHdoZW4gZW5hYmxlZCB2aWEgYGhhc1JvdGF0aW5nUG9pbnRgKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcm90YXRpbmdQb2ludE9mZnNldDogICAgICA0MCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgb2JqZWN0cyBhcmUgXCJmb3VuZFwiIG9uIGNhbnZhcyBvbiBwZXItcGl4ZWwgYmFzaXMgcmF0aGVyIHRoYW4gYWNjb3JkaW5nIHRvIGJvdW5kaW5nIGJveFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBlclBpeGVsVGFyZ2V0RmluZDogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBmYWxzZWAsIGRlZmF1bHQgb2JqZWN0J3MgdmFsdWVzIGFyZSBub3QgaW5jbHVkZWQgaW4gaXRzIHNlcmlhbGl6YXRpb25cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGRldGVybWluZXMgY2xpcHBpbmcgb2YgYW4gb2JqZWN0IChjb250ZXh0IGlzIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50KS5cbiAgICAgKiBJZiB5b3UgYXJlIHVzaW5nIGNvZGUgbWluaWZpY2F0aW9uLCBjdHggYXJndW1lbnQgY2FuIGJlIG1pbmlmaWVkL21hbmdsaWVkIHlvdSBzaG91bGQgdXNlXG4gICAgICogYXMgYSB3b3JrYXJvdW5kIGB2YXIgY3R4ID0gYXJndW1lbnRzWzBdO2AgaW4gdGhlIGZ1bmN0aW9uO1xuICAgICAqIE5vdGUgdGhhdCBjb250ZXh0IG9yaWdpbiBpcyBhdCB0aGUgb2JqZWN0J3MgY2VudGVyIHBvaW50IChub3QgbGVmdC90b3AgY29ybmVyKVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIDIuMC4wXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKi9cbiAgICBjbGlwVG86ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGhvcml6b250YWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WDogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WTogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3Qgcm90YXRpb24gaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1JvdGF0aW9uOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBzY2FsaW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nWDogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHZlcnRpY2FsIHNjYWxpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdZOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3Qgbm9uLXVuaWZvcm0gc2NhbGluZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrVW5pU2NhbGluZzogICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBob3Jpem9udGFsIHNrZXdpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NrZXdpbmdYOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgc2tld2luZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2tld2luZ1k6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBjYW5ub3QgYmUgZmxpcHBlZCBieSBzY2FsaW5nIGludG8gbmVnYXRpdmUgdmFsdWVzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaXMgbm90IGV4cG9ydGVkIGluIE9CSkVDVC9KU09OXG4gICAgICogc2luY2UgMS42LjNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBleGNsdWRlRnJvbUV4cG9ydDogICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBpcyBjYWNoZWQgb24gYW4gYWRkaXRpb25hbCBjYW52YXMuXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG9iamVjdENhY2hpbmc6ICAgICAgICAgICAgb2JqZWN0Q2FjaGluZyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgY2hlY2tlZCBmb3IgY2FjaGUgaW52YWxpZGF0aW9uLiBJbiBzb21lIHBhcnRpY3VsYXJcbiAgICAgKiBzaXR1YXRpb24geW91IG1heSB3YW50IHRoaXMgdG8gYmUgZGlzYWJsZWQgKCBzcHJheSBicnVzaCwgdmVyeSBiaWcsIGdyb3VwcylcbiAgICAgKiBvciBpZiB5b3VyIGFwcGxpY2F0aW9uIGRvZXMgbm90IGFsbG93IHlvdSB0byBtb2RpZnkgcHJvcGVydGllcyBmb3IgZ3JvdXBzIGNoaWxkIHlvdSB3YW50XG4gICAgICogdG8gZGlzYWJsZSBpdCBmb3IgZ3JvdXBzLlxuICAgICAqIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgKiBzaW5jZSAxLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHN0YXRlZnVsbENhY2hlOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIGNhY2hlIGRvZXMgbm90IGdldCB1cGRhdGVkIGR1cmluZyBzY2FsaW5nLiBUaGUgcGljdHVyZSB3aWxsIGdldCBibG9ja3kgaWYgc2NhbGVkXG4gICAgICogdG9vIG11Y2ggYW5kIHdpbGwgYmUgcmVkcmF3biB3aXRoIGNvcnJlY3QgZGV0YWlscyBhdCB0aGUgZW5kIG9mIHNjYWxpbmcuXG4gICAgICogdGhpcyBzZXR0aW5nIGlzIHBlcmZvcm1hbmNlIGFuZCBhcHBsaWNhdGlvbiBkZXBlbmRhbnQuXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG5vU2NhbGVDYWNoZTogICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIG9iamVjdCdzIGNhY2hlIHdpbGwgYmUgcmVyZW5kZXJlZCBuZXh0IHJlbmRlciBjYWxsLlxuICAgICAqIHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBkaXJ0eTogICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIGtlZXBzIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBob3ZlcmVkIGNvcm5lciBkdXJpbmcgbW91c2UgbW92ZS5cbiAgICAgKiAwIGlzIG5vIGNvcm5lciwgb3IgJ210JywgJ21sJywgJ210cicgZXRjLi5cbiAgICAgKiBJdCBzaG91bGQgYmUgcHJpdmF0ZSwgYnV0IHRoZXJlIGlzIG5vIGhhcm0gaW4gdXNpbmcgaXQgYXNcbiAgICAgKiBhIHJlYWQtb25seSBwcm9wZXJ0eS5cbiAgICAgKiBAdHlwZSBudW1iZXJ8c3RyaW5nfGFueVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBfX2Nvcm5lcjogMCxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGZpbGwgb3IgdGhlIHN0cm9rZSBpcyBkcmF3biBmaXJzdCAob25lIG9mIFwiZmlsbFwiIG9yIFwic3Ryb2tlXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYWludEZpcnN0OiAgICAgICAgICAgJ2ZpbGwnLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgc3RhdGVcbiAgICAgKiBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWQpXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiAoXG4gICAgICAndG9wIGxlZnQgd2lkdGggaGVpZ2h0IHNjYWxlWCBzY2FsZVkgZmxpcFggZmxpcFkgb3JpZ2luWCBvcmlnaW5ZIHRyYW5zZm9ybU1hdHJpeCAnICtcbiAgICAgICdzdHJva2Ugc3Ryb2tlV2lkdGggc3Ryb2tlRGFzaEFycmF5IHN0cm9rZUxpbmVDYXAgc3Ryb2tlRGFzaE9mZnNldCBzdHJva2VMaW5lSm9pbiBzdHJva2VNaXRlckxpbWl0ICcgK1xuICAgICAgJ2FuZ2xlIG9wYWNpdHkgZmlsbCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gc2hhZG93IGNsaXBUbyB2aXNpYmxlIGJhY2tncm91bmRDb2xvciAnICtcbiAgICAgICdza2V3WCBza2V3WSBmaWxsUnVsZSBwYWludEZpcnN0IGNsaXBQYXRoJ1xuICAgICkuc3BsaXQoJyAnKSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIGNhY2hlIG5lZWRzIHJlZnJlc2hcbiAgICAgKiBUaG9zZSBwcm9wZXJ0aWVzIGFyZSBjaGVja2VkIGJ5IHN0YXRlZnVsbENhY2hlIE9OICggb3IgbGF6eSBtb2RlIGlmIHdlIHdhbnQgKSBvciBmcm9tIHNpbmdsZVxuICAgICAqIGNhbGxzIHRvIE9iamVjdC5zZXQoa2V5LCB2YWx1ZSkuIElmIHRoZSBrZXkgaXMgaW4gdGhpcyBsaXN0LCB0aGUgb2JqZWN0IGlzIG1hcmtlZCBhcyBkaXJ0eVxuICAgICAqIGFuZCByZWZyZXNoZWQgYXQgdGhlIG5leHQgcmVuZGVyXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6IChcbiAgICAgICdmaWxsIHN0cm9rZSBzdHJva2VXaWR0aCBzdHJva2VEYXNoQXJyYXkgd2lkdGggaGVpZ2h0IHBhaW50Rmlyc3QnICtcbiAgICAgICcgc3Ryb2tlTGluZUNhcCBzdHJva2VEYXNoT2Zmc2V0IHN0cm9rZUxpbmVKb2luIHN0cm9rZU1pdGVyTGltaXQgYmFja2dyb3VuZENvbG9yIGNsaXBQYXRoJ1xuICAgICkuc3BsaXQoJyAnKSxcblxuICAgIC8qKlxuICAgICAqIGEgZmFicmljT2JqZWN0IHRoYXQsIHdpdGhvdXQgc3Ryb2tlIGRlZmluZSBhIGNsaXBwaW5nIGFyZWEgd2l0aCB0aGVpciBzaGFwZS4gZmlsbGVkIGluIGJsYWNrXG4gICAgICogdGhlIGNsaXBQYXRoIG9iamVjdCBnZXRzIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGhhcyByZW5kZXJlZCwgYW5kIHRoZSBjb250ZXh0IGlzIHBsYWNlZCBpbiB0aGUgY2VudGVyXG4gICAgICogb2YgdGhlIG9iamVjdCBjYWNoZUNhbnZhcy5cbiAgICAgKiBJZiB5b3Ugd2FudCAwLDAgb2YgYSBjbGlwUGF0aCB0byBhbGlnbiB3aXRoIGFuIG9iamVjdCBjZW50ZXIsIHVzZSBjbGlwUGF0aC5vcmlnaW5YL1kgdG8gJ2NlbnRlcidcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0XG4gICAgICovXG4gICAgY2xpcFBhdGg6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIE1lYW5pbmdmdWwgT05MWSB3aGVuIHRoZSBvYmplY3QgaXMgdXNlZCBhcyBjbGlwUGF0aC5cbiAgICAgKiBpZiB0cnVlLCB0aGUgY2xpcFBhdGggd2lsbCBtYWtlIHRoZSBvYmplY3QgY2xpcCB0byB0aGUgb3V0c2lkZSBvZiB0aGUgY2xpcFBhdGhcbiAgICAgKiBzaW5jZSAyLjQuMFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGludmVydGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIE1lYW5pbmdmdWwgT05MWSB3aGVuIHRoZSBvYmplY3QgaXMgdXNlZCBhcyBjbGlwUGF0aC5cbiAgICAgKiBpZiB0cnVlLCB0aGUgY2xpcFBhdGggd2lsbCBoYXZlIGl0cyB0b3AgYW5kIGxlZnQgcmVsYXRpdmUgdG8gY2FudmFzLCBhbmQgd2lsbFxuICAgICAqIG5vdCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBvYmplY3QgdHJhbnNmb3JtLiBUaGlzIHdpbGwgbWFrZSB0aGUgY2xpcFBhdGggcmVsYXRpdmVcbiAgICAgKiB0byB0aGUgY2FudmFzLCBidXQgY2xpcHBpbmcganVzdCBhIHBhcnRpY3VsYXIgb2JqZWN0LlxuICAgICAqIFdBUk5JTkcgdGhpcyBpcyBiZXRhLCB0aGlzIGZlYXR1cmUgbWF5IGNoYW5nZSBvciBiZSByZW5hbWVkLlxuICAgICAqIHNpbmNlIDIuNC4wXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgYWJzb2x1dGVQb3NpdGlvbmVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdGhlIGNhbnZhcyB1c2VkIHRvIGtlZXAgdGhlIGNhY2hlZCBjb3B5IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYWNoZUNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jYWNoZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgIHRoaXMuX2NhY2hlQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgdGhpcy5fY2FjaGVDb250ZXh0ID0gdGhpcy5fY2FjaGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNhY2hlQ2FudmFzKCk7XG4gICAgICAvLyBpZiBjYW52YXMgZ2V0cyBjcmVhdGVkLCBpcyBlbXB0eSwgc28gZGlydHkuXG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGltaXQgdGhlIGNhY2hlIGRpbWVuc2lvbnMgc28gdGhhdCBYICogWSBkbyBub3QgY3Jvc3MgZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbFxuICAgICAqIGFuZCBlYWNoIHNpZGUgZG8gbm90IGNyb3NzIGZhYnJpYy5jYWNoZVNpZGVMaW1pdFxuICAgICAqIHRob3NlIG51bWJlcnMgYXJlIGNvbmZpZ3VyYWJsZSBzbyB0aGF0IHlvdSBjYW4gZ2V0IGFzIG11Y2ggZGV0YWlsIGFzIHlvdSB3YW50XG4gICAgICogbWFraW5nIGJhcmdhaW4gd2l0aCBwZXJmb3JtYW5jZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXMuem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqL1xuICAgIF9saW1pdENhY2hlU2l6ZTogZnVuY3Rpb24oZGltcykge1xuICAgICAgdmFyIHBlcmZMaW1pdFNpemVUb3RhbCA9IGZhYnJpYy5wZXJmTGltaXRTaXplVG90YWwsXG4gICAgICAgICAgd2lkdGggPSBkaW1zLndpZHRoLCBoZWlnaHQgPSBkaW1zLmhlaWdodCxcbiAgICAgICAgICBtYXggPSBmYWJyaWMubWF4Q2FjaGVTaWRlTGltaXQsIG1pbiA9IGZhYnJpYy5taW5DYWNoZVNpZGVMaW1pdDtcbiAgICAgIGlmICh3aWR0aCA8PSBtYXggJiYgaGVpZ2h0IDw9IG1heCAmJiB3aWR0aCAqIGhlaWdodCA8PSBwZXJmTGltaXRTaXplVG90YWwpIHtcbiAgICAgICAgaWYgKHdpZHRoIDwgbWluKSB7XG4gICAgICAgICAgZGltcy53aWR0aCA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0IDwgbWluKSB7XG4gICAgICAgICAgZGltcy5oZWlnaHQgPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpbXM7XG4gICAgICB9XG4gICAgICB2YXIgYXIgPSB3aWR0aCAvIGhlaWdodCwgbGltaXRlZERpbXMgPSBmYWJyaWMudXRpbC5saW1pdERpbXNCeUFyZWEoYXIsIHBlcmZMaW1pdFNpemVUb3RhbCksXG4gICAgICAgICAgY2FwVmFsdWUgPSBmYWJyaWMudXRpbC5jYXBWYWx1ZSxcbiAgICAgICAgICB4ID0gY2FwVmFsdWUobWluLCBsaW1pdGVkRGltcy54LCBtYXgpLFxuICAgICAgICAgIHkgPSBjYXBWYWx1ZShtaW4sIGxpbWl0ZWREaW1zLnksIG1heCk7XG4gICAgICBpZiAod2lkdGggPiB4KSB7XG4gICAgICAgIGRpbXMuem9vbVggLz0gd2lkdGggLyB4O1xuICAgICAgICBkaW1zLndpZHRoID0geDtcbiAgICAgICAgZGltcy5jYXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodCA+IHkpIHtcbiAgICAgICAgZGltcy56b29tWSAvPSBoZWlnaHQgLyB5O1xuICAgICAgICBkaW1zLmhlaWdodCA9IHk7XG4gICAgICAgIGRpbXMuY2FwcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaW1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRpbWVuc2lvbiBhbmQgdGhlIHpvb20gbGV2ZWwgbmVlZGVkIHRvIGNyZWF0ZSBhIGNhY2hlIGNhbnZhc1xuICAgICAqIGJpZyBlbm91Z2ggdG8gaG9zdCB0aGUgb2JqZWN0IHRvIGJlIGNhY2hlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ueCB3aWR0aCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fS55IGhlaWdodCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fS53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWCB6b29tWCB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKi9cbiAgICBfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmplY3RTY2FsZSA9IHRoaXMuZ2V0VG90YWxPYmplY3RTY2FsaW5nKCksXG4gICAgICAgICAgZGltID0gdGhpcy5fZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zKCksXG4gICAgICAgICAgem9vbVggPSBvYmplY3RTY2FsZS5zY2FsZVgsXG4gICAgICAgICAgem9vbVkgPSBvYmplY3RTY2FsZS5zY2FsZVksXG4gICAgICAgICAgd2lkdGggPSBkaW0ueCAqIHpvb21YLFxuICAgICAgICAgIGhlaWdodCA9IGRpbS55ICogem9vbVk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBmb3Igc3VyZSB0aGlzIEFMSUFTSU5HX0xJTUlUIGlzIHNsaWdodGx5IGNyYXRpbmcgcHJvYmxlbVxuICAgICAgICAvLyBpbiBzaXR1YXRpb24gaW4gd2ljaCB0aGUgY2FjaGUgY2FudmFzIGdldHMgYW4gdXBwZXIgbGltaXRcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgQUxJQVNJTkdfTElNSVQsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgQUxJQVNJTkdfTElNSVQsXG4gICAgICAgIHpvb21YOiB6b29tWCxcbiAgICAgICAgem9vbVk6IHpvb21ZLFxuICAgICAgICB4OiBkaW0ueCxcbiAgICAgICAgeTogZGltLnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjYW52YXMgZm9yIGNhY2hlXG4gICAgICogcmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIGNhbnZhcyBuZWVkZWQgcmVzaXplLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FudmFzIGhhcyBiZWVuIHJlc2l6ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRhcmdldENhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgaWYgKHRoaXMubm9TY2FsZUNhY2hlICYmIHRhcmdldENhbnZhcyAmJiB0YXJnZXRDYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldENhbnZhcy5fY3VycmVudFRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgICAgICBhY3Rpb24gPSB0YXJnZXRDYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0uYWN0aW9uO1xuICAgICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIGFjdGlvbi5zbGljZSAmJiBhY3Rpb24uc2xpY2UoMCwgNSkgPT09ICdzY2FsZScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYWNoZUNhbnZhcyxcbiAgICAgICAgICBkaW1zID0gdGhpcy5fbGltaXRDYWNoZVNpemUodGhpcy5fZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCkpLFxuICAgICAgICAgIG1pbkNhY2hlU2l6ZSA9IGZhYnJpYy5taW5DYWNoZVNpZGVMaW1pdCxcbiAgICAgICAgICB3aWR0aCA9IGRpbXMud2lkdGgsIGhlaWdodCA9IGRpbXMuaGVpZ2h0LCBkcmF3aW5nV2lkdGgsIGRyYXdpbmdIZWlnaHQsXG4gICAgICAgICAgem9vbVggPSBkaW1zLnpvb21YLCB6b29tWSA9IGRpbXMuem9vbVksXG4gICAgICAgICAgZGltZW5zaW9uc0NoYW5nZWQgPSB3aWR0aCAhPT0gdGhpcy5jYWNoZVdpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5jYWNoZUhlaWdodCxcbiAgICAgICAgICB6b29tQ2hhbmdlZCA9IHRoaXMuem9vbVggIT09IHpvb21YIHx8IHRoaXMuem9vbVkgIT09IHpvb21ZLFxuICAgICAgICAgIHNob3VsZFJlZHJhdyA9IGRpbWVuc2lvbnNDaGFuZ2VkIHx8IHpvb21DaGFuZ2VkLFxuICAgICAgICAgIGFkZGl0aW9uYWxXaWR0aCA9IDAsIGFkZGl0aW9uYWxIZWlnaHQgPSAwLCBzaG91bGRSZXNpemVDYW52YXMgPSBmYWxzZTtcbiAgICAgIGlmIChkaW1lbnNpb25zQ2hhbmdlZCkge1xuICAgICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLl9jYWNoZUNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGNhbnZhc0hlaWdodCA9IHRoaXMuX2NhY2hlQ2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIHNpemVHcm93aW5nID0gd2lkdGggPiBjYW52YXNXaWR0aCB8fCBoZWlnaHQgPiBjYW52YXNIZWlnaHQsXG4gICAgICAgICAgICBzaXplU2hyaW5raW5nID0gKHdpZHRoIDwgY2FudmFzV2lkdGggKiAwLjkgfHwgaGVpZ2h0IDwgY2FudmFzSGVpZ2h0ICogMC45KSAmJlxuICAgICAgICAgICAgICBjYW52YXNXaWR0aCA+IG1pbkNhY2hlU2l6ZSAmJiBjYW52YXNIZWlnaHQgPiBtaW5DYWNoZVNpemU7XG4gICAgICAgIHNob3VsZFJlc2l6ZUNhbnZhcyA9IHNpemVHcm93aW5nIHx8IHNpemVTaHJpbmtpbmc7XG4gICAgICAgIGlmIChzaXplR3Jvd2luZyAmJiAhZGltcy5jYXBwZWQgJiYgKHdpZHRoID4gbWluQ2FjaGVTaXplIHx8IGhlaWdodCA+IG1pbkNhY2hlU2l6ZSkpIHtcbiAgICAgICAgICBhZGRpdGlvbmFsV2lkdGggPSB3aWR0aCAqIDAuMTtcbiAgICAgICAgICBhZGRpdGlvbmFsSGVpZ2h0ID0gaGVpZ2h0ICogMC4xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVkcmF3KSB7XG4gICAgICAgIGlmIChzaG91bGRSZXNpemVDYW52YXMpIHtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBNYXRoLmNlaWwod2lkdGggKyBhZGRpdGlvbmFsV2lkdGgpO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICsgYWRkaXRpb25hbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd2luZ1dpZHRoID0gZGltcy54ICogem9vbVggLyAyO1xuICAgICAgICBkcmF3aW5nSGVpZ2h0ID0gZGltcy55ICogem9vbVkgLyAyO1xuICAgICAgICB0aGlzLmNhY2hlVHJhbnNsYXRpb25YID0gTWF0aC5yb3VuZChjYW52YXMud2lkdGggLyAyIC0gZHJhd2luZ1dpZHRoKSArIGRyYXdpbmdXaWR0aDtcbiAgICAgICAgdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSA9IE1hdGgucm91bmQoY2FudmFzLmhlaWdodCAvIDIgLSBkcmF3aW5nSGVpZ2h0KSArIGRyYXdpbmdIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FjaGVXaWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmNhY2hlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQudHJhbnNsYXRlKHRoaXMuY2FjaGVUcmFuc2xhdGlvblgsIHRoaXMuY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuc2NhbGUoem9vbVgsIHpvb21ZKTtcbiAgICAgICAgdGhpcy56b29tWCA9IHpvb21YO1xuICAgICAgICB0aGlzLnpvb21ZID0gem9vbVk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0R3JhZGllbnQob3B0aW9ucy5maWxsLCAnZmlsbCcpO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KG9wdGlvbnMuc3Ryb2tlLCAnc3Ryb2tlJyk7XG4gICAgICB0aGlzLl9pbml0Q2xpcHBpbmcob3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zLmZpbGwsICdmaWxsJyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zLnN0cm9rZSwgJ3N0cm9rZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbnRleHQgd2hlbiByZW5kZXJpbmcgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0XG4gICAgICovXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBtO1xuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUpIHtcbiAgICAgICAgbSA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG0gPSB0aGlzLmNhbGNPd25NYXRyaXgoKTtcbiAgICAgIH1cbiAgICAgIGN0eC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTLFxuXG4gICAgICAgICAgb2JqZWN0ID0ge1xuICAgICAgICAgICAgdHlwZTogICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiAgICAgICAgICAgICAgICAgIGZhYnJpYy52ZXJzaW9uLFxuICAgICAgICAgICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luWSxcbiAgICAgICAgICAgIGxlZnQ6ICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgdG9wOiAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMudG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHdpZHRoOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGhlaWdodDogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBmaWxsOiAgICAgICAgICAgICAgICAgICAgICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsLnRvT2JqZWN0KSA/IHRoaXMuZmlsbC50b09iamVjdCgpIDogdGhpcy5maWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2UudG9PYmplY3QpID8gdGhpcy5zdHJva2UudG9PYmplY3QoKSA6IHRoaXMuc3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc3Ryb2tlV2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmNvbmNhdCgpIDogdGhpcy5zdHJva2VEYXNoQXJyYXksXG4gICAgICAgICAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgIHRoaXMuc3Ryb2tlTGluZUNhcCxcbiAgICAgICAgICAgIHN0cm9rZURhc2hPZmZzZXQ6ICAgICAgICAgdGhpcy5zdHJva2VEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgc3Ryb2tlTGluZUpvaW46ICAgICAgICAgICB0aGlzLnN0cm9rZUxpbmVKb2luLFxuICAgICAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdDogICAgICAgICB0b0ZpeGVkKHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBzY2FsZVg6ICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5zY2FsZVgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2NhbGVZOiAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2NhbGVZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGFuZ2xlOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmFuZ2xlLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGZsaXBYOiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGlwWCxcbiAgICAgICAgICAgIGZsaXBZOiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGlwWSxcbiAgICAgICAgICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLm9wYWNpdHksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2hhZG93OiAgICAgICAgICAgICAgICAgICAodGhpcy5zaGFkb3cgJiYgdGhpcy5zaGFkb3cudG9PYmplY3QpID8gdGhpcy5zaGFkb3cudG9PYmplY3QoKSA6IHRoaXMuc2hhZG93LFxuICAgICAgICAgICAgdmlzaWJsZTogICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGUsXG4gICAgICAgICAgICBjbGlwVG86ICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcFRvICYmIFN0cmluZyh0aGlzLmNsaXBUbyksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZmlsbFJ1bGU6ICAgICAgICAgICAgICAgICB0aGlzLmZpbGxSdWxlLFxuICAgICAgICAgICAgcGFpbnRGaXJzdDogICAgICAgICAgICAgICB0aGlzLnBhaW50Rmlyc3QsXG4gICAgICAgICAgICBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb246IHRoaXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLFxuICAgICAgICAgICAgdHJhbnNmb3JtTWF0cml4OiAgICAgICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA/IHRoaXMudHJhbnNmb3JtTWF0cml4LmNvbmNhdCgpIDogbnVsbCxcbiAgICAgICAgICAgIHNrZXdYOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNrZXdYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNrZXdZOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNrZXdZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICBvYmplY3QuY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgICBvYmplY3QuY2xpcFBhdGguaW52ZXJ0ZWQgPSB0aGlzLmNsaXBQYXRoLmludmVydGVkO1xuICAgICAgICBvYmplY3QuY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkID0gdGhpcy5jbGlwUGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQ7XG4gICAgICB9XG5cbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgb2JqZWN0LCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBvYmplY3QgPSB0aGlzLl9yZW1vdmVEZWZhdWx0VmFsdWVzKG9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgKGRhdGFsZXNzKSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHN1YmNsYXNzZXNcbiAgICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKi9cbiAgICBfcmVtb3ZlRGVmYXVsdFZhbHVlczogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcHJvdG90eXBlID0gZmFicmljLnV0aWwuZ2V0S2xhc3Mob2JqZWN0LnR5cGUpLnByb3RvdHlwZSxcbiAgICAgICAgICBzdGF0ZVByb3BlcnRpZXMgPSBwcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzO1xuICAgICAgc3RhdGVQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBpZiAob2JqZWN0W3Byb3BdID09PSBwcm90b3R5cGVbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0FycmF5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdFtwcm9wXSkgPT09ICdbb2JqZWN0IEFycmF5XScgJiZcbiAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvdG90eXBlW3Byb3BdKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblxuICAgICAgICAvLyBiYXNpY2FsbHkgYSBjaGVjayBmb3IgW10gPT09IFtdXG4gICAgICAgIGlmIChpc0FycmF5ICYmIG9iamVjdFtwcm9wXS5sZW5ndGggPT09IDAgJiYgcHJvdG90eXBlW3Byb3BdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuJyArIGNhcGl0YWxpemUodGhpcy50eXBlKSArICc+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBvYmplY3Qgc2NhbGUgZmFjdG9yIGNvdW50aW5nIGFsc28gdGhlIGdyb3VwIHNjYWxpbmdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIHNjYWxlWCBhbmQgc2NhbGVZIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRPYmplY3RTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2FsZVggPSB0aGlzLnNjYWxlWCwgc2NhbGVZID0gdGhpcy5zY2FsZVk7XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICB2YXIgc2NhbGluZyA9IHRoaXMuZ3JvdXAuZ2V0T2JqZWN0U2NhbGluZygpO1xuICAgICAgICBzY2FsZVggKj0gc2NhbGluZy5zY2FsZVg7XG4gICAgICAgIHNjYWxlWSAqPSBzY2FsaW5nLnNjYWxlWTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHNjYWxlWDogc2NhbGVYLCBzY2FsZVk6IHNjYWxlWSB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG9iamVjdCBzY2FsZSBmYWN0b3IgY291bnRpbmcgYWxzbyB0aGUgZ3JvdXAgc2NhbGluZywgem9vbSBhbmQgcmV0aW5hXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBzY2FsZVggYW5kIHNjYWxlWSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0VG90YWxPYmplY3RTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpLCBzY2FsZVggPSBzY2FsZS5zY2FsZVgsIHNjYWxlWSA9IHNjYWxlLnNjYWxlWTtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB2YXIgem9vbSA9IHRoaXMuY2FudmFzLmdldFpvb20oKTtcbiAgICAgICAgdmFyIHJldGluYSA9IHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKTtcbiAgICAgICAgc2NhbGVYICo9IHpvb20gKiByZXRpbmE7XG4gICAgICAgIHNjYWxlWSAqPSB6b29tICogcmV0aW5hO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IG9wYWNpdHkgY291bnRpbmcgYWxzbyB0aGUgZ3JvdXAgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0T2JqZWN0T3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIG9wYWNpdHkgKj0gdGhpcy5ncm91cC5nZXRPYmplY3RPcGFjaXR5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3BhY2l0eTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc2hvdWxkQ29uc3RyYWluVmFsdWUgPSAoa2V5ID09PSAnc2NhbGVYJyB8fCBrZXkgPT09ICdzY2FsZVknKSxcbiAgICAgICAgICBpc0NoYW5nZWQgPSB0aGlzW2tleV0gIT09IHZhbHVlLCBncm91cE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRDb25zdHJhaW5WYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2NvbnN0cmFpblNjYWxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzY2FsZVgnICYmIHZhbHVlIDwgMCkge1xuICAgICAgICB0aGlzLmZsaXBYID0gIXRoaXMuZmxpcFg7XG4gICAgICAgIHZhbHVlICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc2NhbGVZJyAmJiB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhpcy5mbGlwWSA9ICF0aGlzLmZsaXBZO1xuICAgICAgICB2YWx1ZSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3NoYWRvdycgJiYgdmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIGZhYnJpYy5TaGFkb3cpKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IGZhYnJpYy5TaGFkb3codmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZGlydHknICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdGhpcy5ncm91cC5zZXQoJ2RpcnR5JywgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcblxuICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICBncm91cE5lZWRzVXBkYXRlID0gdGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKTtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgZ3JvdXBOZWVkc1VwZGF0ZSAmJiB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChncm91cE5lZWRzVXBkYXRlICYmIHRoaXMuc3RhdGVQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5ncm91cC5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IHRoZSBwYXJlbnQgZ3JvdXAgb2YgYW4gb2JqZWN0IGV2ZXJ5XG4gICAgICogdGltZSBhIG5vbi1kZWxlZ2F0ZWQgcHJvcGVydHkgY2hhbmdlcyBvbiB0aGUgZ3JvdXAuIEl0IGlzIHBhc3NlZCB0aGUga2V5XG4gICAgICogYW5kIHZhbHVlIGFzIHBhcmFtZXRlcnMuIE5vdCBhZGRpbmcgaW4gdGhpcyBmdW5jdGlvbidzIHNpZ25hdHVyZSB0byBhdm9pZFxuICAgICAqIFRyYXZpcyBidWlsZCBlcnJvciBhYm91dCB1bnVzZWQgdmFyaWFibGVzLlxuICAgICAqL1xuICAgIHNldE9uR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzZXMsIGFzIG5lZWRlZC5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHZpZXdwb3J0VHJhbnNmb3JtIGZyb20gT2JqZWN0J3MgY2FudmFzIGlmIHBvc3NpYmxlXG4gICAgICogQG1ldGhvZCBnZXRWaWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGdldFZpZXdwb3J0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFicmljLmlNYXRyaXguY29uY2F0KCk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZXR1cm4gaWYgdGhlIG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGluIHJlbmRlcmluZ1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNOb3RWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPT09IDAgfHxcbiAgICAgICAgKHRoaXMud2lkdGggPT09IDAgJiYgdGhpcy5oZWlnaHQgPT09IDAgJiYgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkgfHxcbiAgICAgICAgIXRoaXMudmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgLy8gZG8gbm90IHJlbmRlciBpZiB3aWR0aC9oZWlnaHQgYXJlIHplcm9zIG9yIG9iamVjdCBpcyBub3QgdmlzaWJsZVxuICAgICAgaWYgKHRoaXMuaXNOb3RWaXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnNraXBPZmZzY3JlZW4gJiYgIXRoaXMuZ3JvdXAgJiYgIXRoaXMuaXNPblNjcmVlbigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXR1cENvbXBvc2l0ZU9wZXJhdGlvbihjdHgpO1xuICAgICAgdGhpcy5kcmF3U2VsZWN0aW9uQmFja2dyb3VuZChjdHgpO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oY3R4KTtcbiAgICAgIHRoaXMuX3NldE9wYWNpdHkoY3R4KTtcbiAgICAgIHRoaXMuX3NldFNoYWRvdyhjdHgsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCB0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsaXBUbyAmJiBmYWJyaWMudXRpbC5jbGlwQ29udGV4dCh0aGlzLCBjdHgpO1xuICAgICAgaWYgKHRoaXMuc2hvdWxkQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLnJlbmRlckNhY2hlKCk7XG4gICAgICAgIHRoaXMuZHJhd0NhY2hlT25DYW52YXMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmVDYWNoZUNhbnZhcygpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhd09iamVjdChjdHgpO1xuICAgICAgICBpZiAodGhpcy5vYmplY3RDYWNoaW5nICYmIHRoaXMuc3RhdGVmdWxsQ2FjaGUpIHtcbiAgICAgICAgICB0aGlzLnNhdmVTdGF0ZSh7IHByb3BlcnR5U2V0OiAnY2FjaGVQcm9wZXJ0aWVzJyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5jbGlwVG8gJiYgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIHJlbmRlckNhY2hlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmICghdGhpcy5fY2FjaGVDYW52YXMpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQ2FjaGVDYW52YXMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ2FjaGVEaXJ0eSgpKSB7XG4gICAgICAgIHRoaXMuc3RhdGVmdWxsQ2FjaGUgJiYgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ2NhY2hlUHJvcGVydGllcycgfSk7XG4gICAgICAgIHRoaXMuZHJhd09iamVjdCh0aGlzLl9jYWNoZUNvbnRleHQsIG9wdGlvbnMuZm9yQ2xpcHBpbmcpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjYWNoZUNhbnZhcyBhbmQgaXRzIGRpbWVuc2lvbnMgZnJvbSB0aGUgb2JqZWN0c1xuICAgICAqL1xuICAgIF9yZW1vdmVDYWNoZUNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jYWNoZUNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLmNhY2hlV2lkdGggPSAwO1xuICAgICAgdGhpcy5jYWNoZUhlaWdodCA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgZm9yY2UgdGhlIG9iamVjdCB0byBoYXZlIGl0cyBvd24gY2FjaGUsIGV2ZW4gaWYgaXQgaXMgaW5zaWRlIGEgZ3JvdXBcbiAgICAgKiBpdCBtYXkgYmUgbmVlZGVkIHdoZW4geW91ciBvYmplY3QgYmVoYXZlIGluIGEgcGFydGljdWxhciB3YXkgb24gdGhlIGNhY2hlIGFuZCBhbHdheXMgbmVlZHNcbiAgICAgKiBpdHMgb3duIGlzb2xhdGVkIGNhbnZhcyB0byByZW5kZXIgY29ycmVjdGx5LlxuICAgICAqIENyZWF0ZWQgdG8gYmUgb3ZlcnJpZGRlblxuICAgICAqIHNpbmNlIDEuNy4xMlxuICAgICAqIEByZXR1cm5zIGZhbHNlXG4gICAgICovXG4gICAgbmVlZHNJdHNPd25DYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJyAmJiB0eXBlb2YgdGhpcy5zaGFkb3cgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogb2JqZWN0Q2FjaGluZyBpcyBhIGdsb2JhbCBmbGFnLCB3aW5zIG92ZXIgZXZlcnl0aGluZ1xuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBvdXRzaWRlIGlzIGNhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMub3duQ2FjaGluZyA9IHRoaXMub2JqZWN0Q2FjaGluZyAmJlxuICAgICAgKCF0aGlzLmdyb3VwIHx8IHRoaXMubmVlZHNJdHNPd25DYWNoZSgpIHx8ICF0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKSk7XG4gICAgICByZXR1cm4gdGhpcy5vd25DYWNoaW5nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBvciBhIGNoaWxkIG9iamVjdCB3aWxsIGNhc3QgYSBzaGFkb3dcbiAgICAgKiB1c2VkIGJ5IEdyb3VwLnNob3VsZENhY2hlIHRvIGtub3cgaWYgY2hpbGQgaGFzIGEgc2hhZG93IHJlY3Vyc2l2ZWx5XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB3aWxsRHJhd1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnNoYWRvdyAmJiAodGhpcy5zaGFkb3cub2Zmc2V0WCAhPT0gMCB8fCB0aGlzLnNoYWRvdy5vZmZzZXRZICE9PSAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgZHJhd2luZyBvcGVyYXRpb24gZm9yIGFuIG9iamVjdCBjbGlwUGF0aFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2xpcFBhdGhPbkNhY2hlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvLyBERUJVRzogdW5jb21tZW50IHRoaXMgbGluZSwgY29tbWVudCB0aGUgZm9sbG93aW5nXG4gICAgICAvLyBjdHguZ2xvYmFsQWxwaGEgPSAwLjRcbiAgICAgIGlmIChwYXRoLmludmVydGVkKSB7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgIH1cbiAgICAgIC8vY3R4LnNjYWxlKDEgLyAyLCAxIC8gMik7XG4gICAgICBpZiAocGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQpIHtcbiAgICAgICAgdmFyIG0gPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCkpO1xuICAgICAgICBjdHgudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgfVxuICAgICAgcGF0aC50cmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gcGF0aC56b29tWCwgMSAvIHBhdGguem9vbVkpO1xuICAgICAgY3R4LmRyYXdJbWFnZShwYXRoLl9jYWNoZUNhbnZhcywgLXBhdGguY2FjaGVUcmFuc2xhdGlvblgsIC1wYXRoLmNhY2hlVHJhbnNsYXRpb25ZKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGRyYXdpbmcgb3BlcmF0aW9uIGZvciBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3T2JqZWN0OiBmdW5jdGlvbihjdHgsIGZvckNsaXBwaW5nKSB7XG4gICAgICB2YXIgb3JpZ2luYWxGaWxsID0gdGhpcy5maWxsLCBvcmlnaW5hbFN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgaWYgKGZvckNsaXBwaW5nKSB7XG4gICAgICAgIHRoaXMuZmlsbCA9ICdibGFjayc7XG4gICAgICAgIHRoaXMuc3Ryb2tlID0gJyc7XG4gICAgICAgIHRoaXMuX3NldENsaXBwaW5nUHJvcGVydGllcyhjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoY3R4KTtcbiAgICAgICAgdGhpcy5fc2V0U3Ryb2tlU3R5bGVzKGN0eCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3NldEZpbGxTdHlsZXMoY3R4LCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlcihjdHgpO1xuICAgICAgdGhpcy5fZHJhd0NsaXBQYXRoKGN0eCk7XG4gICAgICB0aGlzLmZpbGwgPSBvcmlnaW5hbEZpbGw7XG4gICAgICB0aGlzLnN0cm9rZSA9IG9yaWdpbmFsU3Ryb2tlO1xuICAgIH0sXG5cbiAgICBfZHJhd0NsaXBQYXRoOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgIGlmICghcGF0aCkgeyByZXR1cm47IH1cbiAgICAgIC8vIG5lZWRlZCB0byBzZXR1cCBhIGNvdXBsZSBvZiB2YXJpYWJsZXNcbiAgICAgIC8vIHBhdGggY2FudmFzIGdldHMgb3ZlcnJpZGRlbiB3aXRoIHRoaXMgb25lLlxuICAgICAgLy8gVE9ETyBmaW5kIGEgYmV0dGVyIHNvbHV0aW9uP1xuICAgICAgcGF0aC5jYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIHBhdGguc2hvdWxkQ2FjaGUoKTtcbiAgICAgIHBhdGguX3RyYW5zZm9ybURvbmUgPSB0cnVlO1xuICAgICAgcGF0aC5yZW5kZXJDYWNoZSh7IGZvckNsaXBwaW5nOiB0cnVlIH0pO1xuICAgICAgdGhpcy5kcmF3Q2xpcFBhdGhPbkNhY2hlKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhaW50IHRoZSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0IG9uIHRoZSB0YXJnZXQgY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd0NhY2hlT25DYW52YXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LnNjYWxlKDEgLyB0aGlzLnpvb21YLCAxIC8gdGhpcy56b29tWSk7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX2NhY2hlQ2FudmFzLCAtdGhpcy5jYWNoZVRyYW5zbGF0aW9uWCwgLXRoaXMuY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjYWNoZSBpcyBkaXJ0eVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcENhbnZhcyBza2lwIGNhbnZhcyBjaGVja3MgYmVjYXVzZSB0aGlzIG9iamVjdCBpcyBwYWludGVkXG4gICAgICogb24gcGFyZW50IGNhbnZhcy5cbiAgICAgKi9cbiAgICBpc0NhY2hlRGlydHk6IGZ1bmN0aW9uKHNraXBDYW52YXMpIHtcbiAgICAgIGlmICh0aGlzLmlzTm90VmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jYWNoZUNhbnZhcyAmJiAhc2tpcENhbnZhcyAmJiB0aGlzLl91cGRhdGVDYWNoZUNhbnZhcygpKSB7XG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB0aGUgY29udGV4dCBpcyBhbHJlYWR5IGNsZWFyZWQuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5IHx8XG4gICAgICAgICAgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwUGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQpIHx8XG4gICAgICAgICAgKHRoaXMuc3RhdGVmdWxsQ2FjaGUgJiYgdGhpcy5oYXNTdGF0ZUNoYW5nZWQoJ2NhY2hlUHJvcGVydGllcycpKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2FjaGVDYW52YXMgJiYgIXNraXBDYW52YXMpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FjaGVXaWR0aCAvIHRoaXMuem9vbVg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5jYWNoZUhlaWdodCAvIHRoaXMuem9vbVk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBiYWNrZ3JvdW5kIGZvciB0aGUgb2JqZWN0IGJpZyBhcyBpdHMgdW50cmFuc2Zvcm1lZCBkaW1lbnNpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGltID0gdGhpcy5fZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgLWRpbS54IC8gMixcbiAgICAgICAgLWRpbS55IC8gMixcbiAgICAgICAgZGltLngsXG4gICAgICAgIGRpbS55XG4gICAgICApO1xuICAgICAgLy8gaWYgdGhlcmUgaXMgYmFja2dyb3VuZCBjb2xvciBubyBvdGhlciBzaGFkb3dzXG4gICAgICAvLyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3NldE9wYWNpdHk6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5nZXRPYmplY3RPcGFjaXR5KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldFN0cm9rZVN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICBpZiAoZGVjbC5zdHJva2UpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGRlY2wuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gZGVjbC5zdHJva2VMaW5lQ2FwO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkZWNsLnN0cm9rZURhc2hPZmZzZXQ7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGRlY2wuc3Ryb2tlTGluZUpvaW47XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gZGVjbC5zdHJva2VNaXRlckxpbWl0O1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBkZWNsLnN0cm9rZS50b0xpdmVcbiAgICAgICAgICA/IGRlY2wuc3Ryb2tlLnRvTGl2ZShjdHgsIHRoaXMpXG4gICAgICAgICAgOiBkZWNsLnN0cm9rZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldEZpbGxTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgZGVjbCkge1xuICAgICAgaWYgKGRlY2wuZmlsbCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gZGVjbC5maWxsLnRvTGl2ZVxuICAgICAgICAgID8gZGVjbC5maWxsLnRvTGl2ZShjdHgsIHRoaXMpXG4gICAgICAgICAgOiBkZWNsLmZpbGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRDbGlwcGluZ1Byb3BlcnRpZXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICd0cmFuc3BhcmVudCc7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJyMwMDAwMDAnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNldHMgbGluZSBkYXNoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHNldCB0aGUgZGFzaCBsaW5lIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGFzaEFycmF5IGFycmF5IHJlcHJlc2VudGluZyBkYXNoZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhbHRlcm5hdGl2ZSBmdW5jdGlvbiB0byBjYWxsIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBsaW5lRGFzaFxuICAgICAqL1xuICAgIF9zZXRMaW5lRGFzaDogZnVuY3Rpb24oY3R4LCBkYXNoQXJyYXksIGFsdGVybmF0aXZlKSB7XG4gICAgICBpZiAoIWRhc2hBcnJheSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBTcGVjIHJlcXVpcmVzIHRoZSBjb25jYXRlbmF0aW9uIG9mIHR3byBjb3BpZXMgdGhlIGRhc2ggbGlzdCB3aGVuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaXMgb2RkXG4gICAgICBpZiAoMSAmIGRhc2hBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgZGFzaEFycmF5LnB1c2guYXBwbHkoZGFzaEFycmF5LCBkYXNoQXJyYXkpO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzTGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYWx0ZXJuYXRpdmUgJiYgYWx0ZXJuYXRpdmUoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjb250cm9scyBhbmQgYm9yZGVycyBmb3IgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT3ZlcnJpZGVdIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqL1xuICAgIF9yZW5kZXJDb250cm9sczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLFxuICAgICAgICAgIG1hdHJpeCA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgIG9wdGlvbnMsIGRyYXdCb3JkZXJzLCBkcmF3Q29udHJvbHM7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7IH07XG4gICAgICBkcmF3Qm9yZGVycyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLmhhc0JvcmRlcnMgIT09ICd1bmRlZmluZWQnID8gc3R5bGVPdmVycmlkZS5oYXNCb3JkZXJzIDogdGhpcy5oYXNCb3JkZXJzO1xuICAgICAgZHJhd0NvbnRyb2xzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgIT09ICd1bmRlZmluZWQnID8gc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyA6IHRoaXMuaGFzQ29udHJvbHM7XG4gICAgICBtYXRyaXggPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKHZwdCwgbWF0cml4KTtcbiAgICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZShtYXRyaXgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUob3B0aW9ucy50cmFuc2xhdGVYLCBvcHRpb25zLnRyYW5zbGF0ZVkpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDEgKiB0aGlzLmJvcmRlclNjYWxlRmFjdG9yO1xuICAgICAgaWYgKCF0aGlzLmdyb3VwKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuaXNNb3ZpbmcgPyB0aGlzLmJvcmRlck9wYWNpdHlXaGVuTW92aW5nIDogMTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZU92ZXJyaWRlLmZvckFjdGl2ZVNlbGVjdGlvbikge1xuICAgICAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnMob3B0aW9ucy5hbmdsZSkpO1xuICAgICAgICBkcmF3Qm9yZGVycyAmJiB0aGlzLmRyYXdCb3JkZXJzSW5Hcm91cChjdHgsIG9wdGlvbnMsIHN0eWxlT3ZlcnJpZGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eC5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICAgIGRyYXdCb3JkZXJzICYmIHRoaXMuZHJhd0JvcmRlcnMoY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGRyYXdDb250cm9scyAmJiB0aGlzLmRyYXdDb250cm9scyhjdHgsIHN0eWxlT3ZlcnJpZGUpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3NldFNoYWRvdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc2hhZG93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNoYWRvdyA9IHRoaXMuc2hhZG93LCBjYW52YXMgPSB0aGlzLmNhbnZhcyxcbiAgICAgICAgICBtdWx0WCA9IChjYW52YXMgJiYgY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtWzBdKSB8fCAxLFxuICAgICAgICAgIG11bHRZID0gKGNhbnZhcyAmJiBjYW52YXMudmlld3BvcnRUcmFuc2Zvcm1bM10pIHx8IDEsXG4gICAgICAgICAgc2NhbGluZyA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpO1xuICAgICAgaWYgKGNhbnZhcyAmJiBjYW52YXMuX2lzUmV0aW5hU2NhbGluZygpKSB7XG4gICAgICAgIG11bHRYICo9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBtdWx0WSAqPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIH1cbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvdy5jb2xvcjtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gc2hhZG93LmJsdXIgKiBmYWJyaWMuYnJvd3NlclNoYWRvd0JsdXJDb25zdGFudCAqXG4gICAgICAgIChtdWx0WCArIG11bHRZKSAqIChzY2FsaW5nLnNjYWxlWCArIHNjYWxpbmcuc2NhbGVZKSAvIDQ7XG4gICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHNoYWRvdy5vZmZzZXRYICogbXVsdFggKiBzY2FsaW5nLnNjYWxlWDtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gc2hhZG93Lm9mZnNldFkgKiBtdWx0WSAqIHNjYWxpbmcuc2NhbGVZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zaGFkb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSAnJztcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gY3R4LnNoYWRvd09mZnNldFggPSBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxsZXIgZmFicmljLlBhdHRlcm4gb3IgZmFicmljLkdyYWRpZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvZmZzZXQub2Zmc2V0WCBvZmZzZXQgZm9yIHRleHQgcmVuZGVyaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvZmZzZXQub2Zmc2V0WSBvZmZzZXQgZm9yIHRleHQgcmVuZGVyaW5nXG4gICAgICovXG4gICAgX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtOiBmdW5jdGlvbihjdHgsIGZpbGxlcikge1xuICAgICAgaWYgKCFmaWxsZXIgfHwgIWZpbGxlci50b0xpdmUpIHtcbiAgICAgICAgcmV0dXJuIHsgb2Zmc2V0WDogMCwgb2Zmc2V0WTogMCB9O1xuICAgICAgfVxuICAgICAgdmFyIHQgPSBmaWxsZXIuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgZmlsbGVyLnBhdHRlcm5UcmFuc2Zvcm07XG4gICAgICB2YXIgb2Zmc2V0WCA9IC10aGlzLndpZHRoIC8gMiArIGZpbGxlci5vZmZzZXRYIHx8IDAsXG4gICAgICAgICAgb2Zmc2V0WSA9IC10aGlzLmhlaWdodCAvIDIgKyBmaWxsZXIub2Zmc2V0WSB8fCAwO1xuICAgICAgY3R4LnRyYW5zbGF0ZShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0odFswXSwgdFsxXSwgdFsyXSwgdFszXSwgdFs0XSwgdFs1XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBvZmZzZXRYOiBvZmZzZXRYLCBvZmZzZXRZOiBvZmZzZXRZIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJQYWludEluT3JkZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCA9PT0gJ3N0cm9rZScpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlckZpbGwoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW5kZXJGaWxsKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclN0cm9rZShjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRmlsbDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuZmlsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShjdHgsIHRoaXMuZmlsbCk7XG4gICAgICBpZiAodGhpcy5maWxsUnVsZSA9PT0gJ2V2ZW5vZGQnKSB7XG4gICAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hhZG93ICYmICF0aGlzLnNoYWRvdy5hZmZlY3RTdHJva2UpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5LCB0aGlzLl9yZW5kZXJEYXNoZWRTdHJva2UpO1xuICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0oY3R4LCB0aGlzLnN0cm9rZSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgcmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBvYmplY3QgaW4gdGhlIHN2Z1xuICAgICAqIHVudHJhbnNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIHBvaW50IGZyb20gZWxlbWVudCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIF9maW5kQ2VudGVyRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgeDogdGhpcy5sZWZ0ICsgdGhpcy53aWR0aCAvIDIsIHk6IHRoaXMudG9wICsgdGhpcy5oZWlnaHQgLyAyIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYW4gaGVscGVyIGZvciBzdmcgaW1wb3J0LiBpdCBkZWNvbXBvc2UgdGhlIHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIGFuZCBhc3NpZ24gcHJvcGVydGllcyB0byBvYmplY3QuXG4gICAgICogdW50cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9hc3NpZ25UcmFuc2Zvcm1NYXRyaXhQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZSh0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgIHRoaXMuZmxpcFggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mbGlwWSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldCgnc2NhbGVYJywgb3B0aW9ucy5zY2FsZVgpO1xuICAgICAgICB0aGlzLnNldCgnc2NhbGVZJywgb3B0aW9ucy5zY2FsZVkpO1xuICAgICAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZTtcbiAgICAgICAgdGhpcy5za2V3WCA9IG9wdGlvbnMuc2tld1g7XG4gICAgICAgIHRoaXMuc2tld1kgPSAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgcmVtb3ZlcyB0aGUgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqIGFuZCBzZXQgdG8gb2JqZWN0IHByb3BlcnRpZXMgdGhhdCBmYWJyaWNqcyBjYW4gaGFuZGxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHt0aGlzQXJnfVxuICAgICAqL1xuICAgIF9yZW1vdmVUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5fZmluZENlbnRlckZyb21FbGVtZW50KCk7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdGhpcy5fYXNzaWduVHJhbnNmb3JtTWF0cml4UHJvcHMoKTtcbiAgICAgICAgY2VudGVyID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoY2VudGVyLCB0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG51bGw7XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zY2FsZVggKj0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuc2NhbGVYO1xuICAgICAgICB0aGlzLnNjYWxlWSAqPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5zY2FsZVk7XG4gICAgICAgIHRoaXMuY3JvcFggPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5jcm9wWDtcbiAgICAgICAgdGhpcy5jcm9wWSA9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLmNyb3BZO1xuICAgICAgICBjZW50ZXIueCArPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5vZmZzZXRMZWZ0O1xuICAgICAgICBjZW50ZXIueSArPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5vZmZzZXRUb3A7XG4gICAgICAgIHRoaXMud2lkdGggPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5oZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFBvc2l0aW9uQnlPcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgYW4gaW5zdGFuY2UsIHVzaW5nIGEgY2FsbGJhY2sgbWV0aG9kIHdpbGwgd29yayBmb3IgZXZlcnkgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGlzIGludm9rZWQgd2l0aCBhIGNsb25lIGFzIGEgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgb2JqZWN0Rm9ybSA9IHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5mcm9tT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZnJvbU9iamVjdChvYmplY3RGb3JtLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnT2JqZWN0Jywgb2JqZWN0Rm9ybSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBvdXQgb2YgYW4gb2JqZWN0XG4gICAgICogY291bGQgbWFrZSB1c2Ugb2YgYm90aCB0b0RhdGFVcmwgb3IgdG9DYW52YXNFbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrLCBpbnZva2VkIHdpdGggYW4gaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gZm9yIGNsb25lIGFzIGltYWdlLCBwYXNzZWQgdG8gdG9EYXRhVVJMXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZvcm1hdD1wbmddIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCBpbWFnZS4gRWl0aGVyIFwianBlZ1wiIG9yIFwicG5nXCJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucXVhbGl0eT0xXSBRdWFsaXR5IGxldmVsICgwLi4xKS4gT25seSB1c2VkIGZvciBqcGVnLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXBsaWVyPTFdIE11bHRpcGxpZXIgdG8gc2NhbGUgYnlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nXSBFbmFibGUgcmV0aW5hIHNjYWxpbmcgZm9yIGNsb25lIGltYWdlLiBJbnRyb2R1Y2UgaW4gMS42LjRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRUcmFuc2Zvcm1dIFJlbW92ZSBjdXJyZW50IG9iamVjdCB0cmFuc2Zvcm0gKCBubyBzY2FsZSAsIG5vIGFuZ2xlLCBubyBmbGlwLCBubyBza2V3ICkuIEludHJvZHVjZWQgaW4gMi4zLjRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRTaGFkb3ddIFJlbW92ZSBjdXJyZW50IG9iamVjdCBzaGFkb3cuIEludHJvZHVjZWQgaW4gMi40LjJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgY2xvbmVBc0ltYWdlOiBmdW5jdGlvbihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgdmFyIGNhbnZhc0VsID0gdGhpcy50b0NhbnZhc0VsZW1lbnQob3B0aW9ucyk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IGZhYnJpYy5JbWFnZShjYW52YXNFbCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgSFRNTENhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlwbGllcj0xXSBNdWx0aXBsaWVyIHRvIHNjYWxlIGJ5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxlZnRdIENyb3BwaW5nIGxlZnQgb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9wXSBDcm9wcGluZyB0b3Agb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGhdIENyb3BwaW5nIHdpZHRoLiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBDcm9wcGluZyBoZWlnaHQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZ10gRW5hYmxlIHJldGluYSBzY2FsaW5nIGZvciBjbG9uZSBpbWFnZS4gSW50cm9kdWNlIGluIDEuNi40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0VHJhbnNmb3JtXSBSZW1vdmUgY3VycmVudCBvYmplY3QgdHJhbnNmb3JtICggbm8gc2NhbGUgLCBubyBhbmdsZSwgbm8gZmxpcCwgbm8gc2tldyApLiBJbnRyb2R1Y2VkIGluIDIuMy40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0U2hhZG93XSBSZW1vdmUgY3VycmVudCBvYmplY3Qgc2hhZG93LiBJbnRyb2R1Y2VkIGluIDIuNC4yXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIGEgZGF0YTogVVJMIGNvbnRhaW5pbmcgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0IGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGJ5IG9wdGlvbnMuZm9ybWF0XG4gICAgICovXG4gICAgdG9DYW52YXNFbGVtZW50OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIHV0aWxzID0gZmFicmljLnV0aWwsIG9yaWdQYXJhbXMgPSB1dGlscy5zYXZlT2JqZWN0VHJhbnNmb3JtKHRoaXMpLFxuICAgICAgICAgIG9yaWdpbmFsU2hhZG93ID0gdGhpcy5zaGFkb3csIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgIG11bHRpcGxpZXIgPSAob3B0aW9ucy5tdWx0aXBsaWVyIHx8IDEpICogKG9wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZyA/IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvIDogMSk7XG5cbiAgICAgIGlmIChvcHRpb25zLndpdGhvdXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdXRpbHMucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy53aXRob3V0U2hhZG93KSB7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICAgIC8vIHNraXAgY2FudmFzIHpvb20gYW5kIGNhbGN1bGF0ZSB3aXRoIHNldENvb3JkcyBub3cuXG4gICAgICAgICAgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QodHJ1ZSwgdHJ1ZSksXG4gICAgICAgICAgc2hhZG93ID0gdGhpcy5zaGFkb3csIHNjYWxpbmcsXG4gICAgICAgICAgc2hhZG93T2Zmc2V0ID0geyB4OiAwLCB5OiAwIH0sIHNoYWRvd0JsdXI7XG5cbiAgICAgIGlmIChzaGFkb3cpIHtcbiAgICAgICAgc2hhZG93Qmx1ciA9IHNoYWRvdy5ibHVyO1xuICAgICAgICBzY2FsaW5nID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICAgIHNoYWRvd09mZnNldC54ID0gMiAqIE1hdGgucm91bmQoKGFicyhzaGFkb3cub2Zmc2V0WCkgKyBzaGFkb3dCbHVyKSAqIGFicyhzY2FsaW5nLnNjYWxlWCkpO1xuICAgICAgICBzaGFkb3dPZmZzZXQueSA9IDIgKiBNYXRoLnJvdW5kKChhYnMoc2hhZG93Lm9mZnNldFkpICsgc2hhZG93Qmx1cikgKiBhYnMoc2NhbGluZy5zY2FsZVkpKTtcbiAgICAgIH1cbiAgICAgIGVsLndpZHRoID0gYm91bmRpbmdSZWN0LndpZHRoICsgc2hhZG93T2Zmc2V0Lng7XG4gICAgICBlbC5oZWlnaHQgPSBib3VuZGluZ1JlY3QuaGVpZ2h0ICsgc2hhZG93T2Zmc2V0Lnk7XG4gICAgICBlbC53aWR0aCArPSBlbC53aWR0aCAlIDIgPyAyIC0gZWwud2lkdGggJSAyIDogMDtcbiAgICAgIGVsLmhlaWdodCArPSBlbC5oZWlnaHQgJSAyID8gMiAtIGVsLmhlaWdodCAlIDIgOiAwO1xuICAgICAgdmFyIGNhbnZhcyA9IG5ldyBmYWJyaWMuU3RhdGljQ2FudmFzKGVsLCB7XG4gICAgICAgIGVuYWJsZVJldGluYVNjYWxpbmc6IGZhbHNlLFxuICAgICAgICByZW5kZXJPbkFkZFJlbW92ZTogZmFsc2UsXG4gICAgICAgIHNraXBPZmZzY3JlZW46IGZhbHNlLFxuICAgICAgfSk7XG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdqcGVnJykge1xuICAgICAgICBjYW52YXMuYmFja2dyb3VuZENvbG9yID0gJyNmZmYnO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkJ5T3JpZ2luKG5ldyBmYWJyaWMuUG9pbnQoY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIpLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuXG4gICAgICB2YXIgb3JpZ2luYWxDYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIGNhbnZhcy5hZGQodGhpcyk7XG4gICAgICB2YXIgY2FudmFzRWwgPSBjYW52YXMudG9DYW52YXNFbGVtZW50KG11bHRpcGxpZXIgfHwgMSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNoYWRvdyA9IG9yaWdpbmFsU2hhZG93O1xuICAgICAgdGhpcy5jYW52YXMgPSBvcmlnaW5hbENhbnZhcztcbiAgICAgIHRoaXMuc2V0KG9yaWdQYXJhbXMpLnNldENvb3JkcygpO1xuICAgICAgLy8gY2FudmFzLmRpc3Bvc2Ugd2lsbCBjYWxsIGltYWdlLmRpc3Bvc2UgdGhhdCB3aWxsIG51bGxpZnkgdGhlIGVsZW1lbnRzXG4gICAgICAvLyBzaW5jZSB0aGlzIGNhbnZhcyBpcyBhIHNpbXBsZSBlbGVtZW50IGZvciB0aGUgcHJvY2Vzcywgd2UgcmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgIC8vIHRvIG9iamVjdHMgaW4gdGhpcyB3YXkgaW4gb3JkZXIgdG8gYXZvaWQgb2JqZWN0IHRyYXNoaW5nLlxuICAgICAgY2FudmFzLl9vYmplY3RzID0gW107XG4gICAgICBjYW52YXMuZGlzcG9zZSgpO1xuICAgICAgY2FudmFzID0gbnVsbDtcblxuICAgICAgcmV0dXJuIGNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIGRhdGEtdXJsLWxpa2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZm9ybWF0PXBuZ10gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0IGltYWdlLiBFaXRoZXIgXCJqcGVnXCIgb3IgXCJwbmdcIlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTFdIFF1YWxpdHkgbGV2ZWwgKDAuLjEpLiBPbmx5IHVzZWQgZm9yIGpwZWcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFRyYW5zZm9ybV0gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHRyYW5zZm9ybSAoIG5vIHNjYWxlICwgbm8gYW5nbGUsIG5vIGZsaXAsIG5vIHNrZXcgKS4gSW50cm9kdWNlZCBpbiAyLjMuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFNoYWRvd10gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHNoYWRvdy4gSW50cm9kdWNlZCBpbiAyLjQuMlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGRhdGE6IFVSTCBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBvcHRpb25zLmZvcm1hdFxuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudG9EYXRhVVJMKHRoaXMudG9DYW52YXNFbGVtZW50KG9wdGlvbnMpLCBvcHRpb25zLmZvcm1hdCB8fCAncG5nJywgb3B0aW9ucy5xdWFsaXR5IHx8IDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3BlY2lmaWVkIHR5cGUgaXMgaWRlbnRpY2FsIHRvIHRoZSB0eXBlIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1R5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlIChpcyAxIHVubGVzcyBzdWJjbGFzc2VkKVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gSlNPTlxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gZGVsZWdhdGUsIG5vdCBhbGlhc1xuICAgICAgcmV0dXJuIHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZ3JhZGllbnQgKGZpbGwgb3Igc3Ryb2tlKSBvZiBhbiBvYmplY3RcbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIG1ldGhvZCB3YXMgbmFtZWQgXCJzZXRHcmFkaWVudEZpbGxcIiB1bnRpbCB2MS4xLjBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSAnc3Ryb2tlJyBvciAnZmlsbCdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnR5cGVdIFR5cGUgb2YgZ3JhZGllbnQgJ3JhZGlhbCcgb3IgJ2xpbmVhcidcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMueDE9MF0geC1jb29yZGluYXRlIG9mIHN0YXJ0IHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnkxPTBdIHktY29vcmRpbmF0ZSBvZiBzdGFydCBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy54Mj0wXSB4LWNvb3JkaW5hdGUgb2YgZW5kIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnkyPTBdIHktY29vcmRpbmF0ZSBvZiBlbmQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucjE9MF0gUmFkaXVzIG9mIHN0YXJ0IHBvaW50IChvbmx5IGZvciByYWRpYWwgZ3JhZGllbnRzKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yMj0wXSBSYWRpdXMgb2YgZW5kIHBvaW50IChvbmx5IGZvciByYWRpYWwgZ3JhZGllbnRzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jb2xvclN0b3BzXSBDb2xvciBzdG9wcyBvYmplY3QgZWcuIHswOiAnZmYwMDAwJywgMTogJzAwMDAwMCd9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtXSB0cmFuc2Zvcm1NYXRyaXggZm9yIGdyYWRpZW50XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzLzU4eThiL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNldCBsaW5lYXIgZ3JhZGllbnQ8L2NhcHRpb24+XG4gICAgICogb2JqZWN0LnNldEdyYWRpZW50KCdmaWxsJywge1xuICAgICAqICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICogICB4MTogLW9iamVjdC53aWR0aCAvIDIsXG4gICAgICogICB5MTogMCxcbiAgICAgKiAgIHgyOiBvYmplY3Qud2lkdGggLyAyLFxuICAgICAqICAgeTI6IDAsXG4gICAgICogICBjb2xvclN0b3BzOiB7XG4gICAgICogICAgIDA6ICdyZWQnLFxuICAgICAqICAgICAwLjU6ICcjMDA1NTU1JyxcbiAgICAgKiAgICAgMTogJ3JnYmEoMCwwLDI1NSwwLjUpJ1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZXQgcmFkaWFsIGdyYWRpZW50PC9jYXB0aW9uPlxuICAgICAqIG9iamVjdC5zZXRHcmFkaWVudCgnZmlsbCcsIHtcbiAgICAgKiAgIHR5cGU6ICdyYWRpYWwnLFxuICAgICAqICAgeDE6IDAsXG4gICAgICogICB5MTogMCxcbiAgICAgKiAgIHgyOiAwLFxuICAgICAqICAgeTI6IDAsXG4gICAgICogICByMTogb2JqZWN0LndpZHRoIC8gMixcbiAgICAgKiAgIHIyOiAxMCxcbiAgICAgKiAgIGNvbG9yU3RvcHM6IHtcbiAgICAgKiAgICAgMDogJ3JlZCcsXG4gICAgICogICAgIDAuNTogJyMwMDU1NTUnLFxuICAgICAqICAgICAxOiAncmdiYSgwLDAsMjU1LDAuNSknXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgICAqL1xuICAgIHNldEdyYWRpZW50OiBmdW5jdGlvbihwcm9wZXJ0eSwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBncmFkaWVudCA9IHsgY29sb3JTdG9wczogW10gfTtcblxuICAgICAgZ3JhZGllbnQudHlwZSA9IG9wdGlvbnMudHlwZSB8fCAob3B0aW9ucy5yMSB8fCBvcHRpb25zLnIyID8gJ3JhZGlhbCcgOiAnbGluZWFyJyk7XG4gICAgICBncmFkaWVudC5jb29yZHMgPSB7XG4gICAgICAgIHgxOiBvcHRpb25zLngxLFxuICAgICAgICB5MTogb3B0aW9ucy55MSxcbiAgICAgICAgeDI6IG9wdGlvbnMueDIsXG4gICAgICAgIHkyOiBvcHRpb25zLnkyXG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucy5yMSB8fCBvcHRpb25zLnIyKSB7XG4gICAgICAgIGdyYWRpZW50LmNvb3Jkcy5yMSA9IG9wdGlvbnMucjE7XG4gICAgICAgIGdyYWRpZW50LmNvb3Jkcy5yMiA9IG9wdGlvbnMucjI7XG4gICAgICB9XG5cbiAgICAgIGdyYWRpZW50LmdyYWRpZW50VHJhbnNmb3JtID0gb3B0aW9ucy5ncmFkaWVudFRyYW5zZm9ybTtcbiAgICAgIGZhYnJpYy5HcmFkaWVudC5wcm90b3R5cGUuYWRkQ29sb3JTdG9wLmNhbGwoZ3JhZGllbnQsIG9wdGlvbnMuY29sb3JTdG9wcyk7XG5cbiAgICAgIHJldHVybiB0aGlzLnNldChwcm9wZXJ0eSwgZmFicmljLkdyYWRpZW50LmZvck9iamVjdCh0aGlzLCBncmFkaWVudCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHBhdHRlcm4gZmlsbCBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7KFN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50KX0gb3B0aW9ucy5zb3VyY2UgUGF0dGVybiBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVwZWF0PXJlcGVhdF0gUmVwZWF0IHByb3BlcnR5IG9mIGEgcGF0dGVybiAob25lIG9mIHJlcGVhdCwgcmVwZWF0LXgsIHJlcGVhdC15IG9yIG5vLXJlcGVhdClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WD0wXSBQYXR0ZXJuIGhvcml6b250YWwgb2Zmc2V0IGZyb20gb2JqZWN0J3MgbGVmdC90b3AgY29ybmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFk9MF0gUGF0dGVybiB2ZXJ0aWNhbCBvZmZzZXQgZnJvbSBvYmplY3QncyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIHNldCBhcyBhIHBhdHRlcm5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvUVQzcGEvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IHBhdHRlcm48L2NhcHRpb24+XG4gICAgICogb2JqZWN0LnNldFBhdHRlcm5GaWxsKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnLFxuICAgICAqICAgcmVwZWF0OiAncmVwZWF0J1xuICAgICAqIH0sY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqL1xuICAgIHNldFBhdHRlcm5GaWxsOiBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KCdmaWxsJywgbmV3IGZhYnJpYy5QYXR0ZXJuKG9wdGlvbnMsIGNhbGxiYWNrKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5PYmplY3Qjc2hhZG93fHNoYWRvd30gb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgb3Igc3RyaW5nIChlLmcuIFwiMnB4IDJweCAxMHB4IHJnYmEoMCwwLDAsMC4yKVwiKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb2xvcj1yZ2IoMCwwLDApXSBTaGFkb3cgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmx1cj0wXSBTaGFkb3cgYmx1clxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRYPTBdIFNoYWRvdyBob3Jpem9udGFsIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRZPTBdIFNoYWRvdyB2ZXJ0aWNhbCBvZmZzZXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvN2d2SkcvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IHNoYWRvdyB3aXRoIHN0cmluZyBub3RhdGlvbjwvY2FwdGlvbj5cbiAgICAgKiBvYmplY3Quc2V0U2hhZG93KCcycHggMnB4IDEwcHggcmdiYSgwLDAsMCwwLjIpJyk7XG4gICAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNldCBzaGFkb3cgd2l0aCBvYmplY3Qgbm90YXRpb248L2NhcHRpb24+XG4gICAgICogb2JqZWN0LnNldFNoYWRvdyh7XG4gICAgICogICBjb2xvcjogJ3JlZCcsXG4gICAgICogICBibHVyOiAxMCxcbiAgICAgKiAgIG9mZnNldFg6IDIwLFxuICAgICAqICAgb2Zmc2V0WTogMjBcbiAgICAgKiB9KTtcbiAgICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICovXG4gICAgc2V0U2hhZG93OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoJ3NoYWRvdycsIG9wdGlvbnMgPyBuZXcgZmFicmljLlNoYWRvdyhvcHRpb25zKSA6IG51bGwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIFwiY29sb3JcIiBvZiBhbiBpbnN0YW5jZSAoYWxpYXMgb2YgYHNldCgnZmlsbCcsICZoZWxsaXA7KWApXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgIHRoaXMuc2V0KCdmaWxsJywgY29sb3IpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgXCJhbmdsZVwiIG9mIGFuIGluc3RhbmNlIHdpdGggY2VudGVyZWQgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgQW5nbGUgdmFsdWUgKGluIGRlZ3JlZXMpXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICB2YXIgc2hvdWxkQ2VudGVyT3JpZ2luID0gKHRoaXMub3JpZ2luWCAhPT0gJ2NlbnRlcicgfHwgdGhpcy5vcmlnaW5ZICE9PSAnY2VudGVyJykgJiYgdGhpcy5jZW50ZXJlZFJvdGF0aW9uO1xuXG4gICAgICBpZiAoc2hvdWxkQ2VudGVyT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX3NldE9yaWdpblRvQ2VudGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KCdhbmdsZScsIGFuZ2xlKTtcblxuICAgICAgaWYgKHNob3VsZENlbnRlck9yaWdpbikge1xuICAgICAgICB0aGlzLl9yZXNldE9yaWdpbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IG9uIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVySDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY2VudGVyT2JqZWN0SCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVySDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3RIKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgb24gY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJWOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3RWKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyVjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3RWKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBvbiBjYW52YXMgdG8gd2hpY2ggaXMgd2FzIGFkZGVkIGxhc3RcbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3QodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3Qgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnRlciByZWxhdGl2ZSB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IHRvIG9wZXJhdGUgdXBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcG9pbnRlcl0gUG9pbnRlciB0byBvcGVyYXRlIHVwb24gKGluc3RlYWQgb2YgZXZlbnQpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiBhIHBvaW50ZXIgKHgsIHkpXG4gICAgICovXG4gICAgZ2V0TG9jYWxQb2ludGVyOiBmdW5jdGlvbihlLCBwb2ludGVyKSB7XG4gICAgICBwb2ludGVyID0gcG9pbnRlciB8fCB0aGlzLmNhbnZhcy5nZXRQb2ludGVyKGUpO1xuICAgICAgdmFyIHBDbGlja2VkID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSksXG4gICAgICAgICAgb2JqZWN0TGVmdFRvcCA9IHRoaXMuX2dldExlZnRUb3BDb29yZHMoKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHBDbGlja2VkID0gZmFicmljLnV0aWwucm90YXRlUG9pbnQoXG4gICAgICAgICAgcENsaWNrZWQsIG9iamVjdExlZnRUb3AsIGRlZ3JlZXNUb1JhZGlhbnMoLXRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBDbGlja2VkLnggLSBvYmplY3RMZWZ0VG9wLngsXG4gICAgICAgIHk6IHBDbGlja2VkLnkgLSBvYmplY3RMZWZ0VG9wLnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY2FudmFzIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBmb3Igc3BlY2lmaWMgb2JqZWN0XG4gICAgICogY3VzdG9tIGNvbXBvc2l0aW9uIG9wZXJhdGlvbiBmb3IgdGhlIHBhcnRpY3VsYXIgb2JqZWN0IGNhbiBiZSBzcGVjaWZpZWQgdXNpbmcgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBSZW5kZXJpbmcgY2FudmFzIGNvbnRleHRcbiAgICAgKi9cbiAgICBfc2V0dXBDb21wb3NpdGVPcGVyYXRpb246IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIGlmICh0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbikge1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMgJiYgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzKGZhYnJpYy5PYmplY3QpO1xuXG4gIGV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgZmFicmljLk9ic2VydmFibGUpO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBudW1iZXIgb2YgZnJhY3Rpb24gZGlnaXRzIHRvIHVzZSB3aGVuIHNlcmlhbGl6aW5nIG9iamVjdCB2YWx1ZXMuXG4gICAqIFlvdSBjYW4gdXNlIGl0IHRvIGluY3JlYXNlL2RlY3JlYXNlIHByZWNpc2lvbiBvZiBzdWNoIHZhbHVlcyBsaWtlIGxlZnQsIHRvcCwgc2NhbGVYLCBzY2FsZVksIGV0Yy5cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMgPSAyO1xuXG4gIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QgPSBmdW5jdGlvbihjbGFzc05hbWUsIG9iamVjdCwgY2FsbGJhY2ssIGV4dHJhUGFyYW0pIHtcbiAgICB2YXIga2xhc3MgPSBmYWJyaWNbY2xhc3NOYW1lXTtcbiAgICBvYmplY3QgPSBjbG9uZShvYmplY3QsIHRydWUpO1xuICAgIGZhYnJpYy51dGlsLmVubGl2ZW5QYXR0ZXJucyhbb2JqZWN0LmZpbGwsIG9iamVjdC5zdHJva2VdLCBmdW5jdGlvbihwYXR0ZXJucykge1xuICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuc1swXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb2JqZWN0LmZpbGwgPSBwYXR0ZXJuc1swXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybnNbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5zdHJva2UgPSBwYXR0ZXJuc1sxXTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKFtvYmplY3QuY2xpcFBhdGhdLCBmdW5jdGlvbihlbmxpdmVkUHJvcHMpIHtcbiAgICAgICAgb2JqZWN0LmNsaXBQYXRoID0gZW5saXZlZFByb3BzWzBdO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBleHRyYVBhcmFtID8gbmV3IGtsYXNzKG9iamVjdFtleHRyYVBhcmFtXSwgb2JqZWN0KSA6IG5ldyBrbGFzcyhvYmplY3QpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVW5pcXVlIGlkIHVzZWQgaW50ZXJuYWxseSB3aGVuIGNyZWF0aW5nIFNWRyBlbGVtZW50c1xuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0XG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgZmFicmljLk9iamVjdC5fX3VpZCA9IDA7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgb3JpZ2luWE9mZnNldCA9IHtcbiAgICAgICAgbGVmdDogLTAuNSxcbiAgICAgICAgY2VudGVyOiAwLFxuICAgICAgICByaWdodDogMC41XG4gICAgICB9LFxuICAgICAgb3JpZ2luWU9mZnNldCA9IHtcbiAgICAgICAgdG9wOiAtMC41LFxuICAgICAgICBjZW50ZXI6IDAsXG4gICAgICAgIGJvdHRvbTogMC41XG4gICAgICB9O1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgY29vcmRpbmF0ZXMgZnJvbSBhIHNldCBvZiBvcmlnaW4gdG8gYW5vdGhlciAoYmFzZWQgb24gdGhlIG9iamVjdCdzIGRpbWVuc2lvbnMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbU9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tT3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b09yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b09yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdHJhbnNsYXRlVG9HaXZlbk9yaWdpbjogZnVuY3Rpb24ocG9pbnQsIGZyb21PcmlnaW5YLCBmcm9tT3JpZ2luWSwgdG9PcmlnaW5YLCB0b09yaWdpblkpIHtcbiAgICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgICBvZmZzZXRYLCBvZmZzZXRZLCBkaW07XG5cbiAgICAgIGlmICh0eXBlb2YgZnJvbU9yaWdpblggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZyb21PcmlnaW5YID0gb3JpZ2luWE9mZnNldFtmcm9tT3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZnJvbU9yaWdpblggLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRvT3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9PcmlnaW5YID0gb3JpZ2luWE9mZnNldFt0b09yaWdpblhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRvT3JpZ2luWCAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldFggPSB0b09yaWdpblggLSBmcm9tT3JpZ2luWDtcblxuICAgICAgaWYgKHR5cGVvZiBmcm9tT3JpZ2luWSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJvbU9yaWdpblkgPSBvcmlnaW5ZT2Zmc2V0W2Zyb21PcmlnaW5ZXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmcm9tT3JpZ2luWSAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdG9PcmlnaW5ZID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b09yaWdpblkgPSBvcmlnaW5ZT2Zmc2V0W3RvT3JpZ2luWV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9PcmlnaW5ZIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0WSA9IHRvT3JpZ2luWSAtIGZyb21PcmlnaW5ZO1xuXG4gICAgICBpZiAob2Zmc2V0WCB8fCBvZmZzZXRZKSB7XG4gICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgICB4ID0gcG9pbnQueCArIG9mZnNldFggKiBkaW0ueDtcbiAgICAgICAgeSA9IHBvaW50LnkgKyBvZmZzZXRZICogZGltLnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIG9yaWdpbiB0byBjZW50ZXIgY29vcmRpbmF0ZXMgKGJhc2VkIG9uIHRoZSBvYmplY3QncyBkaW1lbnNpb25zKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIG9yaWdpblggYW5kIG9yaWdpblkgcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgcCA9IHRoaXMudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwLCBwb2ludCwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgY29vcmRpbmF0ZXMgZnJvbSBjZW50ZXIgdG8gb3JpZ2luIGNvb3JkaW5hdGVzIChiYXNlZCBvbiB0aGUgb2JqZWN0J3MgZGltZW5zaW9ucylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gY2VudGVyIFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byBjZW50ZXIgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVUb09yaWdpblBvaW50OiBmdW5jdGlvbihjZW50ZXIsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwLCBjZW50ZXIsIGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlYWwgY2VudGVyIGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlZnRUb3AgPSBuZXcgZmFicmljLlBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9DZW50ZXJQb2ludChsZWZ0VG9wLCB0aGlzLm9yaWdpblgsIHRoaXMub3JpZ2luWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gY2VudGVyIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgLy8gZ2V0T3JpZ2luUG9pbnQ6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgIC8vICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICAvLyB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBhcyBpZiBpdCBoYXMgYSBkaWZmZXJlbnQgb3JpZ2luXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGdldFBvaW50QnlPcmlnaW46IGZ1bmN0aW9uKG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgb3JpZ2luWCwgb3JpZ2luWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGluIGxvY2FsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgZ2xvYmFsIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRvTG9jYWxQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgcCwgcDI7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luWCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9yaWdpblkgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwID0gbmV3IGZhYnJpYy5Qb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbiAgICAgIH1cblxuICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcDIgPSBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwMiwgY2VudGVyLCAtZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDIuc3VidHJhY3RFcXVhbHMocCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGluIGdsb2JhbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIC8vIHRvR2xvYmFsUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgLy8gICByZXR1cm4gZmFicmljLnV0aWwucm90YXRlUG9pbnQocG9pbnQsIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSkuYWRkRXF1YWxzKG5ldyBmYWJyaWMuUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCkpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0IHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIG9iamVjdCdzIG9yaWdpblxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb3MgVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbkJ5T3JpZ2luOiBmdW5jdGlvbihwb3MsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLnRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQocG9zLCBvcmlnaW5YLCBvcmlnaW5ZKSxcbiAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICAgIHRoaXMuc2V0KCdsZWZ0JywgcG9zaXRpb24ueCk7XG4gICAgICB0aGlzLnNldCgndG9wJywgcG9zaXRpb24ueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0byBPbmUgb2YgJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J1xuICAgICAqL1xuICAgIGFkanVzdFBvc2l0aW9uOiBmdW5jdGlvbih0bykge1xuICAgICAgdmFyIGFuZ2xlID0gZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSxcbiAgICAgICAgICBoeXBvdEZ1bGwgPSB0aGlzLmdldFNjYWxlZFdpZHRoKCksXG4gICAgICAgICAgeEZ1bGwgPSBmYWJyaWMudXRpbC5jb3MoYW5nbGUpICogaHlwb3RGdWxsLFxuICAgICAgICAgIHlGdWxsID0gZmFicmljLnV0aWwuc2luKGFuZ2xlKSAqIGh5cG90RnVsbCxcbiAgICAgICAgICBvZmZzZXRGcm9tLCBvZmZzZXRUbztcblxuICAgICAgLy9UT0RPOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNvbnNpZGVyIG1peGVkIHNpdHVhdGlvbiBsaWtlIHRvcCwgY2VudGVyLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9yaWdpblggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9mZnNldEZyb20gPSBvcmlnaW5YT2Zmc2V0W3RoaXMub3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0RnJvbSA9IHRoaXMub3JpZ2luWCAtIDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9mZnNldFRvID0gb3JpZ2luWE9mZnNldFt0b107XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0VG8gPSB0byAtIDAuNTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGVmdCArPSB4RnVsbCAqIChvZmZzZXRUbyAtIG9mZnNldEZyb20pO1xuICAgICAgdGhpcy50b3AgKz0geUZ1bGwgKiAob2Zmc2V0VG8gLSBvZmZzZXRGcm9tKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLm9yaWdpblggPSB0bztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3JpZ2luL3Bvc2l0aW9uIG9mIHRoZSBvYmplY3QgdG8gaXQncyBjZW50ZXIgcG9pbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX3NldE9yaWdpblRvQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWCA9IHRoaXMub3JpZ2luWDtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSA9IHRoaXMub3JpZ2luWTtcblxuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcblxuICAgICAgdGhpcy5vcmlnaW5YID0gJ2NlbnRlcic7XG4gICAgICB0aGlzLm9yaWdpblkgPSAnY2VudGVyJztcblxuICAgICAgdGhpcy5sZWZ0ID0gY2VudGVyLng7XG4gICAgICB0aGlzLnRvcCA9IGNlbnRlci55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIG9yaWdpbi9wb3NpdGlvbiBvZiB0aGUgb2JqZWN0IHRvIGl0J3Mgb3JpZ2luYWwgb3JpZ2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIF9yZXNldE9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3JpZ2luUG9pbnQgPSB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoXG4gICAgICAgIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblkpO1xuXG4gICAgICB0aGlzLm9yaWdpblggPSB0aGlzLl9vcmlnaW5hbE9yaWdpblg7XG4gICAgICB0aGlzLm9yaWdpblkgPSB0aGlzLl9vcmlnaW5hbE9yaWdpblk7XG5cbiAgICAgIHRoaXMubGVmdCA9IG9yaWdpblBvaW50Lng7XG4gICAgICB0aGlzLnRvcCA9IG9yaWdpblBvaW50Lnk7XG5cbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWCA9IG51bGw7XG4gICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblkgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMZWZ0VG9wQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGhpcy5nZXRDZW50ZXJQb2ludCgpLCAnbGVmdCcsICd0b3AnKTtcbiAgICB9LFxuICB9KTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gZ2V0Q29vcmRzKGNvb3Jkcykge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy50bC54LCBjb29yZHMudGwueSksXG4gICAgICBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy50ci54LCBjb29yZHMudHIueSksXG4gICAgICBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy5ici54LCBjb29yZHMuYnIueSksXG4gICAgICBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy5ibC54LCBjb29yZHMuYmwueSlcbiAgICBdO1xuICB9XG5cbiAgdmFyIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgbXVsdGlwbHlNYXRyaWNlcyA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMsXG4gICAgICB0cmFuc2Zvcm1Qb2ludCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50O1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgb2JqZWN0J3MgY29ybmVyIHBvc2l0aW9uIGluIGNhbnZhcyBlbGVtZW50IGNvb3JkaW5hdGVzLlxuICAgICAqIHByb3BlcnRpZXMgYXJlIHRsLG10LHRyLG1sLG1yLGJsLG1iLGJyLG10ciBmb3IgdGhlIG1haW4gY29udHJvbHMuXG4gICAgICogZWFjaCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qgd2l0aCB4LCB5IGFuZCBjb3JuZXIuXG4gICAgICogVGhlIGBjb3JuZXJgIHByb3BlcnR5IGNvbnRhaW5zIGluIGEgc2ltaWxhciBtYW5uZXIgdGhlIDQgcG9pbnRzIG9mIHRoZVxuICAgICAqIGludGVyYWN0aXZlIGFyZWEgb2YgdGhlIGNvcm5lci5cbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZGVwZW5kcyBmcm9tIHRoaXMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodCwgc2NhbGVYLCBzY2FsZVlcbiAgICAgKiBza2V3WCwgc2tld1ksIGFuZ2xlLCBzdHJva2VXaWR0aCwgdmlld3BvcnRUcmFuc2Zvcm0sIHRvcCwgbGVmdCwgcGFkZGluZy5cbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZ2V0IHVwZGF0ZWQgd2l0aCBAbWV0aG9kIHNldENvb3Jkcy5cbiAgICAgKiBZb3UgY2FuIGNhbGN1bGF0ZSB0aGVtIHdpdGhvdXQgdXBkYXRpbmcgd2l0aCBAbWV0aG9kIGNhbGNDb29yZHM7XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICovXG4gICAgb0Nvb3JkczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIG9iamVjdCdzIGNvcm5lciBwb3NpdGlvbiBpbiBjYW52YXMgb2JqZWN0IGFic29sdXRlIGNvb3JkaW5hdGVzXG4gICAgICogcHJvcGVydGllcyBhcmUgdGwsdHIsYmwsYnIgYW5kIGRlc2NyaWJlIHRoZSBmb3VyIG1haW4gY29ybmVyLlxuICAgICAqIGVhY2ggcHJvcGVydHkgaXMgYW4gb2JqZWN0IHdpdGggeCwgeSwgaW5zdGFuY2Ugb2YgRmFicmljLlBvaW50LlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBkZXBlbmRzIGZyb20gdGhpcyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0LCBzY2FsZVgsIHNjYWxlWVxuICAgICAqIHNrZXdYLCBza2V3WSwgYW5nbGUsIHN0cm9rZVdpZHRoLCB0b3AsIGxlZnQuXG4gICAgICogVGhvc2UgY29vcmRpbmF0ZXMgYXJlIHVzZWZ1bGwgdG8gdW5kZXJzdGFuZCB3aGVyZSBhbiBvYmplY3QgaXMuIFRoZXkgZ2V0IHVwZGF0ZWRcbiAgICAgKiB3aXRoIG9Db29yZHMgYnV0IHRoZXkgZG8gbm90IG5lZWQgdG8gYmUgdXBkYXRlZCB3aGVuIHpvb20gb3IgcGFubmluZyBjaGFuZ2UuXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGdldCB1cGRhdGVkIHdpdGggQG1ldGhvZCBzZXRDb29yZHMuXG4gICAgICogWW91IGNhbiBjYWxjdWxhdGUgdGhlbSB3aXRob3V0IHVwZGF0aW5nIHdpdGggQG1ldGhvZCBjYWxjQ29vcmRzKHRydWUpO1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFDb29yZHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBzdG9yYWdlIGZvciBvYmplY3QgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIG93bk1hdHJpeENhY2hlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogc3RvcmFnZSBmb3Igb2JqZWN0IGZ1bGwgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIG1hdHJpeENhY2hlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGNvcnJlY3Qgc2V0IG9mIGNvb3JkaW5hdGVzIGZvciBpbnRlcnNlY3Rpb25cbiAgICAgKi9cbiAgICBnZXRDb29yZHM6IGZ1bmN0aW9uKGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIGlmICghdGhpcy5vQ29vcmRzKSB7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICB2YXIgY29vcmRzID0gYWJzb2x1dGUgPyB0aGlzLmFDb29yZHMgOiB0aGlzLm9Db29yZHM7XG4gICAgICByZXR1cm4gZ2V0Q29vcmRzKGNhbGN1bGF0ZSA/IHRoaXMuY2FsY0Nvb3JkcyhhYnNvbHV0ZSkgOiBjb29yZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFRMIHRvcC1sZWZ0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRCUiBib3R0b20tcmlnaHQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqL1xuICAgIGludGVyc2VjdHNXaXRoUmVjdDogZnVuY3Rpb24ocG9pbnRUTCwgcG9pbnRCUiwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpLFxuICAgICAgICAgIGludGVyc2VjdGlvbiA9IGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblJlY3RhbmdsZShcbiAgICAgICAgICAgIGNvb3JkcyxcbiAgICAgICAgICAgIHBvaW50VEwsXG4gICAgICAgICAgICBwb2ludEJSXG4gICAgICAgICAgKTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24uc3RhdHVzID09PSAnSW50ZXJzZWN0aW9uJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgT2JqZWN0IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBvYmplY3RcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzV2l0aE9iamVjdDogZnVuY3Rpb24ob3RoZXIsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25Qb2x5Z29uKFxuICAgICAgICB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgb3RoZXIuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9uLnN0YXR1cyA9PT0gJ0ludGVyc2VjdGlvbidcbiAgICAgICAgfHwgb3RoZXIuaXNDb250YWluZWRXaXRoaW5PYmplY3QodGhpcywgYWJzb2x1dGUsIGNhbGN1bGF0ZSlcbiAgICAgICAgfHwgdGhpcy5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvdGhlciwgYWJzb2x1dGUsIGNhbGN1bGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIE9iamVjdCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICovXG4gICAgaXNDb250YWluZWRXaXRoaW5PYmplY3Q6IGZ1bmN0aW9uKG90aGVyLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSksXG4gICAgICAgICAgaSA9IDAsIGxpbmVzID0gb3RoZXIuX2dldEltYWdlTGluZXMoXG4gICAgICAgICAgICBjYWxjdWxhdGUgPyBvdGhlci5jYWxjQ29vcmRzKGFic29sdXRlKSA6IGFic29sdXRlID8gb3RoZXIuYUNvb3JkcyA6IG90aGVyLm9Db29yZHNcbiAgICAgICAgICApO1xuICAgICAgZm9yICg7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgaWYgKCFvdGhlci5jb250YWluc1BvaW50KHBvaW50c1tpXSwgbGluZXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50VEwgdG9wLWxlZnQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludEJSIGJvdHRvbS1yaWdodCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqL1xuICAgIGlzQ29udGFpbmVkV2l0aGluUmVjdDogZnVuY3Rpb24ocG9pbnRUTCwgcG9pbnRCUiwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KGFic29sdXRlLCBjYWxjdWxhdGUpO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBib3VuZGluZ1JlY3QubGVmdCA+PSBwb2ludFRMLnggJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LmxlZnQgKyBib3VuZGluZ1JlY3Qud2lkdGggPD0gcG9pbnRCUi54ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC50b3AgPj0gcG9pbnRUTC55ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC50b3AgKyBib3VuZGluZ1JlY3QuaGVpZ2h0IDw9IHBvaW50QlIueVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFBvaW50IHRvIGNoZWNrIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2xpbmVzXSBvYmplY3QgcmV0dXJuZWQgZnJvbSBAbWV0aG9kIF9nZXRJbWFnZUxpbmVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb2ludCBpcyBpbnNpZGUgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBsaW5lcywgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGxpbmVzID0gbGluZXMgfHwgdGhpcy5fZ2V0SW1hZ2VMaW5lcyhcbiAgICAgICAgICAgIGNhbGN1bGF0ZSA/IHRoaXMuY2FsY0Nvb3JkcyhhYnNvbHV0ZSkgOiBhYnNvbHV0ZSA/IHRoaXMuYUNvb3JkcyA6IHRoaXMub0Nvb3Jkc1xuICAgICAgICAgICksXG4gICAgICAgICAgeFBvaW50cyA9IHRoaXMuX2ZpbmRDcm9zc1BvaW50cyhwb2ludCwgbGluZXMpO1xuXG4gICAgICAvLyBpZiB4UG9pbnRzIGlzIG9kZCB0aGVuIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICByZXR1cm4gKHhQb2ludHMgIT09IDAgJiYgeFBvaW50cyAlIDIgPT09IDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGNhbnZhcyB3aXRoIGN1cnJlbnQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiB0aGUgY2hlY2sgaXMgZG9uZSBzdG9wcGluZyBhdCBmaXJzdCBwb2ludCB0aGF0IGFwcGVhcnMgb24gc2NyZWVuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5hQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgb3IgcGFydGlhbGx5IGNvbnRhaW5lZCB3aXRoaW4gY2FudmFzXG4gICAgICovXG4gICAgaXNPblNjcmVlbjogZnVuY3Rpb24oY2FsY3VsYXRlKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludFRMID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLnRsLCBwb2ludEJSID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLmJyO1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0Q29vcmRzKHRydWUsIGNhbGN1bGF0ZSksIHBvaW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIGlmIChwb2ludC54IDw9IHBvaW50QlIueCAmJiBwb2ludC54ID49IHBvaW50VEwueCAmJiBwb2ludC55IDw9IHBvaW50QlIueSAmJiBwb2ludC55ID49IHBvaW50VEwueSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBubyBwb2ludHMgb24gc2NyZWVuLCBjaGVjayBpbnRlcnNlY3Rpb24gd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlc1xuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1dpdGhSZWN0KHBvaW50VEwsIHBvaW50QlIsIHRydWUsIGNhbGN1bGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbnNDZW50ZXJPZkNhbnZhcyhwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG9iamVjdCBjb250YWlucyB0aGUgbWlkcG9pbnQgYmV0d2VlbiBjYW52YXMgZXh0cmVtaXRpZXNcbiAgICAgKiBEb2VzIG5vdCBtYWtlIHNlbnNlIG91dHNpZGUgdGhlIGNvbnRleHQgb2YgaXNPblNjcmVlbiBhbmQgaXNQYXJ0aWFsbHlPblNjcmVlblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGYWJyaWMuUG9pbnR9IHBvaW50VEwgVG9wIExlZnQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5Qb2ludH0gcG9pbnRCUiBUb3AgUmlnaHQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbGN1bGF0ZSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0cyBjb250YWluZSB0aGUgcG9pbnRcbiAgICAgKi9cbiAgICBfY29udGFpbnNDZW50ZXJPZkNhbnZhczogZnVuY3Rpb24ocG9pbnRUTCwgcG9pbnRCUiwgY2FsY3VsYXRlKSB7XG4gICAgICAvLyB3b3JzdCBjYXNlIHNjZW5hcmlvIHRoZSBvYmplY3QgaXMgc28gYmlnIHRoYXQgY29udGFpbnMgdGhlIHNjcmVlblxuICAgICAgdmFyIGNlbnRlclBvaW50ID0geyB4OiAocG9pbnRUTC54ICsgcG9pbnRCUi54KSAvIDIsIHk6IChwb2ludFRMLnkgKyBwb2ludEJSLnkpIC8gMiB9O1xuICAgICAgaWYgKHRoaXMuY29udGFpbnNQb2ludChjZW50ZXJQb2ludCwgbnVsbCwgdHJ1ZSwgY2FsY3VsYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBwYXJ0aWFsbHkgY29udGFpbmVkIHdpdGhpbiB0aGUgY2FudmFzIHdpdGggY3VycmVudCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGlzIHBhcnRpYWxseSBjb250YWluZWQgd2l0aGluIGNhbnZhc1xuICAgICAqL1xuICAgIGlzUGFydGlhbGx5T25TY3JlZW46IGZ1bmN0aW9uKGNhbGN1bGF0ZSkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRUTCA9IHRoaXMuY2FudmFzLnZwdENvb3Jkcy50bCwgcG9pbnRCUiA9IHRoaXMuY2FudmFzLnZwdENvb3Jkcy5icjtcbiAgICAgIGlmICh0aGlzLmludGVyc2VjdHNXaXRoUmVjdChwb2ludFRMLCBwb2ludEJSLCB0cnVlLCBjYWxjdWxhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5zQ2VudGVyT2ZDYW52YXMocG9pbnRUTCwgcG9pbnRCUiwgY2FsY3VsYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0IGVkZ2VzIGluIGl0LCBnaXZlbiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNvcm5lcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvQ29vcmRzIENvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgY29ybmVyc1xuICAgICAqL1xuICAgIF9nZXRJbWFnZUxpbmVzOiBmdW5jdGlvbihvQ29vcmRzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3BsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy50bCxcbiAgICAgICAgICBkOiBvQ29vcmRzLnRyXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0bGluZToge1xuICAgICAgICAgIG86IG9Db29yZHMudHIsXG4gICAgICAgICAgZDogb0Nvb3Jkcy5iclxuICAgICAgICB9LFxuICAgICAgICBib3R0b21saW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy5icixcbiAgICAgICAgICBkOiBvQ29vcmRzLmJsXG4gICAgICAgIH0sXG4gICAgICAgIGxlZnRsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy5ibCxcbiAgICAgICAgICBkOiBvQ29vcmRzLnRsXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gZGV0ZXJtaW5lIGhvdyBtYW55IGNyb3NzIHBvaW50cyBhcmUgYmV0d2VlbiB0aGUgNCBvYmplY3QgZWRnZXNcbiAgICAgKiBhbmQgdGhlIGhvcml6b250YWwgbGluZSBkZXRlcm1pbmVkIGJ5IGEgcG9pbnQgb24gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgUG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGluZXMgQ29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBiZWluZyBldmFsdWF0ZWRcbiAgICAgKi9cbiAgICAvLyByZW1vdmUgeWksIG5vdCB1c2VkIGJ1dCBsZWZ0IGNvZGUgaGVyZSBqdXN0IGluIGNhc2UuXG4gICAgX2ZpbmRDcm9zc1BvaW50czogZnVuY3Rpb24ocG9pbnQsIGxpbmVzKSB7XG4gICAgICB2YXIgYjEsIGIyLCBhMSwgYTIsIHhpLCAvLyB5aSxcbiAgICAgICAgICB4Y291bnQgPSAwLFxuICAgICAgICAgIGlMaW5lO1xuXG4gICAgICBmb3IgKHZhciBsaW5lS2V5IGluIGxpbmVzKSB7XG4gICAgICAgIGlMaW5lID0gbGluZXNbbGluZUtleV07XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiAxOiBsaW5lIGJlbG93IHBvaW50LiBubyBjcm9zc1xuICAgICAgICBpZiAoKGlMaW5lLm8ueSA8IHBvaW50LnkpICYmIChpTGluZS5kLnkgPCBwb2ludC55KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiAyOiBsaW5lIGFib3ZlIHBvaW50LiBubyBjcm9zc1xuICAgICAgICBpZiAoKGlMaW5lLm8ueSA+PSBwb2ludC55KSAmJiAoaUxpbmUuZC55ID49IHBvaW50LnkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDM6IHZlcnRpY2FsIGxpbmUgY2FzZVxuICAgICAgICBpZiAoKGlMaW5lLm8ueCA9PT0gaUxpbmUuZC54KSAmJiAoaUxpbmUuby54ID49IHBvaW50LngpKSB7XG4gICAgICAgICAgeGkgPSBpTGluZS5vLng7XG4gICAgICAgICAgLy8geWkgPSBwb2ludC55O1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGIxID0gMDtcbiAgICAgICAgICBiMiA9IChpTGluZS5kLnkgLSBpTGluZS5vLnkpIC8gKGlMaW5lLmQueCAtIGlMaW5lLm8ueCk7XG4gICAgICAgICAgYTEgPSBwb2ludC55IC0gYjEgKiBwb2ludC54O1xuICAgICAgICAgIGEyID0gaUxpbmUuby55IC0gYjIgKiBpTGluZS5vLng7XG5cbiAgICAgICAgICB4aSA9IC0oYTEgLSBhMikgLyAoYjEgLSBiMik7XG4gICAgICAgICAgLy8geWkgPSBhMSArIGIxICogeGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9udCBjb3VudCB4aSA8IHBvaW50LnggY2FzZXNcbiAgICAgICAgaWYgKHhpID49IHBvaW50LngpIHtcbiAgICAgICAgICB4Y291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpbWlzYXRpb24gNDogc3BlY2lmaWMgZm9yIHNxdWFyZSBpbWFnZXNcbiAgICAgICAgaWYgKHhjb3VudCA9PT0gMikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSAobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAqIHRoZSBib3ggaXMgaW50ZW50ZWQgYXMgYWxpZ25lZCB0byBheGlzIG9mIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHMgLyAuYUNvb3Jkc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uKGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5tYWtlQm91bmRpbmdCb3hGcm9tUG9pbnRzKGNvb3Jkcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2lkdGggb2YgYW4gb2JqZWN0IGJvdW5kaW5nIGJveCBjb3VudGluZyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBiZWZvcmUgMi4wIGl0IHdhcyBuYW1lZCBnZXRXaWR0aCgpO1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gd2lkdGggdmFsdWVcbiAgICAgKi9cbiAgICBnZXRTY2FsZWRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBoZWlnaHQgb2YgYW4gb2JqZWN0IGJvdW5kaW5nIGJveCBjb3VudGluZyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBiZWZvcmUgMi4wIGl0IHdhcyBuYW1lZCBnZXRIZWlnaHQoKTtcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGhlaWdodCB2YWx1ZVxuICAgICAqL1xuICAgIGdldFNjYWxlZEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgc3VyZSB0aGUgc2NhbGUgaXMgdmFsaWQgYW5kIG1vZGlmaWVzIGl0IGlmIG5lY2Vzc2FyeVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIF9jb25zdHJhaW5TY2FsZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSkgPCB0aGlzLm1pblNjYWxlTGltaXQpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgIHJldHVybiAtdGhpcy5taW5TY2FsZUxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1pblNjYWxlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwLjAwMDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBhbiBvYmplY3QgKGVxdWFsbHkgYnkgeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgU2NhbGUgZmFjdG9yXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldCgnc2NhbGVYJywgdmFsdWUpO1xuICAgICAgdGhpcy5fc2V0KCdzY2FsZVknLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCB0byBhIGdpdmVuIHdpZHRoLCB3aXRoIHJlc3BlY3QgdG8gYm91bmRpbmcgYm94IChzY2FsaW5nIGJ5IHgveSBlcXVhbGx5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBOZXcgd2lkdGggdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFic29sdXRlIGlnbm9yZSB2aWV3cG9ydFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGVUb1dpZHRoOiBmdW5jdGlvbih2YWx1ZSwgYWJzb2x1dGUpIHtcbiAgICAgIC8vIGFkanVzdCB0byBib3VuZGluZyByZWN0IGZhY3RvciBzbyB0aGF0IHJvdGF0ZWQgc2hhcGVzIHdvdWxkIGZpdCBhcyB3ZWxsXG4gICAgICB2YXIgYm91bmRpbmdSZWN0RmFjdG9yID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoYWJzb2x1dGUpLndpZHRoIC8gdGhpcy5nZXRTY2FsZWRXaWR0aCgpO1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWUgLyB0aGlzLndpZHRoIC8gYm91bmRpbmdSZWN0RmFjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCB0byBhIGdpdmVuIGhlaWdodCwgd2l0aCByZXNwZWN0IHRvIGJvdW5kaW5nIGJveCAoc2NhbGluZyBieSB4L3kgZXF1YWxseSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgTmV3IGhlaWdodCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJzb2x1dGUgaWdub3JlIHZpZXdwb3J0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZVRvSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSwgYWJzb2x1dGUpIHtcbiAgICAgIC8vIGFkanVzdCB0byBib3VuZGluZyByZWN0IGZhY3RvciBzbyB0aGF0IHJvdGF0ZWQgc2hhcGVzIHdvdWxkIGZpdCBhcyB3ZWxsXG4gICAgICB2YXIgYm91bmRpbmdSZWN0RmFjdG9yID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoYWJzb2x1dGUpLmhlaWdodCAvIHRoaXMuZ2V0U2NhbGVkSGVpZ2h0KCk7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSAvIHRoaXMuaGVpZ2h0IC8gYm91bmRpbmdSZWN0RmFjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGFuZCByZXR1cm5zIHRoZSAuY29vcmRzIG9mIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIHRsLCB0ciwgYnIsIGJsIC4uLi5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2FsY0Nvb3JkczogZnVuY3Rpb24oYWJzb2x1dGUpIHtcbiAgICAgIHZhciByb3RhdGVNYXRyaXggPSB0aGlzLl9jYWxjUm90YXRlTWF0cml4KCksXG4gICAgICAgICAgdHJhbnNsYXRlTWF0cml4ID0gdGhpcy5fY2FsY1RyYW5zbGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIHN0YXJ0TWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyh0cmFuc2xhdGVNYXRyaXgsIHJvdGF0ZU1hdHJpeCksXG4gICAgICAgICAgdnB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLFxuICAgICAgICAgIGZpbmFsTWF0cml4ID0gYWJzb2x1dGUgPyBzdGFydE1hdHJpeCA6IG11bHRpcGx5TWF0cmljZXModnB0LCBzdGFydE1hdHJpeCksXG4gICAgICAgICAgZGltID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCksXG4gICAgICAgICAgdyA9IGRpbS54IC8gMiwgaCA9IGRpbS55IC8gMixcbiAgICAgICAgICB0bCA9IHRyYW5zZm9ybVBvaW50KHsgeDogLXcsIHk6IC1oIH0sIGZpbmFsTWF0cml4KSxcbiAgICAgICAgICB0ciA9IHRyYW5zZm9ybVBvaW50KHsgeDogdywgeTogLWggfSwgZmluYWxNYXRyaXgpLFxuICAgICAgICAgIGJsID0gdHJhbnNmb3JtUG9pbnQoeyB4OiAtdywgeTogaCB9LCBmaW5hbE1hdHJpeCksXG4gICAgICAgICAgYnIgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IHcsIHk6IGggfSwgZmluYWxNYXRyaXgpO1xuICAgICAgaWYgKCFhYnNvbHV0ZSkge1xuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMucGFkZGluZywgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgICAgY29zID0gZmFicmljLnV0aWwuY29zKGFuZ2xlKSwgc2luID0gZmFicmljLnV0aWwuc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIGNvc1AgPSBjb3MgKiBwYWRkaW5nLCBzaW5QID0gc2luICogcGFkZGluZywgY29zUFNpblAgPSBjb3NQICsgc2luUCxcbiAgICAgICAgICAgIGNvc1BNaW51c1NpblAgPSBjb3NQIC0gc2luUDtcbiAgICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgICB0bC54IC09IGNvc1BNaW51c1NpblA7XG4gICAgICAgICAgdGwueSAtPSBjb3NQU2luUDtcbiAgICAgICAgICB0ci54ICs9IGNvc1BTaW5QO1xuICAgICAgICAgIHRyLnkgLT0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgICBibC54IC09IGNvc1BTaW5QO1xuICAgICAgICAgIGJsLnkgKz0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgICBici54ICs9IGNvc1BNaW51c1NpblA7XG4gICAgICAgICAgYnIueSArPSBjb3NQU2luUDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWwgID0gbmV3IGZhYnJpYy5Qb2ludCgodGwueCArIGJsLngpIC8gMiwgKHRsLnkgKyBibC55KSAvIDIpLFxuICAgICAgICAgICAgbXQgID0gbmV3IGZhYnJpYy5Qb2ludCgodHIueCArIHRsLngpIC8gMiwgKHRyLnkgKyB0bC55KSAvIDIpLFxuICAgICAgICAgICAgbXIgID0gbmV3IGZhYnJpYy5Qb2ludCgoYnIueCArIHRyLngpIC8gMiwgKGJyLnkgKyB0ci55KSAvIDIpLFxuICAgICAgICAgICAgbWIgID0gbmV3IGZhYnJpYy5Qb2ludCgoYnIueCArIGJsLngpIC8gMiwgKGJyLnkgKyBibC55KSAvIDIpLFxuICAgICAgICAgICAgbXRyID0gbmV3IGZhYnJpYy5Qb2ludChtdC54ICsgc2luICogdGhpcy5yb3RhdGluZ1BvaW50T2Zmc2V0LCBtdC55IC0gY29zICogdGhpcy5yb3RhdGluZ1BvaW50T2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgKCFhYnNvbHV0ZSkge1xuICAgICAgLy8gICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAvLyAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuY2xlYXJSZWN0KDAsIDAsIDcwMCwgNzAwKTtcbiAgICAgIC8vICAgICBjYW52YXMuY29udGV4dFRvcC5maWxsU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KG1iLngsIG1iLnksIDMsIDMpO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGJsLngsIGJsLnksIDMsIDMpO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGJyLngsIGJyLnksIDMsIDMpO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KHRsLngsIHRsLnksIDMsIDMpO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KHRyLngsIHRyLnksIDMsIDMpO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KG1sLngsIG1sLnksIDMsIDMpO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KG1yLngsIG1yLnksIDMsIDMpO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KG10LngsIG10LnksIDMsIDMpO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KG10ci54LCBtdHIueSwgMywgMyk7XG4gICAgICAvLyAgIH0sIDUwKTtcbiAgICAgIC8vIH1cblxuICAgICAgdmFyIGNvb3JkcyA9IHtcbiAgICAgICAgLy8gY29ybmVyc1xuICAgICAgICB0bDogdGwsIHRyOiB0ciwgYnI6IGJyLCBibDogYmwsXG4gICAgICB9O1xuICAgICAgaWYgKCFhYnNvbHV0ZSkge1xuICAgICAgICAvLyBtaWRkbGVcbiAgICAgICAgY29vcmRzLm1sID0gbWw7XG4gICAgICAgIGNvb3Jkcy5tdCA9IG10O1xuICAgICAgICBjb29yZHMubXIgPSBtcjtcbiAgICAgICAgY29vcmRzLm1iID0gbWI7XG4gICAgICAgIC8vIHJvdGF0aW5nIHBvaW50XG4gICAgICAgIGNvb3Jkcy5tdHIgPSBtdHI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29vcmRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNvcm5lciBwb3NpdGlvbiBjb29yZGluYXRlcyBiYXNlZCBvbiBjdXJyZW50IGFuZ2xlLCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9mYWJyaWMuanMvd2lraS9XaGVuLXRvLWNhbGwtc2V0Q29vcmRzfFdoZW4tdG8tY2FsbC1zZXRDb29yZHN9XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlWm9vbV0gc2V0IG9Db29yZHMgd2l0aCBvciB3aXRob3V0IHRoZSB2aWV3cG9ydCB0cmFuc2Zvcm0uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcEFic29sdXRlXSBza2lwIGNhbGN1bGF0aW9uIG9mIGFDb29yZHMsIHVzZWZ1bGwgaW4gc2V0Vmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvb3JkczogZnVuY3Rpb24oaWdub3JlWm9vbSwgc2tpcEFic29sdXRlKSB7XG4gICAgICB0aGlzLm9Db29yZHMgPSB0aGlzLmNhbGNDb29yZHMoaWdub3JlWm9vbSk7XG4gICAgICBpZiAoIXNraXBBYnNvbHV0ZSkge1xuICAgICAgICB0aGlzLmFDb29yZHMgPSB0aGlzLmNhbGNDb29yZHModHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBjb29yZGluYXRlcyBvZiB0aGUgZHJhZ2dhYmxlIGJveGVzIGluIHRoZSBjb3JuZXJzIHVzZWQgdG8gc2NhbGUvcm90YXRlIHRoZSBpbWFnZVxuICAgICAgaWdub3JlWm9vbSB8fCAodGhpcy5fc2V0Q29ybmVyQ29vcmRzICYmIHRoaXMuX3NldENvcm5lckNvb3JkcygpKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSByb3RhdGlvbiBtYXRyaXggb2YgYW4gb2JqZWN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIF9jYWxjUm90YXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHZhciB0aGV0YSA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSksIGNvcyA9IGZhYnJpYy51dGlsLmNvcyh0aGV0YSksIHNpbiA9IGZhYnJpYy51dGlsLnNpbih0aGV0YSk7XG4gICAgICAgIHJldHVybiBbY29zLCBzaW4sIC1zaW4sIGNvcywgMCwgMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFicmljLmlNYXRyaXguY29uY2F0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgdHJhbnNsYXRpb24gbWF0cml4IGZvciBhbiBvYmplY3QgdHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7QXJyYXl9IHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIF9jYWxjVHJhbnNsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICByZXR1cm4gWzEsIDAsIDAsIDEsIGNlbnRlci54LCBjZW50ZXIueV07XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybU1hdHJpeEtleTogZnVuY3Rpb24oc2tpcEdyb3VwKSB7XG4gICAgICB2YXIgc2VwID0gJ18nLCBwcmVmaXggPSAnJztcbiAgICAgIGlmICghc2tpcEdyb3VwICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgcHJlZml4ID0gdGhpcy5ncm91cC50cmFuc2Zvcm1NYXRyaXhLZXkoc2tpcEdyb3VwKSArIHNlcDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcHJlZml4ICsgdGhpcy50b3AgKyBzZXAgKyB0aGlzLmxlZnQgKyBzZXAgKyB0aGlzLnNjYWxlWCArIHNlcCArIHRoaXMuc2NhbGVZICtcbiAgICAgICAgc2VwICsgdGhpcy5za2V3WCArIHNlcCArIHRoaXMuc2tld1kgKyBzZXAgKyB0aGlzLmFuZ2xlICsgc2VwICsgdGhpcy5vcmlnaW5YICsgc2VwICsgdGhpcy5vcmlnaW5ZICtcbiAgICAgICAgc2VwICsgdGhpcy53aWR0aCArIHNlcCArIHRoaXMuaGVpZ2h0ICsgc2VwICsgdGhpcy5zdHJva2VXaWR0aCArIHRoaXMuZmxpcFggKyB0aGlzLmZsaXBZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdHJhc2Zvcm0gTWF0cml4IHRoYXQgcmVwcmVzZW50IGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gZnJvbVxuICAgICAqIG9iamVjdCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBHcm91cF0gcmV0dXJuIHRyYW5zZm9ybU1hdHJpeCBmb3Igb2JqZWN0IGFuZCBub3QgZ28gdXB3YXJkIHdpdGggcGFyZW50c1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBtYXRyaXggVHJhbnNmb3JtIE1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHNraXBHcm91cCkge1xuICAgICAgaWYgKHNraXBHcm91cCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxjT3duTWF0cml4KCk7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXhLZXkoKSwgY2FjaGUgPSB0aGlzLm1hdHJpeENhY2hlIHx8ICh0aGlzLm1hdHJpeENhY2hlID0ge30pO1xuICAgICAgaWYgKGNhY2hlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLmNhbGNPd25NYXRyaXgoKTtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXModGhpcy5ncm91cC5jYWxjVHJhbnNmb3JtTWF0cml4KCksIG1hdHJpeCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICBjYWNoZS52YWx1ZSA9IG1hdHJpeDtcbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcblxuICAgIGNhbGNPd25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMudHJhbnNmb3JtTWF0cml4S2V5KHRydWUpLCBjYWNoZSA9IHRoaXMub3duTWF0cml4Q2FjaGUgfHwgKHRoaXMub3duTWF0cml4Q2FjaGUgPSB7fSk7XG4gICAgICBpZiAoY2FjaGUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX2NhbGNUcmFuc2xhdGVNYXRyaXgoKSxcbiAgICAgICAgICByb3RhdGVNYXRyaXgsXG4gICAgICAgICAgZGltZW5zaW9uTWF0cml4ID0gdGhpcy5fY2FsY0RpbWVuc2lvbnNUcmFuc2Zvcm1NYXRyaXgodGhpcy5za2V3WCwgdGhpcy5za2V3WSwgdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICByb3RhdGVNYXRyaXggPSB0aGlzLl9jYWxjUm90YXRlTWF0cml4KCk7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXMobWF0cml4LCByb3RhdGVNYXRyaXgpO1xuICAgICAgfVxuICAgICAgbWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhtYXRyaXgsIGRpbWVuc2lvbk1hdHJpeCk7XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICBjYWNoZS52YWx1ZSA9IG1hdHJpeDtcbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcblxuICAgIF9jYWxjRGltZW5zaW9uc1RyYW5zZm9ybU1hdHJpeDogZnVuY3Rpb24oc2tld1gsIHNrZXdZLCBmbGlwcGluZykge1xuICAgICAgdmFyIHNrZXdNYXRyaXgsXG4gICAgICAgICAgc2NhbGVYID0gdGhpcy5zY2FsZVggKiAoZmxpcHBpbmcgJiYgdGhpcy5mbGlwWCA/IC0xIDogMSksXG4gICAgICAgICAgc2NhbGVZID0gdGhpcy5zY2FsZVkgKiAoZmxpcHBpbmcgJiYgdGhpcy5mbGlwWSA/IC0xIDogMSksXG4gICAgICAgICAgc2NhbGVNYXRyaXggPSBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIDAsIDBdO1xuICAgICAgaWYgKHNrZXdYKSB7XG4gICAgICAgIHNrZXdNYXRyaXggPSBbMSwgMCwgTWF0aC50YW4oZGVncmVlc1RvUmFkaWFucyhza2V3WCkpLCAxXTtcbiAgICAgICAgc2NhbGVNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHNjYWxlTWF0cml4LCBza2V3TWF0cml4LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChza2V3WSkge1xuICAgICAgICBza2V3TWF0cml4ID0gWzEsIE1hdGgudGFuKGRlZ3JlZXNUb1JhZGlhbnMoc2tld1kpKSwgMCwgMV07XG4gICAgICAgIHNjYWxlTWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhzY2FsZU1hdHJpeCwgc2tld01hdHJpeCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NhbGVNYXRyaXg7XG4gICAgfSxcblxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCB3aWR0aCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC55IGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGggKyBzdHJva2VXaWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQgKyBzdHJva2VXaWR0aDtcbiAgICAgIHJldHVybiB7IHg6IHcsIHk6IGggfTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGJvdW5kaW5nIGJveGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllcyBzY2FsZSwgc2tldy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnggd2lkdGggZGltZW5zaW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueSBoZWlnaHQgZGltZW5zaW9uXG4gICAgICovXG4gICAgX2dldFRyYW5zZm9ybWVkRGltZW5zaW9uczogZnVuY3Rpb24oc2tld1gsIHNrZXdZKSB7XG4gICAgICBpZiAodHlwZW9mIHNrZXdYID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBza2V3WCA9IHRoaXMuc2tld1g7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNrZXdZID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBza2V3WSA9IHRoaXMuc2tld1k7XG4gICAgICB9XG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgaWYgKHNrZXdYID09PSAwICYmIHNrZXdZID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IGRpbWVuc2lvbnMueCAqIHRoaXMuc2NhbGVYLCB5OiBkaW1lbnNpb25zLnkgKiB0aGlzLnNjYWxlWSB9O1xuICAgICAgfVxuICAgICAgdmFyIGRpbVggPSBkaW1lbnNpb25zLnggLyAyLCBkaW1ZID0gZGltZW5zaW9ucy55IC8gMixcbiAgICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IC1kaW1YLFxuICAgICAgICAgICAgICB5OiAtZGltWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogZGltWCxcbiAgICAgICAgICAgICAgeTogLWRpbVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IC1kaW1YLFxuICAgICAgICAgICAgICB5OiBkaW1ZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBkaW1YLFxuICAgICAgICAgICAgICB5OiBkaW1ZXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICBpLCB0cmFuc2Zvcm1NYXRyaXggPSB0aGlzLl9jYWxjRGltZW5zaW9uc1RyYW5zZm9ybU1hdHJpeChza2V3WCwgc2tld1ksIGZhbHNlKSxcbiAgICAgICAgICBiYm94O1xuICAgICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludHNbaV0gPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwb2ludHNbaV0sIHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICB9XG4gICAgICBiYm94ID0gZmFicmljLnV0aWwubWFrZUJvdW5kaW5nQm94RnJvbVBvaW50cyhwb2ludHMpO1xuICAgICAgcmV0dXJuIHsgeDogYmJveC53aWR0aCwgeTogYmJveC5oZWlnaHQgfTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZm9yIGNvbnRyb2xzLiBpbmNsdWRlIHBhZGRpbmcgYW5kIGNhbnZhcyB6b29tXG4gICAgICogcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9uczogZnVuY3Rpb24oKSAge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBwID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoZGltLCB2cHQsIHRydWUpO1xuXG4gICAgICByZXR1cm4gcC5zY2FsYXJBZGQoMiAqIHRoaXMucGFkZGluZyk7XG4gICAgfSxcbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRUb0JhY2s6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kVG9CYWNrLmNhbGwodGhpcy5ncm91cCwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMuc2VuZFRvQmFjayh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYnJpbmdUb0Zyb250OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuYnJpbmdUb0Zyb250LmNhbGwodGhpcy5ncm91cCwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMuYnJpbmdUb0Zyb250KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IGRvd24gaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRCYWNrd2FyZHM6IGZ1bmN0aW9uKGludGVyc2VjdGluZykge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kQmFja3dhcmRzLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZW5kQmFja3dhcmRzKHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdXAgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgaW4gZnJvbnQgb2YgbmV4dCB1cHBlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYnJpbmdGb3J3YXJkOiBmdW5jdGlvbihpbnRlcnNlY3RpbmcpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuYnJpbmdGb3J3YXJkLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcy5icmluZ0ZvcndhcmQodGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byBzcGVjaWZpZWQgbGV2ZWwgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggTmV3IHBvc2l0aW9uIG9mIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIG1vdmVUbzogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgIT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5tb3ZlVG8uY2FsbCh0aGlzLmdyb3VwLCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMubW92ZVRvKHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5cbi8qIF9UT19TVkdfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGdldFN2Z0NvbG9yU3RyaW5nKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHByb3AgKyAnOiBub25lOyAnO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS50b0xpdmUpIHtcbiAgICAgIHJldHVybiBwcm9wICsgJzogdXJsKCNTVkdJRF8nICsgdmFsdWUuaWQgKyAnKTsgJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHZhbHVlKSxcbiAgICAgICAgICBzdHIgPSBwcm9wICsgJzogJyArIGNvbG9yLnRvUmdiKCkgKyAnOyAnLFxuICAgICAgICAgIG9wYWNpdHkgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgLy9jaGFuZ2UgdGhlIGNvbG9yIGluIHJnYiArIG9wYWNpdHlcbiAgICAgICAgc3RyICs9IHByb3AgKyAnLW9wYWNpdHk6ICcgKyBvcGFjaXR5LnRvU3RyaW5nKCkgKyAnOyAnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cblxuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwU2hhZG93IGEgYm9vbGVhbiB0byBza2lwIHNoYWRvdyBmaWx0ZXIgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24oc2tpcFNoYWRvdykge1xuXG4gICAgICB2YXIgZmlsbFJ1bGUgPSB0aGlzLmZpbGxSdWxlID8gdGhpcy5maWxsUnVsZSA6ICdub256ZXJvJyxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGggPyB0aGlzLnN0cm9rZVdpZHRoIDogJzAnLFxuICAgICAgICAgIHN0cm9rZURhc2hBcnJheSA9IHRoaXMuc3Ryb2tlRGFzaEFycmF5ID8gdGhpcy5zdHJva2VEYXNoQXJyYXkuam9pbignICcpIDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZURhc2hPZmZzZXQgPSB0aGlzLnN0cm9rZURhc2hPZmZzZXQgPyB0aGlzLnN0cm9rZURhc2hPZmZzZXQgOiAnMCcsXG4gICAgICAgICAgc3Ryb2tlTGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcCA/IHRoaXMuc3Ryb2tlTGluZUNhcCA6ICdidXR0JyxcbiAgICAgICAgICBzdHJva2VMaW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW4gPyB0aGlzLnN0cm9rZUxpbmVKb2luIDogJ21pdGVyJyxcbiAgICAgICAgICBzdHJva2VNaXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0ID8gdGhpcy5zdHJva2VNaXRlckxpbWl0IDogJzQnLFxuICAgICAgICAgIG9wYWNpdHkgPSB0eXBlb2YgdGhpcy5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyA/IHRoaXMub3BhY2l0eSA6ICcxJyxcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gdGhpcy52aXNpYmxlID8gJycgOiAnIHZpc2liaWxpdHk6IGhpZGRlbjsnLFxuICAgICAgICAgIGZpbHRlciA9IHNraXBTaGFkb3cgPyAnJyA6IHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgICAgZmlsbCA9IGdldFN2Z0NvbG9yU3RyaW5nKCdmaWxsJywgdGhpcy5maWxsKSxcbiAgICAgICAgICBzdHJva2UgPSBnZXRTdmdDb2xvclN0cmluZygnc3Ryb2tlJywgdGhpcy5zdHJva2UpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzdHJva2UsXG4gICAgICAgICdzdHJva2Utd2lkdGg6ICcsIHN0cm9rZVdpZHRoLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheTogJywgc3Ryb2tlRGFzaEFycmF5LCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXA6ICcsIHN0cm9rZUxpbmVDYXAsICc7ICcsXG4gICAgICAgICdzdHJva2UtZGFzaG9mZnNldDogJywgc3Ryb2tlRGFzaE9mZnNldCwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lam9pbjogJywgc3Ryb2tlTGluZUpvaW4sICc7ICcsXG4gICAgICAgICdzdHJva2UtbWl0ZXJsaW1pdDogJywgc3Ryb2tlTWl0ZXJMaW1pdCwgJzsgJyxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgJ2ZpbGwtcnVsZTogJywgZmlsbFJ1bGUsICc7ICcsXG4gICAgICAgICdvcGFjaXR5OiAnLCBvcGFjaXR5LCAnOycsXG4gICAgICAgIGZpbHRlcixcbiAgICAgICAgdmlzaWJpbGl0eVxuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIHRoZSBvYmplY3QgZnJvbSB3aGljaCB0byByZXRyaWV2ZSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB1c2VXaGl0ZVNwYWNlIGEgYm9vbGVhbiB0byBpbmNsdWRlIGFuIGFkZGl0aW9uYWwgYXR0cmlidXRlIGluIHRoZSBzdHlsZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3BhblN0eWxlczogZnVuY3Rpb24oc3R5bGUsIHVzZVdoaXRlU3BhY2UpIHtcbiAgICAgIHZhciB0ZXJtID0gJzsgJztcbiAgICAgIHZhciBmb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseSA/XG4gICAgICAgICdmb250LWZhbWlseTogJyArICgoKHN0eWxlLmZvbnRGYW1pbHkuaW5kZXhPZignXFwnJykgPT09IC0xICYmIHN0eWxlLmZvbnRGYW1pbHkuaW5kZXhPZignXCInKSA9PT0gLTEpID9cbiAgICAgICAgICAnXFwnJyArIHN0eWxlLmZvbnRGYW1pbHkgICsgJ1xcJycgOiBzdHlsZS5mb250RmFtaWx5KSkgKyB0ZXJtIDogJyc7XG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSBzdHlsZS5zdHJva2VXaWR0aCA/ICdzdHJva2Utd2lkdGg6ICcgKyBzdHlsZS5zdHJva2VXaWR0aCArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmb250RmFtaWx5ID0gZm9udEZhbWlseSxcbiAgICAgICAgICBmb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplID8gJ2ZvbnQtc2l6ZTogJyArIHN0eWxlLmZvbnRTaXplICsgJ3B4JyArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmb250U3R5bGUgPSBzdHlsZS5mb250U3R5bGUgPyAnZm9udC1zdHlsZTogJyArIHN0eWxlLmZvbnRTdHlsZSArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmb250V2VpZ2h0ID0gc3R5bGUuZm9udFdlaWdodCA/ICdmb250LXdlaWdodDogJyArIHN0eWxlLmZvbnRXZWlnaHQgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZmlsbCA9IHN0eWxlLmZpbGwgPyBnZXRTdmdDb2xvclN0cmluZygnZmlsbCcsIHN0eWxlLmZpbGwpIDogJycsXG4gICAgICAgICAgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlID8gZ2V0U3ZnQ29sb3JTdHJpbmcoJ3N0cm9rZScsIHN0eWxlLnN0cm9rZSkgOiAnJyxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMuZ2V0U3ZnVGV4dERlY29yYXRpb24oc3R5bGUpLFxuICAgICAgICAgIGRlbHRhWSA9IHN0eWxlLmRlbHRhWSA/ICdiYXNlbGluZS1zaGlmdDogJyArICgtc3R5bGUuZGVsdGFZKSArICc7ICcgOiAnJztcbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbikge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9ICd0ZXh0LWRlY29yYXRpb246ICcgKyB0ZXh0RGVjb3JhdGlvbiArIHRlcm07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIGZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBmb250U3R5bGUsXG4gICAgICAgIGZvbnRXZWlnaHQsXG4gICAgICAgIHRleHREZWNvcmF0aW9uLFxuICAgICAgICBmaWxsLFxuICAgICAgICBkZWx0YVksXG4gICAgICAgIHVzZVdoaXRlU3BhY2UgPyAnd2hpdGUtc3BhY2U6IHByZTsgJyA6ICcnXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRleHQtZGVjb3JhdGlvbiBwcm9wZXJ0eSBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSB0aGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmV0cmlldmUgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdUZXh0RGVjb3JhdGlvbjogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIGlmICgnb3ZlcmxpbmUnIGluIHN0eWxlIHx8ICd1bmRlcmxpbmUnIGluIHN0eWxlIHx8ICdsaW5ldGhyb3VnaCcgaW4gc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIChzdHlsZS5vdmVybGluZSA/ICdvdmVybGluZSAnIDogJycpICtcbiAgICAgICAgICAoc3R5bGUudW5kZXJsaW5lID8gJ3VuZGVybGluZSAnIDogJycpICsgKHN0eWxlLmxpbmV0aHJvdWdoID8gJ2xpbmUtdGhyb3VnaCAnIDogJycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpbHRlciBmb3Igc3ZnIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhZG93ID8gJ2ZpbHRlcjogdXJsKCNTVkdJRF8nICsgdGhpcy5zaGFkb3cuaWQgKyAnKTsnIDogJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWQgYXR0cmlidXRlIGZvciBzdmcgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z0NvbW1vbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGhpcy5pZCA/ICdpZD1cIicgKyB0aGlzLmlkICsgJ1wiICcgOiAnJyxcbiAgICAgICAgdGhpcy5jbGlwUGF0aCA/ICdjbGlwLXBhdGg9XCJ1cmwoIycgKyB0aGlzLmNsaXBQYXRoLmNsaXBQYXRoSWQgKyAnKVwiICcgOiAnJyxcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJhbnNmb3JtLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlIHRoZSBmdWxsIHRyYW5zZm9ybSBvciB0aGUgc2luZ2xlIG9iamVjdCBvbmUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1RyYW5zZm9ybTogZnVuY3Rpb24oZnVsbCwgYWRkaXRpb25hbFRyYW5zZm9ybSkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGZ1bGwgPyB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSA6IHRoaXMuY2FsY093bk1hdHJpeCgpLFxuICAgICAgICAgIHN2Z1RyYW5zZm9ybSA9IHRyYW5zZm9ybS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b0ZpeGVkKHZhbHVlLCBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMpO1xuICAgICAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICAgIHJldHVybiAndHJhbnNmb3JtPVwibWF0cml4KCcgKyBzdmdUcmFuc2Zvcm0gKyAnKScgK1xuICAgICAgICAoYWRkaXRpb25hbFRyYW5zZm9ybSB8fCAnJykgKyB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpICsgJ1wiICc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJhbnNmb3JtLXN0cmluZyBmb3Igc3ZnLWV4cG9ydCBmcm9tIHRoZSB0cmFuc2Zvcm0gbWF0cml4IG9mIHNpbmdsZSBlbGVtZW50c1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTWF0cml4ID8gJyBtYXRyaXgoJyArIHRoaXMudHJhbnNmb3JtTWF0cml4LmpvaW4oJyAnKSArICcpJyA6ICcnO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHQmc6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzKSB7XG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdmFyIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG4gICAgICAgIHRleHRCZ1JlY3RzLnB1c2goXG4gICAgICAgICAgJ1xcdFxcdDxyZWN0ICcsXG4gICAgICAgICAgdGhpcy5fZ2V0RmlsbEF0dHJpYnV0ZXModGhpcy5iYWNrZ3JvdW5kQ29sb3IpLFxuICAgICAgICAgICcgeD1cIicsXG4gICAgICAgICAgdG9GaXhlZCgtdGhpcy53aWR0aCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiB5PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKC10aGlzLmhlaWdodCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiB3aWR0aD1cIicsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMuaGVpZ2h0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCI+PC9yZWN0PlxcbicpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAodGhpcy5fdG9TVkcoKSwgeyByZXZpdmVyOiByZXZpdmVyIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyBjbGlwUGF0aCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0NsaXBQYXRoU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICByZXR1cm4gJ1xcdCcgKyB0aGlzLl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAodGhpcy5fdG9TVkcoKSwgeyByZXZpdmVyOiByZXZpdmVyIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXA6IGZ1bmN0aW9uKG9iamVjdE1hcmt1cCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgcmV2aXZlciA9IG9wdGlvbnMucmV2aXZlcixcbiAgICAgICAgICBhZGRpdGlvbmFsVHJhbnNmb3JtID0gb3B0aW9ucy5hZGRpdGlvbmFsVHJhbnNmb3JtIHx8ICcnLFxuICAgICAgICAgIGNvbW1vblBpZWNlcyA9IFtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKHRydWUsIGFkZGl0aW9uYWxUcmFuc2Zvcm0pLFxuICAgICAgICAgICAgdGhpcy5nZXRTdmdDb21tb25zKCksXG4gICAgICAgICAgXS5qb2luKCcnKSxcbiAgICAgICAgICAvLyBpbnNlcnQgY29tbW9ucyBpbiB0aGUgbWFya3VwLCBzdHlsZSBhbmQgc3ZnQ29tbW9uc1xuICAgICAgICAgIGluZGV4ID0gb2JqZWN0TWFya3VwLmluZGV4T2YoJ0NPTU1PTl9QQVJUUycpO1xuICAgICAgb2JqZWN0TWFya3VwW2luZGV4XSA9IGNvbW1vblBpZWNlcztcbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihvYmplY3RNYXJrdXAuam9pbignJykpIDogb2JqZWN0TWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVCYXNlU1ZHTWFya3VwOiBmdW5jdGlvbihvYmplY3RNYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIG5vU3R5bGUgPSBvcHRpb25zLm5vU3R5bGUsIHdpdGhTaGFkb3cgPSBvcHRpb25zLndpdGhTaGFkb3csXG4gICAgICAgICAgcmV2aXZlciA9IG9wdGlvbnMucmV2aXZlcixcbiAgICAgICAgICBzdHlsZUluZm8gPSBub1N0eWxlID8gJycgOiAnc3R5bGU9XCInICsgdGhpcy5nZXRTdmdTdHlsZXMoKSArICdcIiAnLFxuICAgICAgICAgIHNoYWRvd0luZm8gPSB3aXRoU2hhZG93ID8gJ3N0eWxlPVwiJyArIHRoaXMuZ2V0U3ZnRmlsdGVyKCkgKyAnXCIgJyA6ICcnLFxuICAgICAgICAgIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aCxcbiAgICAgICAgICBhYnNvbHV0ZUNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aCAmJiB0aGlzLmNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZCxcbiAgICAgICAgICBjb21tb25QaWVjZXMsIG1hcmt1cCA9IFtdLCBjbGlwUGF0aE1hcmt1cCxcbiAgICAgICAgICAvLyBpbnNlcnQgY29tbW9ucyBpbiB0aGUgbWFya3VwLCBzdHlsZSBhbmQgc3ZnQ29tbW9uc1xuICAgICAgICAgIGluZGV4ID0gb2JqZWN0TWFya3VwLmluZGV4T2YoJ0NPTU1PTl9QQVJUUycpLFxuICAgICAgICAgIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSBvcHRpb25zLmFkZGl0aW9uYWxUcmFuc2Zvcm07XG4gICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgY2xpcFBhdGguY2xpcFBhdGhJZCA9ICdDTElQUEFUSF8nICsgZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgICBjbGlwUGF0aE1hcmt1cCA9ICc8Y2xpcFBhdGggaWQ9XCInICsgY2xpcFBhdGguY2xpcFBhdGhJZCArICdcIiA+XFxuJyArXG4gICAgICAgICAgdGhpcy5jbGlwUGF0aC50b0NsaXBQYXRoU1ZHKHJldml2ZXIpICtcbiAgICAgICAgICAnPC9jbGlwUGF0aD5cXG4nO1xuICAgICAgfVxuICAgICAgaWYgKGFic29sdXRlQ2xpcFBhdGgpIHtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxnICcsIHNoYWRvd0luZm8sIHRoaXMuZ2V0U3ZnQ29tbW9ucygpLCAnID5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxnICcsXG4gICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKGZhbHNlKSxcbiAgICAgICAgIWFic29sdXRlQ2xpcFBhdGggPyBzaGFkb3dJbmZvICsgdGhpcy5nZXRTdmdDb21tb25zKCkgOiAnJyxcbiAgICAgICAgJyA+XFxuJ1xuICAgICAgKTtcbiAgICAgIGNvbW1vblBpZWNlcyA9IFtcbiAgICAgICAgc3R5bGVJbmZvLFxuICAgICAgICBub1N0eWxlID8gJycgOiB0aGlzLmFkZFBhaW50T3JkZXIoKSwgJyAnLFxuICAgICAgICBhZGRpdGlvbmFsVHJhbnNmb3JtID8gJ3RyYW5zZm9ybT1cIicgKyBhZGRpdGlvbmFsVHJhbnNmb3JtICsgJ1wiICcgOiAnJyxcbiAgICAgIF0uam9pbignJyk7XG4gICAgICBvYmplY3RNYXJrdXBbaW5kZXhdID0gY29tbW9uUGllY2VzO1xuICAgICAgaWYgKHRoaXMuZmlsbCAmJiB0aGlzLmZpbGwudG9MaXZlKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHRoaXMuZmlsbC50b1NWRyh0aGlzLCBmYWxzZSkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3Ryb2tlICYmIHRoaXMuc3Ryb2tlLnRvTGl2ZSkge1xuICAgICAgICBtYXJrdXAucHVzaCh0aGlzLnN0cm9rZS50b1NWRyh0aGlzLCBmYWxzZSkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHRoaXMuc2hhZG93LnRvU1ZHKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaChjbGlwUGF0aE1hcmt1cCk7XG4gICAgICB9XG4gICAgICBtYXJrdXAucHVzaChvYmplY3RNYXJrdXAuam9pbignJykpO1xuICAgICAgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIGFic29sdXRlQ2xpcFBhdGggJiYgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBhZGRQYWludE9yZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhaW50Rmlyc3QgIT09ICdmaWxsJyA/ICcgcGFpbnQtb3JkZXI9XCInICsgdGhpcy5wYWludEZpcnN0ICsgJ1wiICcgOiAnJztcbiAgICB9XG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIG9yaWdpbmFsU2V0ID0gJ3N0YXRlUHJvcGVydGllcyc7XG5cbiAgLypcbiAgICBEZXBlbmRzIG9uIGBzdGF0ZVByb3BlcnRpZXNgXG4gICovXG4gIGZ1bmN0aW9uIHNhdmVQcm9wcyhvcmlnaW4sIGRlc3RpbmF0aW9uLCBwcm9wcykge1xuICAgIHZhciB0bXBPYmogPSB7IH0sIGRlZXAgPSB0cnVlO1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgdG1wT2JqW3Byb3BdID0gb3JpZ2luW3Byb3BdO1xuICAgIH0pO1xuICAgIGV4dGVuZChvcmlnaW5bZGVzdGluYXRpb25dLCB0bXBPYmosIGRlZXApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzRXF1YWwob3JpZ1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZpcnN0UGFzcykge1xuICAgIGlmIChvcmlnVmFsdWUgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgLy8gaWYgdGhlIG9iamVjdHMgYXJlIGlkZW50aWNhbCwgcmV0dXJuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcmlnVmFsdWUpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSB8fCBvcmlnVmFsdWUubGVuZ3RoICE9PSBjdXJyZW50VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcmlnVmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFfaXNFcXVhbChvcmlnVmFsdWVbaV0sIGN1cnJlbnRWYWx1ZVtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcmlnVmFsdWUgJiYgdHlwZW9mIG9yaWdWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3JpZ1ZhbHVlKSwga2V5O1xuICAgICAgaWYgKCFjdXJyZW50VmFsdWUgfHxcbiAgICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICghZmlyc3RQYXNzICYmIGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhjdXJyZW50VmFsdWUpLmxlbmd0aClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAvLyBzaW5jZSBjbGlwUGF0aCBpcyBpbiB0aGUgc3RhdGVmdWxsIGNhY2hlIGxpc3QgYW5kIHRoZSBjbGlwUGF0aCBvYmplY3RzXG4gICAgICAgIC8vIHdvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIG9iamVjdCwgdGhpcyB3b3VsZCBsZWFkIHRvIHBvc3NpYmxlIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICBpZiAoa2V5ID09PSAnY2FudmFzJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX2lzRXF1YWwob3JpZ1ZhbHVlW2tleV0sIGN1cnJlbnRWYWx1ZVtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3Qgc3RhdGUgKG9uZSBvZiBpdHMgc3RhdGUgcHJvcGVydGllcykgd2FzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5U2V0XSBvcHRpb25hbCBuYW1lIGZvciB0aGUgc2V0IG9mIHByb3BlcnR5IHdlIHdhbnQgdG8gc2F2ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgaW5zdGFuY2UnIHN0YXRlIGhhcyBjaGFuZ2VkIHNpbmNlIGB7QGxpbmsgZmFicmljLk9iamVjdCNzYXZlU3RhdGV9YCB3YXMgY2FsbGVkXG4gICAgICovXG4gICAgaGFzU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbihwcm9wZXJ0eVNldCkge1xuICAgICAgcHJvcGVydHlTZXQgPSBwcm9wZXJ0eVNldCB8fCBvcmlnaW5hbFNldDtcbiAgICAgIHZhciBkYXNoZWRQcm9wZXJ0eVNldCA9ICdfJyArIHByb3BlcnR5U2V0O1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXNbZGFzaGVkUHJvcGVydHlTZXRdKS5sZW5ndGggPCB0aGlzW3Byb3BlcnR5U2V0XS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gIV9pc0VxdWFsKHRoaXNbZGFzaGVkUHJvcGVydHlTZXRdLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgc3RhdGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGBzdGF0ZVByb3BlcnRpZXNgIGFycmF5IHRvIGluY2x1ZGUgd2hlbiBzYXZpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgc2F2ZVN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcGVydHlTZXQgPSBvcHRpb25zICYmIG9wdGlvbnMucHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQsXG4gICAgICAgICAgZGVzdGluYXRpb24gPSAnXycgKyBwcm9wZXJ0eVNldDtcbiAgICAgIGlmICghdGhpc1tkZXN0aW5hdGlvbl0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dXBTdGF0ZShvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNhdmVQcm9wcyh0aGlzLCBkZXN0aW5hdGlvbiwgdGhpc1twcm9wZXJ0eVNldF0pO1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdGF0ZVByb3BlcnRpZXMpIHtcbiAgICAgICAgc2F2ZVByb3BzKHRoaXMsIGRlc3RpbmF0aW9uLCBvcHRpb25zLnN0YXRlUHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dXBzIHN0YXRlIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggYWRkaXRpb25hbCBgc3RhdGVQcm9wZXJ0aWVzYCBhcnJheSB0byBpbmNsdWRlIHdoZW4gc2F2aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldHVwU3RhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcbiAgICAgIHZhciBwcm9wZXJ0eVNldCA9IG9wdGlvbnMucHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQ7XG4gICAgICBvcHRpb25zLnByb3BlcnR5U2V0ID0gcHJvcGVydHlTZXQ7XG4gICAgICB0aGlzWydfJyArIHByb3BlcnR5U2V0XSA9IHsgfTtcbiAgICAgIHRoaXMuc2F2ZVN0YXRlKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucztcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvYmplY3QgaW50ZXJhY3Rpdml0eSBjb250cm9scy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb250cm9sc1Zpc2liaWxpdHk6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoaWNoIGNvcm5lciBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciBUaGUgcG9pbnRlciBpbmRpY2F0aW5nIHRoZSBtb3VzZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufSBjb3JuZXIgY29kZSAodGwsIHRyLCBibCwgYnIsIGV0Yy4pLCBvciBmYWxzZSBpZiBub3RoaW5nIGlzIGZvdW5kXG4gICAgICovXG4gICAgX2ZpbmRUYXJnZXRDb3JuZXI6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIC8vIG9iamVjdHMgaW4gZ3JvdXAsIGFueWtpbmQsIGFyZSBub3Qgc2VsZiBtb2RpZmljYWJsZSxcbiAgICAgIC8vIG11c3Qgbm90IHJldHVybiBhbiBob3ZlcmVkIGNvcm5lci5cbiAgICAgIGlmICghdGhpcy5oYXNDb250cm9scyB8fCB0aGlzLmdyb3VwIHx8ICghdGhpcy5jYW52YXMgfHwgdGhpcy5jYW52YXMuX2FjdGl2ZU9iamVjdCAhPT0gdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXggPSBwb2ludGVyLngsXG4gICAgICAgICAgZXkgPSBwb2ludGVyLnksXG4gICAgICAgICAgeFBvaW50cyxcbiAgICAgICAgICBsaW5lcztcbiAgICAgIHRoaXMuX19jb3JuZXIgPSAwO1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLm9Db29yZHMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaXNDb250cm9sVmlzaWJsZShpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT09ICdtdHInICYmICF0aGlzLmhhc1JvdGF0aW5nUG9pbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdldCgnbG9ja1VuaVNjYWxpbmcnKSAmJlxuICAgICAgICAgICAoaSA9PT0gJ210JyB8fCBpID09PSAnbXInIHx8IGkgPT09ICdtYicgfHwgaSA9PT0gJ21sJykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gdGhpcy5fZ2V0SW1hZ2VMaW5lcyh0aGlzLm9Db29yZHNbaV0uY29ybmVyKTtcblxuICAgICAgICAvLyBkZWJ1Z2dpbmdcblxuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLmQueCwgbGluZXMuYm90dG9tbGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLm8ueCwgbGluZXMuYm90dG9tbGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLmQueCwgbGluZXMubGVmdGxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMubGVmdGxpbmUuby54LCBsaW5lcy5sZWZ0bGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuZC54LCBsaW5lcy50b3BsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuby54LCBsaW5lcy50b3BsaW5lLm8ueSwgMiwgMik7XG5cbiAgICAgICAgLy8gY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMucmlnaHRsaW5lLmQueCwgbGluZXMucmlnaHRsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5vLngsIGxpbmVzLnJpZ2h0bGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIHhQb2ludHMgPSB0aGlzLl9maW5kQ3Jvc3NQb2ludHMoeyB4OiBleCwgeTogZXkgfSwgbGluZXMpO1xuICAgICAgICBpZiAoeFBvaW50cyAhPT0gMCAmJiB4UG9pbnRzICUgMiA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuX19jb3JuZXIgPSBpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBkcmFnZ2FibGUgYm94ZXMgaW4gdGhlIGNvcm5lcnMgb2ZcbiAgICAgKiB0aGUgaW1hZ2UgdXNlZCB0byBzY2FsZS9yb3RhdGUgaXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0Q29ybmVyQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLm9Db29yZHMsXG4gICAgICAgICAgbmV3VGhldGEgPSBkZWdyZWVzVG9SYWRpYW5zKDQ1IC0gdGhpcy5hbmdsZSksXG4gICAgICAgICAgLyogTWF0aC5zcXJ0KDIgKiBNYXRoLnBvdyh0aGlzLmNvcm5lclNpemUsIDIpKSAvIDIsICovXG4gICAgICAgICAgLyogMC43MDcxMDYgc3RhbmRzIGZvciBzcXJ0KDIpLzIgKi9cbiAgICAgICAgICBjb3JuZXJIeXBvdGVudXNlID0gdGhpcy5jb3JuZXJTaXplICogMC43MDcxMDYsXG4gICAgICAgICAgY29zSGFsZk9mZnNldCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5jb3MobmV3VGhldGEpLFxuICAgICAgICAgIHNpbkhhbGZPZmZzZXQgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuc2luKG5ld1RoZXRhKSxcbiAgICAgICAgICB4LCB5O1xuXG4gICAgICBmb3IgKHZhciBwb2ludCBpbiBjb29yZHMpIHtcbiAgICAgICAgeCA9IGNvb3Jkc1twb2ludF0ueDtcbiAgICAgICAgeSA9IGNvb3Jkc1twb2ludF0ueTtcbiAgICAgICAgY29vcmRzW3BvaW50XS5jb3JuZXIgPSB7XG4gICAgICAgICAgdGw6IHtcbiAgICAgICAgICAgIHg6IHggLSBzaW5IYWxmT2Zmc2V0LFxuICAgICAgICAgICAgeTogeSAtIGNvc0hhbGZPZmZzZXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyOiB7XG4gICAgICAgICAgICB4OiB4ICsgY29zSGFsZk9mZnNldCxcbiAgICAgICAgICAgIHk6IHkgLSBzaW5IYWxmT2Zmc2V0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBibDoge1xuICAgICAgICAgICAgeDogeCAtIGNvc0hhbGZPZmZzZXQsXG4gICAgICAgICAgICB5OiB5ICsgc2luSGFsZk9mZnNldFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYnI6IHtcbiAgICAgICAgICAgIHg6IHggKyBzaW5IYWxmT2Zmc2V0LFxuICAgICAgICAgICAgeTogeSArIGNvc0hhbGZPZmZzZXRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgY29sb3JlZCBsYXllciBiZWhpbmQgdGhlIG9iamVjdCwgaW5zaWRlIGl0cyBzZWxlY3Rpb24gYm9yZGVycy5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yXG4gICAgICogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgY29udGV4dCBpcyB0cmFuc2Zvcm1lZFxuICAgICAqIGhhcyBjaGVja3MgdG8gYmUgc2tpcHBlZCB3aGVuIHRoZSBvYmplY3QgaXMgb24gYSBzdGF0aWNDYW52YXNcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd1NlbGVjdGlvbkJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciB8fFxuICAgICAgICAodGhpcy5jYW52YXMgJiYgIXRoaXMuY2FudmFzLmludGVyYWN0aXZlKSB8fFxuICAgICAgICAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuX2FjdGl2ZU9iamVjdCAhPT0gdGhpcylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpLCB3aCA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zKCksXG4gICAgICAgICAgdnB0ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICBjdHgudHJhbnNsYXRlKGNlbnRlci54LCBjZW50ZXIueSk7XG4gICAgICBjdHguc2NhbGUoMSAvIHZwdFswXSwgMSAvIHZwdFszXSk7XG4gICAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KC13aC54IC8gMiwgLXdoLnkgLyAyLCB3aC54LCB3aC55KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYm9yZGVycyBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3guXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgYm9yZGVyQ29sb3JcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Qm9yZGVyczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIHZhciB3aCA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zKCksXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSAxIC8gdGhpcy5ib3JkZXJTY2FsZUZhY3RvcixcbiAgICAgICAgICB3aWR0aCA9IHdoLnggKyBzdHJva2VXaWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB3aC55ICsgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgZHJhd1JvdGF0aW5nUG9pbnQgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNSb3RhdGluZ1BvaW50ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICBzdHlsZU92ZXJyaWRlLmhhc1JvdGF0aW5nUG9pbnQgOiB0aGlzLmhhc1JvdGF0aW5nUG9pbnQsXG4gICAgICAgICAgaGFzQ29udHJvbHMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyA6IHRoaXMuaGFzQ29udHJvbHMsXG4gICAgICAgICAgcm90YXRpbmdQb2ludE9mZnNldCA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLnJvdGF0aW5nUG9pbnRPZmZzZXQgIT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICAgIHN0eWxlT3ZlcnJpZGUucm90YXRpbmdQb2ludE9mZnNldCA6IHRoaXMucm90YXRpbmdQb2ludE9mZnNldDtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuYm9yZGVyQ29sb3IgfHwgdGhpcy5ib3JkZXJDb2xvcjtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgc3R5bGVPdmVycmlkZS5ib3JkZXJEYXNoQXJyYXkgfHwgdGhpcy5ib3JkZXJEYXNoQXJyYXksIG51bGwpO1xuXG4gICAgICBjdHguc3Ryb2tlUmVjdChcbiAgICAgICAgLXdpZHRoIC8gMixcbiAgICAgICAgLWhlaWdodCAvIDIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgICk7XG5cbiAgICAgIGlmIChkcmF3Um90YXRpbmdQb2ludCAmJiB0aGlzLmlzQ29udHJvbFZpc2libGUoJ210cicpICYmIGhhc0NvbnRyb2xzKSB7XG5cbiAgICAgICAgdmFyIHJvdGF0ZUhlaWdodCA9IC1oZWlnaHQgLyAyO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCByb3RhdGVIZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKDAsIHJvdGF0ZUhlaWdodCAtIHJvdGF0aW5nUG9pbnRPZmZzZXQpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYm9yZGVycyBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3ggd2hlbiBpdCBpcyBpbnNpZGUgYSBncm91cC5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodFxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBwYWRkaW5nLCBib3JkZXJDb2xvclxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgb2JqZWN0IHJlcHJlc2VudGluZyBjdXJyZW50IG9iamVjdCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdCb3JkZXJzSW5Hcm91cDogZnVuY3Rpb24oY3R4LCBvcHRpb25zLCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIHZhciBwID0gdGhpcy5fZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zKCksXG4gICAgICAgICAgbWF0cml4ID0gZmFicmljLnV0aWwuY3VzdG9tVHJhbnNmb3JtTWF0cml4KG9wdGlvbnMuc2NhbGVYLCBvcHRpb25zLnNjYWxlWSwgb3B0aW9ucy5za2V3WCksXG4gICAgICAgICAgd2ggPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwLCBtYXRyaXgpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gMSAvIHRoaXMuYm9yZGVyU2NhbGVGYWN0b3IsXG4gICAgICAgICAgd2lkdGggPSB3aC54ICsgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gd2gueSArIHN0cm9rZVdpZHRoO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCBzdHlsZU92ZXJyaWRlLmJvcmRlckRhc2hBcnJheSB8fCB0aGlzLmJvcmRlckRhc2hBcnJheSwgbnVsbCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmJvcmRlckNvbG9yIHx8IHRoaXMuYm9yZGVyQ29sb3I7XG5cbiAgICAgIGN0eC5zdHJva2VSZWN0KFxuICAgICAgICAtd2lkdGggLyAyLFxuICAgICAgICAtaGVpZ2h0IC8gMixcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgKTtcblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBjb3JuZXJzIG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIGJveC5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodFxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBjb3JuZXJTaXplLCBwYWRkaW5nXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZSBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd0NvbnRyb2xzOiBmdW5jdGlvbihjdHgsIHN0eWxlT3ZlcnJpZGUpIHtcbiAgICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgICAgdmFyIHdoID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB3aWR0aCA9IHdoLngsXG4gICAgICAgICAgaGVpZ2h0ID0gd2gueSxcbiAgICAgICAgICBzY2FsZU9mZnNldCA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyU2l6ZSB8fCB0aGlzLmNvcm5lclNpemUsXG4gICAgICAgICAgbGVmdCA9IC0od2lkdGggKyBzY2FsZU9mZnNldCkgLyAyLFxuICAgICAgICAgIHRvcCA9IC0oaGVpZ2h0ICsgc2NhbGVPZmZzZXQpIC8gMixcbiAgICAgICAgICB0cmFuc3BhcmVudENvcm5lcnMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS50cmFuc3BhcmVudENvcm5lcnMgIT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICAgIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzIDogdGhpcy50cmFuc3BhcmVudENvcm5lcnMsXG4gICAgICAgICAgaGFzUm90YXRpbmdQb2ludCA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLmhhc1JvdGF0aW5nUG9pbnQgIT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICAgIHN0eWxlT3ZlcnJpZGUuaGFzUm90YXRpbmdQb2ludCA6IHRoaXMuaGFzUm90YXRpbmdQb2ludCxcbiAgICAgICAgICBtZXRob2ROYW1lID0gdHJhbnNwYXJlbnRDb3JuZXJzID8gJ3N0cm9rZScgOiAnZmlsbCc7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJDb2xvciB8fCB0aGlzLmNvcm5lckNvbG9yO1xuICAgICAgaWYgKCF0aGlzLnRyYW5zcGFyZW50Q29ybmVycykge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IHRoaXMuY29ybmVyU3Ryb2tlQ29sb3I7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHN0eWxlT3ZlcnJpZGUuY29ybmVyRGFzaEFycmF5IHx8IHRoaXMuY29ybmVyRGFzaEFycmF5LCBudWxsKTtcblxuICAgICAgLy8gdG9wLWxlZnRcbiAgICAgIHRoaXMuX2RyYXdDb250cm9sKCd0bCcsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdG9wLCBzdHlsZU92ZXJyaWRlKTtcblxuICAgICAgLy8gdG9wLXJpZ2h0XG4gICAgICB0aGlzLl9kcmF3Q29udHJvbCgndHInLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgIGxlZnQgKyB3aWR0aCxcbiAgICAgICAgdG9wLCBzdHlsZU92ZXJyaWRlKTtcblxuICAgICAgLy8gYm90dG9tLWxlZnRcbiAgICAgIHRoaXMuX2RyYXdDb250cm9sKCdibCcsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdG9wICsgaGVpZ2h0LCBzdHlsZU92ZXJyaWRlKTtcblxuICAgICAgLy8gYm90dG9tLXJpZ2h0XG4gICAgICB0aGlzLl9kcmF3Q29udHJvbCgnYnInLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgIGxlZnQgKyB3aWR0aCxcbiAgICAgICAgdG9wICsgaGVpZ2h0LCBzdHlsZU92ZXJyaWRlKTtcblxuICAgICAgaWYgKCF0aGlzLmdldCgnbG9ja1VuaVNjYWxpbmcnKSkge1xuXG4gICAgICAgIC8vIG1pZGRsZS10b3BcbiAgICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ210JywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICAgIGxlZnQgKyB3aWR0aCAvIDIsXG4gICAgICAgICAgdG9wLCBzdHlsZU92ZXJyaWRlKTtcblxuICAgICAgICAvLyBtaWRkbGUtYm90dG9tXG4gICAgICAgIHRoaXMuX2RyYXdDb250cm9sKCdtYicsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgICBsZWZ0ICsgd2lkdGggLyAyLFxuICAgICAgICAgIHRvcCArIGhlaWdodCwgc3R5bGVPdmVycmlkZSk7XG5cbiAgICAgICAgLy8gbWlkZGxlLXJpZ2h0XG4gICAgICAgIHRoaXMuX2RyYXdDb250cm9sKCdtcicsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgICBsZWZ0ICsgd2lkdGgsXG4gICAgICAgICAgdG9wICsgaGVpZ2h0IC8gMiwgc3R5bGVPdmVycmlkZSk7XG5cbiAgICAgICAgLy8gbWlkZGxlLWxlZnRcbiAgICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ21sJywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgdG9wICsgaGVpZ2h0IC8gMiwgc3R5bGVPdmVycmlkZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1pZGRsZS10b3Atcm90YXRlXG4gICAgICBpZiAoaGFzUm90YXRpbmdQb2ludCkge1xuICAgICAgICB0aGlzLl9kcmF3Q29udHJvbCgnbXRyJywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICAgIGxlZnQgKyB3aWR0aCAvIDIsXG4gICAgICAgICAgdG9wIC0gdGhpcy5yb3RhdGluZ1BvaW50T2Zmc2V0LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RyYXdDb250cm9sOiBmdW5jdGlvbihjb250cm9sLCBjdHgsIG1ldGhvZE5hbWUsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICBpZiAoIXRoaXMuaXNDb250cm9sVmlzaWJsZShjb250cm9sKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuY29ybmVyU2l6ZSwgc3Ryb2tlID0gIXRoaXMudHJhbnNwYXJlbnRDb3JuZXJzICYmIHRoaXMuY29ybmVyU3Ryb2tlQ29sb3I7XG4gICAgICBzd2l0Y2ggKHN0eWxlT3ZlcnJpZGUuY29ybmVyU3R5bGUgfHwgdGhpcy5jb3JuZXJTdHlsZSkge1xuICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHguYXJjKGxlZnQgKyBzaXplIC8gMiwgdG9wICsgc2l6ZSAvIDIsIHNpemUgLyAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgIGN0eFttZXRob2ROYW1lXSgpO1xuICAgICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy50cmFuc3BhcmVudENvcm5lcnMgfHwgY3R4LmNsZWFyUmVjdChsZWZ0LCB0b3AsIHNpemUsIHNpemUpO1xuICAgICAgICAgIGN0eFttZXRob2ROYW1lICsgJ1JlY3QnXShsZWZ0LCB0b3AsIHNpemUsIHNpemUpO1xuICAgICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KGxlZnQsIHRvcCwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBjb250cm9sIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbE5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnRyb2wuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3RsJywgJ3RyJywgJ2JyJywgJ2JsJywgJ21sJywgJ210JywgJ21yJywgJ21iJywgJ210cicuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNwZWNpZmllZCBjb250cm9sIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzQ29udHJvbFZpc2libGU6IGZ1bmN0aW9uKGNvbnRyb2xOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q29udHJvbHNWaXNpYmlsaXR5KClbY29udHJvbE5hbWVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBzcGVjaWZpZWQgY29udHJvbC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbE5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnRyb2wuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3RsJywgJ3RyJywgJ2JyJywgJ2JsJywgJ21sJywgJ210JywgJ21yJywgJ21iJywgJ210cicuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIHRydWUgdG8gc2V0IHRoZSBzcGVjaWZpZWQgY29udHJvbCB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvbnRyb2xWaXNpYmxlOiBmdW5jdGlvbihjb250cm9sTmFtZSwgdmlzaWJsZSkge1xuICAgICAgdGhpcy5fZ2V0Q29udHJvbHNWaXNpYmlsaXR5KClbY29udHJvbE5hbWVdID0gdmlzaWJsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IHN0YXRlIG9mIG9iamVjdCBjb250cm9scy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ibF0gdHJ1ZSB0byBlbmFibGUgdGhlIGJvdHRvbS1sZWZ0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJyXSB0cnVlIHRvIGVuYWJsZSB0aGUgYm90dG9tLXJpZ2h0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1iXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLWJvdHRvbSBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tbF0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1sZWZ0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1yXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLXJpZ2h0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm10XSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLXRvcCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50bF0gdHJ1ZSB0byBlbmFibGUgdGhlIHRvcC1sZWZ0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyXSB0cnVlIHRvIGVuYWJsZSB0aGUgdG9wLXJpZ2h0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm10cl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS10b3Atcm90YXRlIGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvbnRyb2xzVmlzaWJpbGl0eTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIGZvciAodmFyIHAgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNldENvbnRyb2xWaXNpYmxlKHAsIG9wdGlvbnNbcF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBjb250cm9sIHZpc2liaWxpdHkgc2V0IGZvciB0aGlzIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgX2dldENvbnRyb2xzVmlzaWJpbGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eSkge1xuICAgICAgICB0aGlzLl9jb250cm9sc1Zpc2liaWxpdHkgPSB7XG4gICAgICAgICAgdGw6IHRydWUsXG4gICAgICAgICAgdHI6IHRydWUsXG4gICAgICAgICAgYnI6IHRydWUsXG4gICAgICAgICAgYmw6IHRydWUsXG4gICAgICAgICAgbWw6IHRydWUsXG4gICAgICAgICAgbXQ6IHRydWUsXG4gICAgICAgICAgbXI6IHRydWUsXG4gICAgICAgICAgbWI6IHRydWUsXG4gICAgICAgICAgbXRyOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY29udHJvbHNWaXNpYmlsaXR5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBldmVyeSB0aW1lIF9kaXNjYXJkQWN0aXZlT2JqZWN0IG9yIF9zZXRBY3RpdmVPYmplY3RcbiAgICAgKiB0cnkgdG8gdG8gZGVzZWxlY3QgdGhpcyBvYmplY3QuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIHRoZSBwcm9jZXNzIGlzIGNhbmNlbGxlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBzZW50IGZyb20gdGhlIHVwcGVyIGZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtvcHRpb25zLmVdIGV2ZW50IGlmIHRoZSBwcm9jZXNzIGlzIGdlbmVyYXRlZCBieSBhbiBldmVudFxuICAgICAqL1xuICAgIG9uRGVzZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzZXMsIGFzIG5lZWRlZC5cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBldmVyeSB0aW1lIF9kaXNjYXJkQWN0aXZlT2JqZWN0IG9yIF9zZXRBY3RpdmVPYmplY3RcbiAgICAgKiB0cnkgdG8gdG8gc2VsZWN0IHRoaXMgb2JqZWN0LiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCB0aGUgcHJvY2VzcyBpcyBjYW5jZWxsZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgc2VudCBmcm9tIHRoZSB1cHBlciBmdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbb3B0aW9ucy5lXSBldmVudCBpZiB0aGUgcHJvY2VzcyBpcyBnZW5lcmF0ZWQgYnkgYW4gZXZlbnRcbiAgICAgKi9cbiAgICBvblNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpbXBsZW1lbnRlZCBieSBzdWItY2xhc3NlcywgYXMgbmVlZGVkLlxuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBBbmltYXRpb24gZHVyYXRpb24gKGluIG1zKSBmb3IgZngqIG1ldGhvZHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBGWF9EVVJBVElPTjogNTAwLFxuXG4gIC8qKlxuICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgd2l0aCBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja3NdIENhbGxiYWNrcyBvYmplY3Qgd2l0aCBvcHRpb25hbCBcIm9uQ29tcGxldGVcIiBhbmQvb3IgXCJvbkNoYW5nZVwiIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ4Q2VudGVyT2JqZWN0SDogZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC5sZWZ0LFxuICAgICAgZW5kVmFsdWU6IHRoaXMuZ2V0Q2VudGVyKCkubGVmdCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ2xlZnQnLCB2YWx1ZSk7XG4gICAgICAgIF90aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSB3aXRoIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gQ2FsbGJhY2tzIG9iamVjdCB3aXRoIG9wdGlvbmFsIFwib25Db21wbGV0ZVwiIGFuZC9vciBcIm9uQ2hhbmdlXCIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnhDZW50ZXJPYmplY3RWOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgc3RhcnRWYWx1ZTogb2JqZWN0LnRvcCxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLmdldENlbnRlcigpLnRvcCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ3RvcCcsIHZhbHVlKTtcbiAgICAgICAgX3RoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGBmYWJyaWMuQ2FudmFzI3JlbW92ZWAgYnV0IGFuaW1hdGVkXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byByZW1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja3NdIENhbGxiYWNrcyBvYmplY3Qgd2l0aCBvcHRpb25hbCBcIm9uQ29tcGxldGVcIiBhbmQvb3IgXCJvbkNoYW5nZVwiIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ4UmVtb3ZlOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgc3RhcnRWYWx1ZTogb2JqZWN0Lm9wYWNpdHksXG4gICAgICBlbmRWYWx1ZTogMCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ29wYWNpdHknLCB2YWx1ZSk7XG4gICAgICAgIF90aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlbW92ZShvYmplY3QpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuICAvKipcbiAgICogQW5pbWF0ZXMgb2JqZWN0J3MgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHByb3BlcnR5IFByb3BlcnR5IHRvIGFuaW1hdGUgKGlmIHN0cmluZykgb3IgcHJvcGVydGllcyB0byBhbmltYXRlIChpZiBvYmplY3QpXG4gICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gdmFsdWUgVmFsdWUgdG8gYW5pbWF0ZSBwcm9wZXJ0eSB0byAoaWYgc3RyaW5nIHdhcyBnaXZlbiBmaXJzdCkgb3Igb3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNhbmltYXRpb259XG4gICAqIEBjaGFpbmFibGVcbiAgICpcbiAgICogQXMgb2JqZWN0IOKAlCBtdWx0aXBsZSBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIG9iamVjdC5hbmltYXRlKHsgbGVmdDogLi4uLCB0b3A6IC4uLiB9KTtcbiAgICogb2JqZWN0LmFuaW1hdGUoeyBsZWZ0OiAuLi4sIHRvcDogLi4uIH0sIHsgZHVyYXRpb246IC4uLiB9KTtcbiAgICpcbiAgICogQXMgc3RyaW5nIOKAlCBvbmUgcHJvcGVydHlcbiAgICpcbiAgICogb2JqZWN0LmFuaW1hdGUoJ2xlZnQnLCAuLi4pO1xuICAgKiBvYmplY3QuYW5pbWF0ZSgnbGVmdCcsIHsgZHVyYXRpb246IC4uLiB9KTtcbiAgICpcbiAgICovXG4gIGFuaW1hdGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBwcm9wc1RvQW5pbWF0ZSA9IFtdLCBwcm9wLCBza2lwQ2FsbGJhY2tzO1xuICAgICAgZm9yIChwcm9wIGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICBwcm9wc1RvQW5pbWF0ZS5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BzVG9BbmltYXRlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1RvQW5pbWF0ZVtpXTtcbiAgICAgICAgc2tpcENhbGxiYWNrcyA9IGkgIT09IGxlbiAtIDE7XG4gICAgICAgIHRoaXMuX2FuaW1hdGUocHJvcCwgYXJndW1lbnRzWzBdW3Byb3BdLCBhcmd1bWVudHNbMV0sIHNraXBDYWxsYmFja3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX2FuaW1hdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBhbmltYXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0byBWYWx1ZSB0byBhbmltYXRlIHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcENhbGxiYWNrc10gV2hlbiB0cnVlLCBjYWxsYmFja3MgbGlrZSBvbmNoYW5nZSBhbmQgb25jb21wbGV0ZSBhcmUgbm90IGludm9rZWRcbiAgICovXG4gIF9hbmltYXRlOiBmdW5jdGlvbihwcm9wZXJ0eSwgdG8sIG9wdGlvbnMsIHNraXBDYWxsYmFja3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLCBwcm9wUGFpcjtcblxuICAgIHRvID0gdG8udG9TdHJpbmcoKTtcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZignLicpKSB7XG4gICAgICBwcm9wUGFpciA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHByb3BQYWlyXG4gICAgICA/IHRoaXMuZ2V0KHByb3BQYWlyWzBdKVtwcm9wUGFpclsxXV1cbiAgICAgIDogdGhpcy5nZXQocHJvcGVydHkpO1xuXG4gICAgaWYgKCEoJ2Zyb20nIGluIG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zLmZyb20gPSBjdXJyZW50VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKH50by5pbmRleE9mKCc9JykpIHtcbiAgICAgIHRvID0gY3VycmVudFZhbHVlICsgcGFyc2VGbG9hdCh0by5yZXBsYWNlKCc9JywgJycpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0byA9IHBhcnNlRmxvYXQodG8pO1xuICAgIH1cblxuICAgIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgc3RhcnRWYWx1ZTogb3B0aW9ucy5mcm9tLFxuICAgICAgZW5kVmFsdWU6IHRvLFxuICAgICAgYnlWYWx1ZTogb3B0aW9ucy5ieSxcbiAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcsXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgIGFib3J0OiBvcHRpb25zLmFib3J0ICYmIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5hYm9ydC5jYWxsKF90aGlzKTtcbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcykge1xuICAgICAgICBpZiAocHJvcFBhaXIpIHtcbiAgICAgICAgICBfdGhpc1twcm9wUGFpclswXV1bcHJvcFBhaXJbMV1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgX3RoaXMuc2V0KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBDYWxsYmFja3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5vbkNoYW5nZSAmJiBvcHRpb25zLm9uQ2hhbmdlKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHNraXBDYWxsYmFja3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlICYmIG9wdGlvbnMub25Db21wbGV0ZSh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICBjb29yZFByb3BzID0geyB4MTogMSwgeDI6IDEsIHkxOiAxLCB5MjogMSB9LFxuICAgICAgc3VwcG9ydHNMaW5lRGFzaCA9IGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJyk7XG5cbiAgaWYgKGZhYnJpYy5MaW5lKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5MaW5lIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW5lIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuTGluZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5MaW5lI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuTGluZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkxpbmUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnbGluZScsXG5cbiAgICAvKipcbiAgICAgKiB4IHZhbHVlIG9yIGZpcnN0IGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeDE6IDAsXG5cbiAgICAvKipcbiAgICAgKiB5IHZhbHVlIG9yIGZpcnN0IGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeTE6IDAsXG5cbiAgICAvKipcbiAgICAgKiB4IHZhbHVlIG9yIHNlY29uZCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHgyOiAwLFxuXG4gICAgLyoqXG4gICAgICogeSB2YWx1ZSBvciBzZWNvbmQgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB5MjogMCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgneDEnLCAneDInLCAneTEnLCAneTInKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BvaW50c10gQXJyYXkgb2YgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5MaW5lfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICBwb2ludHMgPSBbMCwgMCwgMCwgMF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuc2V0KCd4MScsIHBvaW50c1swXSk7XG4gICAgICB0aGlzLnNldCgneTEnLCBwb2ludHNbMV0pO1xuICAgICAgdGhpcy5zZXQoJ3gyJywgcG9pbnRzWzJdKTtcbiAgICAgIHRoaXMuc2V0KCd5MicsIHBvaW50c1szXSk7XG5cbiAgICAgIHRoaXMuX3NldFdpZHRoSGVpZ2h0KG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uc1xuICAgICAqL1xuICAgIF9zZXRXaWR0aEhlaWdodDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHRoaXMud2lkdGggPSBNYXRoLmFicyh0aGlzLngyIC0gdGhpcy54MSk7XG4gICAgICB0aGlzLmhlaWdodCA9IE1hdGguYWJzKHRoaXMueTIgLSB0aGlzLnkxKTtcblxuICAgICAgdGhpcy5sZWZ0ID0gJ2xlZnQnIGluIG9wdGlvbnNcbiAgICAgICAgPyBvcHRpb25zLmxlZnRcbiAgICAgICAgOiB0aGlzLl9nZXRMZWZ0VG9PcmlnaW5YKCk7XG5cbiAgICAgIHRoaXMudG9wID0gJ3RvcCcgaW4gb3B0aW9uc1xuICAgICAgICA/IG9wdGlvbnMudG9wXG4gICAgICAgIDogdGhpcy5fZ2V0VG9wVG9PcmlnaW5ZKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldCcsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBjb29yZFByb3BzW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX3NldFdpZHRoSGVpZ2h0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGxlZnRUb09yaWdpblggRGlzdGFuY2UgZnJvbSBsZWZ0IGVkZ2Ugb2YgY2FudmFzIHRvIG9yaWdpblggb2YgTGluZS5cbiAgICAgKi9cbiAgICBfZ2V0TGVmdFRvT3JpZ2luWDogbWFrZUVkZ2VUb09yaWdpbkdldHRlcihcbiAgICAgIHsgLy8gcHJvcGVydHkgbmFtZXNcbiAgICAgICAgb3JpZ2luOiAnb3JpZ2luWCcsXG4gICAgICAgIGF4aXMxOiAneDEnLFxuICAgICAgICBheGlzMjogJ3gyJyxcbiAgICAgICAgZGltZW5zaW9uOiAnd2lkdGgnXG4gICAgICB9LFxuICAgICAgeyAvLyBwb3NzaWJsZSB2YWx1ZXMgb2Ygb3JpZ2luXG4gICAgICAgIG5lYXJlc3Q6ICdsZWZ0JyxcbiAgICAgICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICAgICAgZmFydGhlc3Q6ICdyaWdodCdcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRvcFRvT3JpZ2luWSBEaXN0YW5jZSBmcm9tIHRvcCBlZGdlIG9mIGNhbnZhcyB0byBvcmlnaW5ZIG9mIExpbmUuXG4gICAgICovXG4gICAgX2dldFRvcFRvT3JpZ2luWTogbWFrZUVkZ2VUb09yaWdpbkdldHRlcihcbiAgICAgIHsgLy8gcHJvcGVydHkgbmFtZXNcbiAgICAgICAgb3JpZ2luOiAnb3JpZ2luWScsXG4gICAgICAgIGF4aXMxOiAneTEnLFxuICAgICAgICBheGlzMjogJ3kyJyxcbiAgICAgICAgZGltZW5zaW9uOiAnaGVpZ2h0J1xuICAgICAgfSxcbiAgICAgIHsgLy8gcG9zc2libGUgdmFsdWVzIG9mIG9yaWdpblxuICAgICAgICBuZWFyZXN0OiAndG9wJyxcbiAgICAgICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICAgICAgZmFydGhlc3Q6ICdib3R0b20nXG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBpZiAoIXRoaXMuc3Ryb2tlRGFzaEFycmF5IHx8IHRoaXMuc3Ryb2tlRGFzaEFycmF5ICYmIHN1cHBvcnRzTGluZURhc2gpIHtcbiAgICAgICAgLy8gbW92ZSBmcm9tIGNlbnRlciAob2YgdmlydHVhbCBib3gpIHRvIGl0cyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgICAgLy8gd2UgY2FuJ3QgYXNzdW1lIHgxLCB5MSBpcyB0b3AgbGVmdCBhbmQgeDIsIHkyIGlzIGJvdHRvbSByaWdodFxuICAgICAgICB2YXIgcCA9IHRoaXMuY2FsY0xpbmVQb2ludHMoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwLngxLCBwLnkxKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwLngyLCBwLnkyKTtcbiAgICAgIH1cblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XG5cbiAgICAgIC8vIFRPRE86IHRlc3QgdGhpc1xuICAgICAgLy8gbWFrZSBzdXJlIHNldHRpbmcgXCJmaWxsXCIgY2hhbmdlcyBjb2xvciBvZiBhIGxpbmVcbiAgICAgIC8vIChieSBjb3B5aW5nIGZpbGxTdHlsZSB0byBzdHJva2VTdHlsZSwgc2luY2UgbGluZSBpcyBzdHJva2VkLCBub3QgZmlsbGVkKVxuICAgICAgdmFyIG9yaWdTdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlIHx8IGN0eC5maWxsU3R5bGU7XG4gICAgICB0aGlzLnN0cm9rZSAmJiB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9yaWdTdHJva2VTdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckRhc2hlZFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgcCA9IHRoaXMuY2FsY0xpbmVQb2ludHMoKTtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBwLngxLCBwLnkxLCBwLngyLCBwLnkyLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYW4gaGVscGVyIGZvciBzdmcgaW1wb3J0LiBpdCByZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIG9iamVjdCBpbiB0aGUgc3ZnXG4gICAgICogdW50cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgcG9pbnQgZnJvbSBlbGVtZW50IGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgX2ZpbmRDZW50ZXJGcm9tRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAodGhpcy54MSArIHRoaXMueDIpIC8gMixcbiAgICAgICAgeTogKHRoaXMueTEgKyB0aGlzLnkyKSAvIDIsXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBtZXRoZCB0b09iamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB0aGlzLmNhbGNMaW5lUG9pbnRzKCkpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaW0gPSB0aGlzLmNhbGxTdXBlcignX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucycpO1xuICAgICAgaWYgKHRoaXMuc3Ryb2tlTGluZUNhcCA9PT0gJ2J1dHQnKSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgZGltLnkgLT0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBkaW0ueCAtPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGltO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgbGluZSBwb2ludHMgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2FsY0xpbmVQb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHhNdWx0ID0gdGhpcy54MSA8PSB0aGlzLngyID8gLTEgOiAxLFxuICAgICAgICAgIHlNdWx0ID0gdGhpcy55MSA8PSB0aGlzLnkyID8gLTEgOiAxLFxuICAgICAgICAgIHgxID0gKHhNdWx0ICogdGhpcy53aWR0aCAqIDAuNSksXG4gICAgICAgICAgeTEgPSAoeU11bHQgKiB0aGlzLmhlaWdodCAqIDAuNSksXG4gICAgICAgICAgeDIgPSAoeE11bHQgKiB0aGlzLndpZHRoICogLTAuNSksXG4gICAgICAgICAgeTIgPSAoeU11bHQgKiB0aGlzLmhlaWdodCAqIC0wLjUpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB5MjogeTJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPGxpbmUgJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICd4MT1cIicsIHAueDEsXG4gICAgICAgICdcIiB5MT1cIicsIHAueTEsXG4gICAgICAgICdcIiB4Mj1cIicsIHAueDIsXG4gICAgICAgICdcIiB5Mj1cIicsIHAueTIsXG4gICAgICAgICdcIiAvPlxcbidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuTGluZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5MaW5lXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0xpbmVFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4MSB5MSB4MiB5Micuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuTGluZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMpLFxuICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy54MSB8fCAwLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueTEgfHwgMCxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLngyIHx8IDAsXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy55MiB8fCAwXG4gICAgICAgIF07XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5MaW5lKHBvaW50cywgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkxpbmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIF9jYWxsYmFjayhpbnN0YW5jZSkge1xuICAgICAgZGVsZXRlIGluc3RhbmNlLnBvaW50cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICB9O1xuICAgIHZhciBvcHRpb25zID0gY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBvcHRpb25zLnBvaW50cyA9IFtvYmplY3QueDEsIG9iamVjdC55MSwgb2JqZWN0LngyLCBvYmplY3QueTJdO1xuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0xpbmUnLCBvcHRpb25zLCBfY2FsbGJhY2ssICdwb2ludHMnKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBmdW5jdGlvbiB0aGF0IGNhbGN1bGF0ZXMgZGlzdGFuY2UgZnJvbSBjYW52YXMgZWRnZSB0byBMaW5lIG9yaWdpbi5cbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIocHJvcGVydHlOYW1lcywgb3JpZ2luVmFsdWVzKSB7XG4gICAgdmFyIG9yaWdpbiA9IHByb3BlcnR5TmFtZXMub3JpZ2luLFxuICAgICAgICBheGlzMSA9IHByb3BlcnR5TmFtZXMuYXhpczEsXG4gICAgICAgIGF4aXMyID0gcHJvcGVydHlOYW1lcy5heGlzMixcbiAgICAgICAgZGltZW5zaW9uID0gcHJvcGVydHlOYW1lcy5kaW1lbnNpb24sXG4gICAgICAgIG5lYXJlc3QgPSBvcmlnaW5WYWx1ZXMubmVhcmVzdCxcbiAgICAgICAgY2VudGVyID0gb3JpZ2luVmFsdWVzLmNlbnRlcixcbiAgICAgICAgZmFydGhlc3QgPSBvcmlnaW5WYWx1ZXMuZmFydGhlc3Q7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuZ2V0KG9yaWdpbikpIHtcbiAgICAgICAgY2FzZSBuZWFyZXN0OlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSk7XG4gICAgICAgIGNhc2UgY2VudGVyOlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSkgKyAoMC41ICogdGhpcy5nZXQoZGltZW5zaW9uKSk7XG4gICAgICAgIGNhc2UgZmFydGhlc3Q6XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuZ2V0KGF4aXMxKSwgdGhpcy5nZXQoYXhpczIpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIH1cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgcGkgPSBNYXRoLlBJO1xuXG4gIGlmIChmYWJyaWMuQ2lyY2xlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5DaXJjbGUgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjbGUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5DaXJjbGVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQ2lyY2xlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuQ2lyY2xlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2NpcmNsZScsXG5cbiAgICAvKipcbiAgICAgKiBSYWRpdXMgb2YgdGhpcyBjaXJjbGVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJhZGl1czogMCxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGFuZ2xlIG9mIHRoZSBjaXJjbGUsIG1vdmluZyBjbG9ja3dpc2VcbiAgICAgKiBkZXByZWN0YXRlZCB0eXBlLCB0aGlzIHNob3VsZCBiZSBpbiBkZWdyZWUsIHRoaXMgd2FzIGFuIG92ZXJzaWdodC5cbiAgICAgKiBwcm9iYWJseSB3aWxsIGNoYW5nZSB0byBkZWdyZWVzIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogRW5kIGFuZ2xlIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBkZXByZWN0YXRlZCB0eXBlLCB0aGlzIHNob3VsZCBiZSBpbiBkZWdyZWUsIHRoaXMgd2FzIGFuIG92ZXJzaWdodC5cbiAgICAgKiBwcm9iYWJseSB3aWxsIGNoYW5nZSB0byBkZWdyZWVzIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDJQaVxuICAgICAqL1xuICAgIGVuZEFuZ2xlOiBwaSAqIDIsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJyksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChrZXkgPT09ICdyYWRpdXMnKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcsIHggPSAwLCB5ID0gMCxcbiAgICAgICAgICBhbmdsZSA9ICh0aGlzLmVuZEFuZ2xlIC0gdGhpcy5zdGFydEFuZ2xlKSAlICggMiAqIHBpKTtcblxuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHN2Z1N0cmluZyA9IFtcbiAgICAgICAgICAnPGNpcmNsZSAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgICAnY3g9XCInICsgeCArICdcIiBjeT1cIicgKyB5ICsgJ1wiICcsXG4gICAgICAgICAgJ3I9XCInLCB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAnXCIgLz5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXJ0WCA9IGZhYnJpYy51dGlsLmNvcyh0aGlzLnN0YXJ0QW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBzdGFydFkgPSBmYWJyaWMudXRpbC5zaW4odGhpcy5zdGFydEFuZ2xlKSAqIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgZW5kWCA9IGZhYnJpYy51dGlsLmNvcyh0aGlzLmVuZEFuZ2xlKSAqIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgZW5kWSA9IGZhYnJpYy51dGlsLnNpbih0aGlzLmVuZEFuZ2xlKSAqIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgbGFyZ2VGbGFnID0gYW5nbGUgPiBwaSA/ICcxJyA6ICcwJztcbiAgICAgICAgc3ZnU3RyaW5nID0gW1xuICAgICAgICAgICc8cGF0aCBkPVwiTSAnICsgc3RhcnRYICsgJyAnICsgc3RhcnRZLFxuICAgICAgICAgICcgQSAnICsgdGhpcy5yYWRpdXMgKyAnICcgKyB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAnIDAgJywgK2xhcmdlRmxhZyArICcgMScsICcgJyArIGVuZFggKyAnICcgKyBlbmRZLFxuICAgICAgICAgICdcIicsICdDT01NT05fUEFSVFMnLCAnIC8+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN2Z1N0cmluZztcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5zdGFydEFuZ2xlLFxuICAgICAgICB0aGlzLmVuZEFuZ2xlLCBmYWxzZSk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3Jpem9udGFsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmFkaXVzWDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3JhZGl1cycpICogdGhpcy5nZXQoJ3NjYWxlWCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZlcnRpY2FsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmFkaXVzWTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3JhZGl1cycpICogdGhpcy5nZXQoJ3NjYWxlWScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFuZCB1cGRhdGVzIHdpZHRoIGFjY29yZGluZ2x5KVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DaXJjbGV9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXRSYWRpdXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KCd3aWR0aCcsIHZhbHVlICogMikuc2V0KCdoZWlnaHQnLCB2YWx1ZSAqIDIpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkNpcmNsZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0NpcmNsZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgnY3ggY3kgcicuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5DaXJjbGV9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHZhbHVlIG9mIGByYCBhdHRyaWJ1dGUgaXMgbWlzc2luZyBvciBpbnZhbGlkXG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLkNpcmNsZS5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgaWYgKCFpc1ZhbGlkUmFkaXVzKHBhcnNlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIG9mIGByYCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgYW5kIGNhbiBub3QgYmUgbmVnYXRpdmUnKTtcbiAgICB9XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSAocGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yYWRpdXM7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgPSAocGFyc2VkQXR0cmlidXRlcy50b3AgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJhZGl1cztcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLkNpcmNsZShwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpc1ZhbGlkUmFkaXVzKGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKCgncmFkaXVzJyBpbiBhdHRyaWJ1dGVzKSAmJiAoYXR0cmlidXRlcy5yYWRpdXMgPj0gMCkpO1xuICB9XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5DaXJjbGV9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gSW5zdGFuY2Ugb2YgZmFicmljLkNpcmNsZVxuICAgKi9cbiAgZmFicmljLkNpcmNsZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdDaXJjbGUnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuVHJpYW5nbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlRyaWFuZ2xlIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRyaWFuZ2xlfSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UcmlhbmdsZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRyaWFuZ2xlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuVHJpYW5nbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndHJpYW5nbGUnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggaXMgc2V0IHRvIDEwMCB0byBjb21wZW5zYXRlIHRoZSBvbGQgaW5pdGlhbGl6ZSBjb2RlIHRoYXQgd2FzIHNldHRpbmcgaXQgdG8gMTAwXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogMTAwLFxuXG4gICAgLyoqXG4gICAgICogSGVpZ2h0IGlzIHNldCB0byAxMDAgdG8gY29tcGVuc2F0ZSB0aGUgb2xkIGluaXRpYWxpemUgY29kZSB0aGF0IHdhcyBzZXR0aW5nIGl0IHRvIDEwMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGVpZ2h0OiAxMDAsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygtd2lkdGhCeTIsIGhlaWdodEJ5Mik7XG4gICAgICBjdHgubGluZVRvKDAsIC1oZWlnaHRCeTIpO1xuICAgICAgY3R4LmxpbmVUbyh3aWR0aEJ5MiwgaGVpZ2h0QnkyKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHdpZHRoQnkyID0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0QnkyID0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIC13aWR0aEJ5MiwgaGVpZ2h0QnkyLCAwLCAtaGVpZ2h0QnkyLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIDAsIC1oZWlnaHRCeTIsIHdpZHRoQnkyLCBoZWlnaHRCeTIsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgd2lkdGhCeTIsIGhlaWdodEJ5MiwgLXdpZHRoQnkyLCBoZWlnaHRCeTIsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgd2lkdGhCeTIgPSB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgICBoZWlnaHRCeTIgPSB0aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgICAgLXdpZHRoQnkyICsgJyAnICsgaGVpZ2h0QnkyLFxuICAgICAgICAgICAgJzAgJyArIC1oZWlnaHRCeTIsXG4gICAgICAgICAgICB3aWR0aEJ5MiArICcgJyArIGhlaWdodEJ5MlxuICAgICAgICAgIF0uam9pbignLCcpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxwb2x5Z29uICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAncG9pbnRzPVwiJywgcG9pbnRzLFxuICAgICAgICAnXCIgLz4nXG4gICAgICBdO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuVHJpYW5nbGV9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UcmlhbmdsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICovXG4gIGZhYnJpYy5UcmlhbmdsZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdUcmlhbmdsZScsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBwaUJ5MiAgID0gTWF0aC5QSSAqIDI7XG5cbiAgaWYgKGZhYnJpYy5FbGxpcHNlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5FbGxpcHNlIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogRWxsaXBzZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkVsbGlwc2VcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuRWxsaXBzZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5FbGxpcHNlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2VsbGlwc2UnLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ4OiAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ5OiAgIDAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3J4JywgJ3J5JyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldCgncngnLCBvcHRpb25zICYmIG9wdGlvbnMucnggfHwgMCk7XG4gICAgICB0aGlzLnNldCgncnknLCBvcHRpb25zICYmIG9wdGlvbnMucnkgfHwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuXG4gICAgICAgIGNhc2UgJ3J4JzpcbiAgICAgICAgICB0aGlzLnJ4ID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zZXQoJ3dpZHRoJywgdmFsdWUgKiAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyeSc6XG4gICAgICAgICAgdGhpcy5yeSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc2V0KCdoZWlnaHQnLCB2YWx1ZSAqIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3Jpem9udGFsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Ung6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdyeCcpICogdGhpcy5nZXQoJ3NjYWxlWCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFZlcnRpY2FsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Unk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdyeScpICogdGhpcy5nZXQoJ3NjYWxlWScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgWydyeCcsICdyeSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxlbGxpcHNlICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAnY3g9XCIwXCIgY3k9XCIwXCIgJyxcbiAgICAgICAgJ3J4PVwiJywgdGhpcy5yeCxcbiAgICAgICAgJ1wiIHJ5PVwiJywgdGhpcy5yeSxcbiAgICAgICAgJ1wiIC8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCB0aGlzLnJ5IC8gdGhpcy5yeCwgMCwgMCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnJ4LFxuICAgICAgICAwLFxuICAgICAgICBwaUJ5MixcbiAgICAgICAgZmFsc2UpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkVsbGlwc2UuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNFbGxpcHNlRWxlbWVudFxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgnY3ggY3kgcnggcnknLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuRWxsaXBzZX0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfVxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5FbGxpcHNlLkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSAocGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yeDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCA9IChwYXJzZWRBdHRyaWJ1dGVzLnRvcCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucnk7XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5FbGxpcHNlKHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkVsbGlwc2V9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX1cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0VsbGlwc2UnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcblxuICBpZiAoZmFicmljLlJlY3QpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlJlY3QgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3RhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlJlY3RcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUmVjdH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUmVjdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlJlY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5SZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBzdGF0ZSBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoe0BsaW5rIGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkfSlcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoJ3J4JywgJ3J5JyksXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3JlY3QnLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBib3JkZXIgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeDogICAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgYm9yZGVyIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcnk6ICAgMCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncngnLCAncnknKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0UnhSeSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyByeC9yeSBhdHRyaWJ1dGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFJ4Unk6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucnggJiYgIXRoaXMucnkpIHtcbiAgICAgICAgdGhpcy5yeSA9IHRoaXMucng7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnJ5ICYmICF0aGlzLnJ4KSB7XG4gICAgICAgIHRoaXMucnggPSB0aGlzLnJ5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcblxuICAgICAgLy8gMXgxIGNhc2UgKHVzZWQgaW4gc3ByYXkgYnJ1c2gpIG9wdGltaXphdGlvbiB3YXMgcmVtb3ZlZCBiZWNhdXNlXG4gICAgICAvLyB3aXRoIGNhY2hpbmcgYW5kIGhpZ2hlciB6b29tIGxldmVsIHRoaXMgbWFrZXMgbW9yZSBkYW1hZ2UgdGhhbiBoZWxwXG5cbiAgICAgIHZhciByeCA9IHRoaXMucnggPyBNYXRoLm1pbih0aGlzLnJ4LCB0aGlzLndpZHRoIC8gMikgOiAwLFxuICAgICAgICAgIHJ5ID0gdGhpcy5yeSA/IE1hdGgubWluKHRoaXMucnksIHRoaXMuaGVpZ2h0IC8gMikgOiAwLFxuICAgICAgICAgIHcgPSB0aGlzLndpZHRoLFxuICAgICAgICAgIGggPSB0aGlzLmhlaWdodCxcbiAgICAgICAgICB4ID0gLXRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIHkgPSAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICAgIGlzUm91bmRlZCA9IHJ4ICE9PSAwIHx8IHJ5ICE9PSAwLFxuICAgICAgICAgIC8qIFwibWFnaWMgbnVtYmVyXCIgZm9yIGJlemllciBhcHByb3hpbWF0aW9ucyBvZiBhcmNzIChodHRwOi8vaXRjLmt0dS5sdC9pdGMzNTQvUmlza3VzMzU0LnBkZikgKi9cbiAgICAgICAgICBrID0gMSAtIDAuNTUyMjg0NzQ5ODtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgY3R4Lm1vdmVUbyh4ICsgcngsIHkpO1xuXG4gICAgICBjdHgubGluZVRvKHggKyB3IC0gcngsIHkpO1xuICAgICAgaXNSb3VuZGVkICYmIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3IC0gayAqIHJ4LCB5LCB4ICsgdywgeSArIGsgKiByeSwgeCArIHcsIHkgKyByeSk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcnkpO1xuICAgICAgaXNSb3VuZGVkICYmIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3LCB5ICsgaCAtIGsgKiByeSwgeCArIHcgLSBrICogcngsIHkgKyBoLCB4ICsgdyAtIHJ4LCB5ICsgaCk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHJ4LCB5ICsgaCk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIGsgKiByeCwgeSArIGgsIHgsIHkgKyBoIC0gayAqIHJ5LCB4LCB5ICsgaCAtIHJ5KTtcblxuICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcnkpO1xuICAgICAgaXNSb3VuZGVkICYmIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHkgKyBrICogcnksIHggKyBrICogcngsIHksIHggKyByeCwgeSk7XG5cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHggPSAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgeSA9IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHgsIHksIHggKyB3LCB5LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHggKyB3LCB5LCB4ICsgdywgeSArIGgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCArIHcsIHkgKyBoLCB4LCB5ICsgaCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4LCB5ICsgaCwgeCwgeSwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgWydyeCcsICdyeSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSAtdGhpcy53aWR0aCAvIDIsIHkgPSAtdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxyZWN0ICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAneD1cIicsIHgsICdcIiB5PVwiJywgeSxcbiAgICAgICAgJ1wiIHJ4PVwiJywgdGhpcy5yeCwgJ1wiIHJ5PVwiJywgdGhpcy5yeSxcbiAgICAgICAgJ1wiIHdpZHRoPVwiJywgdGhpcy53aWR0aCwgJ1wiIGhlaWdodD1cIicsIHRoaXMuaGVpZ2h0LFxuICAgICAgICAnXCIgLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlJlY3QuZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUmVjdFxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUmVjdEVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5SZWN0LkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ3ggeSByeCByeSB3aWR0aCBoZWlnaHQnLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuUmVjdH0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUmVjdFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIHBhcnNpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLlJlY3QuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG5cbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlJlY3QuQVRUUklCVVRFX05BTUVTKTtcblxuICAgIHBhcnNlZEF0dHJpYnV0ZXMubGVmdCA9IHBhcnNlZEF0dHJpYnV0ZXMubGVmdCB8fCAwO1xuICAgIHBhcnNlZEF0dHJpYnV0ZXMudG9wICA9IHBhcnNlZEF0dHJpYnV0ZXMudG9wICB8fCAwO1xuICAgIHZhciByZWN0ID0gbmV3IGZhYnJpYy5SZWN0KGV4dGVuZCgob3B0aW9ucyA/IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKSA6IHsgfSksIHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgICByZWN0LnZpc2libGUgPSByZWN0LnZpc2libGUgJiYgcmVjdC53aWR0aCA+IDAgJiYgcmVjdC5oZWlnaHQgPiAwO1xuICAgIGNhbGxiYWNrKHJlY3QpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuUmVjdH0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUmVjdCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuUmVjdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdSZWN0Jywgb2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBtaW4gPSBmYWJyaWMudXRpbC5hcnJheS5taW4sXG4gICAgICBtYXggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZDtcblxuICBpZiAoZmFicmljLlBvbHlsaW5lKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2x5bGluZSBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUG9seWxpbmUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5Qb2x5bGluZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuUG9seWxpbmUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncG9seWxpbmUnLFxuXG4gICAgLyoqXG4gICAgICogUG9pbnRzIGFycmF5XG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBvaW50czogbnVsbCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncG9pbnRzJyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHMgKHdoZXJlIGVhY2ggcG9pbnQgaXMgYW4gb2JqZWN0IHdpdGggeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvbHlsaW5lfSB0aGlzQXJnXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9seSA9IG5ldyBmYWJyaWMuUG9seWxpbmUoW1xuICAgICAqICAgICB7IHg6IDEwLCB5OiAxMCB9LFxuICAgICAqICAgICB7IHg6IDUwLCB5OiAzMCB9LFxuICAgICAqICAgICB7IHg6IDQwLCB5OiA3MCB9LFxuICAgICAqICAgICB7IHg6IDYwLCB5OiA1MCB9LFxuICAgICAqICAgICB7IHg6IDEwMCwgeTogMTUwIH0sXG4gICAgICogICAgIHsgeDogNDAsIHk6IDEwMCB9XG4gICAgICogICBdLCB7XG4gICAgICogICBzdHJva2U6ICdyZWQnLFxuICAgICAqICAgbGVmdDogMTAwLFxuICAgICAqICAgdG9wOiAxMDBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHMgfHwgW107XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdmFyIGNhbGNEaW0gPSB0aGlzLl9jYWxjRGltZW5zaW9ucygpO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxlZnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMubGVmdCA9IGNhbGNEaW0ubGVmdDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b3AgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMudG9wID0gY2FsY0RpbS50b3A7XG4gICAgICB9XG4gICAgICB0aGlzLndpZHRoID0gY2FsY0RpbS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gY2FsY0RpbS5oZWlnaHQ7XG4gICAgICB0aGlzLnBhdGhPZmZzZXQgPSB7XG4gICAgICAgIHg6IGNhbGNEaW0ubGVmdCArIHRoaXMud2lkdGggLyAyLFxuICAgICAgICB5OiBjYWxjRGltLnRvcCArIHRoaXMuaGVpZ2h0IC8gMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb2x5Z29uIG1pbiBhbmQgbWF4IHBvaW50IGZyb20gcG9pbnRzIGFycmF5LFxuICAgICAqIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBsZWZ0LCB0b3AsIHdpZGh0LCBoZWlnaHQgdG8gbWVhc3VyZSB0aGVcbiAgICAgKiBwb2x5Z29uIHNpemVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC5sZWZ0IFggY29vcmRpbmF0ZSBvZiB0aGUgcG9seWdvbiBsZWZ0bW9zdCBwb2ludFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LnRvcCBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb24gdG9wbW9zdCBwb2ludFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LndpZHRoIGRpc3RhbmNlIGJldHdlZW4gWCBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbiBsZWZ0bW9zdCBhbmQgcmlnaHRtb3N0IHBvaW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QuaGVpZ2h0IGRpc3RhbmNlIGJldHdlZW4gWSBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbiB0b3Btb3N0IGFuZCBib3R0b21tb3N0IHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgbWluWCA9IG1pbihwb2ludHMsICd4JykgfHwgMCxcbiAgICAgICAgICBtaW5ZID0gbWluKHBvaW50cywgJ3knKSB8fCAwLFxuICAgICAgICAgIG1heFggPSBtYXgocG9pbnRzLCAneCcpIHx8IDAsXG4gICAgICAgICAgbWF4WSA9IG1heChwb2ludHMsICd5JykgfHwgMCxcbiAgICAgICAgICB3aWR0aCA9IChtYXhYIC0gbWluWCksXG4gICAgICAgICAgaGVpZ2h0ID0gKG1heFkgLSBtaW5ZKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbWluWCxcbiAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB7XG4gICAgICAgIHBvaW50czogdGhpcy5wb2ludHMuY29uY2F0KClcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHMgPSBbXSwgZGlmZlggPSB0aGlzLnBhdGhPZmZzZXQueCwgZGlmZlkgPSB0aGlzLnBhdGhPZmZzZXQueSxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2goXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLnBvaW50c1tpXS54IC0gZGlmZlgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnLCcsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLnBvaW50c1tpXS55IC0gZGlmZlksIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnICdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8JyArIHRoaXMudHlwZSArICcgJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICdwb2ludHM9XCInLCBwb2ludHMuam9pbignJyksXG4gICAgICAgICdcIiAvPlxcbidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgY29tbW9uUmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBwb2ludCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoLFxuICAgICAgICAgIHggPSB0aGlzLnBhdGhPZmZzZXQueCxcbiAgICAgICAgICB5ID0gdGhpcy5wYXRoT2Zmc2V0Lnk7XG5cbiAgICAgIGlmICghbGVuIHx8IGlzTmFOKHRoaXMucG9pbnRzW2xlbiAtIDFdLnkpKSB7XG4gICAgICAgIC8vIGRvIG5vdCBkcmF3IGlmIG5vIHBvaW50cyBvciBvZGQgcG9pbnRzXG4gICAgICAgIC8vIE5hTiBjb21lcyBmcm9tIHBhcnNlRmxvYXQgb2YgYSBlbXB0eSBzdHJpbmcgaW4gcGFyc2VyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5wb2ludHNbMF0ueCAtIHgsIHRoaXMucG9pbnRzWzBdLnkgLSB5KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC54IC0geCwgcG9pbnQueSAtIHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmNvbW1vblJlbmRlcihjdHgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRGFzaGVkU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBwMSwgcDI7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwMSA9IHRoaXMucG9pbnRzW2ldO1xuICAgICAgICBwMiA9IHRoaXMucG9pbnRzW2kgKyAxXSB8fCBwMTtcbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBwMS54LCBwMS55LCBwMi54LCBwMi55LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3BvaW50cycpLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlsaW5lXG4gICAqIEBzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNQb2x5bGluZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlBvbHlsaW5lIGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlsaW5lXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIHBhcnNpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICB2YXIgcG9pbnRzID0gZmFicmljLnBhcnNlUG9pbnRzQXR0cmlidXRlKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwb2ludHMnKSksXG4gICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5Qb2x5bGluZS5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5Qb2x5bGluZShwb2ludHMsIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlsaW5lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BvbHlsaW5lJywgb2JqZWN0LCBjYWxsYmFjaywgJ3BvaW50cycpO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kO1xuXG4gIGlmIChmYWJyaWMuUG9seWdvbikge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9seWdvbiBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUG9seWdvbiBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBvbHlnb25cbiAgICogQGV4dGVuZHMgZmFicmljLlBvbHlsaW5lXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5Qb2x5Z29uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUG9seWdvbiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Qb2x5bGluZSwgLyoqIEBsZW5kcyBmYWJyaWMuUG9seWdvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdwb2x5Z29uJyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmNvbW1vblJlbmRlcihjdHgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRGFzaGVkU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfcmVuZGVyRGFzaGVkU3Ryb2tlJywgY3R4KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5Qb2x5Z29uLmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1BvbHlnb25FbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUG9seWdvbi5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5Qb2x5Z29ufSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuUG9seWdvbi5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICB2YXIgcG9pbnRzID0gZmFicmljLnBhcnNlUG9pbnRzQXR0cmlidXRlKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwb2ludHMnKSksXG4gICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5Qb2x5Z29uLkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBjYWxsYmFjayhuZXcgZmFicmljLlBvbHlnb24ocG9pbnRzLCBleHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWdvbiBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWdvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BvbHlnb24nLCBvYmplY3QsIGNhbGxiYWNrLCAncG9pbnRzJyk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbixcbiAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heCxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgZHJhd0FyYyA9IGZhYnJpYy51dGlsLmRyYXdBcmMsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIGNvbW1hbmRMZW5ndGhzID0ge1xuICAgICAgICBtOiAyLFxuICAgICAgICBsOiAyLFxuICAgICAgICBoOiAxLFxuICAgICAgICB2OiAxLFxuICAgICAgICBjOiA2LFxuICAgICAgICBzOiA0LFxuICAgICAgICBxOiA0LFxuICAgICAgICB0OiAyLFxuICAgICAgICBhOiA3XG4gICAgICB9LFxuICAgICAgcmVwZWF0ZWRDb21tYW5kcyA9IHtcbiAgICAgICAgbTogJ2wnLFxuICAgICAgICBNOiAnTCdcbiAgICAgIH07XG5cbiAgaWYgKGZhYnJpYy5QYXRoKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5QYXRoIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRoIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUGF0aFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI3BhdGhfYW5kX3BhdGhncm91cH1cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBhdGgjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5QYXRoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuUGF0aC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdwYXRoJyxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHBhdGggcG9pbnRzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdGg6IG51bGwsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3BhdGgnLCAnZmlsbFJ1bGUnKSxcblxuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdCgncGF0aCcpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gcGF0aCBQYXRoIGRhdGEgKHNlcXVlbmNlIG9mIGNvb3JkaW5hdGVzIGFuZCBjb3JyZXNwb25kaW5nIFwiY29tbWFuZFwiIHRva2VucylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBhdGh9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcGF0aCA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJvbUFycmF5ID0gX3RvU3RyaW5nLmNhbGwocGF0aCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cbiAgICAgIHRoaXMucGF0aCA9IGZyb21BcnJheVxuICAgICAgICA/IHBhdGhcbiAgICAgICAgLy8gb25lIG9mIGNvbW1hbmRzIChtLE0sbCxMLHEsUSxjLEMsZXRjLikgZm9sbG93ZWQgYnkgbm9uLWNvbW1hbmQgY2hhcmFjdGVycyAoaS5lLiBjb21tYW5kIHZhbHVlcylcbiAgICAgICAgOiBwYXRoLm1hdGNoICYmIHBhdGgubWF0Y2goL1ttemxodmNzcXRhXVtebXpsaHZjc3F0YV0qL2dpKTtcblxuICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyb21BcnJheSkge1xuICAgICAgICB0aGlzLnBhdGggPSB0aGlzLl9wYXJzZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0UG9zaXRpb25EaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX3NldFBvc2l0aW9uRGltZW5zaW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhbGNEaW0gPSB0aGlzLl9wYXJzZURpbWVuc2lvbnMoKTtcblxuICAgICAgdGhpcy53aWR0aCA9IGNhbGNEaW0ud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGNhbGNEaW0uaGVpZ2h0O1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gY2FsY0RpbS5sZWZ0O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnRvcCA9IGNhbGNEaW0udG9wO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhdGhPZmZzZXQgPSB0aGlzLnBhdGhPZmZzZXQgfHwge1xuICAgICAgICB4OiBjYWxjRGltLmxlZnQgKyB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgeTogY2FsY0RpbS50b3AgKyB0aGlzLmhlaWdodCAvIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBwYXRoIG9uXG4gICAgICovXG4gICAgX3JlbmRlclBhdGhDb21tYW5kczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRYID0gMCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRZID0gMCxcbiAgICAgICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgdGVtcFksXG4gICAgICAgICAgbCA9IC10aGlzLnBhdGhPZmZzZXQueCxcbiAgICAgICAgICB0ID0gLXRoaXMucGF0aE9mZnNldC55O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgICAgIGNhc2UgJ2wnOiAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdoJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdWJzogLy8gdmVyaWNhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB5ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFggPSB4O1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IHk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRZID0geTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYyc6IC8vIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzVdO1xuICAgICAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs2XTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCwgLy8geDFcbiAgICAgICAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LCAvLyB5MVxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsIC8vIHgyXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCwgLy8geTJcbiAgICAgICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB4ICsgbCxcbiAgICAgICAgICAgICAgeSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcblxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW0NjU3NdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgQywgYywgUywgb3IgcyxcbiAgICAgICAgICAgICAgLy8gdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICAgICAgICAvLyB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb25cbiAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tDY1NzXS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIEMsIGMsIFMsIG9yIHMsXG4gICAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcblxuICAgICAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmVcbiAgICAgICAgICAgIC8vIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvblxuICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG5cbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0JzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgdGVtcFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgdGVtcFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzXG4gICAgICAgICAgICBkcmF3QXJjKGN0eCwgeCArIGwsIHkgKyB0LCBbXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl0gKyB4ICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFs3XSArIHkgKyB0XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHggKz0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzXG4gICAgICAgICAgICBkcmF3QXJjKGN0eCwgeCArIGwsIHkgKyB0LCBbXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl0gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzddICsgdFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHggPSBzdWJwYXRoU3RhcnRYO1xuICAgICAgICAgICAgeSA9IHN1YnBhdGhTdGFydFk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBwYXRoIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJQYXRoQ29tbWFuZHMoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5QYXRoICgnICsgdGhpcy5jb21wbGV4aXR5KCkgK1xuICAgICAgICAnKTogeyBcInRvcFwiOiAnICsgdGhpcy50b3AgKyAnLCBcImxlZnRcIjogJyArIHRoaXMubGVmdCArICcgfT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgbyA9IGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBwYXRoOiB0aGlzLnBhdGgubWFwKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uc2xpY2UoKTsgfSksXG4gICAgICAgIHRvcDogdGhpcy50b3AsXG4gICAgICAgIGxlZnQ6IHRoaXMubGVmdCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3Mgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG8gPSB0aGlzLnRvT2JqZWN0KFsnc291cmNlUGF0aCddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgICBpZiAoby5zb3VyY2VQYXRoKSB7XG4gICAgICAgIGRlbGV0ZSBvLnBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aC5tYXAoZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5qb2luKCcgJyk7XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPHBhdGggJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICdkPVwiJywgcGF0aCxcbiAgICAgICAgJ1wiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiAnLFxuICAgICAgICAnLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICBfZ2V0T2Zmc2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaWdpdHMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG4gICAgICByZXR1cm4gJyB0cmFuc2xhdGUoJyArIHRvRml4ZWQoLXRoaXMucGF0aE9mZnNldC54LCBkaWdpdHMpICsgJywgJyArXG4gICAgICAgICAgdG9GaXhlZCgtdGhpcy5wYXRoT2Zmc2V0LnksIGRpZ2l0cykgKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIGNsaXBQYXRoIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvQ2xpcFBhdGhTVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBhZGRpdGlvbmFsVHJhbnNmb3JtID0gdGhpcy5fZ2V0T2Zmc2V0VHJhbnNmb3JtKCk7XG4gICAgICByZXR1cm4gJ1xcdCcgKyB0aGlzLl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAoXG4gICAgICAgIHRoaXMuX3RvU1ZHKCksIHsgcmV2aXZlcjogcmV2aXZlciwgYWRkaXRpb25hbFRyYW5zZm9ybTogYWRkaXRpb25hbFRyYW5zZm9ybSB9XG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSB0aGlzLl9nZXRPZmZzZXRUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKHRoaXMuX3RvU1ZHKCksIHsgcmV2aXZlcjogcmV2aXZlciwgYWRkaXRpb25hbFRyYW5zZm9ybTogYWRkaXRpb25hbFRyYW5zZm9ybSAgfSk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlIGNvbXBsZXhpdHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aC5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhcnNlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgY29vcmRzID0gW10sXG4gICAgICAgICAgY3VycmVudFBhdGgsXG4gICAgICAgICAgcGFyc2VkLFxuICAgICAgICAgIHJlID0gLyhbLStdPygoXFxkK1xcLlxcZCspfCgoXFxkKyl8KFxcLlxcZCspKSkoPzplWy0rXT9cXGQrKT8pL2lnLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGNvb3Jkc1N0cjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGNvb3Jkc1BhcnNlZCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnRQYXRoID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIGNvb3Jkc1N0ciA9IGN1cnJlbnRQYXRoLnNsaWNlKDEpLnRyaW0oKTtcbiAgICAgICAgY29vcmRzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoY29vcmRzU3RyKSkpIHtcbiAgICAgICAgICBjb29yZHMucHVzaChtYXRjaFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb29yZHNQYXJzZWQgPSBbY3VycmVudFBhdGguY2hhckF0KDApXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICBwYXJzZWQgPSBwYXJzZUZsb2F0KGNvb3Jkc1tqXSk7XG4gICAgICAgICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICAgICAgICBjb29yZHNQYXJzZWQucHVzaChwYXJzZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21tYW5kID0gY29vcmRzUGFyc2VkWzBdLFxuICAgICAgICAgICAgY29tbWFuZExlbmd0aCA9IGNvbW1hbmRMZW5ndGhzW2NvbW1hbmQudG9Mb3dlckNhc2UoKV0sXG4gICAgICAgICAgICByZXBlYXRlZENvbW1hbmQgPSByZXBlYXRlZENvbW1hbmRzW2NvbW1hbmRdIHx8IGNvbW1hbmQ7XG5cbiAgICAgICAgaWYgKGNvb3Jkc1BhcnNlZC5sZW5ndGggLSAxID4gY29tbWFuZExlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGsgPSAxLCBrbGVuID0gY29vcmRzUGFyc2VkLmxlbmd0aDsgayA8IGtsZW47IGsgKz0gY29tbWFuZExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW2NvbW1hbmRdLmNvbmNhdChjb29yZHNQYXJzZWQuc2xpY2UoaywgayArIGNvbW1hbmRMZW5ndGgpKSk7XG4gICAgICAgICAgICBjb21tYW5kID0gcmVwZWF0ZWRDb21tYW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChjb29yZHNQYXJzZWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhcnNlRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhWCA9IFtdLFxuICAgICAgICAgIGFZID0gW10sXG4gICAgICAgICAgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRYID0gMCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRZID0gMCxcbiAgICAgICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgdGVtcFksXG4gICAgICAgICAgYm91bmRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgY3VycmVudCA9IHRoaXMucGF0aFtpXTtcblxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgICAgICBjYXNlICdsJzogLy8gbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdIJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1YnOiAvLyB2ZXJpY2FsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ20nOiAvLyBtb3ZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRYID0geDtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSB5O1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRZID0geTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjJzogLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbNV07XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzZdO1xuICAgICAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIHggKyBjdXJyZW50WzFdLCAvLyB4MVxuICAgICAgICAgICAgICB5ICsgY3VycmVudFsyXSwgLy8geTFcbiAgICAgICAgICAgICAgY29udHJvbFgsIC8vIHgyXG4gICAgICAgICAgICAgIGNvbnRyb2xZLCAvLyB5MlxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tDY1NzXS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIEMsIGMsIFMsIG9yIHMsXG4gICAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIHggKyBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICB5ICsgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgICAgIHRlbXBZXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmVcbiAgICAgICAgICAgIC8vIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvblxuICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tDY1NzXS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIEMsIGMsIFMsIG9yIHMsXG4gICAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUoeCwgeSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZVxuICAgICAgICAgICAgLy8gdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uXG4gICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgICAgY3VycmVudFs0XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3QnOiAvLyBzaG9ydGhhbmQgcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzWzBdLm1hdGNoKC9bUXFUdF0vKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgICAgIHRlbXBZXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgdGVtcFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgdGVtcFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgICAgIHRlbXBZXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIC8vIFRPRE86IG9wdGltaXplIHRoaXNcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQXJjKHgsIHksXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl0gKyB4LFxuICAgICAgICAgICAgICBjdXJyZW50WzddICsgeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggKz0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzXG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkFyYyh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgICAgICBjdXJyZW50WzZdLFxuICAgICAgICAgICAgICBjdXJyZW50WzddXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICB4ID0gc3VicGF0aFN0YXJ0WDtcbiAgICAgICAgICAgIHkgPSBzdWJwYXRoU3RhcnRZO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgICAgICBib3VuZHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICBhWC5wdXNoKHBvaW50LngpO1xuICAgICAgICAgIGFZLnB1c2gocG9pbnQueSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhWC5wdXNoKHgpO1xuICAgICAgICBhWS5wdXNoKHkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluWCA9IG1pbihhWCkgfHwgMCxcbiAgICAgICAgICBtaW5ZID0gbWluKGFZKSB8fCAwLFxuICAgICAgICAgIG1heFggPSBtYXgoYVgpIHx8IDAsXG4gICAgICAgICAgbWF4WSA9IG1heChhWSkgfHwgMCxcbiAgICAgICAgICBkZWx0YVggPSBtYXhYIC0gbWluWCxcbiAgICAgICAgICBkZWx0YVkgPSBtYXhZIC0gbWluWSxcblxuICAgICAgICAgIG8gPSB7XG4gICAgICAgICAgICBsZWZ0OiBtaW5YLFxuICAgICAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICAgICAgd2lkdGg6IGRlbHRhWCxcbiAgICAgICAgICAgIGhlaWdodDogZGVsdGFZXG4gICAgICAgICAgfTtcblxuICAgICAgcmV0dXJuIG87XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuUGF0aCBmcm9tIGFuIG9iamVjdFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBhdGguZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdC5zb3VyY2VQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHBhdGhVcmwgPSBvYmplY3Quc291cmNlUGF0aDtcbiAgICAgIGZhYnJpYy5sb2FkU1ZHRnJvbVVSTChwYXRoVXJsLCBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBlbGVtZW50c1swXTtcbiAgICAgICAgcGF0aC5zZXRPcHRpb25zKG9iamVjdCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUGF0aCcsIG9iamVjdCwgY2FsbGJhY2ssICdwYXRoJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlBhdGguZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUGF0aC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFsnZCddKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuUGF0aCBmcm9tIGFuIFNWRyA8cGF0aD4gZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9ucyBjYWxsYmFjayBpbnZva2VkIGFmdGVyIHBhcnNpbmcgaXMgZmluaXNoZWRcbiAgICovXG4gIGZhYnJpYy5QYXRoLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlBhdGguQVRUUklCVVRFX05BTUVTKTtcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLlBhdGgocGFyc2VkQXR0cmlidXRlcy5kLCBleHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4O1xuXG4gIGlmIChmYWJyaWMuR3JvdXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogR3JvdXAgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Hcm91cFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBtaXhlcyBmYWJyaWMuQ29sbGVjdGlvblxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNncm91cHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5Hcm91cCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkdyb3VwID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgZmFicmljLkNvbGxlY3Rpb24sIC8qKiBAbGVuZHMgZmFicmljLkdyb3VwLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2dyb3VwJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHN0cm9rZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgY2xpY2sgZXZlbnRzIHNob3VsZCBhbHNvIGNoZWNrIGZvciBzdWJ0YXJnZXRzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3ViVGFyZ2V0Q2hlY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogR3JvdXBzIGFyZSBjb250YWluZXIsIGRvIG5vdCByZW5kZXIgYW55dGhpbmcgb24gdGhleXIgb3duLCBlbmNlIG5vIGNhY2hlIHByb3BlcnRpZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIHNldE9uR3JvdXAgaXMgYSBtZXRob2QgdXNlZCBmb3IgVGV4dEJveCB0aGF0IGlzIG5vIG1vcmUgdXNlZCBzaW5jZSAyLjAuMCBUaGUgYmVoYXZpb3IgaXMgc3RpbGxcbiAgICAgKiBhdmFpbGFibGUgc2V0dGluZyB0aGlzIGJvb2xlYW4gdG8gdHJ1ZS5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB1c2VTZXRPbkdyb3VwOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdHMgR3JvdXAgb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0FscmVhZHlHcm91cGVkXSBpZiB0cnVlLCBvYmplY3RzIGhhdmUgYmVlbiBncm91cGVkIGFscmVhZHkuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob2JqZWN0cywgb3B0aW9ucywgaXNBbHJlYWR5R3JvdXBlZCkge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICAvLyBpZiBvYmplY3RzIGVuY2xvc2VkIGluIGEgZ3JvdXAgaGF2ZSBiZWVuIGdyb3VwZWQgYWxyZWFkeSxcbiAgICAgIC8vIHdlIGNhbm5vdCBjaGFuZ2UgcHJvcGVydGllcyBvZiBvYmplY3RzLlxuICAgICAgLy8gVGh1cyB3ZSBuZWVkIHRvIHNldCBvcHRpb25zIHRvIGdyb3VwIHdpdGhvdXQgb2JqZWN0cyxcbiAgICAgIGlzQWxyZWFkeUdyb3VwZWQgJiYgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmdyb3VwID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0FscmVhZHlHcm91cGVkKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuY2VudGVyUG9pbnQ7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gc2V0IG9yaWdpbnMgYmVmb3JlIGNhbGN1bGF0aW5nIHRoZSBib3VuZGluZyBib3guXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIHRvcGxlZnQgY2FuIGJlIHNldCB3aXRoIHRoYXQgaW4gbWluZC5cbiAgICAgICAgLy8gaWYgc3BlY2lmaWMgdG9wIGFuZCBsZWZ0IGFyZSBwYXNzZWQsIGFyZSBvdmVyd3JpdHRlbiBsYXRlclxuICAgICAgICAvLyB3aXRoIHRoZSBjYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKVxuICAgICAgICBpZiAob3B0aW9ucy5vcmlnaW5YICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9yaWdpblggPSBvcHRpb25zLm9yaWdpblg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW5ZID0gb3B0aW9ucy5vcmlnaW5ZO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGNvbWluZyBmcm9tIHN2ZyBpIGRvIG5vdCB3YW50IHRvIGNhbGMgYm91bmRzLlxuICAgICAgICAvLyBpIGFzc3VtZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBwYXNzZWQgYWxvbmcgb3B0aW9uc1xuICAgICAgICBjZW50ZXIgfHwgdGhpcy5fY2FsY0JvdW5kcygpO1xuICAgICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKGNlbnRlcik7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmNlbnRlclBvaW50O1xuICAgICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNBQ29vcmRzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcENvb3Jkc0NoYW5nZV0gaWYgdHJ1ZSwgY29vcmRpbmF0ZXMgb2Ygb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwIGRvIG5vdCBjaGFuZ2VcbiAgICAgKi9cbiAgICBfdXBkYXRlT2JqZWN0c0FDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlnbm9yZVpvb20gPSB0cnVlLCBza2lwQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICl7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uc2V0Q29vcmRzKGlnbm9yZVpvb20sIHNraXBBYnNvbHV0ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcENvb3Jkc0NoYW5nZV0gaWYgdHJ1ZSwgY29vcmRpbmF0ZXMgb2Ygb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwIGRvIG5vdCBjaGFuZ2VcbiAgICAgKi9cbiAgICBfdXBkYXRlT2JqZWN0c0Nvb3JkczogZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgICB2YXIgY2VudGVyID0gY2VudGVyIHx8IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApe1xuICAgICAgICB0aGlzLl91cGRhdGVPYmplY3RDb29yZHModGhpcy5fb2JqZWN0c1tpXSwgY2VudGVyKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGNlbnRlciwgY3VycmVudCBjZW50ZXIgb2YgZ3JvdXAuXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdENvb3JkczogZnVuY3Rpb24ob2JqZWN0LCBjZW50ZXIpIHtcbiAgICAgIHZhciBvYmplY3RMZWZ0ID0gb2JqZWN0LmxlZnQsXG4gICAgICAgICAgb2JqZWN0VG9wID0gb2JqZWN0LnRvcCxcbiAgICAgICAgICBpZ25vcmVab29tID0gdHJ1ZSwgc2tpcEFic29sdXRlID0gdHJ1ZTtcblxuICAgICAgb2JqZWN0LnNldCh7XG4gICAgICAgIGxlZnQ6IG9iamVjdExlZnQgLSBjZW50ZXIueCxcbiAgICAgICAgdG9wOiBvYmplY3RUb3AgLSBjZW50ZXIueVxuICAgICAgfSk7XG4gICAgICBvYmplY3QuZ3JvdXAgPSB0aGlzO1xuICAgICAgb2JqZWN0LnNldENvb3JkcyhpZ25vcmVab29tLCBza2lwQWJzb2x1dGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbmF0aW9uIG9mIGEgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5Hcm91cDogKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArICcpPic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gb2JqZWN0IHRvIGEgZ3JvdXA7IFRoZW4gcmVjYWxjdWxhdGVzIGdyb3VwJ3MgZGltZW5zaW9uLCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFkZFdpdGhVcGRhdGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgICAgZmFicmljLnV0aWwucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIHRoaXMuX29iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSB0aGlzO1xuICAgICAgICBvYmplY3QuX3NldCgnY2FudmFzJywgdGhpcy5jYW52YXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FsY0JvdW5kcygpO1xuICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3JkcygpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gb2JqZWN0IGZyb20gYSBncm91cDsgVGhlbiByZWNhbGN1bGF0ZXMgZ3JvdXAncyBkaW1lbnNpb24sIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVtb3ZlV2l0aFVwZGF0ZTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgICBmYWJyaWMudXRpbC5yZXNldE9iamVjdFRyYW5zZm9ybSh0aGlzKTtcblxuICAgICAgdGhpcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk9iamVjdEFkZGVkOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgIG9iamVjdC5fc2V0KCdjYW52YXMnLCB0aGlzLmNhbnZhcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uT2JqZWN0UmVtb3ZlZDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIGRlbGV0ZSBvYmplY3QuZ3JvdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLnVzZVNldE9uR3JvdXApIHtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uc2V0T25Hcm91cChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uX3NldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuX3NldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgX2luY2x1ZGVEZWZhdWx0VmFsdWVzID0gdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgIHZhciBvYmpzVG9PYmplY3QgPSB0aGlzLl9vYmplY3RzLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsRGVmYXVsdHMgPSBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IF9pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgdmFyIF9vYmogPSBvYmoudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsRGVmYXVsdHM7XG4gICAgICAgIHJldHVybiBfb2JqO1xuICAgICAgfSk7XG4gICAgICB2YXIgb2JqID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIG9iai5vYmplY3RzID0gb2Jqc1RvT2JqZWN0O1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2UsIGluIGRhdGFsZXNzIG1vZGUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9ianNUb09iamVjdCwgc291cmNlUGF0aCA9IHRoaXMuc291cmNlUGF0aDtcbiAgICAgIGlmIChzb3VyY2VQYXRoKSB7XG4gICAgICAgIG9ianNUb09iamVjdCA9IHNvdXJjZVBhdGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIG9ianNUb09iamVjdCA9IHRoaXMuX29iamVjdHMubWFwKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIHZhciBvcmlnaW5hbERlZmF1bHRzID0gb2JqLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IF9pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgICB2YXIgX29iaiA9IG9iai50b0RhdGFsZXNzT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsRGVmYXVsdHM7XG4gICAgICAgICAgcmV0dXJuIF9vYmo7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnRvRGF0YWxlc3NPYmplY3QuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIG9iai5vYmplY3RzID0gb2Jqc1RvT2JqZWN0O1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBpbnN0YW5jZSBvbiBhIGdpdmVuIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIGluc3RhbmNlIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybURvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ3JlbmRlcicsIGN0eCk7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Eb25lID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogb2JqZWN0Q2FjaGluZyBpcyBhIGdsb2JhbCBmbGFnLCB3aW5zIG92ZXIgZXZlcnl0aGluZ1xuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBvdXRzaWRlIGlzIGNhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvd25DYWNoZSA9IHRoaXMub2JqZWN0Q2FjaGluZyAmJiAoIXRoaXMuZ3JvdXAgfHwgdGhpcy5uZWVkc0l0c093bkNhY2hlKCkgfHwgIXRoaXMuZ3JvdXAuaXNPbkFDYWNoZSgpKTtcbiAgICAgIHRoaXMub3duQ2FjaGluZyA9IG93bkNhY2hlO1xuICAgICAgaWYgKG93bkNhY2hlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0ud2lsbERyYXdTaGFkb3coKSkge1xuICAgICAgICAgICAgdGhpcy5vd25DYWNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3duQ2FjaGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IG9yIGEgY2hpbGQgb2JqZWN0IHdpbGwgY2FzdCBhIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgd2lsbERyYXdTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS53aWxsRHJhd1NoYWRvdy5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0ud2lsbERyYXdTaGFkb3coKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgZ3JvdXAgb3IgaXRzIHBhcmVudCBncm91cCBhcmUgY2FjaGluZywgcmVjdXJzaXZlbHkgdXBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzT25BQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3duQ2FjaGluZyB8fCAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGRyYXdpbmcgb3BlcmF0aW9uIGZvciBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3T2JqZWN0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kcmF3Q2xpcFBhdGgoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY2FjaGUgaXMgZGlydHlcbiAgICAgKi9cbiAgICBpc0NhY2hlRGlydHk6IGZ1bmN0aW9uKHNraXBDYW52YXMpIHtcbiAgICAgIGlmICh0aGlzLmNhbGxTdXBlcignaXNDYWNoZURpcnR5Jywgc2tpcENhbnZhcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhdGVmdWxsQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0uaXNDYWNoZURpcnR5KHRydWUpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NhY2hlQ2FudmFzKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGdyb3VwIGhhcyBub3QgYSBjYWNoZSBjYW52YXMgdGhlcmUgaXMgbm90aGluZyB0byBjbGVhblxuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmNhY2hlV2lkdGggLyB0aGlzLnpvb21YLCB5ID0gdGhpcy5jYWNoZUhlaWdodCAvIHRoaXMuem9vbVk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KC14IC8gMiwgLXkgLyAyLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0b3JlcyBvcmlnaW5hbCBzdGF0ZSBvZiBlYWNoIG9mIGdyb3VwIG9iamVjdHMgKG9yaWdpbmFsIHN0YXRlIGlzIHRoYXQgd2hpY2ggd2FzIGJlZm9yZSBncm91cCB3YXMgY3JlYXRlZCkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX3Jlc3RvcmVPYmplY3RzU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKHRoaXMuX3Jlc3RvcmVPYmplY3RTdGF0ZSwgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhbGlzZXMgdGhlIHRyYW5zZm9ybSBmcm9tIHRoaXMgZ3JvdXAgb250byB0aGUgc3VwcGxpZWQgb2JqZWN0XG4gICAgICogaS5lLiBpdCB0ZWxscyB5b3Ugd2hhdCB3b3VsZCBoYXBwZW4gaWYgdGhlIHN1cHBsaWVkIG9iamVjdCB3YXMgaW5cbiAgICAgKiB0aGUgZ3JvdXAsIGFuZCB0aGVuIHRoZSBncm91cCB3YXMgZGVzdHJveWVkLiBJdCBtdXRhdGVzIHRoZSBzdXBwbGllZFxuICAgICAqIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRyYW5zZm9ybWVkT2JqZWN0XG4gICAgICovXG4gICAgcmVhbGl6ZVRyYW5zZm9ybTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgbWF0cml4ID0gb2JqZWN0LmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UobWF0cml4KSxcbiAgICAgICAgICBjZW50ZXIgPSBuZXcgZmFicmljLlBvaW50KG9wdGlvbnMudHJhbnNsYXRlWCwgb3B0aW9ucy50cmFuc2xhdGVZKTtcbiAgICAgIG9iamVjdC5mbGlwWCA9IGZhbHNlO1xuICAgICAgb2JqZWN0LmZsaXBZID0gZmFsc2U7XG4gICAgICBvYmplY3Quc2V0KCdzY2FsZVgnLCBvcHRpb25zLnNjYWxlWCk7XG4gICAgICBvYmplY3Quc2V0KCdzY2FsZVknLCBvcHRpb25zLnNjYWxlWSk7XG4gICAgICBvYmplY3Quc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgb2JqZWN0LnNrZXdZID0gb3B0aW9ucy5za2V3WTtcbiAgICAgIG9iamVjdC5hbmdsZSA9IG9wdGlvbnMuYW5nbGU7XG4gICAgICBvYmplY3Quc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBzdGF0ZSBvZiBhIHNwZWNpZmllZCBvYmplY3QgaW4gZ3JvdXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICovXG4gICAgX3Jlc3RvcmVPYmplY3RTdGF0ZTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLnJlYWxpemVUcmFuc2Zvcm0ob2JqZWN0KTtcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgIGRlbGV0ZSBvYmplY3QuZ3JvdXA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBncm91cCAocmVzdG9yaW5nIHN0YXRlIG9mIGl0cyBvYmplY3RzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHdoZW4gZ3JvdXAgaXMgZGVzdHJveWVkIG9iamVjdHMgbmVlZHMgdG8gZ2V0IGEgcmVwYWludCB0byBiZSBldmVudHVhbGx5XG4gICAgICAvLyBkaXNwbGF5ZWQgb24gY2FudmFzLlxuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3Quc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgZ3JvdXAgYW4gYWN0aXZlIHNlbGVjdGlvbiwgcmVtb3ZlIHRoZSBncm91cCBmcm9tIGNhbnZhc1xuICAgICAqIHRoZSBncm91cCBoYXMgdG8gYmUgb24gY2FudmFzIGZvciB0aGlzIHRvIHdvcmsuXG4gICAgICogQHJldHVybiB7ZmFicmljLkFjdGl2ZVNlbGVjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB0b0FjdGl2ZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cywgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9iamVjdHM7XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gbmV3IGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24oW10pO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLnNldChvcHRpb25zKTtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi50eXBlID0gJ2FjdGl2ZVNlbGVjdGlvbic7XG4gICAgICBjYW52YXMucmVtb3ZlKHRoaXMpO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSBhY3RpdmVTZWxlY3Rpb247XG4gICAgICAgIG9iamVjdC5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGNhbnZhcy5hZGQob2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cyA9IG9iamVjdHM7XG4gICAgICBjYW52YXMuX2FjdGl2ZU9iamVjdCA9IGFjdGl2ZVNlbGVjdGlvbjtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5zZXRDb29yZHMoKTtcbiAgICAgIHJldHVybiBhY3RpdmVTZWxlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGEgZ3JvdXAgKHJlc3RvcmluZyBzdGF0ZSBvZiBpdHMgb2JqZWN0cylcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdW5ncm91cE9uQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29vcmRpbmF0ZXMgb2YgYWxsIG9iamVjdHMgaW5zaWRlIGdyb3VwXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldE9iamVjdHNDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlnbm9yZVpvb20gPSB0cnVlLCBza2lwQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKGlnbm9yZVpvb20sIHNraXBBYnNvbHV0ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjQm91bmRzOiBmdW5jdGlvbihvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgIHZhciBhWCA9IFtdLFxuICAgICAgICAgIGFZID0gW10sXG4gICAgICAgICAgbywgcHJvcCxcbiAgICAgICAgICBwcm9wcyA9IFsndHInLCAnYnInLCAnYmwnLCAndGwnXSxcbiAgICAgICAgICBpID0gMCwgaUxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoLFxuICAgICAgICAgIGosIGpMZW4gPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgaWdub3JlWm9vbSA9IHRydWU7XG5cbiAgICAgIGZvciAoIDsgaSA8IGlMZW47ICsraSkge1xuICAgICAgICBvID0gdGhpcy5fb2JqZWN0c1tpXTtcbiAgICAgICAgby5zZXRDb29yZHMoaWdub3JlWm9vbSk7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICBwcm9wID0gcHJvcHNbal07XG4gICAgICAgICAgYVgucHVzaChvLm9Db29yZHNbcHJvcF0ueCk7XG4gICAgICAgICAgYVkucHVzaChvLm9Db29yZHNbcHJvcF0ueSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fZ2V0Qm91bmRzKGFYLCBhWSwgb25seVdpZHRoSGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbihhWCwgYVksIG9ubHlXaWR0aEhlaWdodCkge1xuICAgICAgdmFyIG1pblhZID0gbmV3IGZhYnJpYy5Qb2ludChtaW4oYVgpLCBtaW4oYVkpKSxcbiAgICAgICAgICBtYXhYWSA9IG5ldyBmYWJyaWMuUG9pbnQobWF4KGFYKSwgbWF4KGFZKSksXG4gICAgICAgICAgdG9wID0gbWluWFkueSB8fCAwLCBsZWZ0ID0gbWluWFkueCB8fCAwLFxuICAgICAgICAgIHdpZHRoID0gKG1heFhZLnggLSBtaW5YWS54KSB8fCAwLFxuICAgICAgICAgIGhlaWdodCA9IChtYXhYWS55IC0gbWluWFkueSkgfHwgMDtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgaWYgKCFvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgICAgLy8gdGhlIGJvdW5kaW5nIGJveCBhbHdheXMgZmluZHMgdGhlIHRvcGxlZnQgbW9zdCBjb3JuZXIuXG4gICAgICAgIC8vIHdoYXRldmVyIGlzIHRoZSBncm91cCBvcmlnaW4sIHdlIHNldCB1cCBoZXJlIHRoZSBsZWZ0L3RvcCBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbkJ5T3JpZ2luKHsgeDogbGVmdCwgeTogdG9wIH0sICdsZWZ0JywgJ3RvcCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgc3ZnU3RyaW5nID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN2Z1N0cmluZy5wdXNoKCdcXHQnLCB0aGlzLl9vYmplY3RzW2ldLnRvU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoXG4gICAgICAgIHN2Z1N0cmluZyxcbiAgICAgICAgeyByZXZpdmVyOiByZXZpdmVyLCBub1N0eWxlOiB0cnVlLCB3aXRoU2hhZG93OiB0cnVlIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyBjbGlwUGF0aCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0NsaXBQYXRoU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgc3ZnU3RyaW5nID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN2Z1N0cmluZy5wdXNoKCdcXHQnLCB0aGlzLl9vYmplY3RzW2ldLnRvQ2xpcFBhdGhTVkcocmV2aXZlcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwKHN2Z1N0cmluZywgeyByZXZpdmVyOiByZXZpdmVyIH0pO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuR3JvdXB9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Hcm91cFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYSBncm91cCBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZ3JvdXAgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLkdyb3VwLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0Lm9iamVjdHMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKFtvYmplY3QuY2xpcFBhdGhdLCBmdW5jdGlvbihlbmxpdmVkQ2xpcFBhdGgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICAgICAgb3B0aW9ucy5jbGlwUGF0aCA9IGVubGl2ZWRDbGlwUGF0aFswXTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMub2JqZWN0cztcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IGZhYnJpYy5Hcm91cChlbmxpdmVuZWRPYmplY3RzLCBvcHRpb25zLCB0cnVlKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEdyb3VwIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uXG4gICAqIEBleHRlbmRzIGZhYnJpYy5Hcm91cFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNncm91cHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24gPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuR3JvdXAsIC8qKiBAbGVuZHMgZmFicmljLkFjdGl2ZVNlbGVjdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdhY3RpdmVTZWxlY3Rpb24nLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0cyBBY3RpdmVTZWxlY3Rpb24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvYmplY3RzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmdyb3VwID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWCkge1xuICAgICAgICB0aGlzLm9yaWdpblggPSBvcHRpb25zLm9yaWdpblg7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vcmlnaW5ZKSB7XG4gICAgICAgIHRoaXMub3JpZ2luWSA9IG9wdGlvbnMub3JpZ2luWTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0ZSBhY3RpdmVTZWxlY3Rpb24gdG8gYSBub3JtYWwgZ3JvdXAsXG4gICAgICogSGlnaCBsZXZlbCBmdW5jdGlvbiB0aGF0IGF1dG9tYXRpY2FsbHkgYWRkcyBpdCB0byBjYW52YXMgYXNcbiAgICAgKiBhY3RpdmUgb2JqZWN0LiBubyBldmVudHMgZmlyZWQuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfVxuICAgICAqL1xuICAgIHRvR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLmNvbmNhdCgpO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuICAgICAgdmFyIG5ld0dyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChbXSk7XG4gICAgICBkZWxldGUgb3B0aW9ucy50eXBlO1xuICAgICAgbmV3R3JvdXAuc2V0KG9wdGlvbnMpO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuY2FudmFzLnJlbW92ZShvYmplY3QpO1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSBuZXdHcm91cDtcbiAgICAgIH0pO1xuICAgICAgbmV3R3JvdXAuX29iamVjdHMgPSBvYmplY3RzO1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gbmV3R3JvdXA7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICBjYW52YXMuYWRkKG5ld0dyb3VwKTtcbiAgICAgIGNhbnZhcy5fYWN0aXZlT2JqZWN0ID0gbmV3R3JvdXA7XG4gICAgICBuZXdHcm91cC5zZXRDb29yZHMoKTtcbiAgICAgIHJldHVybiBuZXdHcm91cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgcmV0dXJucyB0cnVlLCBkZXNlbGVjdGlvbiBpcyBjYW5jZWxsZWQuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gW2NhbmNlbF1cbiAgICAgKi9cbiAgICBvbkRlc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuQWN0aXZlU2VsZWN0aW9uOiAoJyArIHRoaXMuY29tcGxleGl0eSgpICsgJyk+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIHRoZSBvYmplY3Qgc2hvdWxkIGNhY2hlIG9yIG5vdC4gQ3JlYXRlIGl0cyBvd24gY2FjaGUgbGV2ZWxcbiAgICAgKiBvYmplY3RDYWNoaW5nIGlzIGEgZ2xvYmFsIGZsYWcsIHdpbnMgb3ZlciBldmVyeXRoaW5nXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIG91dHNpZGUgaXMgY2FjaGVkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGdyb3VwIG9yIGl0cyBwYXJlbnQgZ3JvdXAgYXJlIGNhY2hpbmcsIHJlY3Vyc2l2ZWx5IHVwXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09uQUNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjb250cm9scyBhbmQgYm9yZGVycyBmb3IgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT3ZlcnJpZGVdIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY2hpbGRyZW5PdmVycmlkZV0gcHJvcGVydGllcyB0byBvdmVycmlkZSB0aGUgY2hpbGRyZW4gb3ZlcnJpZGVzXG4gICAgICovXG4gICAgX3JlbmRlckNvbnRyb2xzOiBmdW5jdGlvbihjdHgsIHN0eWxlT3ZlcnJpZGUsIGNoaWxkcmVuT3ZlcnJpZGUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmlzTW92aW5nID8gdGhpcy5ib3JkZXJPcGFjaXR5V2hlbk1vdmluZyA6IDE7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlckNvbnRyb2xzJywgY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIGNoaWxkcmVuT3ZlcnJpZGUgPSBjaGlsZHJlbk92ZXJyaWRlIHx8IHsgfTtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW5PdmVycmlkZS5oYXNDb250cm9scyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2hpbGRyZW5PdmVycmlkZS5oYXNDb250cm9scyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbk92ZXJyaWRlLmhhc1JvdGF0aW5nUG9pbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNoaWxkcmVuT3ZlcnJpZGUuaGFzUm90YXRpbmdQb2ludCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW5PdmVycmlkZS5mb3JBY3RpdmVTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5fcmVuZGVyQ29udHJvbHMoY3R4LCBjaGlsZHJlbk92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb259IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JvdXAgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIEFjdGl2ZVNlbGVjdGlvbiBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0Lm9iamVjdHMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIGRlbGV0ZSBvYmplY3Qub2JqZWN0cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGVubGl2ZW5lZE9iamVjdHMsIG9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcblxuICBpZiAoIWdsb2JhbC5mYWJyaWMpIHtcbiAgICBnbG9iYWwuZmFicmljID0geyB9O1xuICB9XG5cbiAgaWYgKGdsb2JhbC5mYWJyaWMuSW1hZ2UpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkltYWdlIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW1hZ2UgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI2ltYWdlc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdpbWFnZScsXG5cbiAgICAvKipcbiAgICAgKiBjcm9zc09yaWdpbiB2YWx1ZSAob25lIG9mIFwiXCIsIFwiYW5vbnltb3VzXCIsIFwidXNlLWNyZWRlbnRpYWxzXCIpXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjcm9zc09yaWdpbjogJycsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIHN0cm9rZS5cbiAgICAgKiBGb3IgaW1hZ2UgcXVhbGl0eSBhIHN0cm9rZSBtdWx0aXBsZSBvZiAyIGdpdmVzIGJldHRlciByZXN1bHRzLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsZVggdG8gZGV0ZWN0XG4gICAgICogaWYgdGhlIEltYWdlIGdvdCByZXNpemVkIGFmdGVyIHRoZSBsYXN0IFJlbmRlclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9sYXN0U2NhbGVYOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGVZIHRvIGRldGVjdFxuICAgICAqIGlmIHRoZSBJbWFnZSBnb3QgcmVzaXplZCBhZnRlciB0aGUgbGFzdCBSZW5kZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfbGFzdFNjYWxlWTogMSxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxpbmcgYXBwbGllZCBieSB0aGUgYXBwbHkgZmlsdGVyIGNoYWluXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2ZpbHRlclNjYWxpbmdYOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGluZyBhcHBsaWVkIGJ5IHRoZSBhcHBseSBmaWx0ZXIgY2hhaW5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfZmlsdGVyU2NhbGluZ1k6IDEsXG5cbiAgICAvKipcbiAgICAgKiBtaW5pbXVtIHNjYWxlIGZhY3RvciB1bmRlciB3aGljaCBhbnkgcmVzaXplRmlsdGVyIGlzIHRyaWdnZXJlZCB0byByZXNpemUgdGhlIGltYWdlXG4gICAgICogMCB3aWxsIGRpc2FibGUgdGhlIGF1dG9tYXRpYyByZXNpemUuIDEgd2lsbCB0cmlnZ2VyIGF1dG9tYXRpY2FsbHkgYWx3YXlzLlxuICAgICAqIG51bWJlciBiaWdnZXIgdGhhbiAxIGFyZSBub3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIG1pbmltdW1TY2FsZVRyaWdnZXI6IDAuNSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmXG4gICAgICogc3RhdGUgb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKHtAbGluayBmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZH0pXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCdjcm9wWCcsICdjcm9wWScpLFxuXG4gICAgLyoqXG4gICAgICoga2V5IHVzZWQgdG8gcmV0cmlldmUgdGhlIHRleHR1cmUgcmVwcmVzZW50aW5nIHRoaXMgaW1hZ2VcbiAgICAgKiBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2FjaGVLZXk6ICcnLFxuXG4gICAgLyoqXG4gICAgICogSW1hZ2UgY3JvcCBpbiBwaXhlbHMgZnJvbSBvcmlnaW5hbCBpbWFnZSBzaXplLlxuICAgICAqIHNpbmNlIDIuMC4wXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjcm9wWDogMCxcblxuICAgIC8qKlxuICAgICAqIEltYWdlIGNyb3AgaW4gcGl4ZWxzIGZyb20gb3JpZ2luYWwgaW1hZ2Ugc2l6ZS5cbiAgICAgKiBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3JvcFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IFN0cmluZ30gZWxlbWVudCBJbWFnZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciBldmVudHVhbCBmaWx0ZXJzIGFwcGxpZWQuXG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICAgIHRoaXMuY2FjaGVLZXkgPSAndGV4dHVyZScgKyBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEVsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW1hZ2UgZWxlbWVudCB3aGljaCB0aGlzIGluc3RhbmNlIGlmIGJhc2VkIG9uXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gSW1hZ2UgZWxlbWVudFxuICAgICAqL1xuICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQgfHwge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgaW1hZ2UgZWxlbWVudCBmb3IgdGhpcyBpbnN0YW5jZSB0byBhIHNwZWNpZmllZCBvbmUuXG4gICAgICogSWYgZmlsdGVycyBkZWZpbmVkIHRoZXkgYXJlIGFwcGxpZWQgdG8gbmV3IGltYWdlLlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYGNhbnZhcy5yZW5kZXJBbGxgIGFuZCBgb2JqZWN0LnNldENvb3Jkc2AgYWZ0ZXIgcmVwbGFjaW5nLCB0byByZW5kZXIgbmV3IGltYWdlIGFuZCB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dHVyZSh0aGlzLmNhY2hlS2V5KTtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dHVyZSh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9vcmlnaW5hbEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5faW5pdENvbmZpZyhvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRoaXMuYXBwbHlGaWx0ZXJzKCk7XG4gICAgICB9XG4gICAgICAvLyByZXNpemVGaWx0ZXJzIHdvcmsgb24gdGhlIGFscmVhZHkgZmlsdGVyZWQgY29weS5cbiAgICAgIC8vIHdlIG5lZWQgdG8gYXBwbHkgcmVzaXplRmlsdGVycyBBRlRFUiBub3JtYWwgZmlsdGVycy5cbiAgICAgIC8vIGFwcGx5UmVzaXplRmlsdGVycyBpcyBydW4gbW9yZSBvZnRlbiB0aGFuIG5vcm1hbCBmaXRlcnNcbiAgICAgIC8vIGFuZCBpcyB0cmlnZ2VyZWQgYnkgdXNlciBpbnRlcmFjdGlvbnMgcmF0aGVyIHRoYW4gZGV2IGNvZGVcbiAgICAgIGlmICh0aGlzLnJlc2l6ZUZpbHRlcikge1xuICAgICAgICB0aGlzLmFwcGx5UmVzaXplRmlsdGVycygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHNpbmdsZSB0ZXh0dXJlIGlmIGluIHdlYmdsIG1vZGVcbiAgICAgKi9cbiAgICByZW1vdmVUZXh0dXJlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBiYWNrZW5kID0gZmFicmljLmZpbHRlckJhY2tlbmQ7XG4gICAgICBpZiAoYmFja2VuZCAmJiBiYWNrZW5kLmV2aWN0Q2FjaGVzRm9yS2V5KSB7XG4gICAgICAgIGJhY2tlbmQuZXZpY3RDYWNoZXNGb3JLZXkoa2V5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRleHR1cmVzLCByZWZlcmVuY2UgdG8gZWxlbWVudHMgYW5kIGV2ZW50dWFsbHkgSlNET00gY2xlYW51cFxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkpO1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG4gICAgICB0aGlzLl9jYWNoZUNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICBbJ19vcmlnaW5hbEVsZW1lbnQnLCAnX2VsZW1lbnQnLCAnX2ZpbHRlcmVkRWwnLCAnX2NhY2hlQ2FudmFzJ10uZm9yRWFjaCgoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBmYWJyaWMudXRpbC5jbGVhblVwSnNkb21Ob2RlKHRoaXNbZWxlbWVudF0pO1xuICAgICAgICB0aGlzW2VsZW1lbnRdID0gdW5kZWZpbmVkO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY3Jvc3NPcmlnaW4gdmFsdWUgKG9uIGFuIGluc3RhbmNlIGFuZCBjb3JyZXNwb25kaW5nIGltYWdlIGVsZW1lbnQpXG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuICAgICAgdGhpcy5fZWxlbWVudC5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvcmlnaW5hbCBzaXplIG9mIGFuIGltYWdlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBcIndpZHRoXCIgYW5kIFwiaGVpZ2h0XCIgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldE9yaWdpbmFsU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGVsZW1lbnQubmF0dXJhbFdpZHRoIHx8IGVsZW1lbnQud2lkdGgsXG4gICAgICAgIGhlaWdodDogZWxlbWVudC5uYXR1cmFsSGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfc3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdyA9IHRoaXMud2lkdGggLyAyLCBoID0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygtdywgLWgpO1xuICAgICAgY3R4LmxpbmVUbyh3LCAtaCk7XG4gICAgICBjdHgubGluZVRvKHcsIGgpO1xuICAgICAgY3R4LmxpbmVUbygtdywgaCk7XG4gICAgICBjdHgubGluZVRvKC13LCAtaCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHggPSAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgeSA9IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0U3Ryb2tlU3R5bGVzKGN0eCwgdGhpcyk7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSwgeCArIHcsIHksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCArIHcsIHksIHggKyB3LCB5ICsgaCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4ICsgdywgeSArIGgsIHgsIHkgKyBoLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHgsIHkgKyBoLCB4LCB5LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgZmlsdGVycyA9IFtdO1xuXG4gICAgICB0aGlzLmZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXJPYmopIHtcbiAgICAgICAgaWYgKGZpbHRlck9iaikge1xuICAgICAgICAgIGZpbHRlcnMucHVzaChmaWx0ZXJPYmoudG9PYmplY3QoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIG9iamVjdCA9IGV4dGVuZChcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoXG4gICAgICAgICAgJ3RvT2JqZWN0JyxcbiAgICAgICAgICBbJ2Nyb3NzT3JpZ2luJywgJ2Nyb3BYJywgJ2Nyb3BZJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpXG4gICAgICAgICksIHtcbiAgICAgICAgICBzcmM6IHRoaXMuZ2V0U3JjKCksXG4gICAgICAgICAgZmlsdGVyczogZmlsdGVycyxcbiAgICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5yZXNpemVGaWx0ZXIpIHtcbiAgICAgICAgb2JqZWN0LnJlc2l6ZUZpbHRlciA9IHRoaXMucmVzaXplRmlsdGVyLnRvT2JqZWN0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYW4gaW1hZ2UgaGFzIGNyb3AgYXBwbGllZCwgaW5zcGVjdGluZyB2YWx1ZXMgb2YgY3JvcFgsY3JvcFksd2lkdGgsaGlnaHQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDcm9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyb3BYIHx8IHRoaXMuY3JvcFkgfHwgdGhpcy53aWR0aCA8IHRoaXMuX2VsZW1lbnQud2lkdGggfHwgdGhpcy5oZWlnaHQgPCB0aGlzLl9lbGVtZW50LmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3ZnU3RyaW5nID0gW10sIGltYWdlTWFya3VwID0gW10sIHN0cm9rZVN2ZyxcbiAgICAgICAgICB4ID0gLXRoaXMud2lkdGggLyAyLCB5ID0gLXRoaXMuaGVpZ2h0IC8gMiwgY2xpcFBhdGggPSAnJztcbiAgICAgIGlmICh0aGlzLmhhc0Nyb3AoKSkge1xuICAgICAgICB2YXIgY2xpcFBhdGhJZCA9IGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgICAgc3ZnU3RyaW5nLnB1c2goXG4gICAgICAgICAgJzxjbGlwUGF0aCBpZD1cImltYWdlQ3JvcF8nICsgY2xpcFBhdGhJZCArICdcIj5cXG4nLFxuICAgICAgICAgICdcXHQ8cmVjdCB4PVwiJyArIHggKyAnXCIgeT1cIicgKyB5ICsgJ1wiIHdpZHRoPVwiJyArIHRoaXMud2lkdGggKyAnXCIgaGVpZ2h0PVwiJyArIHRoaXMuaGVpZ2h0ICsgJ1wiIC8+XFxuJyxcbiAgICAgICAgICAnPC9jbGlwUGF0aD5cXG4nXG4gICAgICAgICk7XG4gICAgICAgIGNsaXBQYXRoID0gJyBjbGlwLXBhdGg9XCJ1cmwoI2ltYWdlQ3JvcF8nICsgY2xpcFBhdGhJZCArICcpXCIgJztcbiAgICAgIH1cbiAgICAgIGltYWdlTWFya3VwLnB1c2goJ1xcdDxpbWFnZSAnLCAnQ09NTU9OX1BBUlRTJywgJ3hsaW5rOmhyZWY9XCInLCB0aGlzLmdldFN2Z1NyYyh0cnVlKSxcbiAgICAgICAgJ1wiIHg9XCInLCB4IC0gdGhpcy5jcm9wWCwgJ1wiIHk9XCInLCB5IC0gdGhpcy5jcm9wWSxcbiAgICAgICAgLy8gd2UncmUgZXNzZW50aWFsbHkgbW92aW5nIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRvcC9sZWZ0IGNvcm5lciB0byB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZVxuICAgICAgICAvLyBieSB3cmFwcGluZyBpdCBpbiBjb250YWluZXIgPGc+IGVsZW1lbnQgd2l0aCBhY3R1YWwgdHJhbnNmb3JtYXRpb24sIHRoZW4gb2Zmc2V0dGluZyBvYmplY3QgdG8gdGhlIHRvcC9sZWZ0XG4gICAgICAgIC8vIHNvIHRoYXQgb2JqZWN0J3MgY2VudGVyIGFsaWducyB3aXRoIGNvbnRhaW5lcidzIGxlZnQvdG9wXG4gICAgICAgICdcIiB3aWR0aD1cIicsIHRoaXMuX2VsZW1lbnQud2lkdGggfHwgdGhpcy5fZWxlbWVudC5uYXR1cmFsV2lkdGgsXG4gICAgICAgICdcIiBoZWlnaHQ9XCInLCB0aGlzLl9lbGVtZW50LmhlaWdodCB8fCB0aGlzLl9lbGVtZW50LmhlaWdodCxcbiAgICAgICAgJ1wiJywgY2xpcFBhdGgsXG4gICAgICAgICc+PC9pbWFnZT5cXG4nKTtcblxuICAgICAgaWYgKHRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlRGFzaEFycmF5KSB7XG4gICAgICAgIHZhciBvcmlnRmlsbCA9IHRoaXMuZmlsbDtcbiAgICAgICAgdGhpcy5maWxsID0gbnVsbDtcbiAgICAgICAgc3Ryb2tlU3ZnID0gW1xuICAgICAgICAgICdcXHQ8cmVjdCAnLFxuICAgICAgICAgICd4PVwiJywgeCwgJ1wiIHk9XCInLCB5LFxuICAgICAgICAgICdcIiB3aWR0aD1cIicsIHRoaXMud2lkdGgsICdcIiBoZWlnaHQ9XCInLCB0aGlzLmhlaWdodCxcbiAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICBdO1xuICAgICAgICB0aGlzLmZpbGwgPSBvcmlnRmlsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhaW50Rmlyc3QgIT09ICdmaWxsJykge1xuICAgICAgICBzdmdTdHJpbmcgPSBzdmdTdHJpbmcuY29uY2F0KHN0cm9rZVN2ZywgaW1hZ2VNYXJrdXApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN2Z1N0cmluZyA9IHN2Z1N0cmluZy5jb25jYXQoaW1hZ2VNYXJrdXAsIHN0cm9rZVN2Zyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ZnU3RyaW5nO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNvdXJjZSBvZiBhbiBpbWFnZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmlsdGVyZWQgaW5kaWNhdGVzIGlmIHRoZSBzcmMgaXMgbmVlZGVkIGZvciBzdmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNvdXJjZSBvZiBhbiBpbWFnZVxuICAgICAqL1xuICAgIGdldFNyYzogZnVuY3Rpb24oZmlsdGVyZWQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZmlsdGVyZWQgPyB0aGlzLl9lbGVtZW50IDogdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQudG9EYXRhVVJMKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQudG9EYXRhVVJMKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3JjO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNyYyB8fCAnJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzb3VyY2Ugb2YgYW4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFNvdXJjZSBzdHJpbmcgKFVSTClcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBpbWFnZSBoYXMgYmVlbiBsb2FkZWQgKGFuZCBhbGwgZmlsdGVycyBoYXZlIGJlZW4gYXBwbGllZClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFNyYzogZnVuY3Rpb24oc3JjLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKHNyYywgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudChpbWcsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodCgpO1xuICAgICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICAgIH0sIHRoaXMsIG9wdGlvbnMgJiYgb3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuSW1hZ2U6IHsgc3JjOiBcIicgKyB0aGlzLmdldFNyYygpICsgJ1wiIH0+JztcbiAgICB9LFxuXG4gICAgYXBwbHlSZXNpemVGaWx0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLnJlc2l6ZUZpbHRlcixcbiAgICAgICAgICBtaW5pbXVtU2NhbGUgPSB0aGlzLm1pbmltdW1TY2FsZVRyaWdnZXIsXG4gICAgICAgICAgb2JqZWN0U2NhbGUgPSB0aGlzLmdldFRvdGFsT2JqZWN0U2NhbGluZygpLFxuICAgICAgICAgIHNjYWxlWCA9IG9iamVjdFNjYWxlLnNjYWxlWCxcbiAgICAgICAgICBzY2FsZVkgPSBvYmplY3RTY2FsZS5zY2FsZVksXG4gICAgICAgICAgZWxlbWVudFRvRmlsdGVyID0gdGhpcy5fZmlsdGVyZWRFbCB8fCB0aGlzLl9vcmlnaW5hbEVsZW1lbnQ7XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICB0aGlzLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZmlsdGVyIHx8IChzY2FsZVggPiBtaW5pbXVtU2NhbGUgJiYgc2NhbGVZID4gbWluaW11bVNjYWxlKSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFRvRmlsdGVyO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IDE7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gMTtcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFmYWJyaWMuZmlsdGVyQmFja2VuZCkge1xuICAgICAgICBmYWJyaWMuZmlsdGVyQmFja2VuZCA9IGZhYnJpYy5pbml0RmlsdGVyQmFja2VuZCgpO1xuICAgICAgfVxuICAgICAgdmFyIGNhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICAgIGNhY2hlS2V5ID0gdGhpcy5fZmlsdGVyZWRFbCA/ICh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpIDogdGhpcy5jYWNoZUtleSxcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9IGVsZW1lbnRUb0ZpbHRlci53aWR0aCwgc291cmNlSGVpZ2h0ID0gZWxlbWVudFRvRmlsdGVyLmhlaWdodDtcbiAgICAgIGNhbnZhc0VsLndpZHRoID0gc291cmNlV2lkdGg7XG4gICAgICBjYW52YXNFbC5oZWlnaHQgPSBzb3VyY2VIZWlnaHQ7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gY2FudmFzRWw7XG4gICAgICB0aGlzLl9sYXN0U2NhbGVYID0gZmlsdGVyLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSBmaWx0ZXIuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQuYXBwbHlGaWx0ZXJzKFxuICAgICAgICBbZmlsdGVyXSwgZWxlbWVudFRvRmlsdGVyLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0aGlzLl9lbGVtZW50LCBjYWNoZUtleSk7XG4gICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IGNhbnZhc0VsLndpZHRoIC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LndpZHRoO1xuICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSBjYW52YXNFbC5oZWlnaHQgLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlcnMgYXNzaWduZWQgdG8gdGhpcyBpbWFnZSAoZnJvbSBcImZpbHRlcnNcIiBhcnJheSkgb3IgZnJvbSBmaWx0ZXIgcGFyYW1cbiAgICAgKiBAbWV0aG9kIGFwcGx5RmlsdGVyc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgYXBwbGllZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yUmVzaXppbmcgc3BlY2lmeSBpZiB0aGUgZmlsdGVyIG9wZXJhdGlvbiBpcyBhIHJlc2l6ZSBvcGVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHt0aGlzQXJnfSByZXR1cm4gdGhlIGZhYnJpYy5JbWFnZSBvYmplY3RcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzKSB7XG5cbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzIHx8IHRoaXMuZmlsdGVycyB8fCBbXTtcbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzLmZpbHRlcihmdW5jdGlvbihmaWx0ZXIpIHsgcmV0dXJuIGZpbHRlciAmJiAhZmlsdGVyLmlzTmV1dHJhbFN0YXRlKCk7IH0pO1xuICAgICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG5cbiAgICAgIC8vIG5lZWRzIHRvIGNsZWFyIG91dCBvciBXRUJHTCB3aWxsIG5vdCByZXNpemUgY29ycmVjdGx5XG4gICAgICB0aGlzLnJlbW92ZVRleHR1cmUodGhpcy5jYWNoZUtleSArICdfZmlsdGVyZWQnKTtcblxuICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9vcmlnaW5hbEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkRWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IDE7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbWdFbGVtZW50ID0gdGhpcy5fb3JpZ2luYWxFbGVtZW50LFxuICAgICAgICAgIHNvdXJjZVdpZHRoID0gaW1nRWxlbWVudC5uYXR1cmFsV2lkdGggfHwgaW1nRWxlbWVudC53aWR0aCxcbiAgICAgICAgICBzb3VyY2VIZWlnaHQgPSBpbWdFbGVtZW50Lm5hdHVyYWxIZWlnaHQgfHwgaW1nRWxlbWVudC5oZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLl9lbGVtZW50ID09PSB0aGlzLl9vcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaXMgdGhlIHNhbWUgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgZWxlbWVudFxuICAgICAgICB2YXIgY2FudmFzRWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgIGNhbnZhc0VsLndpZHRoID0gc291cmNlV2lkdGg7XG4gICAgICAgIGNhbnZhc0VsLmhlaWdodCA9IHNvdXJjZUhlaWdodDtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGNhbnZhc0VsO1xuICAgICAgICB0aGlzLl9maWx0ZXJlZEVsID0gY2FudmFzRWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gY2xlYXIgdGhlIGV4aXN0aW5nIGVsZW1lbnQgdG8gZ2V0IG5ldyBmaWx0ZXIgZGF0YVxuICAgICAgICAvLyBhbHNvIGRlcmVmZXJlbmNlIHRoZSBldmVudHVhbCByZXNpemVkIF9lbGVtZW50XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9maWx0ZXJlZEVsO1xuICAgICAgICB0aGlzLl9maWx0ZXJlZEVsLmdldENvbnRleHQoJzJkJykuY2xlYXJSZWN0KDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgICAvLyB3ZSBhbHNvIG5lZWQgdG8gcmVzaXplIGFnYWluIGF0IG5leHQgcmVuZGVyQWxsLCBzbyByZW1vdmUgc2F2ZWQgX2xhc3RTY2FsZVgvWVxuICAgICAgICB0aGlzLl9sYXN0U2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAoIWZhYnJpYy5maWx0ZXJCYWNrZW5kKSB7XG4gICAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kID0gZmFicmljLmluaXRGaWx0ZXJCYWNrZW5kKCk7XG4gICAgICB9XG4gICAgICBmYWJyaWMuZmlsdGVyQmFja2VuZC5hcHBseUZpbHRlcnMoXG4gICAgICAgIGZpbHRlcnMsIHRoaXMuX29yaWdpbmFsRWxlbWVudCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGhpcy5fZWxlbWVudCwgdGhpcy5jYWNoZUtleSk7XG4gICAgICBpZiAodGhpcy5fb3JpZ2luYWxFbGVtZW50LndpZHRoICE9PSB0aGlzLl9lbGVtZW50LndpZHRoIHx8XG4gICAgICAgIHRoaXMuX29yaWdpbmFsRWxlbWVudC5oZWlnaHQgIT09IHRoaXMuX2VsZW1lbnQuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdYID0gdGhpcy5fZWxlbWVudC53aWR0aCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC53aWR0aDtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSB0aGlzLl9lbGVtZW50LmhlaWdodCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC5oZWlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5pc01vdmluZyAhPT0gdHJ1ZSAmJiB0aGlzLnJlc2l6ZUZpbHRlciAmJiB0aGlzLl9uZWVkc1Jlc2l6ZSgpKSB7XG4gICAgICAgIHRoaXMuYXBwbHlSZXNpemVGaWx0ZXJzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdHJva2UoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG9iamVjdENhY2hpbmcgaXMgYSBnbG9iYWwgZmxhZywgd2lucyBvdmVyIGV2ZXJ5dGhpbmdcbiAgICAgKiBuZWVkc0l0c093bkNhY2hlIHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIG9iamVjdCBkcmF3aW5nIG1ldGhvZCByZXF1aXJlc1xuICAgICAqIGEgY2FjaGUgc3RlcC4gTm9uZSBvZiB0aGUgZmFicmljIGNsYXNzZXMgcmVxdWlyZXMgaXQuXG4gICAgICogR2VuZXJhbGx5IHlvdSBkbyBub3QgY2FjaGUgb2JqZWN0cyBpbiBncm91cHMgYmVjYXVzZSB0aGUgZ3JvdXAgb3V0c2lkZSBpcyBjYWNoZWQuXG4gICAgICogVGhpcyBpcyB0aGUgc3BlY2lhbCBpbWFnZSB2ZXJzaW9uIHdoZXJlIHdlIHdvdWxkIGxpa2UgdG8gYXZvaWQgY2FjaGluZyB3aGVyZSBwb3NzaWJsZS5cbiAgICAgKiBFc3NlbnRpYWxseSBpbWFnZXMgZG8gbm90IGJlbmVmaXQgZnJvbSBjYWNoaW5nLiBUaGV5IG1heSByZXF1aXJlIGNhY2hpbmcsIGFuZCBpbiB0aGF0XG4gICAgICogY2FzZSB3ZSBkbyBpdC4gQWxzbyBjYWNoaW5nIGFuIGltYWdlIHVzdWFsbHkgZW5kcyBpbiBhIGxvc3Mgb2YgZGV0YWlscy5cbiAgICAgKiBBIGZ1bGwgcGVyZm9ybWFuY2UgYXVkaXQgc2hvdWxkIGJlIGRvbmUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG91bGRDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm93bkNhY2hpbmcgPSB0aGlzLm9iamVjdENhY2hpbmcgJiYgdGhpcy5uZWVkc0l0c093bkNhY2hlKCk7XG4gICAgICByZXR1cm4gdGhpcy5vd25DYWNoaW5nO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyRmlsbDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgZWxlbWVudFRvRHJhdyA9IHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsIGggPSB0aGlzLmhlaWdodCxcbiAgICAgICAgICBzVyA9IE1hdGgubWluKGVsZW1lbnRUb0RyYXcubmF0dXJhbFdpZHRoIHx8IGVsZW1lbnRUb0RyYXcud2lkdGgsIHcgKiB0aGlzLl9maWx0ZXJTY2FsaW5nWCksXG4gICAgICAgICAgc0ggPSBNYXRoLm1pbihlbGVtZW50VG9EcmF3Lm5hdHVyYWxIZWlnaHQgfHwgZWxlbWVudFRvRHJhdy5oZWlnaHQsIGggKiB0aGlzLl9maWx0ZXJTY2FsaW5nWSksXG4gICAgICAgICAgeCA9IC13IC8gMiwgeSA9IC1oIC8gMixcbiAgICAgICAgICBzWCA9IE1hdGgubWF4KDAsIHRoaXMuY3JvcFggKiB0aGlzLl9maWx0ZXJTY2FsaW5nWCksXG4gICAgICAgICAgc1kgPSBNYXRoLm1heCgwLCB0aGlzLmNyb3BZICogdGhpcy5fZmlsdGVyU2NhbGluZ1kpO1xuXG4gICAgICBlbGVtZW50VG9EcmF3ICYmIGN0eC5kcmF3SW1hZ2UoZWxlbWVudFRvRHJhdywgc1gsIHNZLCBzVywgc0gsIHgsIHksIHcsIGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSwgbmVlZGVkIHRvIGNoZWNrIGlmIGltYWdlIG5lZWRzIHJlc2l6ZVxuICAgICAqL1xuICAgIF9uZWVkc1Jlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldFRvdGFsT2JqZWN0U2NhbGluZygpO1xuICAgICAgcmV0dXJuIChzY2FsZS5zY2FsZVggIT09IHRoaXMuX2xhc3RTY2FsZVggfHwgc2NhbGUuc2NhbGVZICE9PSB0aGlzLl9sYXN0U2NhbGVZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzZXRXaWR0aEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldCh0aGlzLmdldE9yaWdpbmFsU2l6ZSgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIEltYWdlIGNsYXNzJ3MgaW5pdGlhbGl6YXRpb24gbWV0aG9kLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxTdHJpbmd9IGVsZW1lbnQgVGhlIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2V0RWxlbWVudChmYWJyaWMudXRpbC5nZXRCeUlkKGVsZW1lbnQpLCBvcHRpb25zKTtcbiAgICAgIGZhYnJpYy51dGlsLmFkZENsYXNzKHRoaXMuZ2V0RWxlbWVudCgpLCBmYWJyaWMuSW1hZ2UuQ1NTX0NBTlZBUyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0Q29uZmlnOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMuX3NldFdpZHRoSGVpZ2h0KG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgJiYgdGhpcy5jcm9zc09yaWdpbikge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzIHRvIGJlIGluaXRpYWxpemVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYWxsIGZhYnJpYy5JbWFnZS5maWx0ZXJzIGluc3RhbmNlcyBhcmUgY3JlYXRlZFxuICAgICAqL1xuICAgIF9pbml0RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChmaWx0ZXJzICYmIGZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKGZpbHRlcnMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgfSwgJ2ZhYnJpYy5JbWFnZS5maWx0ZXJzJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTZXQgdGhlIHdpZHRoIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSBvYmplY3QsIHVzaW5nIHRoZSBlbGVtZW50IG9yIHRoZVxuICAgICAqIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCB3aWR0aC9oZWlnaHQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIF9zZXRXaWR0aEhlaWdodDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB2YXIgZWwgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IGVsLm5hdHVyYWxXaWR0aCB8fCBlbC53aWR0aCB8fCAwO1xuICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBlbC5uYXR1cmFsSGVpZ2h0IHx8IGVsLmhlaWdodCB8fCAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgb2Zmc2V0IGZvciBjZW50ZXIgYW5kIHNjYWxlIGZhY3RvciBmb3IgdGhlIGltYWdlIGluIG9yZGVyIHRvIHJlc3BlY3RcbiAgICAgKiB0aGUgcHJlc2VydmVBc3BlY3RSYXRpbyBhdHRyaWJ1dGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBBUiA9IGZhYnJpYy51dGlsLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZSh0aGlzLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJycpLFxuICAgICAgICAgIHJXaWR0aCA9IHRoaXMuX2VsZW1lbnQud2lkdGgsIHJIZWlnaHQgPSB0aGlzLl9lbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBzY2FsZVggPSAxLCBzY2FsZVkgPSAxLCBvZmZzZXRMZWZ0ID0gMCwgb2Zmc2V0VG9wID0gMCwgY3JvcFggPSAwLCBjcm9wWSA9IDAsXG4gICAgICAgICAgb2Zmc2V0LCBwV2lkdGggPSB0aGlzLndpZHRoLCBwSGVpZ2h0ID0gdGhpcy5oZWlnaHQsIHBhcnNlZEF0dHJpYnV0ZXMgPSB7IHdpZHRoOiBwV2lkdGgsIGhlaWdodDogcEhlaWdodCB9O1xuICAgICAgaWYgKHBBUiAmJiAocEFSLmFsaWduWCAhPT0gJ25vbmUnIHx8IHBBUi5hbGlnblkgIT09ICdub25lJykpIHtcbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gZmFicmljLnV0aWwuZmluZFNjYWxlVG9GaXQodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gKHBXaWR0aCAtIHJXaWR0aCAqIHNjYWxlWCkgLyAyO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWluJykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IC1vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWF4Jykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0ID0gKHBIZWlnaHQgLSBySGVpZ2h0ICogc2NhbGVZKSAvIDI7XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgICAgICBvZmZzZXRUb3AgPSAtb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIG9mZnNldFRvcCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IGZhYnJpYy51dGlsLmZpbmRTY2FsZVRvQ292ZXIodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gcldpZHRoIC0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWlkJykge1xuICAgICAgICAgICAgY3JvcFggPSBvZmZzZXQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWCA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIGNyb3BYID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQgPSBySGVpZ2h0IC0gcEhlaWdodCAvIHNjYWxlWTtcbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01pZCcpIHtcbiAgICAgICAgICAgIGNyb3BZID0gb2Zmc2V0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNYXgnKSB7XG4gICAgICAgICAgICBjcm9wWSA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcldpZHRoID0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIHJIZWlnaHQgPSBwSGVpZ2h0IC8gc2NhbGVZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGVYID0gcFdpZHRoIC8gcldpZHRoO1xuICAgICAgICBzY2FsZVkgPSBwSGVpZ2h0IC8gckhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiByV2lkdGgsXG4gICAgICAgIGhlaWdodDogckhlaWdodCxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICBvZmZzZXRMZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICBvZmZzZXRUb3A6IG9mZnNldFRvcCxcbiAgICAgICAgY3JvcFg6IGNyb3BYLFxuICAgICAgICBjcm9wWTogY3JvcFlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogRGVmYXVsdCBDU1MgY2xhc3MgbmFtZSBmb3IgY2FudmFzXG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQ1NTX0NBTlZBUyA9ICdjYW52YXMtaW1nJztcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGdldFNyY1xuICAgKiBAc3RhdGljXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLmdldFN2Z1NyYyA9IGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuZ2V0U3JjO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGl0cyBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBpbWFnZSBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKF9vYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdCA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShfb2JqZWN0KTtcbiAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob2JqZWN0LnNyYywgZnVuY3Rpb24oaW1nLCBlcnJvcikge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIG9iamVjdC5maWx0ZXJzLCBmdW5jdGlvbihmaWx0ZXJzKSB7XG4gICAgICAgIG9iamVjdC5maWx0ZXJzID0gZmlsdGVycyB8fCBbXTtcbiAgICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIFtvYmplY3QucmVzaXplRmlsdGVyXSwgZnVuY3Rpb24ocmVzaXplRmlsdGVycykge1xuICAgICAgICAgIG9iamVjdC5yZXNpemVGaWx0ZXIgPSByZXNpemVGaWx0ZXJzWzBdO1xuICAgICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKFtvYmplY3QuY2xpcFBhdGhdLCBmdW5jdGlvbihlbmxpdmVkUHJvcHMpIHtcbiAgICAgICAgICAgIG9iamVjdC5jbGlwUGF0aCA9IGVubGl2ZWRQcm9wc1swXTtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBvYmplY3QpO1xuICAgICAgICAgICAgY2FsbGJhY2soaW1hZ2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIG51bGwsIG9iamVjdC5jcm9zc09yaWdpbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLkltYWdlIGZyb20gYW4gVVJMIHN0cmluZ1xuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIGNyZWF0ZSBhbiBpbWFnZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgY3JlYXRlZCAobmV3bHkgY3JlYXRlZCBpbWFnZSBpcyBwYXNzZWQgYXMgYSBmaXJzdCBhcmd1bWVudClcbiAgICogQHBhcmFtIHtPYmplY3R9IFtpbWdPcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZyb21VUkwgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrLCBpbWdPcHRpb25zKSB7XG4gICAgZmFicmljLnV0aWwubG9hZEltYWdlKHVybCwgZnVuY3Rpb24oaW1nKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlKGltZywgaW1nT3B0aW9ucykpO1xuICAgIH0sIG51bGwsIGltZ09wdGlvbnMgJiYgaW1nT3B0aW9ucy5jcm9zc09yaWdpbik7XG4gIH07XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuSW1hZ2UuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNJbWFnZUVsZW1lbnR9XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQVRUUklCVVRFX05BTUVTID1cbiAgICBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4IHkgd2lkdGggaGVpZ2h0IHByZXNlcnZlQXNwZWN0UmF0aW8geGxpbms6aHJlZiBjcm9zc09yaWdpbicuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5JbWFnZX0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIGZhYnJpYy5JbWFnZSBvYmplY3QgaXMgY3JlYXRlZFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLkltYWdlLkFUVFJJQlVURV9OQU1FUyk7XG4gICAgZmFicmljLkltYWdlLmZyb21VUkwocGFyc2VkQXR0cmlidXRlc1sneGxpbms6aHJlZiddLCBjYWxsYmFjayxcbiAgICAgIGV4dGVuZCgob3B0aW9ucyA/IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKSA6IHsgfSksIHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlIHZhbHVlXG4gICAqL1xuICBfZ2V0QW5nbGVWYWx1ZUZvclN0cmFpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhbmdsZSA9IHRoaXMuYW5nbGUgJSAzNjA7XG4gICAgaWYgKGFuZ2xlID4gMCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoKGFuZ2xlIC0gMSkgLyA5MCkgKiA5MDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYW5nbGUgLyA5MCkgKiA5MDtcbiAgfSxcblxuICAvKipcbiAgICogU3RyYWlnaHRlbnMgYW4gb2JqZWN0IChyb3RhdGluZyBpdCBmcm9tIGN1cnJlbnQgYW5nbGUgdG8gb25lIG9mIDAsIDkwLCAxODAsIDI3MCwgZXRjLiBkZXBlbmRpbmcgb24gd2hpY2ggaXMgY2xvc2VyKVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHN0cmFpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucm90YXRlKHRoaXMuX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHtAbGluayBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdHJhaWdodGVufSBidXQgd2l0aCBhbmltYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrcyBPYmplY3Qgd2l0aCBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ4U3RyYWlnaHRlbjogZnVuY3Rpb24oY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IHRoaXMuZ2V0KCdhbmdsZScpLFxuICAgICAgZW5kVmFsdWU6IHRoaXMuX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuKCksXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfdGhpcy5yb3RhdGUodmFsdWUpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIFN0cmFpZ2h0ZW5zIG9iamVjdCwgdGhlbiByZXJlbmRlcnMgY2FudmFzXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzdHJhaWdodGVuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc3RyYWlnaHRlbk9iamVjdDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIG9iamVjdC5zdHJhaWdodGVuKCk7XG4gICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMge0BsaW5rIGZhYnJpYy5DYW52YXMucHJvdG90eXBlLnN0cmFpZ2h0ZW5PYmplY3R9LCBidXQgYW5pbWF0ZWRcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHN0cmFpZ2h0ZW5cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeFN0cmFpZ2h0ZW5PYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBvYmplY3QuZnhTdHJhaWdodGVuKHtcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLnJlcXVlc3RSZW5kZXJBbGxCb3VuZFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB3ZWJnbCBzdXBwb3J0cyBjZXJ0YWluIHByZWNpc2lvblxuICAgKiBAcGFyYW0ge1dlYkdMfSBDYW52YXMgV2ViR0wgY29udGV4dCB0byB0ZXN0IG9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBQcmVjaXNpb24gdG8gdGVzdCBjYW4gYmUgYW55IG9mIGZvbGxvd2luZzogJ2xvd3AnLCAnbWVkaXVtcCcsICdoaWdocCdcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIFdlYkdMIHN1cHBvcnRzIGdpdmVuIHByZWNpc2lvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHRlc3RQcmVjaXNpb24oZ2wsIHByZWNpc2lvbil7XG4gICAgdmFyIGZyYWdtZW50U291cmNlID0gJ3ByZWNpc2lvbiAnICsgcHJlY2lzaW9uICsgJyBmbG9hdDtcXG52b2lkIG1haW4oKXt9JztcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlIHdoZXRoZXIgdGhpcyBmaWx0ZXJpbmcgYmFja2VuZCBpcyBzdXBwb3J0ZWQgYnkgdGhlIHVzZXIncyBicm93c2VyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGlsZVNpemUgY2hlY2sgaWYgdGhlIHRpbGVTaXplIGlzIHN1cHBvcnRlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgc3VwcG9ydHMgV2ViR0wuXG4gICAqL1xuICBmYWJyaWMuaXNXZWJnbFN1cHBvcnRlZCA9IGZ1bmN0aW9uKHRpbGVTaXplKSB7XG4gICAgaWYgKGZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGlsZVNpemUgPSB0aWxlU2l6ZSB8fCBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZS50aWxlU2l6ZTtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xuICAgIHZhciBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmIChnbCkge1xuICAgICAgZmFicmljLm1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpO1xuICAgICAgaXNTdXBwb3J0ZWQgPSBmYWJyaWMubWF4VGV4dHVyZVNpemUgPj0gdGlsZVNpemU7XG4gICAgICB2YXIgcHJlY2lzaW9ucyA9IFsnaGlnaHAnLCAnbWVkaXVtcCcsICdsb3dwJ107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKyl7XG4gICAgICAgIGlmICh0ZXN0UHJlY2lzaW9uKGdsLCBwcmVjaXNpb25zW2ldKSl7XG4gICAgICAgICAgZmFicmljLndlYkdsUHJlY2lzaW9uID0gcHJlY2lzaW9uc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pc1N1cHBvcnRlZCA9IGlzU3VwcG9ydGVkO1xuICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgfTtcblxuICBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kID0gV2ViZ2xGaWx0ZXJCYWNrZW5kO1xuXG4gIC8qKlxuICAgKiBXZWJHTCBmaWx0ZXIgYmFja2VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIFdlYmdsRmlsdGVyQmFja2VuZChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aWxlU2l6ZSkge1xuICAgICAgdGhpcy50aWxlU2l6ZSA9IG9wdGlvbnMudGlsZVNpemU7XG4gICAgfVxuICAgIHRoaXMuc2V0dXBHTENvbnRleHQodGhpcy50aWxlU2l6ZSwgdGhpcy50aWxlU2l6ZSk7XG4gICAgdGhpcy5jYXB0dXJlR1BVSW5mbygpO1xuICB9O1xuXG4gIFdlYmdsRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5XZWJnbEZpbHRlckJhY2tlbmQucHJvdG90eXBlICovIHtcblxuICAgIHRpbGVTaXplOiAyMDQ4LFxuXG4gICAgLyoqXG4gICAgICogRXhwZXJpbWVudGFsLiBUaGlzIG9iamVjdCBpcyBhIHNvcnQgb2YgcmVwb3NpdG9yeSBvZiBoZWxwIGxheWVycyB1c2VkIHRvIGF2b2lkXG4gICAgICogb2YgcmVjcmVhdGluZyB0aGVtIGR1cmluZyBmcmVxdWVudCBmaWx0ZXJpbmcuIElmIHlvdSBhcmUgcHJldmlld2luZyBhIGZpbHRlciB3aXRoXG4gICAgICogYSBzbGlkZXIgeW91IHByb2JsYWJseSBkbyBub3Qgd2FudCB0byBjcmVhdGUgaGVscCBsYXllcnMgZXZlcnkgZmlsdGVyIHN0ZXAuXG4gICAgICogaW4gdGhpcyBvYmplY3QgdGhlcmUgd2lsbCBiZSBhcHBlbmRlZCBzb21lIGNhbnZhc2VzLCBjcmVhdGVkIG9uY2UsIHJlc2l6ZWQgc29tZXRpbWVzXG4gICAgICogY2xlYXJlZCBuZXZlci4gQ2xlYXJpbmcgaXMgbGVmdCB0byB0aGUgZGV2ZWxvcGVyLlxuICAgICAqKi9cbiAgICByZXNvdXJjZXM6IHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXR1cCBhIFdlYkdMIGNvbnRleHQgc3VpdGFibGUgZm9yIGZpbHRlcmluZywgYW5kIGJpbmQgYW55IG5lZWRlZCBldmVudCBoYW5kbGVycy5cbiAgICAgKi9cbiAgICBzZXR1cEdMQ29udGV4dDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLmNyZWF0ZVdlYkdMQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB0aGlzLmFQb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdKTtcbiAgICAgIHRoaXMuY2hvb3NlRmFzdGVzdENvcHlHTFRvMkRNZXRob2Qod2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpY2sgYSBtZXRob2QgdG8gY29weSBkYXRhIGZyb20gR0wgY29udGV4dCB0byAyZCBjYW52YXMuICBJbiBzb21lIGJyb3dzZXJzIHVzaW5nXG4gICAgICogcHV0SW1hZ2VEYXRhIGlzIGZhc3RlciB0aGFuIGRyYXdJbWFnZSBmb3IgdGhhdCBzcGVjaWZpYyBvcGVyYXRpb24uXG4gICAgICovXG4gICAgY2hvb3NlRmFzdGVzdENvcHlHTFRvMkRNZXRob2Q6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBjYW5NZWFzdXJlUGVyZiA9IHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnO1xuICAgICAgdmFyIGNhblVzZUltYWdlRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBJbWFnZURhdGEoMSwgMSk7XG4gICAgICAgIGNhblVzZUltYWdlRGF0YSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBjYW5Vc2VJbWFnZURhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGNhblVzZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGNhblVzZVVpbnQ4Q2xhbXBlZCA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgIGlmICghKGNhbk1lYXN1cmVQZXJmICYmIGNhblVzZUltYWdlRGF0YSAmJiBjYW5Vc2VBcnJheUJ1ZmZlciAmJiBjYW5Vc2VVaW50OENsYW1wZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldENhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGltYWdlQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICB2YXIgdGVzdENvbnRleHQgPSB7XG4gICAgICAgIGltYWdlQnVmZmVyOiBpbWFnZUJ1ZmZlcixcbiAgICAgICAgZGVzdGluYXRpb25XaWR0aDogd2lkdGgsXG4gICAgICAgIGRlc3RpbmF0aW9uSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHRhcmdldENhbnZhczogdGFyZ2V0Q2FudmFzXG4gICAgICB9O1xuICAgICAgdmFyIHN0YXJ0VGltZSwgZHJhd0ltYWdlVGltZSwgcHV0SW1hZ2VEYXRhVGltZTtcbiAgICAgIHRhcmdldENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29weUdMVG8yRERyYXdJbWFnZS5jYWxsKHRlc3RDb250ZXh0LCB0aGlzLmdsLCB0ZXN0Q29udGV4dCk7XG4gICAgICBkcmF3SW1hZ2VUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICBzdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhLmNhbGwodGVzdENvbnRleHQsIHRoaXMuZ2wsIHRlc3RDb250ZXh0KTtcbiAgICAgIHB1dEltYWdlRGF0YVRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIGlmIChkcmF3SW1hZ2VUaW1lID4gcHV0SW1hZ2VEYXRhVGltZSkge1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyID0gaW1hZ2VCdWZmZXI7XG4gICAgICAgIHRoaXMuY29weUdMVG8yRCA9IGNvcHlHTFRvMkRQdXRJbWFnZURhdGE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3B5R0xUbzJEID0gY29weUdMVG8yRERyYXdJbWFnZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY2FudmFzIGVsZW1lbnQgYW5kIGFzc29jaWF0ZWQgV2ViR0wgY29udGV4dCBhbmQgYXR0YWNoZXMgdGhlbSBhc1xuICAgICAqIGNsYXNzIHByb3BlcnRpZXMgdG8gdGhlIEdMRmlsdGVyQmFja2VuZCBjbGFzcy5cbiAgICAgKi9cbiAgICBjcmVhdGVXZWJHTENhbnZhczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGNhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHZhciBnbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgICAgICAgICBkZXB0aDogZmFsc2UsXG4gICAgICAgICAgICBzdGVuY2lsOiBmYWxzZSxcbiAgICAgICAgICAgIGFudGlhbGlhczogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgZ2xPcHRpb25zKTtcbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgZ2xPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgIC8vIHRoaXMgY2FudmFzIGNhbiBmaXJlIHdlYmdsY29udGV4dGxvc3QgYW5kIHdlYmdsY29udGV4dHJlc3RvcmVkXG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gYXBwbHkgdGhlIHJlcXVlc3RlZCBmaWx0ZXJzIHRvIHRoZSBzb3VyY2UgcHJvdmlkZWQsIGRyYXdpbmcgdGhlIGZpbHRlcmVkIG91dHB1dFxuICAgICAqIHRvIHRoZSBwcm92aWRlZCB0YXJnZXQgY2FudmFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVycyBUaGUgZmlsdGVycyB0byBhcHBseS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZSBUaGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIGRlc3RpbmF0aW9uIGZvciBmaWx0ZXJlZCBvdXRwdXQgdG8gYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd8dW5kZWZpbmVkfSBjYWNoZUtleSBBIGtleSB1c2VkIHRvIGNhY2hlIHJlc291cmNlcyByZWxhdGVkIHRvIHRoZSBzb3VyY2UuIElmXG4gICAgICogb21pdHRlZCwgY2FjaGluZyB3aWxsIGJlIHNraXBwZWQuXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBzb3VyY2UsIHdpZHRoLCBoZWlnaHQsIHRhcmdldENhbnZhcywgY2FjaGVLZXkpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICB2YXIgY2FjaGVkVGV4dHVyZTtcbiAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICBjYWNoZWRUZXh0dXJlID0gdGhpcy5nZXRDYWNoZWRUZXh0dXJlKGNhY2hlS2V5LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIHBpcGVsaW5lU3RhdGUgPSB7XG4gICAgICAgIG9yaWdpbmFsV2lkdGg6IHNvdXJjZS53aWR0aCB8fCBzb3VyY2Uub3JpZ2luYWxXaWR0aCxcbiAgICAgICAgb3JpZ2luYWxIZWlnaHQ6IHNvdXJjZS5oZWlnaHQgfHwgc291cmNlLm9yaWdpbmFsSGVpZ2h0LFxuICAgICAgICBzb3VyY2VXaWR0aDogd2lkdGgsXG4gICAgICAgIHNvdXJjZUhlaWdodDogaGVpZ2h0LFxuICAgICAgICBkZXN0aW5hdGlvbldpZHRoOiB3aWR0aCxcbiAgICAgICAgZGVzdGluYXRpb25IZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgY29udGV4dDogZ2wsXG4gICAgICAgIHNvdXJjZVRleHR1cmU6IHRoaXMuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgIWNhY2hlZFRleHR1cmUgJiYgc291cmNlKSxcbiAgICAgICAgdGFyZ2V0VGV4dHVyZTogdGhpcy5jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0KSxcbiAgICAgICAgb3JpZ2luYWxUZXh0dXJlOiBjYWNoZWRUZXh0dXJlIHx8XG4gICAgICAgICAgdGhpcy5jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCAhY2FjaGVkVGV4dHVyZSAmJiBzb3VyY2UpLFxuICAgICAgICBwYXNzZXM6IGZpbHRlcnMubGVuZ3RoLFxuICAgICAgICB3ZWJnbDogdHJ1ZSxcbiAgICAgICAgYVBvc2l0aW9uOiB0aGlzLmFQb3NpdGlvbixcbiAgICAgICAgcHJvZ3JhbUNhY2hlOiB0aGlzLnByb2dyYW1DYWNoZSxcbiAgICAgICAgcGFzczogMCxcbiAgICAgICAgZmlsdGVyQmFja2VuZDogdGhpcyxcbiAgICAgICAgdGFyZ2V0Q2FudmFzOiB0YXJnZXRDYW52YXNcbiAgICAgIH07XG4gICAgICB2YXIgdGVtcEZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRlbXBGYm8pO1xuICAgICAgZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikgeyBmaWx0ZXIgJiYgZmlsdGVyLmFwcGx5VG8ocGlwZWxpbmVTdGF0ZSk7IH0pO1xuICAgICAgcmVzaXplQ2FudmFzSWZOZWVkZWQocGlwZWxpbmVTdGF0ZSk7XG4gICAgICB0aGlzLmNvcHlHTFRvMkQoZ2wsIHBpcGVsaW5lU3RhdGUpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICBnbC5kZWxldGVUZXh0dXJlKHBpcGVsaW5lU3RhdGUuc291cmNlVGV4dHVyZSk7XG4gICAgICBnbC5kZWxldGVUZXh0dXJlKHBpcGVsaW5lU3RhdGUudGFyZ2V0VGV4dHVyZSk7XG4gICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcih0ZW1wRmJvKTtcbiAgICAgIHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHJldHVybiBwaXBlbGluZVN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggZXZlbnQgbGlzdGVuZXJzLCByZW1vdmUgcmVmZXJlbmNlcywgYW5kIGNsZWFuIHVwIGNhY2hlcy5cbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhcldlYkdMQ2FjaGVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdpcGUgb3V0IFdlYkdMLXJlbGF0ZWQgY2FjaGVzLlxuICAgICAqL1xuICAgIGNsZWFyV2ViR0xDYWNoZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wcm9ncmFtQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMudGV4dHVyZUNhY2hlID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFdlYkdMIHRleHR1cmUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQWNjZXB0cyBzcGVjaWZpYyBkaW1lbnNpb25zIHRvIGluaXRpYWxpemUgdGhlIHRleHR1ZXIgdG8gb3IgYSBzb3VyY2UgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNvbnRleHQgdG8gdXNlIGZvciBjcmVhdGluZyB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUgYXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSB0ZXh0dXJlSW1hZ2VTb3VyY2UgQSBzb3VyY2UgZm9yIHRoZSB0ZXh0dXJlIGRhdGEuXG4gICAgICogQHJldHVybnMge1dlYkdMVGV4dHVyZX1cbiAgICAgKi9cbiAgICBjcmVhdGVUZXh0dXJlOiBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodCwgdGV4dHVyZUltYWdlU291cmNlKSB7XG4gICAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGlmICh0ZXh0dXJlSW1hZ2VTb3VyY2UpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0ZXh0dXJlSW1hZ2VTb3VyY2UpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIG9wdGlvbmFsbHkgdXNlZCB0byBnZXQgYSB0ZXh0dXJlIGZyb20gdGhlIGNhY2hlIGFycmF5XG4gICAgICpcbiAgICAgKiBJZiBhbiBleGlzdGluZyB0ZXh0dXJlIGlzIG5vdCBmb3VuZCwgYSBuZXcgdGV4dHVyZSBpcyBjcmVhdGVkIGFuZCBjYWNoZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdW5pcXVlSWQgQSBjYWNoZSBrZXkgdG8gdXNlIHRvIGZpbmQgYW4gZXhpc3RpbmcgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHRleHR1cmVJbWFnZVNvdXJjZSBBIHNvdXJjZSB0byB1c2UgdG8gY3JlYXRlIHRoZVxuICAgICAqIHRleHR1cmUgY2FjaGUgZW50cnkgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVkVGV4dHVyZTogZnVuY3Rpb24odW5pcXVlSWQsIHRleHR1cmVJbWFnZVNvdXJjZSkge1xuICAgICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW3VuaXF1ZUlkXSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKFxuICAgICAgICAgIHRoaXMuZ2wsIHRleHR1cmVJbWFnZVNvdXJjZS53aWR0aCwgdGV4dHVyZUltYWdlU291cmNlLmhlaWdodCwgdGV4dHVyZUltYWdlU291cmNlKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdID0gdGV4dHVyZTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIG91dCBjYWNoZWQgcmVzb3VyY2VzIHJlbGF0ZWQgdG8gYSBzb3VyY2UgaW1hZ2UgdGhhdCBoYXMgYmVlblxuICAgICAqIGZpbHRlcmVkIHByZXZpb3VzbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2FjaGVLZXkgVGhlIGNhY2hlIGtleSBwcm92aWRlZCB3aGVuIHRoZSBzb3VyY2UgaW1hZ2Ugd2FzIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGV2aWN0Q2FjaGVzRm9yS2V5OiBmdW5jdGlvbihjYWNoZUtleSkge1xuICAgICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldKTtcbiAgICAgICAgZGVsZXRlIHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weUdMVG8yRDogY29weUdMVG8yRERyYXdJbWFnZSxcblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gZXh0cmFjdCBHUFUgaW5mb3JtYXRpb24gc3RyaW5ncyBmcm9tIGEgV2ViR0wgY29udGV4dC5cbiAgICAgKlxuICAgICAqIFVzZWZ1bCBpbmZvcm1hdGlvbiB3aGVuIGRlYnVnZ2luZyBvciBibGFja2xpc3Rpbmcgc3BlY2lmaWMgR1BVcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgR1BVIGluZm8gb2JqZWN0IHdpdGggcmVuZGVyZXIgYW5kIHZlbmRvciBzdHJpbmdzLlxuICAgICAqL1xuICAgIGNhcHR1cmVHUFVJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmdwdUluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3B1SW5mbztcbiAgICAgIH1cbiAgICAgIHZhciBnbCA9IHRoaXMuZ2wsIGdwdUluZm8gPSB7IHJlbmRlcmVyOiAnJywgdmVuZG9yOiAnJyB9O1xuICAgICAgaWYgKCFnbCkge1xuICAgICAgICByZXR1cm4gZ3B1SW5mbztcbiAgICAgIH1cbiAgICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm8nKTtcbiAgICAgIGlmIChleHQpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dC5VTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCk7XG4gICAgICAgIHZhciB2ZW5kb3IgPSBnbC5nZXRQYXJhbWV0ZXIoZXh0LlVOTUFTS0VEX1ZFTkRPUl9XRUJHTCk7XG4gICAgICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICAgIGdwdUluZm8ucmVuZGVyZXIgPSByZW5kZXJlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZW5kb3IpIHtcbiAgICAgICAgICBncHVJbmZvLnZlbmRvciA9IHZlbmRvci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmdwdUluZm8gPSBncHVJbmZvO1xuICAgICAgcmV0dXJuIGdwdUluZm87XG4gICAgfSxcbiAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIHJlc2l6ZUNhbnZhc0lmTmVlZGVkKHBpcGVsaW5lU3RhdGUpIHtcbiAgdmFyIHRhcmdldENhbnZhcyA9IHBpcGVsaW5lU3RhdGUudGFyZ2V0Q2FudmFzLFxuICAgICAgd2lkdGggPSB0YXJnZXRDYW52YXMud2lkdGgsIGhlaWdodCA9IHRhcmdldENhbnZhcy5oZWlnaHQsXG4gICAgICBkV2lkdGggPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uV2lkdGgsXG4gICAgICBkSGVpZ2h0ID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbkhlaWdodDtcblxuICBpZiAod2lkdGggIT09IGRXaWR0aCB8fCBoZWlnaHQgIT09IGRIZWlnaHQpIHtcbiAgICB0YXJnZXRDYW52YXMud2lkdGggPSBkV2lkdGg7XG4gICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IGRIZWlnaHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5IGFuIGlucHV0IFdlYkdMIGNhbnZhcyBvbiB0byBhbiBvdXRwdXQgMkQgY2FudmFzLlxuICpcbiAqIFRoZSBXZWJHTCBjYW52YXMgaXMgYXNzdW1lZCB0byBiZSB1cHNpZGUgZG93biwgd2l0aCB0aGUgdG9wLWxlZnQgcGl4ZWwgb2YgdGhlXG4gKiBkZXNpcmVkIG91dHB1dCBpbWFnZSBhcHBlYXJpbmcgaW4gdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZiB0aGUgV2ViR0wgY2FudmFzLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBzb3VyY2VDb250ZXh0IFRoZSBXZWJHTCBjb250ZXh0IHRvIGNvcHkgZnJvbS5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IHRhcmdldENhbnZhcyBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IHBpcGVsaW5lU3RhdGUgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqL1xuZnVuY3Rpb24gY29weUdMVG8yRERyYXdJbWFnZShnbCwgcGlwZWxpbmVTdGF0ZSkge1xuICB2YXIgZ2xDYW52YXMgPSBnbC5jYW52YXMsIHRhcmdldENhbnZhcyA9IHBpcGVsaW5lU3RhdGUudGFyZ2V0Q2FudmFzLFxuICAgICAgY3R4ID0gdGFyZ2V0Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGN0eC50cmFuc2xhdGUoMCwgdGFyZ2V0Q2FudmFzLmhlaWdodCk7IC8vIG1vdmUgaXQgZG93biBhZ2FpblxuICBjdHguc2NhbGUoMSwgLTEpOyAvLyB2ZXJ0aWNhbCBmbGlwXG4gIC8vIHdoZXJlIGlzIG15IGltYWdlIG9uIHRoZSBiaWcgZ2xjYW52YXM/XG4gIHZhciBzb3VyY2VZID0gZ2xDYW52YXMuaGVpZ2h0IC0gdGFyZ2V0Q2FudmFzLmhlaWdodDtcbiAgY3R4LmRyYXdJbWFnZShnbENhbnZhcywgMCwgc291cmNlWSwgdGFyZ2V0Q2FudmFzLndpZHRoLCB0YXJnZXRDYW52YXMuaGVpZ2h0LCAwLCAwLFxuICAgIHRhcmdldENhbnZhcy53aWR0aCwgdGFyZ2V0Q2FudmFzLmhlaWdodCk7XG59XG5cbi8qKlxuICogQ29weSBhbiBpbnB1dCBXZWJHTCBjYW52YXMgb24gdG8gYW4gb3V0cHV0IDJEIGNhbnZhcyB1c2luZyAyZCBjYW52YXMnIHB1dEltYWdlRGF0YVxuICogQVBJLiBNZWFzdXJhYmx5IGZhc3RlciB0aGFuIHVzaW5nIGN0eC5kcmF3SW1hZ2UgaW4gRmlyZWZveCAodmVyc2lvbiA1NCBvbiBPU1ggU2llcnJhKS5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gc291cmNlQ29udGV4dCBUaGUgV2ViR0wgY29udGV4dCB0byBjb3B5IGZyb20uXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwaXBlbGluZVN0YXRlIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKi9cbmZ1bmN0aW9uIGNvcHlHTFRvMkRQdXRJbWFnZURhdGEoZ2wsIHBpcGVsaW5lU3RhdGUpIHtcbiAgdmFyIHRhcmdldENhbnZhcyA9IHBpcGVsaW5lU3RhdGUudGFyZ2V0Q2FudmFzLCBjdHggPSB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIGRXaWR0aCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25XaWR0aCxcbiAgICAgIGRIZWlnaHQgPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uSGVpZ2h0LFxuICAgICAgbnVtQnl0ZXMgPSBkV2lkdGggKiBkSGVpZ2h0ICogNDtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIHU4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5pbWFnZUJ1ZmZlciwgMCwgbnVtQnl0ZXMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIHU4Q2xhbXBlZCA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLmltYWdlQnVmZmVyLCAwLCBudW1CeXRlcyk7XG5cbiAgZ2wucmVhZFBpeGVscygwLCAwLCBkV2lkdGgsIGRIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHU4KTtcbiAgdmFyIGltZ0RhdGEgPSBuZXcgSW1hZ2VEYXRhKHU4Q2xhbXBlZCwgZFdpZHRoLCBkSGVpZ2h0KTtcbiAgY3R4LnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuICBmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kID0gQ2FudmFzMmRGaWx0ZXJCYWNrZW5kO1xuXG4gIC8qKlxuICAgKiBDYW52YXMgMkQgZmlsdGVyIGJhY2tlbmQuXG4gICAqL1xuICBmdW5jdGlvbiBDYW52YXMyZEZpbHRlckJhY2tlbmQoKSB7fTtcblxuICBDYW52YXMyZEZpbHRlckJhY2tlbmQucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSAqLyB7XG4gICAgZXZpY3RDYWNoZXNGb3JLZXk6IG5vb3AsXG4gICAgZGlzcG9zZTogbm9vcCxcbiAgICBjbGVhcldlYkdMQ2FjaGVzOiBub29wLFxuXG4gICAgLyoqXG4gICAgICogRXhwZXJpbWVudGFsLiBUaGlzIG9iamVjdCBpcyBhIHNvcnQgb2YgcmVwb3NpdG9yeSBvZiBoZWxwIGxheWVycyB1c2VkIHRvIGF2b2lkXG4gICAgICogb2YgcmVjcmVhdGluZyB0aGVtIGR1cmluZyBmcmVxdWVudCBmaWx0ZXJpbmcuIElmIHlvdSBhcmUgcHJldmlld2luZyBhIGZpbHRlciB3aXRoXG4gICAgICogYSBzbGlkZXIgeW91IHByb2JhYmx5IGRvIG5vdCB3YW50IHRvIGNyZWF0ZSBoZWxwIGxheWVycyBldmVyeSBmaWx0ZXIgc3RlcC5cbiAgICAgKiBpbiB0aGlzIG9iamVjdCB0aGVyZSB3aWxsIGJlIGFwcGVuZGVkIHNvbWUgY2FudmFzZXMsIGNyZWF0ZWQgb25jZSwgcmVzaXplZCBzb21ldGltZXNcbiAgICAgKiBjbGVhcmVkIG5ldmVyLiBDbGVhcmluZyBpcyBsZWZ0IHRvIHRoZSBkZXZlbG9wZXIuXG4gICAgICoqL1xuICAgIHJlc291cmNlczoge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgc2V0IG9mIGZpbHRlcnMgYWdhaW5zdCBhIHNvdXJjZSBpbWFnZSBhbmQgZHJhdyB0aGUgZmlsdGVyZWQgb3V0cHV0XG4gICAgICogdG8gdGhlIHByb3ZpZGVkIGRlc3RpbmF0aW9uIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5oYW5jZWRGaWx0ZXJ9IGZpbHRlcnMgVGhlIGZpbHRlciB0byBhcHBseS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZUVsZW1lbnQgVGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZUhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSBkZXN0aW5hdGlvbiBmb3IgZmlsdGVyZWQgb3V0cHV0IHRvIGJlIGRyYXduLlxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycywgc291cmNlRWxlbWVudCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGFyZ2V0Q2FudmFzKSB7XG4gICAgICB2YXIgY3R4ID0gdGFyZ2V0Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZHJhd0ltYWdlKHNvdXJjZUVsZW1lbnQsIDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCk7XG4gICAgICB2YXIgb3JpZ2luYWxJbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgdmFyIHBpcGVsaW5lU3RhdGUgPSB7XG4gICAgICAgIHNvdXJjZVdpZHRoOiBzb3VyY2VXaWR0aCxcbiAgICAgICAgc291cmNlSGVpZ2h0OiBzb3VyY2VIZWlnaHQsXG4gICAgICAgIGltYWdlRGF0YTogaW1hZ2VEYXRhLFxuICAgICAgICBvcmlnaW5hbEVsOiBzb3VyY2VFbGVtZW50LFxuICAgICAgICBvcmlnaW5hbEltYWdlRGF0YTogb3JpZ2luYWxJbWFnZURhdGEsXG4gICAgICAgIGNhbnZhc0VsOiB0YXJnZXRDYW52YXMsXG4gICAgICAgIGN0eDogY3R4LFxuICAgICAgICBmaWx0ZXJCYWNrZW5kOiB0aGlzLFxuICAgICAgfTtcbiAgICAgIGZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHsgZmlsdGVyLmFwcGx5VG8ocGlwZWxpbmVTdGF0ZSk7IH0pO1xuICAgICAgaWYgKHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLndpZHRoICE9PSBzb3VyY2VXaWR0aCB8fCBwaXBlbGluZVN0YXRlLmltYWdlRGF0YS5oZWlnaHQgIT09IHNvdXJjZUhlaWdodCkge1xuICAgICAgICB0YXJnZXRDYW52YXMud2lkdGggPSBwaXBlbGluZVN0YXRlLmltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEocGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEsIDAsIDApO1xuICAgICAgcmV0dXJuIHBpcGVsaW5lU3RhdGU7XG4gICAgfSxcblxuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIEBuYW1lc3BhY2UgZmFicmljLkltYWdlLmZpbHRlcnNcbiAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2VcbiAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2ltYWdlX2ZpbHRlcnN9XG4gKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gKi9cbmZhYnJpYy5JbWFnZSA9IGZhYnJpYy5JbWFnZSB8fCB7IH07XG5mYWJyaWMuSW1hZ2UuZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzIHx8IHsgfTtcblxuLyoqXG4gKiBSb290IGZpbHRlciBjbGFzcyBmcm9tIHdoaWNoIGFsbCBmaWx0ZXIgY2xhc3NlcyBpbmhlcml0IGZyb21cbiAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAqL1xuZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlciA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgdHlwZTogJ0Jhc2VGaWx0ZXInLFxuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHNlbmQgd2l0aCBidWZmZXJzLiBkbyBub3QgbW9kaWZ5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZlcnRleFNvdXJjZTogJ2F0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcXG4nICtcbiAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgJ3ZUZXhDb29yZCA9IGFQb3NpdGlvbjtcXG4nICtcbiAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uICogMi4wIC0gMS4wLCAwLjAsIDEuMCk7XFxuJyArXG4gICAgJ30nLFxuXG4gIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgJ2dsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAnfScsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBmaWx0ZXIncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIgcHJvZ3JhbS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB0byB1c2UgZm9yIHNoYWRlciBjb21waWxhdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGZyYWdtZW50U291cmNlIGZyYWdtZW50U2hhZGVyIHNvdXJjZSBmb3IgY29tcGlsYXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZlcnRleFNvdXJjZSB2ZXJ0ZXhTaGFkZXIgc291cmNlIGZvciBjb21waWxhdGlvblxuICAgKi9cbiAgY3JlYXRlUHJvZ3JhbTogZnVuY3Rpb24oZ2wsIGZyYWdtZW50U291cmNlLCB2ZXJ0ZXhTb3VyY2UpIHtcbiAgICBmcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50U291cmNlIHx8IHRoaXMuZnJhZ21lbnRTb3VyY2U7XG4gICAgdmVydGV4U291cmNlID0gdmVydGV4U291cmNlIHx8IHRoaXMudmVydGV4U291cmNlO1xuICAgIGlmIChmYWJyaWMud2ViR2xQcmVjaXNpb24gIT09ICdoaWdocCcpe1xuICAgICAgZnJhZ21lbnRTb3VyY2UgPSBmcmFnbWVudFNvdXJjZS5yZXBsYWNlKFxuICAgICAgICAvcHJlY2lzaW9uIGhpZ2hwIGZsb2F0L2csXG4gICAgICAgICdwcmVjaXNpb24gJyArIGZhYnJpYy53ZWJHbFByZWNpc2lvbiArICcgZmxvYXQnXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgJ1ZlcnRleCBzaGFkZXIgY29tcGlsZSBlcnJvciBmb3IgJyArIHRoaXMudHlwZSArICc6ICcgK1xuICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXRlbXBsYXRlXG4gICAgICAgICdGcmFnbWVudCBzaGFkZXIgY29tcGlsZSBlcnJvciBmb3IgJyArIHRoaXMudHlwZSArICc6ICcgK1xuICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdtZW50U2hhZGVyKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci10ZW1wbGF0ZVxuICAgICAgICAnU2hhZGVyIGxpbmsgZXJyb3IgZm9yIFwiJHt0aGlzLnR5cGV9XCIgJyArXG4gICAgICAgIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVMb2NhdGlvbnMgPSB0aGlzLmdldEF0dHJpYnV0ZUxvY2F0aW9ucyhnbCwgcHJvZ3JhbSk7XG4gICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbnMoZ2wsIHByb2dyYW0pIHx8IHsgfTtcbiAgICB1bmlmb3JtTG9jYXRpb25zLnVTdGVwVyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBXJyk7XG4gICAgdW5pZm9ybUxvY2F0aW9ucy51U3RlcEggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwSCcpO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgYXR0cmlidXRlTG9jYXRpb25zOiBhdHRyaWJ1dGVMb2NhdGlvbnMsXG4gICAgICB1bmlmb3JtTG9jYXRpb25zOiB1bmlmb3JtTG9jYXRpb25zXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbWFwIG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBXZWJHTEF0dHJpYnV0ZUxvY2F0aW9uIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhlIHNoYWRlciBwcm9ncmFtIGZyb20gd2hpY2ggdG8gdGFrZSBhdHRyaWJ1dGUgbG9jYXRpb25zLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIG1hcCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYXR0cmlidXRlIGxvY2F0aW9ucy5cbiAgICovXG4gIGdldEF0dHJpYnV0ZUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgYVBvc2l0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVBvc2l0aW9uJyksXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbWFwIG9mIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0cy5cbiAgICpcbiAgICogSW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoZSBzaGFkZXIgcHJvZ3JhbSBmcm9tIHdoaWNoIHRvIHRha2UgdW5pZm9ybSBsb2NhdGlvbnMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgbWFwIG9mIHVuaWZvcm0gbmFtZXMgdG8gdW5pZm9ybSBsb2NhdGlvbnMuXG4gICAqL1xuICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbiAoLyogZ2wsIHByb2dyYW0gKi8pIHtcbiAgICAvLyBpbiBjYXNlIGkgZG8gbm90IG5lZWQgYW55IHNwZWNpYWwgdW5pZm9ybSBpIG5lZWQgdG8gcmV0dXJuIGFuIGVtcHR5IG9iamVjdFxuICAgIHJldHVybiB7IH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmQgYXR0cmlidXRlIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0gb24gdGhlIEdQVS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlTG9jYXRpb25zIEEgbWFwIG9mIHNoYWRlciBhdHRyaWJ1dGUgbmFtZXMgdG8gdGhlaXIgbG9jYXRpb25zLlxuICAgKi9cbiAgc2VuZEF0dHJpYnV0ZURhdGE6IGZ1bmN0aW9uKGdsLCBhdHRyaWJ1dGVMb2NhdGlvbnMsIGFQb3NpdGlvbkRhdGEpIHtcbiAgICB2YXIgYXR0cmlidXRlTG9jYXRpb24gPSBhdHRyaWJ1dGVMb2NhdGlvbnMuYVBvc2l0aW9uO1xuICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWJ1dGVMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYVBvc2l0aW9uRGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuICB9LFxuXG4gIF9zZXR1cEZyYW1lQnVmZmVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGdsID0gb3B0aW9ucy5jb250ZXh0LCB3aWR0aCwgaGVpZ2h0O1xuICAgIGlmIChvcHRpb25zLnBhc3NlcyA+IDEpIHtcbiAgICAgIHdpZHRoID0gb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoO1xuICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodDtcbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZVdpZHRoICE9PSB3aWR0aCB8fCBvcHRpb25zLnNvdXJjZUhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUob3B0aW9ucy50YXJnZXRUZXh0dXJlKTtcbiAgICAgICAgb3B0aW9ucy50YXJnZXRUZXh0dXJlID0gb3B0aW9ucy5maWx0ZXJCYWNrZW5kLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELFxuICAgICAgICBvcHRpb25zLnRhcmdldFRleHR1cmUsIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGRyYXcgbGFzdCBmaWx0ZXIgb24gY2FudmFzIGFuZCBub3QgdG8gZnJhbWVidWZmZXIuXG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgZ2wuZmluaXNoKCk7XG4gICAgfVxuICB9LFxuXG4gIF9zd2FwVGV4dHVyZXM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnBhc3Nlcy0tO1xuICAgIG9wdGlvbnMucGFzcysrO1xuICAgIHZhciB0ZW1wID0gb3B0aW9ucy50YXJnZXRUZXh0dXJlO1xuICAgIG9wdGlvbnMudGFyZ2V0VGV4dHVyZSA9IG9wdGlvbnMuc291cmNlVGV4dHVyZTtcbiAgICBvcHRpb25zLnNvdXJjZVRleHR1cmUgPSB0ZW1wO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZW5lcmljIGlzTmV1dHJhbCBpbXBsZW1lbnRhdGlvbiBmb3Igb25lIHBhcmFtZXRlciBiYXNlZCBmaWx0ZXJzLlxuICAgKiBVc2VkIG9ubHkgaW4gaW1hZ2UgYXBwbHlGaWx0ZXJzIHRvIGRpc2NhcmQgZmlsdGVycyB0aGF0IHdpbGwgbm90IGhhdmUgYW4gZWZmZWN0XG4gICAqIG9uIHRoZSBpbWFnZVxuICAgKiBPdGhlciBmaWx0ZXJzIG1heSBuZWVkIHRoZWlyIG93biB2ZXJpc29uICggQ29sb3JNYXRyaXgsIEh1ZVJvdGF0aW9uLCBnYW1tYSwgQ29tcG9zZWRGaWx0ZXIgKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiovXG4gIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigvKiBvcHRpb25zICovKSB7XG4gICAgdmFyIG1haW4gPSB0aGlzLm1haW5QYXJhbWV0ZXIsXG4gICAgICAgIF9jbGFzcyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzW3RoaXMudHlwZV0ucHJvdG90eXBlO1xuICAgIGlmIChtYWluKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShfY2xhc3NbbWFpbl0pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBfY2xhc3NbbWFpbl0ubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgaWYgKHRoaXNbbWFpbl1baV0gIT09IF9jbGFzc1ttYWluXVtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gX2NsYXNzW21haW5dID09PSB0aGlzW21haW5dO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGx5IHRoaXMgZmlsdGVyIHRvIHRoZSBpbnB1dCBpbWFnZSBkYXRhIHByb3ZpZGVkLlxuICAgKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gdXNlIFdlYkdMIG9yIENhbnZhczJEIGJhc2VkIG9uIHRoZSBvcHRpb25zLndlYmdsIGZsYWcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGV4ZWN1dGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy53ZWJnbCBXaGV0aGVyIHRvIHVzZSB3ZWJnbCB0byByZW5kZXIgdGhlIGZpbHRlci5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy50YXJnZXRUZXh0dXJlIFRoZSB0ZXh0dXJlIHdoZXJlIGZpbHRlcmVkIG91dHB1dCBzaG91bGQgYmUgZHJhd24uXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICovXG4gIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbHlUbzJkKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAqL1xuICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkodGhpcy50eXBlKSkge1xuICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbdGhpcy50eXBlXSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbdGhpcy50eXBlXTtcbiAgfSxcblxuICAvKipcbiAgICogQXBwbHkgdGhpcyBmaWx0ZXIgdXNpbmcgd2ViZ2wuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGV4ZWN1dGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy53ZWJnbCBXaGV0aGVyIHRvIHVzZSB3ZWJnbCB0byByZW5kZXIgdGhlIGZpbHRlci5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMub3JpZ2luYWxUZXh0dXJlIFRoZSB0ZXh0dXJlIG9mIHRoZSBvcmlnaW5hbCBpbnB1dCBpbWFnZS5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy50YXJnZXRUZXh0dXJlIFRoZSB0ZXh0dXJlIHdoZXJlIGZpbHRlcmVkIG91dHB1dCBzaG91bGQgYmUgZHJhd24uXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICovXG4gIGFwcGx5VG9XZWJHTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBnbCA9IG9wdGlvbnMuY29udGV4dDtcbiAgICB2YXIgc2hhZGVyID0gdGhpcy5yZXRyaWV2ZVNoYWRlcihvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5wYXNzID09PSAwICYmIG9wdGlvbnMub3JpZ2luYWxUZXh0dXJlKSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBvcHRpb25zLm9yaWdpbmFsVGV4dHVyZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgb3B0aW9ucy5zb3VyY2VUZXh0dXJlKTtcbiAgICB9XG4gICAgZ2wudXNlUHJvZ3JhbShzaGFkZXIucHJvZ3JhbSk7XG4gICAgdGhpcy5zZW5kQXR0cmlidXRlRGF0YShnbCwgc2hhZGVyLmF0dHJpYnV0ZUxvY2F0aW9ucywgb3B0aW9ucy5hUG9zaXRpb24pO1xuXG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51bmlmb3JtTG9jYXRpb25zLnVTdGVwVywgMSAvIG9wdGlvbnMuc291cmNlV2lkdGgpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybUxvY2F0aW9ucy51U3RlcEgsIDEgLyBvcHRpb25zLnNvdXJjZUhlaWdodCk7XG5cbiAgICB0aGlzLnNlbmRVbmlmb3JtRGF0YShnbCwgc2hhZGVyLnVuaWZvcm1Mb2NhdGlvbnMpO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIG9wdGlvbnMuZGVzdGluYXRpb25XaWR0aCwgb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gIH0sXG5cbiAgYmluZEFkZGl0aW9uYWxUZXh0dXJlOiBmdW5jdGlvbihnbCwgdGV4dHVyZSwgdGV4dHVyZVVuaXQpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRleHR1cmVVbml0KTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAvLyByZXNldCBhY3RpdmUgdGV4dHVyZSB0byAwIGFzIHVzdWFsXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gIH0sXG5cbiAgdW5iaW5kQWRkaXRpb25hbFRleHR1cmU6IGZ1bmN0aW9uKGdsLCB0ZXh0dXJlVW5pdCkge1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZVVuaXQpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICB9LFxuXG4gIGdldE1haW5QYXJhbWV0ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzW3RoaXMubWFpblBhcmFtZXRlcl07XG4gIH0sXG5cbiAgc2V0TWFpblBhcmFtZXRlcjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzW3RoaXMubWFpblBhcmFtZXRlcl0gPSB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU2VuZCB1bmlmb3JtIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0gb24gdGhlIEdQVS5cbiAgICpcbiAgICogSW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHNoYWRlciB1bmlmb3JtIG5hbWVzIHRvIHRoZWlyIGxvY2F0aW9ucy5cbiAgICovXG4gIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oLyogZ2wsIHVuaWZvcm1Mb2NhdGlvbnMgKi8pIHtcbiAgICAvLyBJbnRlbnRpb25hbGx5IGxlZnQgYmxhbmsuICBPdmVycmlkZSBtZSBpbiBzdWJjbGFzc2VzLlxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBuZWVkZWQgYnkgYSAyZCBmaWx0ZXIsIHRoaXMgZnVuY3Rpb25zIGNhbiBjcmVhdGUgYW4gaGVscGVyIGNhbnZhcyB0byBiZSB1c2VkXG4gICAqIHJlbWVtYmVyIHRoYXQgb3B0aW9ucy50YXJnZXRDYW52YXMgaXMgYXZhaWxhYmxlIGZvciB1c2UgdGlsbCBlbmQgb2YgY2hhaW4uXG4gICAqL1xuICBjcmVhdGVIZWxwTGF5ZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuaGVscExheWVyKSB7XG4gICAgICB2YXIgaGVscExheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBoZWxwTGF5ZXIud2lkdGggPSBvcHRpb25zLnNvdXJjZVdpZHRoO1xuICAgICAgaGVscExheWVyLmhlaWdodCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgb3B0aW9ucy5oZWxwTGF5ZXIgPSBoZWxwTGF5ZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgKi9cbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmplY3QgPSB7IHR5cGU6IHRoaXMudHlwZSB9LCBtYWluUCA9IHRoaXMubWFpblBhcmFtZXRlcjtcbiAgICBpZiAobWFpblApIHtcbiAgICAgIG9iamVjdFttYWluUF0gPSB0aGlzW21haW5QXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBKU09OXG4gICAqL1xuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIC8vIGRlbGVnYXRlLCBub3QgYWxpYXNcbiAgICByZXR1cm4gdGhpcy50b09iamVjdCgpO1xuICB9XG59KTtcblxuZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzW29iamVjdC50eXBlXShvYmplY3QpO1xuICBjYWxsYmFjayAmJiBjYWxsYmFjayhmaWx0ZXIpO1xuICByZXR1cm4gZmlsdGVyO1xufTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBDb2xvciBNYXRyaXggZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBzZWUge0BMaW5rIGh0dHA6Ly93d3cud2Vid2FzcC5jby51ay90dXRvcmlhbHMvMjE5L0NvbG9yX01hdHJpeF9GaWx0ZXIucGhwfVxuICAgKiBAc2VlIHtATGluayBodHRwOi8vcGhvYm9zbGFiLm9yZy9sb2cvMjAxMy8xMS9mYXN0LWltYWdlLWZpbHRlcnMtd2l0aC13ZWJnbH1cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+S29kYWNocm9tZSBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgoe1xuICAgKiAgbWF0cml4OiBbXG4gICAgICAgMS4xMjg1NTgyMzk2NTkzNTI1LCAtMC4zOTY3MzgyMjgzNjAxMzQ4LCAtMC4wMzk5MjU1OTE3MjkyMTc5MywgMCwgNjMuNzI5NTg3NjIxOTY1MDIsXG4gICAgICAgLTAuMTY0MDQzMzk5NjIyNDQ2MTYsIDEuMDgzNTI1MTU2NjI5MTMwNCwgLTAuMDU0OTg4MDUxMTU2MzMxMzIsIDAsIDI0LjczMjQwNzg5NjcwNjIwMyxcbiAgICAgICAtMC4xNjc4NjAxMDcwNjE1NTc2MywgLTAuNTYwMzQxNjI3NzY5NTI0OCwgMS42MDE0ODUwNzYxOTY0OTQzLCAwLCAzNS42Mjk4MjgwNzQ2MDk0NixcbiAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuQ29sb3JNYXRyaXggPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb2xvck1hdHJpeCcsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gbWF0NCB1Q29sb3JNYXRyaXg7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWM0IHVDb25zdGFudHM7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yICo9IHVDb2xvck1hdHJpeDtcXG4nICtcbiAgICAgICAgJ2NvbG9yICs9IHVDb25zdGFudHM7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIENvbG9ybWF0cml4IGZvciBwaXhlbHMuXG4gICAgICogYXJyYXkgb2YgMjAgZmxvYXRzLiBOdW1iZXJzIGluIHBvc2l0aW9ucyA0LCA5LCAxNCwgMTkgbG9vc2UgbWVhbmluZ1xuICAgICAqIG91dHNpZGUgdGhlIC0xLCAxIHJhbmdlLlxuICAgICAqIDAuMDAzOTIxNTY4NiBpcyB0aGUgcGFydCBvZiAxIHRoYXQgZ2V0IHRyYW5zbGF0ZWQgdG8gMSBpbiAyZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBhcnJheSBvZiAyMCBudW1iZXJzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWF0cml4OiBbXG4gICAgICAxLCAwLCAwLCAwLCAwLFxuICAgICAgMCwgMSwgMCwgMCwgMCxcbiAgICAgIDAsIDAsIDEsIDAsIDAsXG4gICAgICAwLCAwLCAwLCAxLCAwXG4gICAgXSxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdtYXRyaXgnLFxuXG4gICAgLyoqXG4gICAgICogTG9jayB0aGUgY29sb3JtYXRyaXggb24gdGhlIGNvbG9yIHBhcnQsIHNraXBwaW5nIGFscGhhLCBtYW5seSBmb3Igbm9uIHdlYmdsIHNjZW5hcmlvXG4gICAgICogdG8gc2F2ZSBzb21lIGNhbGN1bGF0aW9uXG4gICAgICovXG4gICAgY29sb3JzT25seTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgYXJyYXkgaW5zdGVhZCBtdXRhdGluZyB0aGUgcHJvdG90eXBlIHdpdGggcHVzaFxuICAgICAgdGhpcy5tYXRyaXggPSB0aGlzLm1hdHJpeC5zbGljZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIENvbG9yTWF0cml4IG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIG0gPSB0aGlzLm1hdHJpeCxcbiAgICAgICAgICByLCBnLCBiLCBhLCBpLCBjb2xvcnNPbmx5ID0gdGhpcy5jb2xvcnNPbmx5O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgaWYgKGNvbG9yc09ubHkpIHtcbiAgICAgICAgICBkYXRhW2ldID0gciAqIG1bMF0gKyBnICogbVsxXSArIGIgKiBtWzJdICsgbVs0XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9IHIgKiBtWzVdICsgZyAqIG1bNl0gKyBiICogbVs3XSArIG1bOV0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgMl0gPSByICogbVsxMF0gKyBnICogbVsxMV0gKyBiICogbVsxMl0gKyBtWzE0XSAqIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhID0gZGF0YVtpICsgM107XG4gICAgICAgICAgZGF0YVtpXSA9IHIgKiBtWzBdICsgZyAqIG1bMV0gKyBiICogbVsyXSArIGEgKiBtWzNdICsgbVs0XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9IHIgKiBtWzVdICsgZyAqIG1bNl0gKyBiICogbVs3XSArIGEgKiBtWzhdICsgbVs5XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9IHIgKiBtWzEwXSArIGcgKiBtWzExXSArIGIgKiBtWzEyXSArIGEgKiBtWzEzXSArIG1bMTRdICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDNdID0gciAqIG1bMTVdICsgZyAqIG1bMTZdICsgYiAqIG1bMTddICsgYSAqIG1bMThdICsgbVsxOV0gKiAyNTU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb2xvck1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29sb3JNYXRyaXgnKSxcbiAgICAgICAgdUNvbnN0YW50czogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29uc3RhbnRzJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0cml4LFxuICAgICAgICAgIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sXG4gICAgICAgICAgICBtWzVdLCBtWzZdLCBtWzddLCBtWzhdLFxuICAgICAgICAgICAgbVsxMF0sIG1bMTFdLCBtWzEyXSwgbVsxM10sXG4gICAgICAgICAgICBtWzE1XSwgbVsxNl0sIG1bMTddLCBtWzE4XVxuICAgICAgICAgIF0sXG4gICAgICAgICAgY29uc3RhbnRzID0gW21bNF0sIG1bOV0sIG1bMTRdLCBtWzE5XV07XG4gICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUNvbG9yTWF0cml4LCBmYWxzZSwgbWF0cml4KTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29uc3RhbnRzLCBjb25zdGFudHMpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXhcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQnJpZ2h0bmVzcyBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3NcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcyh7XG4gICAqICAgYnJpZ2h0bmVzczogMC4wNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkJyaWdodG5lc3MgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0JyaWdodG5lc3MnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgYnJpZ2h0bmVzcyBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1QnJpZ2h0bmVzcztcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdjb2xvci5yZ2IgKz0gdUJyaWdodG5lc3M7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEJyaWdodG5lc3MgdmFsdWUsIGZyb20gLTEgdG8gMS5cbiAgICAgKiB0cmFuc2xhdGVkIHRvIC0yNTUgdG8gMjU1IGZvciAyZFxuICAgICAqIDAuMDAzOTIxNTY4NiBpcyB0aGUgcGFydCBvZiAxIHRoYXQgZ2V0IHRyYW5zbGF0ZWQgdG8gMSBpbiAyZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBicmlnaHRuZXNzOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ2JyaWdodG5lc3MnLFxuXG4gICAgLyoqXG4gICAgKiBBcHBseSB0aGUgQnJpZ2h0bmVzcyBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAqXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuYnJpZ2h0bmVzcyA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBicmlnaHRuZXNzID0gTWF0aC5yb3VuZCh0aGlzLmJyaWdodG5lc3MgKiAyNTUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSBkYXRhW2ldICsgYnJpZ2h0bmVzcztcbiAgICAgICAgZGF0YVtpICsgMV0gPSBkYXRhW2kgKyAxXSArIGJyaWdodG5lc3M7XG4gICAgICAgIGRhdGFbaSArIDJdID0gZGF0YVtpICsgMl0gKyBicmlnaHRuZXNzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUJyaWdodG5lc3M6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUJyaWdodG5lc3MnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVCcmlnaHRuZXNzLCB0aGlzLmJyaWdodG5lc3MpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc30gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc1xuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2ltYWdlZmlsdGVycy9cIj5odG1sNXJvY2tzIGFydGljbGU8L2E+XG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+U2hhcnBlbiBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMCwgLTEsICAwLFxuICAgKiAgICAgICAgICAgIC0xLCAgNSwgLTEsXG4gICAqICAgICAgICAgICAgIDAsIC0xLCAgMCBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5CbHVyIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAxLzksIDEvOSwgMS85LFxuICAgKiAgICAgICAgICAgICAxLzksIDEvOSwgMS85LFxuICAgKiAgICAgICAgICAgICAxLzksIDEvOSwgMS85IF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtYm9zcyBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMSwgICAxLCAgMSxcbiAgICogICAgICAgICAgICAgMSwgMC43LCAtMSxcbiAgICogICAgICAgICAgICAtMSwgIC0xLCAtMSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWJvc3MgZmlsdGVyIHdpdGggb3BhcXVlbmVzczwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG9wYXF1ZTogdHJ1ZSxcbiAgICogICBtYXRyaXg6IFsgMSwgICAxLCAgMSxcbiAgICogICAgICAgICAgICAgMSwgMC43LCAtMSxcbiAgICogICAgICAgICAgICAtMSwgIC0xLCAtMSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5Db252b2x1dGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29udm9sdXRlJyxcblxuICAgIC8qXG4gICAgICogT3BhcXVlIHZhbHVlICh0cnVlL2ZhbHNlKVxuICAgICAqL1xuICAgIG9wYXF1ZTogZmFsc2UsXG5cbiAgICAvKlxuICAgICAqIG1hdHJpeCBmb3IgdGhlIGZpbHRlciwgbWF4IDl4OVxuICAgICAqL1xuICAgIG1hdHJpeDogWzAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDBdLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgYnJpZ2h0bmVzcyBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIENvbnZvbHV0ZV8zXzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgMy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCAzLjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMSksIHVTdGVwSCAqIChoIC0gMSkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDMuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV8zXzA6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgMy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCAzLjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMS4wKSwgdVN0ZXBIICogKGggLSAxLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDMuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV81XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFsyNV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDUuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDIuMCksIHVTdGVwSCAqIChoIC0gMi4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogNS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzVfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzI1XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA1LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMi4wKSwgdVN0ZXBIICogKGggLSAyLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDUuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV83XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs0OV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDcuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNy4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDMuMCksIHVTdGVwSCAqIChoIC0gMy4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogNy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzdfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzQ5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA3LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMy4wKSwgdVN0ZXBIICogKGggLSAzLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDcuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV85XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs4MV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDkuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgOS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDQuMCksIHVTdGVwSCAqIChoIC0gNC4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogOS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzlfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzgxXTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgOS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA5LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gNC4wKSwgdVN0ZXBIICogKGggLSA0LjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDkuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9wYXF1ZT1mYWxzZV0gT3BhcXVlIHZhbHVlICh0cnVlL2ZhbHNlKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1hdHJpeF0gRmlsdGVyIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaXplID0gTWF0aC5zcXJ0KHRoaXMubWF0cml4Lmxlbmd0aCk7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyBzaXplICsgJ18nICsgKHRoaXMub3BhcXVlID8gMSA6IDApO1xuICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbY2FjaGVLZXldO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCcmlnaHRuZXNzIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICB3ZWlnaHRzID0gdGhpcy5tYXRyaXgsXG4gICAgICAgICAgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSksXG4gICAgICAgICAgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKSxcbiAgICAgICAgICBzdyA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBzaCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgb3V0cHV0ID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKHN3LCBzaCksXG4gICAgICAgICAgZHN0ID0gb3V0cHV0LmRhdGEsXG4gICAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgZGVzdGluYXRpb24gaW1hZ2UgcGl4ZWxzXG4gICAgICAgICAgYWxwaGFGYWMgPSB0aGlzLm9wYXF1ZSA/IDEgOiAwLFxuICAgICAgICAgIHIsIGcsIGIsIGEsIGRzdE9mZixcbiAgICAgICAgICBzY3gsIHNjeSwgc3JjT2ZmLCB3dCxcbiAgICAgICAgICB4LCB5LCBjeCwgY3k7XG5cbiAgICAgIGZvciAoeSA9IDA7IHkgPCBzaDsgeSsrKSB7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCBzdzsgeCsrKSB7XG4gICAgICAgICAgZHN0T2ZmID0gKHkgKiBzdyArIHgpICogNDtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdlaWdoZWQgc3VtIG9mIHRoZSBzb3VyY2UgaW1hZ2UgcGl4ZWxzIHRoYXRcbiAgICAgICAgICAvLyBmYWxsIHVuZGVyIHRoZSBjb252b2x1dGlvbiBtYXRyaXhcbiAgICAgICAgICByID0gMDsgZyA9IDA7IGIgPSAwOyBhID0gMDtcblxuICAgICAgICAgIGZvciAoY3kgPSAwOyBjeSA8IHNpZGU7IGN5KyspIHtcbiAgICAgICAgICAgIGZvciAoY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcbiAgICAgICAgICAgICAgc2N5ID0geSArIGN5IC0gaGFsZlNpZGU7XG4gICAgICAgICAgICAgIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgaWYgKHNjeSA8IDAgfHwgc2N5ID4gc2ggfHwgc2N4IDwgMCB8fCBzY3ggPiBzdykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3JjT2ZmID0gKHNjeSAqIHN3ICsgc2N4KSAqIDQ7XG4gICAgICAgICAgICAgIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG5cbiAgICAgICAgICAgICAgciArPSBkYXRhW3NyY09mZl0gKiB3dDtcbiAgICAgICAgICAgICAgZyArPSBkYXRhW3NyY09mZiArIDFdICogd3Q7XG4gICAgICAgICAgICAgIGIgKz0gZGF0YVtzcmNPZmYgKyAyXSAqIHd0O1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgIGlmICghYWxwaGFGYWMpIHtcbiAgICAgICAgICAgICAgICBhICs9IGRhdGFbc3JjT2ZmICsgM10gKiB3dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkc3RbZHN0T2ZmXSA9IHI7XG4gICAgICAgICAgZHN0W2RzdE9mZiArIDFdID0gZztcbiAgICAgICAgICBkc3RbZHN0T2ZmICsgMl0gPSBiO1xuICAgICAgICAgIGlmICghYWxwaGFGYWMpIHtcbiAgICAgICAgICAgIGRzdFtkc3RPZmYgKyAzXSA9IGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHN0W2RzdE9mZiArIDNdID0gZGF0YVtkc3RPZmYgKyAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gb3V0cHV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdU1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TWF0cml4JyksXG4gICAgICAgIHVPcGFxdWU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU9wYXF1ZScpLFxuICAgICAgICB1SGFsZlNpemU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUhhbGZTaXplJyksXG4gICAgICAgIHVTaXplOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTaXplJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWZ2KHVuaWZvcm1Mb2NhdGlvbnMudU1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBvcGFxdWU6IHRoaXMub3BhcXVlLFxuICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogR3JheXNjYWxlIGltYWdlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkdyYXlzY2FsZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdHcmF5c2NhbGUnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIGF2ZXJhZ2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGF2ZXJhZ2UgPSAoY29sb3IuciArIGNvbG9yLmIgKyBjb2xvci5nKSAvIDMuMDtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2xvci5hKTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgbGlnaHRuZXNzOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGludCB1TW9kZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdmbG9hdCBhdmVyYWdlID0gKG1heChtYXgoY29sLnIsIGNvbC5nKSxjb2wuYikgKyBtaW4obWluKGNvbC5yLCBjb2wuZyksY29sLmIpKSAvIDIuMDtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2wuYSk7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIGx1bWlub3NpdHk6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gaW50IHVNb2RlO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2wgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGF2ZXJhZ2UgPSAwLjIxICogY29sLnIgKyAwLjcyICogY29sLmcgKyAwLjA3ICogY29sLmI7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY29sLmEpO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR3JheXNjYWxlIG1vZGUsIGJldHdlZW4gJ2F2ZXJhZ2UnLCAnbGlnaHRuZXNzJywgJ2x1bWlub3NpdHknXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1vZGU6ICdhdmVyYWdlJyxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdtb2RlJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBHcmF5c2NhbGUgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSxcbiAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCwgdmFsdWUsXG4gICAgICAgICAgbW9kZSA9IHRoaXMubW9kZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBpZiAobW9kZSA9PT0gJ2F2ZXJhZ2UnKSB7XG4gICAgICAgICAgdmFsdWUgPSAoZGF0YVtpXSArIGRhdGFbaSArIDFdICsgZGF0YVtpICsgMl0pIC8gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnbGlnaHRuZXNzJykge1xuICAgICAgICAgIHZhbHVlID0gKE1hdGgubWluKGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSkgK1xuICAgICAgICAgICAgTWF0aC5tYXgoZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdsdW1pbm9zaXR5Jykge1xuICAgICAgICAgIHZhbHVlID0gMC4yMSAqIGRhdGFbaV0gKyAwLjcyICogZGF0YVtpICsgMV0gKyAwLjA3ICogZGF0YVtpICsgMl07XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtpXSA9IHZhbHVlO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IHZhbHVlO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbdGhpcy5tb2RlXTtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1TW9kZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TW9kZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgLy8gZGVmYXVsdCBhdmVyYWdlIG1vZGUuXG4gICAgICB2YXIgbW9kZSA9IDE7XG4gICAgICBnbC51bmlmb3JtMWkodW5pZm9ybUxvY2F0aW9ucy51TW9kZSwgbW9kZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyYXlzY2FsZSBmaWx0ZXIgaXNOZXV0cmFsU3RhdGUgaW1wbGVtZW50YXRpb25cbiAgICAgKiBUaGUgZmlsdGVyIGlzIG5ldmVyIG5ldXRyYWxcbiAgICAgKiBvbiB0aGUgaW1hZ2VcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogSW52ZXJ0IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnQoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuSW52ZXJ0ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0ludmVydCcsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGludCB1SW52ZXJ0O1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2lmICh1SW52ZXJ0ID09IDEpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAgLSBjb2xvci5yLDEuMCAtY29sb3IuZywxLjAgLWNvbG9yLmIsY29sb3IuYSk7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBpbnZlcnQuIGlmIGZhbHNlLCBkb2VzIG5vdGhpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGludmVydFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW52ZXJ0OiB0cnVlLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2ludmVydCcsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgSW52ZXJ0IG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksXG4gICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IDI1NSAtIGRhdGFbaV07XG4gICAgICAgIGRhdGFbaSArIDFdID0gMjU1IC0gZGF0YVtpICsgMV07XG4gICAgICAgIGRhdGFbaSArIDJdID0gMjU1IC0gZGF0YVtpICsgMl07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludmVydCBmaWx0ZXIgaXNOZXV0cmFsU3RhdGUgaW1wbGVtZW50YXRpb25cbiAgICAgKiBVc2VkIG9ubHkgaW4gaW1hZ2UgYXBwbHlGaWx0ZXJzIHRvIGRpc2NhcmQgZmlsdGVycyB0aGF0IHdpbGwgbm90IGhhdmUgYW4gZWZmZWN0XG4gICAgICogb24gdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmludmVydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVJbnZlcnQ6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUludmVydCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1Mb2NhdGlvbnMudUludmVydCwgdGhpcy5pbnZlcnQpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnRcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydC5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogTm9pc2UgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2Uoe1xuICAgKiAgIG5vaXNlOiA3MDBcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuICBmaWx0ZXJzLk5vaXNlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnTm9pc2UnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgbm9pc2UgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdU5vaXNlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVNlZWQ7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICdmbG9hdCByYW5kKHZlYzIgY28sIGZsb2F0IHNlZWQsIGZsb2F0IHZTY2FsZSkge1xcbicgK1xuICAgICAgICAncmV0dXJuIGZyYWN0KHNpbihkb3QoY28ueHkgKiB2U2NhbGUgLHZlYzIoMTIuOTg5OCAsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMgKiAoc2VlZCArIDAuMDEpIC8gMi4wKTtcXG4nICtcbiAgICAgICd9XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnJnYiArPSAoMC41IC0gcmFuZCh2VGV4Q29vcmQsIHVTZWVkLCAwLjEgLyB1U3RlcEgpKSAqIHVOb2lzZTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ25vaXNlJyxcblxuICAgIC8qKlxuICAgICAqIE5vaXNlIHZhbHVlLCBmcm9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5vaXNlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBub2lzZTogMCxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCcmlnaHRuZXNzIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMubm9pc2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgbm9pc2UgPSB0aGlzLm5vaXNlLCByYW5kO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgcmFuZCA9ICgwLjUgLSBNYXRoLnJhbmRvbSgpKSAqIG5vaXNlO1xuXG4gICAgICAgIGRhdGFbaV0gKz0gcmFuZDtcbiAgICAgICAgZGF0YVtpICsgMV0gKz0gcmFuZDtcbiAgICAgICAgZGF0YVtpICsgMl0gKz0gcmFuZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVOb2lzZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Tm9pc2UnKSxcbiAgICAgICAgdVNlZWQ6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNlZWQnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVOb2lzZSwgdGhpcy5ub2lzZSAvIDI1NSk7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51U2VlZCwgTWF0aC5yYW5kb20oKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIG5vaXNlOiB0aGlzLm5vaXNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUGl4ZWxhdGUgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUoe1xuICAgKiAgIGJsb2Nrc2l6ZTogOFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLlBpeGVsYXRlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnUGl4ZWxhdGUnLFxuXG4gICAgYmxvY2tzaXplOiA0LFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2Jsb2Nrc2l6ZScsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBQaXhlbGF0ZSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1QmxvY2tzaXplO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAnZmxvYXQgYmxvY2tXID0gdUJsb2Nrc2l6ZSAqIHVTdGVwVztcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGJsb2NrSCA9IHVCbG9ja3NpemUgKiB1U3RlcFc7XFxuJyArXG4gICAgICAgICdpbnQgcG9zWCA9IGludCh2VGV4Q29vcmQueCAvIGJsb2NrVyk7XFxuJyArXG4gICAgICAgICdpbnQgcG9zWSA9IGludCh2VGV4Q29vcmQueSAvIGJsb2NrSCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBmcG9zWCA9IGZsb2F0KHBvc1gpO1xcbicgK1xuICAgICAgICAnZmxvYXQgZnBvc1kgPSBmbG9hdChwb3NZKTtcXG4nICtcbiAgICAgICAgJ3ZlYzIgc3F1YXJlQ29vcmRzID0gdmVjMihmcG9zWCAqIGJsb2NrVywgZnBvc1kgKiBibG9ja0gpO1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgc3F1YXJlQ29vcmRzKTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIFBpeGVsYXRlIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBpTGVuID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICBqTGVuID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGluZGV4LCBpLCBqLCByLCBnLCBiLCBhLFxuICAgICAgICAgIF9pLCBfaiwgX2lMZW4sIF9qTGVuO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuXG4gICAgICAgICAgaW5kZXggPSAoaSAqIDQpICogakxlbiArIChqICogNCk7XG5cbiAgICAgICAgICByID0gZGF0YVtpbmRleF07XG4gICAgICAgICAgZyA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgICBiID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgIGEgPSBkYXRhW2luZGV4ICsgM107XG5cbiAgICAgICAgICBfaUxlbiA9IE1hdGgubWluKGkgKyB0aGlzLmJsb2Nrc2l6ZSwgaUxlbik7XG4gICAgICAgICAgX2pMZW4gPSBNYXRoLm1pbihqICsgdGhpcy5ibG9ja3NpemUsIGpMZW4pO1xuICAgICAgICAgIGZvciAoX2kgPSBpOyBfaSA8IF9pTGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBmb3IgKF9qID0gajsgX2ogPCBfakxlbjsgX2orKykge1xuICAgICAgICAgICAgICBpbmRleCA9IChfaSAqIDQpICogakxlbiArIChfaiAqIDQpO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHI7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IGc7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAyXSA9IGI7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAzXSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHdoZW4gdGhlIGZpbHRlciBpcyBub3QgZ29ubmEgYXBwbHkgY2hhbmdlcyB0byB0aGUgaW1hZ2VcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmxvY2tzaXplID09PSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUJsb2Nrc2l6ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1QmxvY2tzaXplJyksXG4gICAgICAgIHVTdGVwVzogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcFcnKSxcbiAgICAgICAgdVN0ZXBIOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwSCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudUJsb2Nrc2l6ZSwgdGhpcy5ibG9ja3NpemUpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB3aGl0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvcih7XG4gICAqICAgdGhyZXNob2xkOiAwLjIsXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5SZW1vdmVDb2xvciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvci5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1JlbW92ZUNvbG9yJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIHJlbW92ZSwgaW4gYW55IGZvcm1hdCB1bmRlcnN0b29kIGJ5IGZhYnJpYy5Db2xvci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29sb3I6ICcjRkZGRkZGJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGJyaWdodG5lc3MgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1TG93O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1SGlnaDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2lmKGFsbChncmVhdGVyVGhhbihnbF9GcmFnQ29sb3IucmdiLHVMb3cucmdiKSkgJiYgYWxsKGdyZWF0ZXJUaGFuKHVIaWdoLnJnYixnbF9GcmFnQ29sb3IucmdiKSkpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSAwLjA7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBkaXN0YW5jZSB0byBhY3R1YWwgY29sb3IsIGFzIHZhbHVlIHVwIG9yIGRvd24gZnJvbSBlYWNoIHIsZyxiXG4gICAgICogYmV0d2VlbiAwIGFuZCAxXG4gICAgICoqL1xuICAgIGRpc3RhbmNlOiAwLjAyLFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNvbG9yIHRvIHJlbW92ZSBpbnNpZGUgZGlzdGFuY2UsIHVzZSBhbHBoYSBjaGFubmVsIGZvciBhIHNtb290aGVyIGRlbGV0aW9uXG4gICAgICogTk9UIElNUExFTUVOVEVEIFlFVFxuICAgICAqKi9cbiAgICB1c2VBbHBoYTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVXaGl0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbG9yPSNSUkdHQkJdIFRocmVzaG9sZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZT0xMF0gRGlzdGFuY2UgdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSxcbiAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UgKiAyNTUsXG4gICAgICAgICAgciwgZywgYixcbiAgICAgICAgICBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGxvd0MgPSBbXG4gICAgICAgICAgICBzb3VyY2VbMF0gLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsxXSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzJdIC0gZGlzdGFuY2UsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBoaWdoQyA9IFtcbiAgICAgICAgICAgIHNvdXJjZVswXSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzFdICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMl0gKyBkaXN0YW5jZSxcbiAgICAgICAgICBdO1xuXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICBpZiAociA+IGxvd0NbMF0gJiZcbiAgICAgICAgICAgIGcgPiBsb3dDWzFdICYmXG4gICAgICAgICAgICBiID4gbG93Q1syXSAmJlxuICAgICAgICAgICAgciA8IGhpZ2hDWzBdICYmXG4gICAgICAgICAgICBnIDwgaGlnaENbMV0gJiZcbiAgICAgICAgICAgIGIgPCBoaWdoQ1syXSkge1xuICAgICAgICAgIGRhdGFbaSArIDNdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUxvdzogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TG93JyksXG4gICAgICAgIHVIaWdoOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VIaWdoJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBkaXN0YW5jZSA9IHBhcnNlRmxvYXQodGhpcy5kaXN0YW5jZSksXG4gICAgICAgICAgbG93QyA9IFtcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMF0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMV0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMl0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICBdLFxuICAgICAgICAgIGhpZ2hDID0gW1xuICAgICAgICAgICAgc291cmNlWzBdIC8gMjU1ICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMV0gLyAyNTUgKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsyXSAvIDI1NSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgMVxuICAgICAgICAgIF07XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUxvdywgbG93Qyk7XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUhpZ2gsIGhpZ2hDKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgIGRpc3RhbmNlOiB0aGlzLmRpc3RhbmNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3J9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvci5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICB2YXIgbWF0cmljZXMgPSB7XG4gICAgQnJvd25pZTogW1xuICAgICAgMC41OTk3MCwwLjM0NTUzLC0wLjI3MDgyLDAsMC4xODYsXG4gICAgICAtMC4wMzc3MCwwLjg2MDk1LDAuMTUwNTksMCwtMC4xNDQ5LFxuICAgICAgMC4yNDExMywtMC4wNzQ0MSwwLjQ0OTcyLDAsLTAuMDI5NjUsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFZpbnRhZ2U6IFtcbiAgICAgIDAuNjI3OTMsMC4zMjAyMSwtMC4wMzk2NSwwLDAuMDM3ODQsXG4gICAgICAwLjAyNTc4LDAuNjQ0MTEsMC4wMzI1OSwwLDAuMDI5MjYsXG4gICAgICAwLjA0NjYwLC0wLjA4NTEyLDAuNTI0MTYsMCwwLjAyMDIzLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBLb2RhY2hyb21lOiBbXG4gICAgICAxLjEyODU1LC0wLjM5NjczLC0wLjAzOTkyLDAsMC4yNDk5MSxcbiAgICAgIC0wLjE2NDA0LDEuMDgzNTIsLTAuMDU0OTgsMCwwLjA5Njk4LFxuICAgICAgLTAuMTY3ODYsLTAuNTYwMzQsMS42MDE0OCwwLDAuMTM5NzIsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFRlY2huaWNvbG9yOiBbXG4gICAgICAxLjkxMjUyLC0wLjg1NDUzLC0wLjA5MTU1LDAsMC4wNDYyNCxcbiAgICAgIC0wLjMwODc4LDEuNzY1ODksLTAuMTA2MDEsMCwtMC4yNzU4OSxcbiAgICAgIC0wLjIzMTEwLC0wLjc1MDE4LDEuODQ3NTksMCwwLjEyMTM3LFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBQb2xhcm9pZDogW1xuICAgICAgMS40MzgsLTAuMDYyLC0wLjA2MiwwLDAsXG4gICAgICAtMC4xMjIsMS4zNzgsLTAuMTIyLDAsMCxcbiAgICAgIC0wLjAxNiwtMC4wMTYsMS40ODMsMCwwLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBTZXBpYTogW1xuICAgICAgMC4zOTMsIDAuNzY5LCAwLjE4OSwgMCwgMCxcbiAgICAgIDAuMzQ5LCAwLjY4NiwgMC4xNjgsIDAsIDAsXG4gICAgICAwLjI3MiwgMC41MzQsIDAuMTMxLCAwLCAwLFxuICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF0sXG4gICAgQmxhY2tXaGl0ZTogW1xuICAgICAgMS41LCAxLjUsIDEuNSwgMCwgLTEsXG4gICAgICAxLjUsIDEuNSwgMS41LCAwLCAtMSxcbiAgICAgIDEuNSwgMS41LCAxLjUsIDAsIC0xLFxuICAgICAgMCwgMCwgMCwgMSwgMCxcbiAgICBdXG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIG1hdHJpY2VzKSB7XG4gICAgZmlsdGVyc1trZXldID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5Db2xvck1hdHJpeCwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYS5wcm90b3R5cGUgKi8ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpbHRlciB0eXBlXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgICogQGRlZmF1bHRcbiAgICAgICAqL1xuICAgICAgdHlwZToga2V5LFxuXG4gICAgICAvKipcbiAgICAgICAqIENvbG9ybWF0cml4IGZvciB0aGUgZWZmZWN0XG4gICAgICAgKiBhcnJheSBvZiAyMCBmbG9hdHMuIE51bWJlcnMgaW4gcG9zaXRpb25zIDQsIDksIDE0LCAxOSBsb29zZSBtZWFuaW5nXG4gICAgICAgKiBvdXRzaWRlIHRoZSAtMSwgMSByYW5nZS5cbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBhcnJheSBvZiAyMCBudW1iZXJzLlxuICAgICAgICogQGRlZmF1bHRcbiAgICAgICAqL1xuICAgICAgbWF0cml4OiBtYXRyaWNlc1trZXldLFxuXG4gICAgICAvKipcbiAgICAgICAqIExvY2sgdGhlIG1hdHJpeCBleHBvcnQgZm9yIHRoaXMga2luZCBvZiBzdGF0aWMsIHBhcmFtZXRlciBsZXNzIGZpbHRlcnMuXG4gICAgICAgKi9cbiAgICAgIG1haW5QYXJhbWV0ZXI6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBMb2NrIHRoZSBjb2xvcm1hdHJpeCBvbiB0aGUgY29sb3IgcGFydCwgc2tpcHBpbmcgYWxwaGFcbiAgICAgICAqL1xuICAgICAgY29sb3JzT25seTogdHJ1ZSxcblxuICAgIH0pO1xuICAgIGZhYnJpYy5JbWFnZS5maWx0ZXJzW2tleV0uZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29sb3IgQmxlbmQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVyLkJsZW5kQ29sb3JcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yKHtcbiAgICogIGNvbG9yOiAnIzAwMCcsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknXG4gICAqIH0pO1xuICAgKlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2Uoe1xuICAgKiAgaW1hZ2U6IGZhYnJpY0ltYWdlT2JqZWN0LFxuICAgKiAgbW9kZTogJ211bHRpcGx5JyxcbiAgICogIGFscGhhOiAwLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuXG4gIGZpbHRlcnMuQmxlbmRDb2xvciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZC5wcm90b3R5cGUgKi8ge1xuICAgIHR5cGU6ICdCbGVuZENvbG9yJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIG1ha2UgdGhlIGJsZW5kIG9wZXJhdGlvbiB3aXRoLiBkZWZhdWx0IHRvIGEgcmVkZGlzaCBjb2xvciBzaW5jZSBibGFjayBvciB3aGl0ZVxuICAgICAqIGdpdmVzIGFsd2F5cyBzdHJvbmcgcmVzdWx0LlxuICAgICAqKi9cbiAgICBjb2xvcjogJyNGOTVDNjMnLFxuXG4gICAgLyoqXG4gICAgICogQmxlbmQgbW9kZSBmb3IgdGhlIGZpbHRlcjogb25lIG9mIG11bHRpcGx5LCBhZGQsIGRpZmYsIHNjcmVlbiwgc3VidHJhY3QsXG4gICAgICogZGFya2VuLCBsaWdodGVuLCBvdmVybGF5LCBleGNsdXNpb24sIHRpbnQuXG4gICAgICoqL1xuICAgIG1vZGU6ICdtdWx0aXBseScsXG5cbiAgICAvKipcbiAgICAgKiBhbHBoYSB2YWx1ZS4gcmVwcmVzZW50IHRoZSBzdHJlbmd0aCBvZiB0aGUgYmxlbmQgY29sb3Igb3BlcmF0aW9uLlxuICAgICAqKi9cbiAgICBhbHBoYTogMSxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIE11bHRpcGx5IHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgbXVsdGlwbHk6ICdnbF9GcmFnQ29sb3IucmdiICo9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICAgIHNjcmVlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSAxLjAgLSAoMS4wIC0gZ2xfRnJhZ0NvbG9yLnJnYikgKiAoMS4wIC0gdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGFkZDogJ2dsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYjtcXG4nLFxuICAgICAgZGlmZjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBhYnMoZ2xfRnJhZ0NvbG9yLnJnYiAtIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBzdWJ0cmFjdDogJ2dsX0ZyYWdDb2xvci5yZ2IgLT0gdUNvbG9yLnJnYjtcXG4nLFxuICAgICAgbGlnaHRlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBtYXgoZ2xfRnJhZ0NvbG9yLnJnYiwgdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGRhcmtlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBtaW4oZ2xfRnJhZ0NvbG9yLnJnYiwgdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGV4Y2x1c2lvbjogJ2dsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYiAtIDIuMCAqICh1Q29sb3IucmdiICogZ2xfRnJhZ0NvbG9yLnJnYik7XFxuJyxcbiAgICAgIG92ZXJsYXk6ICdpZiAodUNvbG9yLnIgPCAwLjUpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLnIgKj0gMi4wICogdUNvbG9yLnI7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuciA9IDEuMCAtIDIuMCAqICgxLjAgLSBnbF9GcmFnQ29sb3IucikgKiAoMS4wIC0gdUNvbG9yLnIpO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgICAnaWYgKHVDb2xvci5nIDwgMC41KSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5nICo9IDIuMCAqIHVDb2xvci5nO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmcgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLmcpICogKDEuMCAtIHVDb2xvci5nKTtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ2lmICh1Q29sb3IuYiA8IDAuNSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYiAqPSAyLjAgKiB1Q29sb3IuYjtcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5iID0gMS4wIC0gMi4wICogKDEuMCAtIGdsX0ZyYWdDb2xvci5iKSAqICgxLjAgLSB1Q29sb3IuYik7XFxuJyArXG4gICAgICAgICd9XFxuJyxcbiAgICAgIHRpbnQ6ICdnbF9GcmFnQ29sb3IucmdiICo9ICgxLjAgLSB1Q29sb3IuYSk7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYnVpbGQgdGhlIGZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGZpbHRlcnMsIGpvaW5pbmcgdGhlIGNvbW1vbiBwYXJ0IHdpdGhcbiAgICAgKiB0aGUgc3BlY2lmaWMgb25lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIHRoZSBtb2RlIG9mIHRoZSBmaWx0ZXIsIGEga2V5IG9mIHRoaXMuZnJhZ21lbnRTb3VyY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBzb3VyY2UgdG8gYmUgY29tcGlsZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ1aWxkU291cmNlOiBmdW5jdGlvbihtb2RlKSB7XG4gICAgICByZXR1cm4gJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdpZiAoY29sb3IuYSA+IDAuMCkge1xcbicgK1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFNvdXJjZVttb2RlXSArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ30nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlLCBzaGFkZXJTb3VyY2U7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICBzaGFkZXJTb3VyY2UgPSB0aGlzLmJ1aWxkU291cmNlKHRoaXMubW9kZSk7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQmxlbmQgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgdHIsIHRnLCB0YixcbiAgICAgICAgICByLCBnLCBiLFxuICAgICAgICAgIHNvdXJjZSwgYWxwaGExID0gMSAtIHRoaXMuYWxwaGE7XG5cbiAgICAgIHNvdXJjZSA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0U291cmNlKCk7XG4gICAgICB0ciA9IHNvdXJjZVswXSAqIHRoaXMuYWxwaGE7XG4gICAgICB0ZyA9IHNvdXJjZVsxXSAqIHRoaXMuYWxwaGE7XG4gICAgICB0YiA9IHNvdXJjZVsyXSAqIHRoaXMuYWxwaGE7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKiB0ciAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAqIHRnIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICogdGIgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzY3JlZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IDI1NSAtICgyNTUgLSByKSAqICgyNTUgLSB0cikgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtICgyNTUgLSBnKSAqICgyNTUgLSB0ZykgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtICgyNTUgLSBiKSAqICgyNTUgLSB0YikgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKyB0cjtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyArIHRnO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICsgdGI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkaWZmJzpcbiAgICAgICAgICBjYXNlICdkaWZmZXJlbmNlJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLmFicyhyIC0gdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLmFicyhnIC0gdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLmFicyhiIC0gdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3VidHJhY3QnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgLSB0cjtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAtIHRnO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiIC0gdGI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkYXJrZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGgubWluKHIsIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5taW4oZywgdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLm1pbihiLCB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsaWdodGVuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLm1heChyLCB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWF4KGcsIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5tYXgoYiwgdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb3ZlcmxheSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gdHIgPCAxMjggPyAoMiAqIHIgKiB0ciAvIDI1NSkgOiAoMjU1IC0gMiAqICgyNTUgLSByKSAqICgyNTUgLSB0cikgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSB0ZyA8IDEyOCA/ICgyICogZyAqIHRnIC8gMjU1KSA6ICgyNTUgLSAyICogKDI1NSAtIGcpICogKDI1NSAtIHRnKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IHRiIDwgMTI4ID8gKDIgKiBiICogdGIgLyAyNTUpIDogKDI1NSAtIDIgKiAoMjU1IC0gYikgKiAoMjU1IC0gdGIpIC8gMjU1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2V4Y2x1c2lvbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gdHIgKyByIC0gKCgyICogdHIgKiByKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IHRnICsgZyAtICgoMiAqIHRnICogZykgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiArIGIgLSAoKDIgKiB0YiAqIGIpIC8gMjU1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RpbnQnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHRyICsgciAqIGFscGhhMTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gdGcgKyBnICogYWxwaGExO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiArIGIgKiBhbHBoYTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29sb3InKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpO1xuICAgICAgc291cmNlWzBdID0gdGhpcy5hbHBoYSAqIHNvdXJjZVswXSAvIDI1NTtcbiAgICAgIHNvdXJjZVsxXSA9IHRoaXMuYWxwaGEgKiBzb3VyY2VbMV0gLyAyNTU7XG4gICAgICBzb3VyY2VbMl0gPSB0aGlzLmFscGhhICogc291cmNlWzJdIC8gMjU1O1xuICAgICAgc291cmNlWzNdID0gdGhpcy5hbHBoYTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29sb3IsIHNvdXJjZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGFscGhhOiB0aGlzLmFscGhhXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEltYWdlIEJsZW5kIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlci5CbGVuZEltYWdlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvcih7XG4gICAqICBjb2xvcjogJyMwMDAnLFxuICAgKiAgbW9kZTogJ211bHRpcGx5J1xuICAgKiB9KTtcbiAgICpcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlKHtcbiAgICogIGltYWdlOiBmYWJyaWNJbWFnZU9iamVjdCxcbiAgICogIG1vZGU6ICdtdWx0aXBseScsXG4gICAqICBhbHBoYTogMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cblxuICBmaWx0ZXJzLkJsZW5kSW1hZ2UgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZS5wcm90b3R5cGUgKi8ge1xuICAgIHR5cGU6ICdCbGVuZEltYWdlJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIG1ha2UgdGhlIGJsZW5kIG9wZXJhdGlvbiB3aXRoLiBkZWZhdWx0IHRvIGEgcmVkZGlzaCBjb2xvciBzaW5jZSBibGFjayBvciB3aGl0ZVxuICAgICAqIGdpdmVzIGFsd2F5cyBzdHJvbmcgcmVzdWx0LlxuICAgICAqKi9cbiAgICBpbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEJsZW5kIG1vZGUgZm9yIHRoZSBmaWx0ZXI6IG9uZSBvZiBtdWx0aXBseSwgYWRkLCBkaWZmLCBzY3JlZW4sIHN1YnRyYWN0LFxuICAgICAqIGRhcmtlbiwgbGlnaHRlbiwgb3ZlcmxheSwgZXhjbHVzaW9uLCB0aW50LlxuICAgICAqKi9cbiAgICBtb2RlOiAnbXVsdGlwbHknLFxuXG4gICAgLyoqXG4gICAgICogYWxwaGEgdmFsdWUuIHJlcHJlc2VudCB0aGUgc3RyZW5ndGggb2YgdGhlIGJsZW5kIGltYWdlIG9wZXJhdGlvbi5cbiAgICAgKiBub3QgaW1wbGVtZW50ZWQuXG4gICAgICoqL1xuICAgIGFscGhhOiAxLFxuXG4gICAgdmVydGV4U291cmNlOiAnYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDI7XFxuJyArXG4gICAgICAndW5pZm9ybSBtYXQzIHVUcmFuc2Zvcm1NYXRyaXg7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndlRleENvb3JkID0gYVBvc2l0aW9uO1xcbicgK1xuICAgICAgICAndlRleENvb3JkMiA9ICh1VHJhbnNmb3JtTWF0cml4ICogdmVjMyhhUG9zaXRpb24sIDEuMCkpLnh5O1xcbicgK1xuICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiAqIDIuMCAtIDEuMCwgMC4wLCAxLjApO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgTXVsdGlwbHkgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiB7XG4gICAgICBtdWx0aXBseTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdUltYWdlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkMjtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodUltYWdlLCB2VGV4Q29vcmQyKTtcXG4nICtcbiAgICAgICAgICAnY29sb3IucmdiYSAqPSBjb2xvcjIucmdiYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIG1hc2s6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVJbWFnZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29sb3I7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDI7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IyID0gdGV4dHVyZTJEKHVJbWFnZSwgdlRleENvb3JkMik7XFxuJyArXG4gICAgICAgICAgJ2NvbG9yLmEgPSBjb2xvcjIuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHRoaXMubW9kZTtcbiAgICAgIHZhciBzaGFkZXJTb3VyY2UgPSB0aGlzLmZyYWdtZW50U291cmNlW3RoaXMubW9kZV07XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBzaGFkZXJTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgYXBwbHlUb1dlYkdMOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAvLyBsb2FkIHRleHR1cmUgdG8gYmxlbmQuXG4gICAgICB2YXIgZ2wgPSBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgICAgdGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZShvcHRpb25zLmZpbHRlckJhY2tlbmQsIHRoaXMuaW1hZ2UpO1xuICAgICAgdGhpcy5iaW5kQWRkaXRpb25hbFRleHR1cmUoZ2wsIHRleHR1cmUsIGdsLlRFWFRVUkUxKTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdhcHBseVRvV2ViR0wnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMudW5iaW5kQWRkaXRpb25hbFRleHR1cmUoZ2wsIGdsLlRFWFRVUkUxKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlVGV4dHVyZTogZnVuY3Rpb24oYmFja2VuZCwgaW1hZ2UpIHtcbiAgICAgIHJldHVybiBiYWNrZW5kLmdldENhY2hlZFRleHR1cmUoaW1hZ2UuY2FjaGVLZXksIGltYWdlLl9lbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGEgdHJhbnNmb3JtTWF0cml4IHRvIGFkYXB0IHRoZSBpbWFnZSB0byBibGVuZCBvdmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZSxcbiAgICAgICAgICB3aWR0aCA9IGltYWdlLl9lbGVtZW50LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGltYWdlLl9lbGVtZW50LmhlaWdodDtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIDEgLyBpbWFnZS5zY2FsZVgsIDAsIDAsXG4gICAgICAgIDAsIDEgLyBpbWFnZS5zY2FsZVksIDAsXG4gICAgICAgIC1pbWFnZS5sZWZ0IC8gd2lkdGgsIC1pbWFnZS50b3AgLyBoZWlnaHQsIDFcbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCbGVuZCBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICByZXNvdXJjZXMgPSBvcHRpb25zLmZpbHRlckJhY2tlbmQucmVzb3VyY2VzLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaUxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgdHIsIHRnLCB0YiwgdGEsXG4gICAgICAgICAgciwgZywgYiwgYSxcbiAgICAgICAgICBjYW52YXMxLCBjb250ZXh0LCBpbWFnZSA9IHRoaXMuaW1hZ2UsIGJsZW5kRGF0YTtcblxuICAgICAgaWYgKCFyZXNvdXJjZXMuYmxlbmRJbWFnZSkge1xuICAgICAgICByZXNvdXJjZXMuYmxlbmRJbWFnZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhczEgPSByZXNvdXJjZXMuYmxlbmRJbWFnZTtcbiAgICAgIGNvbnRleHQgPSBjYW52YXMxLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAoY2FudmFzMS53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzMS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICBjYW52YXMxLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhczEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oaW1hZ2Uuc2NhbGVYLCAwLCAwLCBpbWFnZS5zY2FsZVksIGltYWdlLmxlZnQsIGltYWdlLnRvcCk7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZS5fZWxlbWVudCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBibGVuZERhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQpIHtcblxuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICAgIGEgPSBkYXRhW2kgKyAzXTtcblxuICAgICAgICB0ciA9IGJsZW5kRGF0YVtpXTtcbiAgICAgICAgdGcgPSBibGVuZERhdGFbaSArIDFdO1xuICAgICAgICB0YiA9IGJsZW5kRGF0YVtpICsgMl07XG4gICAgICAgIHRhID0gYmxlbmREYXRhW2kgKyAzXTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgIGNhc2UgJ211bHRpcGx5JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByICogdHIgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgKiB0ZyAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiAqIHRiIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgM10gPSBhICogdGEgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdtYXNrJzpcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gdGE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdVRyYW5zZm9ybU1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1VHJhbnNmb3JtTWF0cml4JyksXG4gICAgICAgIHVJbWFnZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SW1hZ2UnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLmNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1Mb2NhdGlvbnMudUltYWdlLCAxKTsgLy8gdGV4dHVyZSB1bml0IDEuXG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVuaWZvcm1Mb2NhdGlvbnMudVRyYW5zZm9ybU1hdHJpeCwgZmFsc2UsIG1hdHJpeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGltYWdlOiB0aGlzLmltYWdlICYmIHRoaXMuaW1hZ2UudG9PYmplY3QoKSxcbiAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICBhbHBoYTogdGhpcy5hbHBoYVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdChvYmplY3QuaW1hZ2UsIGZ1bmN0aW9uKGltYWdlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvYmplY3QpO1xuICAgICAgb3B0aW9ucy5pbWFnZSA9IGltYWdlO1xuICAgICAgY2FsbGJhY2sobmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2Uob3B0aW9ucykpO1xuICAgIH0pO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLCBwb3cgPSBNYXRoLnBvdywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgc3FydCA9IE1hdGguc3FydCwgYWJzID0gTWF0aC5hYnMsIHJvdW5kID0gTWF0aC5yb3VuZCwgc2luID0gTWF0aC5zaW4sXG4gICAgICBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUmVzaXplIGltYWdlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuUmVzaXplID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1Jlc2l6ZScsXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdHlwZVxuICAgICAqIGZvciB3ZWJnbCByZXNpemVUeXBlIGlzIGp1c3QgbGFuY3pvcywgZm9yIGNhbnZhczJkIGNhbiBiZTpcbiAgICAgKiBiaWxpbmVhciwgaGVybWl0ZSwgc2xpY2VIYWNrLCBsYW5jem9zLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXNpemVUeXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZXNpemVUeXBlOiAnaGVybWl0ZScsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3IgZm9yIHJlc2l6aW5nLCB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVg6IDEsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3IgZm9yIHJlc2l6aW5nLCB5IGF4aXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVk6IDEsXG5cbiAgICAvKipcbiAgICAgKiBMYW5jem9zTG9iZXMgcGFyYW1ldGVyIGZvciBsYW5jem9zIGZpbHRlciwgdmFsaWQgZm9yIHJlc2l6ZVR5cGUgbGFuY3pvc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsYW5jem9zTG9iZXNcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxhbmN6b3NMb2JlczogMyxcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVEZWx0YTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1RGVsdGEnKSxcbiAgICAgICAgdVRhcHM6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVRhcHMnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0yZnYodW5pZm9ybUxvY2F0aW9ucy51RGVsdGEsIHRoaXMuaG9yaXpvbnRhbCA/IFsxIC8gdGhpcy53aWR0aCwgMF0gOiBbMCwgMSAvIHRoaXMuaGVpZ2h0XSk7XG4gICAgICBnbC51bmlmb3JtMWZ2KHVuaWZvcm1Mb2NhdGlvbnMudVRhcHMsIHRoaXMudGFwcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgZmlsdGVyV2luZG93ID0gdGhpcy5nZXRGaWx0ZXJXaW5kb3coKSwgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyBmaWx0ZXJXaW5kb3c7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdlbmVyYXRlU2hhZGVyKGZpbHRlcldpbmRvdyk7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIGZyYWdtZW50U2hhZGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIGdldEZpbHRlcldpbmRvdzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLnRlbXBTY2FsZTtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5sYW5jem9zTG9iZXMgLyBzY2FsZSk7XG4gICAgfSxcblxuICAgIGdldFRhcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxvYmVGdW5jdGlvbiA9IHRoaXMubGFuY3pvc0NyZWF0ZSh0aGlzLmxhbmN6b3NMb2JlcyksIHNjYWxlID0gdGhpcy50ZW1wU2NhbGUsXG4gICAgICAgICAgZmlsdGVyV2luZG93ID0gdGhpcy5nZXRGaWx0ZXJXaW5kb3coKSwgdGFwcyA9IG5ldyBBcnJheShmaWx0ZXJXaW5kb3cpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZmlsdGVyV2luZG93OyBpKyspIHtcbiAgICAgICAgdGFwc1tpIC0gMV0gPSBsb2JlRnVuY3Rpb24oaSAqIHNjYWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB2ZXJ0ZXggYW5kIHNoYWRlciBzb3VyY2VzIGZyb20gdGhlIG5lY2Vzc2FyeSBzdGVwcyBudW1iZXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZpbHRlcldpbmRvd1xuICAgICAqL1xuICAgIGdlbmVyYXRlU2hhZGVyOiBmdW5jdGlvbihmaWx0ZXJXaW5kb3cpIHtcbiAgICAgIHZhciBvZmZzZXRzID0gbmV3IEFycmF5KGZpbHRlcldpbmRvdyksXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U291cmNlVE9QLCBmaWx0ZXJXaW5kb3c7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGZpbHRlcldpbmRvdzsgaSsrKSB7XG4gICAgICAgIG9mZnNldHNbaSAtIDFdID0gaSArICcuMCAqIHVEZWx0YSc7XG4gICAgICB9XG5cbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICd1bmlmb3JtIGZsb2F0IHVUYXBzWycgKyBmaWx0ZXJXaW5kb3cgKyAnXTtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJ3ZvaWQgbWFpbigpIHtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgZmxvYXQgc3VtID0gMS4wO1xcbic7XG5cbiAgICAgIG9mZnNldHMuZm9yRWFjaChmdW5jdGlvbihvZmZzZXQsIGkpIHtcbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyAnICsgb2Zmc2V0ICsgJykgKiB1VGFwc1snICsgaSArICddO1xcbic7XG4gICAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGNvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkIC0gJyArIG9mZnNldCArICcpICogdVRhcHNbJyArIGkgKyAnXTtcXG4nO1xuICAgICAgICBmcmFnbWVudFNoYWRlciArPSAnICBzdW0gKz0gMi4wICogdVRhcHNbJyArIGkgKyAnXTtcXG4nO1xuICAgICAgfSk7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnICBnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHN1bTtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJ30nO1xuICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgIH0sXG5cbiAgICBmcmFnbWVudFNvdXJjZVRPUDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzIgdURlbHRhO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSByZXNpemUgZmlsdGVyIHRvIHRoZSBpbWFnZVxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgICAgICBvcHRpb25zLnBhc3NlcysrO1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0aW9ucy5zb3VyY2VXaWR0aDtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kVyA9IE1hdGgucm91bmQodGhpcy53aWR0aCAqIHRoaXMuc2NhbGVYKTtcbiAgICAgICAgdGhpcy5kSCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgICB0aGlzLnRlbXBTY2FsZSA9IHRoaXMuZFcgLyB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLnRhcHMgPSB0aGlzLmdldFRhcHMoKTtcbiAgICAgICAgb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoID0gdGhpcy5kVztcbiAgICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VXaWR0aCA9IG9wdGlvbnMuZGVzdGluYXRpb25XaWR0aDtcblxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kSCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiB0aGlzLnNjYWxlWSk7XG4gICAgICAgIHRoaXMudGVtcFNjYWxlID0gdGhpcy5kSCAvIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnRhcHMgPSB0aGlzLmdldFRhcHMoKTtcbiAgICAgICAgb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodCA9IHRoaXMuZEg7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuc291cmNlSGVpZ2h0ID0gb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGx5VG8yZChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYID09PSAxICYmIHRoaXMuc2NhbGVZID09PSAxO1xuICAgIH0sXG5cbiAgICBsYW5jem9zQ3JlYXRlOiBmdW5jdGlvbihsb2Jlcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPj0gbG9iZXMgfHwgeCA8PSAtbG9iZXMpIHtcbiAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4IDwgMS4xOTIwOTI5MEUtMDcgJiYgeCA+IC0xLjE5MjA5MjkwRS0wNykge1xuICAgICAgICAgIHJldHVybiAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgeCAqPSBNYXRoLlBJO1xuICAgICAgICB2YXIgeHggPSB4IC8gbG9iZXM7XG4gICAgICAgIHJldHVybiAoc2luKHgpIC8geCkgKiBzaW4oeHgpIC8geHg7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgc2NhbGVYID0gdGhpcy5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZID0gdGhpcy5zY2FsZVk7XG5cbiAgICAgIHRoaXMucmNwU2NhbGVYID0gMSAvIHNjYWxlWDtcbiAgICAgIHRoaXMucmNwU2NhbGVZID0gMSAvIHNjYWxlWTtcblxuICAgICAgdmFyIG9XID0gaW1hZ2VEYXRhLndpZHRoLCBvSCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgZFcgPSByb3VuZChvVyAqIHNjYWxlWCksIGRIID0gcm91bmQob0ggKiBzY2FsZVkpLFxuICAgICAgICAgIG5ld0RhdGE7XG5cbiAgICAgIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdzbGljZUhhY2snKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLnNsaWNlQnlUd28ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnaGVybWl0ZScpIHtcbiAgICAgICAgbmV3RGF0YSA9IHRoaXMuaGVybWl0ZUZhc3RSZXNpemUob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnYmlsaW5lYXInKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmJpbGluZWFyRmlsdGVyaW5nKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2xhbmN6b3MnKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmxhbmN6b3NSZXNpemUob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5pbWFnZURhdGEgPSBuZXdEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgc2xpY2VCeVR3b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgc2xpY2VCeVR3bzogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBtdWx0ID0gMC41LCBkb25lVyA9IGZhbHNlLCBkb25lSCA9IGZhbHNlLCBzdGVwVyA9IG9XICogbXVsdCxcbiAgICAgICAgICBzdGVwSCA9IG9IICogbXVsdCwgcmVzb3VyY2VzID0gZmFicmljLmZpbHRlckJhY2tlbmQucmVzb3VyY2VzLFxuICAgICAgICAgIHRtcENhbnZhcywgY3R4LCBzWCA9IDAsIHNZID0gMCwgZFggPSBvVywgZFkgPSAwO1xuICAgICAgaWYgKCFyZXNvdXJjZXMuc2xpY2VCeVR3bykge1xuICAgICAgICByZXNvdXJjZXMuc2xpY2VCeVR3byA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgfVxuICAgICAgdG1wQ2FudmFzID0gcmVzb3VyY2VzLnNsaWNlQnlUd287XG4gICAgICBpZiAodG1wQ2FudmFzLndpZHRoIDwgb1cgKiAxLjUgfHwgdG1wQ2FudmFzLmhlaWdodCA8IG9IKSB7XG4gICAgICAgIHRtcENhbnZhcy53aWR0aCA9IG9XICogMS41O1xuICAgICAgICB0bXBDYW52YXMuaGVpZ2h0ID0gb0g7XG4gICAgICB9XG4gICAgICBjdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgb1cgKiAxLjUsIG9IKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcblxuICAgICAgZFcgPSBmbG9vcihkVyk7XG4gICAgICBkSCA9IGZsb29yKGRIKTtcblxuICAgICAgd2hpbGUgKCFkb25lVyB8fCAhZG9uZUgpIHtcbiAgICAgICAgb1cgPSBzdGVwVztcbiAgICAgICAgb0ggPSBzdGVwSDtcbiAgICAgICAgaWYgKGRXIDwgZmxvb3Ioc3RlcFcgKiBtdWx0KSkge1xuICAgICAgICAgIHN0ZXBXID0gZmxvb3Ioc3RlcFcgKiBtdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGVwVyA9IGRXO1xuICAgICAgICAgIGRvbmVXID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZEggPCBmbG9vcihzdGVwSCAqIG11bHQpKSB7XG4gICAgICAgICAgc3RlcEggPSBmbG9vcihzdGVwSCAqIG11bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHN0ZXBIID0gZEg7XG4gICAgICAgICAgZG9uZUggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodG1wQ2FudmFzLCBzWCwgc1ksIG9XLCBvSCwgZFgsIGRZLCBzdGVwVywgc3RlcEgpO1xuICAgICAgICBzWCA9IGRYO1xuICAgICAgICBzWSA9IGRZO1xuICAgICAgICBkWSArPSBzdGVwSDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHguZ2V0SW1hZ2VEYXRhKHNYLCBzWSwgZFcsIGRIKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIGxhbmN6b3NSZXNpemVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIGxhbmN6b3NSZXNpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG5cbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3ModSkge1xuICAgICAgICB2YXIgdiwgaSwgd2VpZ2h0LCBpZHgsIGEsIHJlZCwgZ3JlZW4sXG4gICAgICAgICAgICBibHVlLCBhbHBoYSwgZlgsIGZZO1xuICAgICAgICBjZW50ZXIueCA9ICh1ICsgMC41KSAqIHJhdGlvWDtcbiAgICAgICAgaWNlbnRlci54ID0gZmxvb3IoY2VudGVyLngpO1xuICAgICAgICBmb3IgKHYgPSAwOyB2IDwgZEg7IHYrKykge1xuICAgICAgICAgIGNlbnRlci55ID0gKHYgKyAwLjUpICogcmF0aW9ZO1xuICAgICAgICAgIGljZW50ZXIueSA9IGZsb29yKGNlbnRlci55KTtcbiAgICAgICAgICBhID0gMDsgcmVkID0gMDsgZ3JlZW4gPSAwOyBibHVlID0gMDsgYWxwaGEgPSAwO1xuICAgICAgICAgIGZvciAoaSA9IGljZW50ZXIueCAtIHJhbmdlMlg7IGkgPD0gaWNlbnRlci54ICsgcmFuZ2UyWDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBvVykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZYID0gZmxvb3IoMTAwMCAqIGFicyhpIC0gY2VudGVyLngpKTtcbiAgICAgICAgICAgIGlmICghY2FjaGVMYW5jW2ZYXSkge1xuICAgICAgICAgICAgICBjYWNoZUxhbmNbZlhdID0geyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGljZW50ZXIueSAtIHJhbmdlMlk7IGogPD0gaWNlbnRlci55ICsgcmFuZ2UyWTsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IG9IKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZlkgPSBmbG9vcigxMDAwICogYWJzKGogLSBjZW50ZXIueSkpO1xuICAgICAgICAgICAgICBpZiAoIWNhY2hlTGFuY1tmWF1bZlldKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVMYW5jW2ZYXVtmWV0gPSBsYW5jem9zKHNxcnQocG93KGZYICogcmNwUmF0aW9YLCAyKSArIHBvdyhmWSAqIHJjcFJhdGlvWSwgMikpIC8gMTAwMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2VpZ2h0ID0gY2FjaGVMYW5jW2ZYXVtmWV07XG4gICAgICAgICAgICAgIGlmICh3ZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gKGogKiBvVyArIGkpICogNDtcbiAgICAgICAgICAgICAgICBhICs9IHdlaWdodDtcbiAgICAgICAgICAgICAgICByZWQgKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHhdO1xuICAgICAgICAgICAgICAgIGdyZWVuICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4ICsgMV07XG4gICAgICAgICAgICAgICAgYmx1ZSArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDJdO1xuICAgICAgICAgICAgICAgIGFscGhhICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4ICsgM107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWR4ID0gKHYgKiBkVyArIHUpICogNDtcbiAgICAgICAgICBkZXN0RGF0YVtpZHhdID0gcmVkIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAxXSA9IGdyZWVuIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAyXSA9IGJsdWUgLyBhO1xuICAgICAgICAgIGRlc3REYXRhW2lkeCArIDNdID0gYWxwaGEgLyBhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCsrdSA8IGRXKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3ModSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc3RJbWc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNyY0RhdGEgPSBvcHRpb25zLmltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGRlc3RJbWcgPSBvcHRpb25zLmN0eC5jcmVhdGVJbWFnZURhdGEoZFcsIGRIKSxcbiAgICAgICAgICBkZXN0RGF0YSA9IGRlc3RJbWcuZGF0YSxcbiAgICAgICAgICBsYW5jem9zID0gdGhpcy5sYW5jem9zQ3JlYXRlKHRoaXMubGFuY3pvc0xvYmVzKSxcbiAgICAgICAgICByYXRpb1ggPSB0aGlzLnJjcFNjYWxlWCwgcmF0aW9ZID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmNwUmF0aW9YID0gMiAvIHRoaXMucmNwU2NhbGVYLCByY3BSYXRpb1kgPSAyIC8gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmFuZ2UyWCA9IGNlaWwocmF0aW9YICogdGhpcy5sYW5jem9zTG9iZXMgLyAyKSxcbiAgICAgICAgICByYW5nZTJZID0gY2VpbChyYXRpb1kgKiB0aGlzLmxhbmN6b3NMb2JlcyAvIDIpLFxuICAgICAgICAgIGNhY2hlTGFuYyA9IHsgfSwgY2VudGVyID0geyB9LCBpY2VudGVyID0geyB9O1xuXG4gICAgICByZXR1cm4gcHJvY2VzcygwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmlsaW5lYXJGaWx0ZXJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIGJpbGluZWFyRmlsdGVyaW5nOiBmdW5jdGlvbihvcHRpb25zLCBvVywgb0gsIGRXLCBkSCkge1xuICAgICAgdmFyIGEsIGIsIGMsIGQsIHgsIHksIGksIGosIHhEaWZmLCB5RGlmZiwgY2hubCxcbiAgICAgICAgICBjb2xvciwgb2Zmc2V0ID0gMCwgb3JpZ1BpeCwgcmF0aW9YID0gdGhpcy5yY3BTY2FsZVgsXG4gICAgICAgICAgcmF0aW9ZID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgdzQgPSA0ICogKG9XIC0gMSksIGltZyA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIHBpeGVscyA9IGltZy5kYXRhLCBkZXN0SW1hZ2UgPSBvcHRpb25zLmN0eC5jcmVhdGVJbWFnZURhdGEoZFcsIGRIKSxcbiAgICAgICAgICBkZXN0UGl4ZWxzID0gZGVzdEltYWdlLmRhdGE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZEg7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgZFc7IGorKykge1xuICAgICAgICAgIHggPSBmbG9vcihyYXRpb1ggKiBqKTtcbiAgICAgICAgICB5ID0gZmxvb3IocmF0aW9ZICogaSk7XG4gICAgICAgICAgeERpZmYgPSByYXRpb1ggKiBqIC0geDtcbiAgICAgICAgICB5RGlmZiA9IHJhdGlvWSAqIGkgLSB5O1xuICAgICAgICAgIG9yaWdQaXggPSA0ICogKHkgKiBvVyArIHgpO1xuXG4gICAgICAgICAgZm9yIChjaG5sID0gMDsgY2hubCA8IDQ7IGNobmwrKykge1xuICAgICAgICAgICAgYSA9IHBpeGVsc1tvcmlnUGl4ICsgY2hubF07XG4gICAgICAgICAgICBiID0gcGl4ZWxzW29yaWdQaXggKyA0ICsgY2hubF07XG4gICAgICAgICAgICBjID0gcGl4ZWxzW29yaWdQaXggKyB3NCArIGNobmxdO1xuICAgICAgICAgICAgZCA9IHBpeGVsc1tvcmlnUGl4ICsgdzQgKyA0ICsgY2hubF07XG4gICAgICAgICAgICBjb2xvciA9IGEgKiAoMSAtIHhEaWZmKSAqICgxIC0geURpZmYpICsgYiAqIHhEaWZmICogKDEgLSB5RGlmZikgK1xuICAgICAgICAgICAgICAgICAgICBjICogeURpZmYgKiAoMSAtIHhEaWZmKSArIGQgKiB4RGlmZiAqIHlEaWZmO1xuICAgICAgICAgICAgZGVzdFBpeGVsc1tvZmZzZXQrK10gPSBjb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXN0SW1hZ2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhlcm1pdGVGYXN0UmVzaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBoZXJtaXRlRmFzdFJlc2l6ZTogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciByYXRpb1cgPSB0aGlzLnJjcFNjYWxlWCwgcmF0aW9IID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmF0aW9XSGFsZiA9IGNlaWwocmF0aW9XIC8gMiksXG4gICAgICAgICAgcmF0aW9ISGFsZiA9IGNlaWwocmF0aW9IIC8gMiksXG4gICAgICAgICAgaW1nID0gb3B0aW9ucy5pbWFnZURhdGEsIGRhdGEgPSBpbWcuZGF0YSxcbiAgICAgICAgICBpbWcyID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksIGRhdGEyID0gaW1nMi5kYXRhO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkSDsgaisrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZFc7IGkrKykge1xuICAgICAgICAgIHZhciB4MiA9IChpICsgaiAqIGRXKSAqIDQsIHdlaWdodCA9IDAsIHdlaWdodHMgPSAwLCB3ZWlnaHRzQWxwaGEgPSAwLFxuICAgICAgICAgICAgICBneFIgPSAwLCBneEcgPSAwLCBneEIgPSAwLCBneEEgPSAwLCBjZW50ZXJZID0gKGogKyAwLjUpICogcmF0aW9IO1xuICAgICAgICAgIGZvciAodmFyIHl5ID0gZmxvb3IoaiAqIHJhdGlvSCk7IHl5IDwgKGogKyAxKSAqIHJhdGlvSDsgeXkrKykge1xuICAgICAgICAgICAgdmFyIGR5ID0gYWJzKGNlbnRlclkgLSAoeXkgKyAwLjUpKSAvIHJhdGlvSEhhbGYsXG4gICAgICAgICAgICAgICAgY2VudGVyWCA9IChpICsgMC41KSAqIHJhdGlvVywgdzAgPSBkeSAqIGR5O1xuICAgICAgICAgICAgZm9yICh2YXIgeHggPSBmbG9vcihpICogcmF0aW9XKTsgeHggPCAoaSArIDEpICogcmF0aW9XOyB4eCsrKSB7XG4gICAgICAgICAgICAgIHZhciBkeCA9IGFicyhjZW50ZXJYIC0gKHh4ICsgMC41KSkgLyByYXRpb1dIYWxmLFxuICAgICAgICAgICAgICAgICAgdyA9IHNxcnQodzAgKyBkeCAqIGR4KTtcbiAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWRlcHRoICovXG4gICAgICAgICAgICAgIGlmICh3ID4gMSAmJiB3IDwgLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvL2hlcm1pdGUgZmlsdGVyXG4gICAgICAgICAgICAgIHdlaWdodCA9IDIgKiB3ICogdyAqIHcgLSAzICogdyAqIHcgKyAxO1xuICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGR4ID0gNCAqICh4eCArIHl5ICogb1cpO1xuICAgICAgICAgICAgICAgIC8vYWxwaGFcbiAgICAgICAgICAgICAgICBneEEgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDNdO1xuICAgICAgICAgICAgICAgIHdlaWdodHNBbHBoYSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy9jb2xvcnNcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtkeCArIDNdIDwgMjU1KSB7XG4gICAgICAgICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHQgKiBkYXRhW2R4ICsgM10gLyAyNTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGd4UiArPSB3ZWlnaHQgKiBkYXRhW2R4XTtcbiAgICAgICAgICAgICAgICBneEcgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDFdO1xuICAgICAgICAgICAgICAgIGd4QiArPSB3ZWlnaHQgKiBkYXRhW2R4ICsgMl07XG4gICAgICAgICAgICAgICAgd2VpZ2h0cyArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGggKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YTJbeDJdID0gZ3hSIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDFdID0gZ3hHIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDJdID0gZ3hCIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDNdID0gZ3hBIC8gd2VpZ2h0c0FscGhhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1nMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0aGlzLnNjYWxlWSxcbiAgICAgICAgcmVzaXplVHlwZTogdGhpcy5yZXNpemVUeXBlLFxuICAgICAgICBsYW5jem9zTG9iZXM6IHRoaXMubGFuY3pvc0xvYmVzXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBDb250cmFzdCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdCh7XG4gICAqICAgY29udHJhc3Q6IDQwXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuQ29udHJhc3QgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb250cmFzdCcsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVDb250cmFzdDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBjb250cmFzdEYgPSAxLjAxNSAqICh1Q29udHJhc3QgKyAxLjApIC8gKDEuMCAqICgxLjAxNSAtIHVDb250cmFzdCkpO1xcbicgK1xuICAgICAgICAnY29sb3IucmdiID0gY29udHJhc3RGICogKGNvbG9yLnJnYiAtIDAuNSkgKyAwLjU7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIGNvbnRyYXN0OiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2NvbnRyYXN0JyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29udHJhc3Q9MF0gVmFsdWUgdG8gY29udHJhc3QgdGhlIGltYWdlIHVwICgtMS4uLjEpXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgICogQXBwbHkgdGhlIENvbnRyYXN0IG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5jb250cmFzdCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsIGksIGxlbixcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGNvbnRyYXN0ID0gTWF0aC5mbG9vcih0aGlzLmNvbnRyYXN0ICogMjU1KSxcbiAgICAgICAgICBjb250cmFzdEYgPSAyNTkgKiAoY29udHJhc3QgKyAyNTUpIC8gKDI1NSAqICgyNTkgLSBjb250cmFzdCkpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IGNvbnRyYXN0RiAqIChkYXRhW2ldIC0gMTI4KSArIDEyODtcbiAgICAgICAgZGF0YVtpICsgMV0gPSBjb250cmFzdEYgKiAoZGF0YVtpICsgMV0gLSAxMjgpICsgMTI4O1xuICAgICAgICBkYXRhW2kgKyAyXSA9IGNvbnRyYXN0RiAqIChkYXRhW2kgKyAyXSAtIDEyOCkgKyAxMjg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1Q29udHJhc3Q6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUNvbnRyYXN0JyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51Q29udHJhc3QsIHRoaXMuY29udHJhc3QpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3R9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdC5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogU2F0dXJhdGUgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24oe1xuICAgKiAgIHNhdHVyYXRpb246IDEwMFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLlNhdHVyYXRpb24gPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1NhdHVyYXRpb24nLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U2F0dXJhdGlvbjtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdmbG9hdCByZ01heCA9IG1heChjb2xvci5yLCBjb2xvci5nKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IHJnYk1heCA9IG1heChyZ01heCwgY29sb3IuYik7XFxuJyArXG4gICAgICAgICdjb2xvci5yICs9IHJnYk1heCAhPSBjb2xvci5yID8gKHJnYk1heCAtIGNvbG9yLnIpICogdVNhdHVyYXRpb24gOiAwLjAwO1xcbicgK1xuICAgICAgICAnY29sb3IuZyArPSByZ2JNYXggIT0gY29sb3IuZyA/IChyZ2JNYXggLSBjb2xvci5nKSAqIHVTYXR1cmF0aW9uIDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmIgKz0gcmdiTWF4ICE9IGNvbG9yLmIgPyAocmdiTWF4IC0gY29sb3IuYikgKiB1U2F0dXJhdGlvbiA6IDAuMDA7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIHNhdHVyYXRpb246IDAsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnc2F0dXJhdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhdHVyYXRlPTBdIFZhbHVlIHRvIHNhdHVyYXRlIHRoZSBpbWFnZSAoLTEuLi4xKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIFNhdHVyYXRpb24gb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5zYXR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGFkanVzdCA9IC10aGlzLnNhdHVyYXRpb24sIGksIG1heDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSk7XG4gICAgICAgIGRhdGFbaV0gKz0gbWF4ICE9PSBkYXRhW2ldID8gKG1heCAtIGRhdGFbaV0pICogYWRqdXN0IDogMDtcbiAgICAgICAgZGF0YVtpICsgMV0gKz0gbWF4ICE9PSBkYXRhW2kgKyAxXSA/IChtYXggLSBkYXRhW2kgKyAxXSkgKiBhZGp1c3QgOiAwO1xuICAgICAgICBkYXRhW2kgKyAyXSArPSBtYXggIT09IGRhdGFbaSArIDJdID8gKG1heCAtIGRhdGFbaSArIDJdKSAqIGFkanVzdCA6IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1U2F0dXJhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2F0dXJhdGlvbicpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudVNhdHVyYXRpb24sIC10aGlzLnNhdHVyYXRpb24pO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbn0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24uZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEJsdXIgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsdXIjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsdXIoe1xuICAgKiAgIGJsdXI6IDAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG4gIGZpbHRlcnMuQmx1ciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyLnByb3RvdHlwZSAqLyB7XG5cbiAgICB0eXBlOiAnQmx1cicsXG5cbiAgICAvKlxuJ2dsX0ZyYWdDb2xvciA9IHZlYzQoMC4wKTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTcgKiB1RGVsdGEpKjAuMDA0NDI5OTEyMTA1NTExMzI2NTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTYgKiB1RGVsdGEpKjAuMDA4OTU3ODEyMTE3OTQ7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC01ICogdURlbHRhKSowLjAyMTU5NjM4NjYwNTM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC00ICogdURlbHRhKSowLjA0NDM2ODMzMzg3MTg7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC0zICogdURlbHRhKSowLjA3NzY3NDQyMTk5MzM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC0yICogdURlbHRhKSowLjExNTg3NjYyMTEwNTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTEgKiB1RGVsdGEpKjAuMTQ3MzA4MDU2MTIxOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgICAgICAgICAgICAgICkqMC4xNTk1NzY5MTIxNjE7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDEgKiB1RGVsdGEpKjAuMTQ3MzA4MDU2MTIxOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAyICogdURlbHRhKSowLjExNTg3NjYyMTEwNTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgMyAqIHVEZWx0YSkqMC4wNzc2NzQ0MjE5OTMzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA0ICogdURlbHRhKSowLjA0NDM2ODMzMzg3MTg7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDUgKiB1RGVsdGEpKjAuMDIxNTk2Mzg2NjA1MzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNiAqIHVEZWx0YSkqMC4wMDg5NTc4MTIxMTc5NDsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNyAqIHVEZWx0YSkqMC4wMDQ0Mjk5MTIxMDU1MTEzMjY1OycsXG4qL1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjMiB1RGVsdGE7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICdjb25zdCBmbG9hdCBuU2FtcGxlcyA9IDE1LjA7XFxuJyArXG4gICAgICAndmVjMyB2M29mZnNldCA9IHZlYzMoMTIuOTg5OCwgNzguMjMzLCAxNTEuNzE4Mik7XFxuJyArXG4gICAgICAnZmxvYXQgcmFuZG9tKHZlYzMgc2NhbGUpIHtcXG4nICtcbiAgICAgICAgLyogdXNlIHRoZSBmcmFnbWVudCBwb3NpdGlvbiBmb3IgYSBkaWZmZXJlbnQgc2VlZCBwZXItcGl4ZWwgKi9cbiAgICAgICAgJ3JldHVybiBmcmFjdChzaW4oZG90KGdsX0ZyYWdDb29yZC54eXosIHNjYWxlKSkgKiA0Mzc1OC41NDUzKTtcXG4nICtcbiAgICAgICd9XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IHRvdGFsID0gMC4wO1xcbicgK1xuICAgICAgICAnZmxvYXQgb2Zmc2V0ID0gcmFuZG9tKHYzb2Zmc2V0KTtcXG4nICtcbiAgICAgICAgJ2ZvciAoZmxvYXQgdCA9IC1uU2FtcGxlczsgdCA8PSBuU2FtcGxlczsgdCsrKSB7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IHBlcmNlbnQgPSAodCArIG9mZnNldCAtIDAuNSkgLyBuU2FtcGxlcztcXG4nICtcbiAgICAgICAgICAnZmxvYXQgd2VpZ2h0ID0gMS4wIC0gYWJzKHBlcmNlbnQpO1xcbicgK1xuICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIHVEZWx0YSAqIHBlcmNlbnQpICogd2VpZ2h0O1xcbicgK1xuICAgICAgICAgICd0b3RhbCArPSB3ZWlnaHQ7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHRvdGFsO1xcbicgK1xuICAgICAgJ30nLFxuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgLyoqXG4gICAgICogYmx1ciB2YWx1ZSwgaW4gcGVyY2VudGFnZSBvZiBpbWFnZSBkaW1lbnNpb25zLlxuICAgICAqIHNwZWNpZmljIHRvIGtlZXAgdGhlIGltYWdlIGJsdXIgY29uc3RhbnQgYXQgZGlmZmVyZW50IHJlc29sdXRpb25zXG4gICAgICogcmFuZ2UgYmV3dGVlbiAwIGFuZCAxLlxuICAgICAqL1xuICAgIGJsdXI6IDAsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnYmx1cicsXG5cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgICAgICAvLyB0aGlzIGFzcGVjdFJhdGlvIGlzIHVzZWQgdG8gZ2l2ZSB0aGUgc2FtZSBibHVyIHRvIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsXG4gICAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSBvcHRpb25zLnNvdXJjZVdpZHRoIC8gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICAgIG9wdGlvbnMucGFzc2VzKys7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwbHlUbzJkKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIC8vIHBhaW50IGNhbnZhc0VsIHdpdGggY3VycmVudCBpbWFnZSBkYXRhLlxuICAgICAgLy9vcHRpb25zLmN0eC5wdXRJbWFnZURhdGEob3B0aW9ucy5pbWFnZURhdGEsIDAsIDApO1xuICAgICAgb3B0aW9ucy5pbWFnZURhdGEgPSB0aGlzLnNpbXBsZUJsdXIob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIHNpbXBsZUJsdXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZXNvdXJjZXMgPSBvcHRpb25zLmZpbHRlckJhY2tlbmQucmVzb3VyY2VzLCBjYW52YXMxLCBjYW52YXMyLFxuICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy5pbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5pbWFnZURhdGEuaGVpZ2h0O1xuXG4gICAgICBpZiAoIXJlc291cmNlcy5ibHVyTGF5ZXIxKSB7XG4gICAgICAgIHJlc291cmNlcy5ibHVyTGF5ZXIxID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICByZXNvdXJjZXMuYmx1ckxheWVyMiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhczEgPSByZXNvdXJjZXMuYmx1ckxheWVyMTtcbiAgICAgIGNhbnZhczIgPSByZXNvdXJjZXMuYmx1ckxheWVyMjtcbiAgICAgIGlmIChjYW52YXMxLndpZHRoICE9PSB3aWR0aCB8fCBjYW52YXMxLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIGNhbnZhczIud2lkdGggPSBjYW52YXMxLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhczIuaGVpZ2h0ID0gY2FudmFzMS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgICB2YXIgY3R4MSA9IGNhbnZhczEuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBjdHgyID0gY2FudmFzMi5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIG5TYW1wbGVzID0gMTUsXG4gICAgICAgICAgcmFuZG9tLCBwZXJjZW50LCBqLCBpLFxuICAgICAgICAgIGJsdXIgPSB0aGlzLmJsdXIgKiAwLjA2ICogMC41O1xuXG4gICAgICAvLyBsb2FkIGZpcnN0IGNhbnZhc1xuICAgICAgY3R4MS5wdXRJbWFnZURhdGEob3B0aW9ucy5pbWFnZURhdGEsIDAsIDApO1xuICAgICAgY3R4Mi5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgIGZvciAoaSA9IC1uU2FtcGxlczsgaSA8PSBuU2FtcGxlczsgaSsrKSB7XG4gICAgICAgIHJhbmRvbSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDQ7XG4gICAgICAgIHBlcmNlbnQgPSBpIC8gblNhbXBsZXM7XG4gICAgICAgIGogPSBibHVyICogcGVyY2VudCAqIHdpZHRoICsgcmFuZG9tO1xuICAgICAgICBjdHgyLmdsb2JhbEFscGhhID0gMSAtIE1hdGguYWJzKHBlcmNlbnQpO1xuICAgICAgICBjdHgyLmRyYXdJbWFnZShjYW52YXMxLCBqLCByYW5kb20pO1xuICAgICAgICBjdHgxLmRyYXdJbWFnZShjYW52YXMyLCAwLCAwKTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIGN0eDIuY2xlYXJSZWN0KDAsIDAsIGNhbnZhczIud2lkdGgsIGNhbnZhczIuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IC1uU2FtcGxlczsgaSA8PSBuU2FtcGxlczsgaSsrKSB7XG4gICAgICAgIHJhbmRvbSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDQ7XG4gICAgICAgIHBlcmNlbnQgPSBpIC8gblNhbXBsZXM7XG4gICAgICAgIGogPSBibHVyICogcGVyY2VudCAqIGhlaWdodCArIHJhbmRvbTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDEgLSBNYXRoLmFicyhwZXJjZW50KTtcbiAgICAgICAgY3R4Mi5kcmF3SW1hZ2UoY2FudmFzMSwgcmFuZG9tLCBqKTtcbiAgICAgICAgY3R4MS5kcmF3SW1hZ2UoY2FudmFzMiwgMCwgMCk7XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHgyLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMyLndpZHRoLCBjYW52YXMyLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLmN0eC5kcmF3SW1hZ2UoY2FudmFzMSwgMCwgMCk7XG4gICAgICB2YXIgbmV3SW1hZ2VEYXRhID0gb3B0aW9ucy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhczEud2lkdGgsIGNhbnZhczEuaGVpZ2h0KTtcbiAgICAgIGN0eDEuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgY3R4MS5jbGVhclJlY3QoMCwgMCwgY2FudmFzMS53aWR0aCwgY2FudmFzMS5oZWlnaHQpO1xuICAgICAgcmV0dXJuIG5ld0ltYWdlRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlbHRhOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VEZWx0YScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIGRlbHRhID0gdGhpcy5jaG9vc2VSaWdodERlbHRhKCk7XG4gICAgICBnbC51bmlmb3JtMmZ2KHVuaWZvcm1Mb2NhdGlvbnMuZGVsdGEsIGRlbHRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2hvb3NlIHJpZ2h0IHZhbHVlIG9mIGltYWdlIHBlcmNlbnRhZ2UgdG8gYmx1ciB3aXRoXG4gICAgICogQHJldHVybnMge0FycmF5fSBhIG51bWVyaWMgYXJyYXkgd2l0aCBkZWx0YSB2YWx1ZXNcbiAgICAgKi9cbiAgICBjaG9vc2VSaWdodERlbHRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBibHVyU2NhbGUgPSAxLCBkZWx0YSA9IFswLCAwXSwgYmx1cjtcbiAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuYXNwZWN0UmF0aW8gPiAxKSB7XG4gICAgICAgICAgLy8gaW1hZ2UgaXMgd2lkZSwgaSB3YW50IHRvIHNocmluayByYWRpdXMgaG9yaXpvbnRhbFxuICAgICAgICAgIGJsdXJTY2FsZSA9IDEgLyB0aGlzLmFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYXNwZWN0UmF0aW8gPCAxKSB7XG4gICAgICAgICAgLy8gaW1hZ2UgaXMgdGFsbCwgaSB3YW50IHRvIHNocmluayByYWRpdXMgdmVydGljYWxcbiAgICAgICAgICBibHVyU2NhbGUgPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBibHVyID0gYmx1clNjYWxlICogdGhpcy5ibHVyICogMC4xMjtcbiAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgZGVsdGFbMF0gPSBibHVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRlbHRhWzFdID0gYmx1cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBKU09OIGRlZmluaXRpb24gb2YgYSBCbHVyRmlsdGVyIGludG8gYSBjb25jcmV0ZSBpbnN0YW5jZS5cbiAgICovXG4gIGZpbHRlcnMuQmx1ci5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogR2FtbWEgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEoe1xuICAgKiAgIGJyaWdodG5lc3M6IDIwMFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkdhbW1hID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnR2FtbWEnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWMzIHVHYW1tYTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICd2ZWMzIGNvcnJlY3Rpb24gPSAoMS4wIC8gdUdhbW1hKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnIgPSBwb3coY29sb3IuciwgY29ycmVjdGlvbi5yKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmcgPSBwb3coY29sb3IuZywgY29ycmVjdGlvbi5nKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmIgPSBwb3coY29sb3IuYiwgY29ycmVjdGlvbi5iKTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvci5hO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogR2FtbWEgYXJyYXkgdmFsdWUsIGZyb20gMC4wMSB0byAyLjIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ2FtbWFcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGdhbW1hOiBbMSwgMSwgMV0sXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAnZ2FtbWEnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5nYW1tYSA9IFsxLCAxLCAxXTtcbiAgICAgIGZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgR2FtbWEgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLCBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgZ2FtbWEgPSB0aGlzLmdhbW1hLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBySW52ID0gMSAvIGdhbW1hWzBdLCBnSW52ID0gMSAvIGdhbW1hWzFdLFxuICAgICAgICAgIGJJbnYgPSAxIC8gZ2FtbWFbMl0sIGk7XG5cbiAgICAgIGlmICghdGhpcy5yVmFscykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5yVmFscyA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLmdWYWxzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuYlZhbHMgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiAtIHByZS1jb21wdXRlIGEgbG9vay11cCB0YWJsZSBmb3IgZWFjaCBjb2xvciBjaGFubmVsXG4gICAgICAvLyBpbnN0ZWFkIG9mIHBlcmZvcm1pbmcgdGhlc2UgcG93IGNhbGxzIGZvciBlYWNoIHBpeGVsIGluIHRoZSBpbWFnZS5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IDI1NjsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuclZhbHNbaV0gPSBNYXRoLnBvdyhpIC8gMjU1LCBySW52KSAqIDI1NTtcbiAgICAgICAgdGhpcy5nVmFsc1tpXSA9IE1hdGgucG93KGkgLyAyNTUsIGdJbnYpICogMjU1O1xuICAgICAgICB0aGlzLmJWYWxzW2ldID0gTWF0aC5wb3coaSAvIDI1NSwgYkludikgKiAyNTU7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSB0aGlzLnJWYWxzW2RhdGFbaV1dO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IHRoaXMuZ1ZhbHNbZGF0YVtpICsgMV1dO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IHRoaXMuYlZhbHNbZGF0YVtpICsgMl1dO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUdhbW1hOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VHYW1tYScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTNmdih1bmlmb3JtTG9jYXRpb25zLnVHYW1tYSwgdGhpcy5nYW1tYSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWFcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBBIGNvbnRhaW5lciBjbGFzcyB0aGF0IGtub3dzIGhvdyB0byBhcHBseSBhIHNlcXVlbmNlIG9mIGZpbHRlcnMgdG8gYW4gaW5wdXQgaW1hZ2UuXG4gICAqL1xuICBmaWx0ZXJzLkNvbXBvc2VkID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbXBvc2VkLnByb3RvdHlwZSAqLyB7XG5cbiAgICB0eXBlOiAnQ29tcG9zZWQnLFxuXG4gICAgLyoqXG4gICAgICogQSBub24gc3BhcnNlIGFycmF5IG9mIGZpbHRlcnMgdG8gYXBwbHlcbiAgICAgKi9cbiAgICBzdWJGaWx0ZXJzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgYXJyYXkgaW5zdGVhZCBtdXRhdGluZyB0aGUgcHJvdG90eXBlIHdpdGggcHVzaFxuICAgICAgdGhpcy5zdWJGaWx0ZXJzID0gdGhpcy5zdWJGaWx0ZXJzLnNsaWNlKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGlzIGNvbnRhaW5lcidzIGZpbHRlcnMgdG8gdGhlIGlucHV0IGltYWdlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBhcHBsaWVkLlxuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMucGFzc2VzICs9IHRoaXMuc3ViRmlsdGVycy5sZW5ndGggLSAxO1xuICAgICAgdGhpcy5zdWJGaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIGZpbHRlci5hcHBseVRvKG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGlzIGZpbHRlciBpbnRvIEpTT04uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmaWx0ZXIuXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgc3ViRmlsdGVyczogdGhpcy5zdWJGaWx0ZXJzLm1hcChmdW5jdGlvbihmaWx0ZXIpIHsgcmV0dXJuIGZpbHRlci50b09iamVjdCgpOyB9KSxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuc3ViRmlsdGVycy5zb21lKGZ1bmN0aW9uKGZpbHRlcikgeyByZXR1cm4gIWZpbHRlci5pc05ldXRyYWxTdGF0ZSgpOyB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhIEpTT04gZGVmaW5pdGlvbiBvZiBhIENvbXBvc2VkRmlsdGVyIGludG8gYSBjb25jcmV0ZSBpbnN0YW5jZS5cbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbXBvc2VkLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpbHRlcnMgPSBvYmplY3Quc3ViRmlsdGVycyB8fCBbXSxcbiAgICAgICAgc3ViRmlsdGVycyA9IGZpbHRlcnMubWFwKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgZmFicmljLkltYWdlLmZpbHRlcnNbZmlsdGVyLnR5cGVdKGZpbHRlcik7XG4gICAgICAgIH0pLFxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db21wb3NlZCh7IHN1YkZpbHRlcnM6IHN1YkZpbHRlcnMgfSk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBIdWVSb3RhdGlvbiBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbih7XG4gICAqICAgcm90YXRpb246IC0wLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5IdWVSb3RhdGlvbiA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQ29sb3JNYXRyaXgsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdIdWVSb3RhdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBIdWVSb3RhdGlvbiB2YWx1ZSwgZnJvbSAtMSB0byAxLlxuICAgICAqIHRoZSB1bml0IGlzIHJhZGlhbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbXlQYXJhbWV0ZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJvdGF0aW9uOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ3JvdGF0aW9uJyxcblxuICAgIGNhbGN1bGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFkID0gdGhpcy5yb3RhdGlvbiAqIE1hdGguUEksIGNvcyA9IGZhYnJpYy51dGlsLmNvcyhyYWQpLCBzaW4gPSBmYWJyaWMudXRpbC5zaW4ocmFkKSxcbiAgICAgICAgICBhVGhpcmQgPSAxIC8gMywgYVRoaXJkU3F0U2luID0gTWF0aC5zcXJ0KGFUaGlyZCkgKiBzaW4sIE9uZU1pbnVzQ29zID0gMSAtIGNvcztcbiAgICAgIHRoaXMubWF0cml4ID0gW1xuICAgICAgICAxLCAwLCAwLCAwLCAwLFxuICAgICAgICAwLCAxLCAwLCAwLCAwLFxuICAgICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICBdO1xuICAgICAgdGhpcy5tYXRyaXhbMF0gPSBjb3MgKyBPbmVNaW51c0NvcyAvIDM7XG4gICAgICB0aGlzLm1hdHJpeFsxXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zIC0gYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMl0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzVdID0gYVRoaXJkICogT25lTWludXNDb3MgKyBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFs2XSA9IGNvcyArIGFUaGlyZCAqIE9uZU1pbnVzQ29zO1xuICAgICAgdGhpcy5tYXRyaXhbN10gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyAtIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzEwXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zIC0gYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMTFdID0gYVRoaXJkICogT25lTWludXNDb3MgKyBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsxMl0gPSBjb3MgKyBhVGhpcmQgKiBPbmVNaW51c0NvcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSHVlUm90YXRpb24gaXNOZXV0cmFsU3RhdGUgaW1wbGVtZW50YXRpb25cbiAgICAgKiBVc2VkIG9ubHkgaW4gaW1hZ2UgYXBwbHlGaWx0ZXJzIHRvIGRpc2NhcmQgZmlsdGVycyB0aGF0IHdpbGwgbm90IGhhdmUgYW4gZWZmZWN0XG4gICAgICogb24gdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlTWF0cml4KCk7XG4gICAgICByZXR1cm4gZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZS5pc05ldXRyYWxTdGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGlzIGZpbHRlciB0byB0aGUgaW5wdXQgaW1hZ2UgZGF0YSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZS5hcHBseVRvLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9ufSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvblxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24uZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgaWYgKGZhYnJpYy5UZXh0KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5UZXh0IGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXh0IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuVGV4dFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI3RleHR9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UZXh0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuVGV4dCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgd2hpY2ggd2hlbiBzZXQgY2F1c2Ugb2JqZWN0IHRvIGNoYW5nZSBkaW1lbnNpb25zXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaW1lbnNpb25BZmZlY3RpbmdQcm9wczogW1xuICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICdmb250U3R5bGUnLFxuICAgICAgJ2xpbmVIZWlnaHQnLFxuICAgICAgJ3RleHQnLFxuICAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgICd0ZXh0QWxpZ24nLFxuICAgICAgJ3N0eWxlcycsXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlTmV3bGluZTogL1xccj9cXG4vLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBmb3Igd2hpdGVzcGFjZXMgdGhhdCBpcyBub3QgYSBuZXcgbGluZS5cbiAgICAgKiBNb3N0bHkgdXNlZCB3aGVuIHRleHQgaXMgJ2p1c3RpZnknIGFsaWduZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVTcGFjZXNBbmRUYWJzOiAvWyBcXHRcXHJdL2csXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyByZWd1bGFyIGV4cHJlc3Npb24gdG8gZmlsdGVyIGZvciB3aGl0ZXNwYWNlIHRoYXQgaXMgbm90IGEgbmV3IGxpbmUuXG4gICAgICogTW9zdGx5IHVzZWQgd2hlbiB0ZXh0IGlzICdqdXN0aWZ5JyBhbGlnbmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2VBbmRUYWI6IC9bIFxcdFxccl0vLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBjb25zZWN1dGl2ZSBncm91cHMgb2Ygbm9uIHNwYWNlcy5cbiAgICAgKiBNb3N0bHkgdXNlZCB3aGVuIHRleHQgaXMgJ2p1c3RpZnknIGFsaWduZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVXb3JkczogL1xcUysvZyxcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAgICAgICAgICAgICAgICAgJ3RleHQnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzaXplIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250U2l6ZTogICAgICAgICAgICAgNDAsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHdlaWdodCAoZS5nLiBib2xkLCBub3JtYWwsIDQwMCwgNjAwLCA4MDApXG4gICAgICogQHR5cGUgeyhOdW1iZXJ8U3RyaW5nKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRXZWlnaHQ6ICAgICAgICAgICAnbm9ybWFsJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgZmFtaWx5XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250RmFtaWx5OiAgICAgICAgICAgJ1RpbWVzIE5ldyBSb21hbicsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gdW5kZXJsaW5lLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuZGVybGluZTogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gb3ZlcmxpbmUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxpbmU6ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBkZWNvcmF0aW9uIGxpbmV0aHJvdWdoLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxpbmV0aHJvdWdoOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgYWxpZ25tZW50LiBQb3NzaWJsZSB2YWx1ZXM6IFwibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCIsIFwianVzdGlmeVwiLFxuICAgICAqIFwianVzdGlmeS1sZWZ0XCIsIFwianVzdGlmeS1jZW50ZXJcIiBvciBcImp1c3RpZnktcmlnaHRcIi5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRleHRBbGlnbjogICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIC4gUG9zc2libGUgdmFsdWVzOiBcIlwiLCBcIm5vcm1hbFwiLCBcIml0YWxpY1wiIG9yIFwib2JsaXF1ZVwiLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFN0eWxlOiAgICAgICAgICAgICdub3JtYWwnLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxpbmVIZWlnaHQ6ICAgICAgICAgICAxLjE2LFxuXG4gICAgLyoqXG4gICAgICogU3VwZXJzY3JpcHQgc2NoZW1hIG9iamVjdCAobWluaW11bSBvdmVybGFwKVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdXBlcnNjcmlwdDoge1xuICAgICAgc2l6ZTogICAgICAwLjYwLCAvLyBmb250U2l6ZSBmYWN0b3JcbiAgICAgIGJhc2VsaW5lOiAtMC4zNSAgLy8gYmFzZWxpbmUtc2hpZnQgZmFjdG9yICh1cHdhcmRzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpcHQgc2NoZW1hIG9iamVjdCAobWluaW11bSBvdmVybGFwKVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdWJzY3JpcHQ6IHtcbiAgICAgIHNpemU6ICAgICAgMC42MCwgLy8gZm9udFNpemUgZmFjdG9yXG4gICAgICBiYXNlbGluZTogIDAuMTEgIC8vIGJhc2VsaW5lLXNoaWZ0IGZhY3RvciAoZG93bndhcmRzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIHRleHQgbGluZXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRleHRCYWNrZ3JvdW5kQ29sb3I6ICAnJyxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmXG4gICAgICogc3RhdGUgb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKHtAbGluayBmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZH0pXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCdmb250RmFtaWx5JyxcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAndGV4dCcsXG4gICAgICAndW5kZXJsaW5lJyxcbiAgICAgICdvdmVybGluZScsXG4gICAgICAnbGluZXRocm91Z2gnLFxuICAgICAgJ3RleHRBbGlnbicsXG4gICAgICAnZm9udFN0eWxlJyxcbiAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICd0ZXh0QmFja2dyb3VuZENvbG9yJyxcbiAgICAgICdjaGFyU3BhY2luZycsXG4gICAgICAnc3R5bGVzJyksXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBjYWNoZSBuZWVkcyByZWZyZXNoXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ2ZvbnRGYW1pbHknLFxuICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICd0ZXh0JyxcbiAgICAgICd1bmRlcmxpbmUnLFxuICAgICAgJ292ZXJsaW5lJyxcbiAgICAgICdsaW5ldGhyb3VnaCcsXG4gICAgICAndGV4dEFsaWduJyxcbiAgICAgICdmb250U3R5bGUnLFxuICAgICAgJ2xpbmVIZWlnaHQnLFxuICAgICAgJ3RleHRCYWNrZ3JvdW5kQ29sb3InLFxuICAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgICdzdHlsZXMnKSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGVmaW5lZCwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIHZpYSBzdHJva2UgYW5kIHRoaXMgcHJvcGVydHkgc3BlY2lmaWVzIGl0cyBjb2xvci5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHdhcyBuYW1lZCBcInN0cm9rZVN0eWxlXCIgdW50aWwgdjEuMS42XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2U6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgd2FzIG5hbWVkIFwidGV4dFNoYWRvd1wiIChTdHJpbmcpIHVudGlsIHYxLjIuMTFcbiAgICAgKiBAdHlwZSBmYWJyaWMuU2hhZG93XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzaGFkb3c6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZvbnRTaXplRnJhY3Rpb246IDAuMjIyLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvZmZzZXRzOiB7XG4gICAgICB1bmRlcmxpbmU6IDAuMTAsXG4gICAgICBsaW5ldGhyb3VnaDogLTAuMzE1LFxuICAgICAgb3ZlcmxpbmU6IC0wLjg4XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgTGluZSBwcm9wb3J0aW9uIHRvIGZvbnQgU2l6ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgX2ZvbnRTaXplTXVsdDogICAgICAgICAgICAgMS4xMyxcblxuICAgIC8qKlxuICAgICAqIGFkZGl0aW9uYWwgc3BhY2UgYmV0d2VlbiBjaGFyYWN0ZXJzXG4gICAgICogZXhwcmVzc2VkIGluIHRob3VzYW5kcyBvZiBlbSB1bml0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjaGFyU3BhY2luZzogICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBjb250YWluaW5nIGNoYXJhY3RlciBzdHlsZXMgLSB0b3AtbGV2ZWwgcHJvcGVydGllcyAtPiBsaW5lIG51bWJlcnMsXG4gICAgICogMm5kLWxldmVsIHByb3BlcnRpZXMgLSBjaGFyYXRlciBudW1iZXJzXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHlsZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gYSBjb250ZXh0IHRvIG1lYXN1cmUgdGV4dCBjaGFyIG9yIGNvdXBsZSBvZiBjaGFyc1xuICAgICAqIHRoZSBjYWNoZUNvbnRleHQgb2YgdGhlIGNhbnZhcyB3aWxsIGJlIHVzZWQgb3IgYSBmcmVzaGx5IGNyZWF0ZWQgb25lIGlmIHRoZSBvYmplY3QgaXMgbm90IG9uIGNhbnZhc1xuICAgICAqIG9uY2UgY3JlYXRlZCBpdCB3aWxsIGJlIHJlZmVyZW5jZWQgb24gZmFicmljLl9tZWFzdXJpbmdDb250ZXh0IHRvIGF2b2lkZSBjcmVhdGluZyBhIGNhbnZhcyBmb3IgZXZlcnlcbiAgICAgKiB0ZXh0IG9iamVjdCBjcmVhdGVkLlxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBfbWVhc3VyaW5nQ29udGV4dDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEJhc2VsaW5lIHNoaWZ0LCBzdGx5ZXMgb25seSwga2VlcCBhdCAwIGZvciB0aGUgbWFpbiB0ZXh0IG9iamVjdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBkZWx0YVk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBwcm9wZXJ0aWVzIHRoYXQgZGVmaW5lIGEgc3R5bGUgdW5pdCAob2YgJ3N0eWxlcycpLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIF9zdHlsZVByb3BlcnRpZXM6IFtcbiAgICAgICdzdHJva2UnLFxuICAgICAgJ3N0cm9rZVdpZHRoJyxcbiAgICAgICdmaWxsJyxcbiAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAnZm9udFdlaWdodCcsXG4gICAgICAnZm9udFN0eWxlJyxcbiAgICAgICd1bmRlcmxpbmUnLFxuICAgICAgJ292ZXJsaW5lJyxcbiAgICAgICdsaW5ldGhyb3VnaCcsXG4gICAgICAnZGVsdGFZJyxcbiAgICAgICd0ZXh0QmFja2dyb3VuZENvbG9yJyxcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogY29udGFpbnMgY2hhcmFjdGVycyBib3VuZGluZyBib3hlc1xuICAgICAqL1xuICAgIF9fY2hhckJvdW5kczogW10sXG5cbiAgICAvKipcbiAgICAgKiB1c2UgdGhpcyBzaXplIHdoZW4gbWVhc3VyaW5nIHRleHQuIFRvIGF2b2lkIElFMTEgcm91bmRpbmcgZXJyb3JzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ0FDSEVfRk9OVF9TSVpFOiA0MDAsXG5cbiAgICAvKipcbiAgICAgKiBjb250YWlucyB0aGUgbWluIHRleHQgd2lkdGggdG8gYXZvaWQgZ2V0dGluZyAwXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIE1JTl9URVhUX1dJRFRIOiAyLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc3R5bGVzID0gb3B0aW9ucyA/IChvcHRpb25zLnN0eWxlcyB8fCB7IH0pIDogeyB9O1xuICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgIHRoaXMuX19za2lwRGltZW5zaW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9fc2tpcERpbWVuc2lvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuc2V0dXBTdGF0ZSh7IHByb3BlcnR5U2V0OiAnX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzJyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY29udGV4IGZvciBtZWFzdXJlbWVudCBvZiB0ZXh0IHN0cmluZy5cbiAgICAgKiBpZiBjcmVhdGVkIGl0IGdldHMgc3RvcmVkIGZvciByZXVzZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICovXG4gICAgZ2V0TWVhc3VyaW5nQ29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpZiB3ZSBkaWQgbm90IHJldHVybiB3ZSBoYXZlIHRvIG1lYXN1cmUgc29tZXRoaW5nLlxuICAgICAgaWYgKCFmYWJyaWMuX21lYXN1cmluZ0NvbnRleHQpIHtcbiAgICAgICAgZmFicmljLl9tZWFzdXJpbmdDb250ZXh0ID0gdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY29udGV4dENhY2hlIHx8XG4gICAgICAgICAgZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFicmljLl9tZWFzdXJpbmdDb250ZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIERpdmlkZXMgdGV4dCBpbnRvIGxpbmVzIG9mIHRleHQgYW5kIGxpbmVzIG9mIGdyYXBoZW1lcy5cbiAgICAgKi9cbiAgICBfc3BsaXRUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuZXdMaW5lcyA9IHRoaXMuX3NwbGl0VGV4dEludG9MaW5lcyh0aGlzLnRleHQpO1xuICAgICAgdGhpcy50ZXh0TGluZXMgPSBuZXdMaW5lcy5saW5lcztcbiAgICAgIHRoaXMuX3RleHRMaW5lcyA9IG5ld0xpbmVzLmdyYXBoZW1lTGluZXM7XG4gICAgICB0aGlzLl91bndyYXBwZWRUZXh0TGluZXMgPSBuZXdMaW5lcy5fdW53cmFwcGVkTGluZXM7XG4gICAgICB0aGlzLl90ZXh0ID0gbmV3TGluZXMuZ3JhcGhlbWVUZXh0O1xuICAgICAgcmV0dXJuIG5ld0xpbmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIG9yIHVwZGF0ZSB0ZXh0IGRpbWVuc2lvbnMuXG4gICAgICogVXBkYXRlcyB0aGlzLndpZHRoIGFuZCB0aGlzLmhlaWdodCB3aXRoIHRoZSBwcm9wZXIgdmFsdWVzLlxuICAgICAqIERvZXMgbm90IHJldHVybiBkaW1lbnNpb25zLlxuICAgICAqL1xuICAgIGluaXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9fc2tpcERpbWVuc2lvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zcGxpdFRleHQoKTtcbiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbGNUZXh0V2lkdGgoKSB8fCB0aGlzLmN1cnNvcldpZHRoIHx8IHRoaXMuTUlOX1RFWFRfV0lEVEg7XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSkge1xuICAgICAgICAvLyBvbmNlIHRleHQgaXMgbWVhc3VyZWQgd2UgbmVlZCB0byBtYWtlIHNwYWNlIGZhdHRlciB0byBtYWtlIGp1c3RpZmllZCB0ZXh0LlxuICAgICAgICB0aGlzLmVubGFyZ2VTcGFjZXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYWxjVGV4dEhlaWdodCgpO1xuICAgICAgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVubGFyZ2Ugc3BhY2UgYm94ZXMgYW5kIHNoaWZ0IHRoZSBvdGhlcnNcbiAgICAgKi9cbiAgICBlbmxhcmdlU3BhY2VzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaWZmU3BhY2UsIGN1cnJlbnRMaW5lV2lkdGgsIG51bWJlck9mU3BhY2VzLCBhY2N1bXVsYXRlZFNwYWNlLCBsaW5lLCBjaGFyQm91bmQsIHNwYWNlcztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dEFsaWduICE9PSAnanVzdGlmeScgJiYgKGkgPT09IGxlbiAtIDEgfHwgdGhpcy5pc0VuZE9mV3JhcHBpbmcoaSkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYWNjdW11bGF0ZWRTcGFjZSA9IDA7XG4gICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV07XG4gICAgICAgIGN1cnJlbnRMaW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lV2lkdGggPCB0aGlzLndpZHRoICYmIChzcGFjZXMgPSB0aGlzLnRleHRMaW5lc1tpXS5tYXRjaCh0aGlzLl9yZVNwYWNlc0FuZFRhYnMpKSkge1xuICAgICAgICAgIG51bWJlck9mU3BhY2VzID0gc3BhY2VzLmxlbmd0aDtcbiAgICAgICAgICBkaWZmU3BhY2UgPSAodGhpcy53aWR0aCAtIGN1cnJlbnRMaW5lV2lkdGgpIC8gbnVtYmVyT2ZTcGFjZXM7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8PSBqbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGNoYXJCb3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2ldW2pdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChsaW5lW2pdKSkge1xuICAgICAgICAgICAgICBjaGFyQm91bmQud2lkdGggKz0gZGlmZlNwYWNlO1xuICAgICAgICAgICAgICBjaGFyQm91bmQua2VybmVkV2lkdGggKz0gZGlmZlNwYWNlO1xuICAgICAgICAgICAgICBjaGFyQm91bmQubGVmdCArPSBhY2N1bXVsYXRlZFNwYWNlO1xuICAgICAgICAgICAgICBhY2N1bXVsYXRlZFNwYWNlICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjaGFyQm91bmQubGVmdCArPSBhY2N1bXVsYXRlZFNwYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgdGhlIHRleHQgbGluZSBpcyBlbmRlZCB3aXRoIGFuIGhhcmQgYnJlYWtcbiAgICAgKiB0ZXh0IGFuZCBpdGV4dCBkbyBub3QgaGF2ZSB3cmFwcGluZywgcmV0dXJuIGZhbHNlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VuZE9mV3JhcHBpbmc6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgcmV0dXJuIGxpbmVJbmRleCA9PT0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aCAtIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGV4dCBvYmplY3RcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLlRleHQgKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArXG4gICAgICAgICcpOiB7IFwidGV4dFwiOiBcIicgKyB0aGlzLnRleHQgKyAnXCIsIFwiZm9udEZhbWlseVwiOiBcIicgKyB0aGlzLmZvbnRGYW1pbHkgKyAnXCIgfT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRpbWVuc2lvbiBhbmQgdGhlIHpvb20gbGV2ZWwgbmVlZGVkIHRvIGNyZWF0ZSBhIGNhY2hlIGNhbnZhc1xuICAgICAqIGJpZyBlbm91Z2ggdG8gaG9zdCB0aGUgb2JqZWN0IHRvIGJlIGNhY2hlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW0ueCB3aWR0aCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbS55IGhlaWdodCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fS53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWCB6b29tWCB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKi9cbiAgICBfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaW1zID0gdGhpcy5jYWxsU3VwZXIoJ19nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnMnKTtcbiAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZm9udFNpemU7XG4gICAgICBkaW1zLndpZHRoICs9IGZvbnRTaXplICogZGltcy56b29tWDtcbiAgICAgIGRpbXMuaGVpZ2h0ICs9IGZvbnRTaXplICogZGltcy56b29tWTtcbiAgICAgIHJldHVybiBkaW1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHRMaW5lc0JhY2tncm91bmQoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCwgJ3VuZGVybGluZScpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dChjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dERlY29yYXRpb24oY3R4LCAnb3ZlcmxpbmUnKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCwgJ2xpbmV0aHJvdWdoJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLnBhaW50Rmlyc3QgPT09ICdzdHJva2UnKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRTdHJva2UoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dEZpbGwoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0RmlsbChjdHgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0U3Ryb2tlKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZm9udCBwYXJhbWV0ZXIgb2YgdGhlIGNvbnRleHQgd2l0aCB0aGUgb2JqZWN0IHByb3BlcnRpZXMgb3Igd2l0aCBjaGFyU3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NoYXJTdHlsZV0gb2JqZWN0IHdpdGggZm9udCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGFyU3R5bGUuZm9udEZhbWlseV0gRm9udCBGYW1pbHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NoYXJTdHlsZS5mb250U2l6ZV0gRm9udCBzaXplIGluIHBpeGVscy4gKCB3aXRob3V0IHB4IHN1ZmZpeCApXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGFyU3R5bGUuZm9udFdlaWdodF0gRm9udCB3ZWlnaHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJTdHlsZS5mb250U3R5bGVdIEZvbnQgc3R5bGUgKGl0YWxpY3xub3JtYWwpXG4gICAgICovXG4gICAgX3NldFRleHRTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgY2hhclN0eWxlLCBmb3JNZWFzdXJpbmcpIHtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICBjdHguZm9udCA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihjaGFyU3R5bGUsIGZvck1lYXN1cmluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSB0ZXh0IFdpZHRoIG1lYXN1cmluZyBlYWNoIGxpbmUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBNYXhpbXVtIHdpZHRoIG9mIGZhYnJpYy5UZXh0IG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNUZXh0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoMCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgIG1heFdpZHRoID0gY3VycmVudExpbmVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1heFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTWV0aG9kIG5hbWUgKFwiZmlsbFRleHRcIiBvciBcInN0cm9rZVRleHRcIilcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmUgVGV4dCB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IHBvc2l0aW9uIG9mIHRleHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBwb3NpdGlvbiBvZiB0ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmUgaW4gYSB0ZXh0XG4gICAgICovXG4gICAgX3JlbmRlclRleHRMaW5lOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckNoYXJzKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHRleHQgYmFja2dyb3VuZCBmb3IgbGluZXMsIHRha2luZyBjYXJlIG9mIHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRMaW5lc0JhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgIXRoaXMuc3R5bGVIYXMoJ3RleHRCYWNrZ3JvdW5kQ29sb3InKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGluZVRvcE9mZnNldCA9IDAsIGhlaWdodE9mTGluZSxcbiAgICAgICAgICBsaW5lTGVmdE9mZnNldCwgb3JpZ2luYWxGaWxsID0gY3R4LmZpbGxTdHlsZSxcbiAgICAgICAgICBsaW5lLCBsYXN0Q29sb3IsXG4gICAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSxcbiAgICAgICAgICB0b3BPZmZzZXQgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKSxcbiAgICAgICAgICBib3hTdGFydCA9IDAsIGJveFdpZHRoID0gMCwgY2hhckJveCwgY3VycmVudENvbG9yO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgICBpZiAoIXRoaXMudGV4dEJhY2tncm91bmRDb2xvciAmJiAhdGhpcy5zdHlsZUhhcygndGV4dEJhY2tncm91bmRDb2xvcicsIGkpKSB7XG4gICAgICAgICAgbGluZVRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXTtcbiAgICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICBib3hTdGFydCA9IDA7XG4gICAgICAgIGxhc3RDb2xvciA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ3RleHRCYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgICBjdXJyZW50Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRDb2xvciAhPT0gbGFzdENvbG9yKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFzdENvbG9yO1xuICAgICAgICAgICAgbGFzdENvbG9yICYmIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICAgIHRvcE9mZnNldCArIGxpbmVUb3BPZmZzZXQsXG4gICAgICAgICAgICAgIGJveFdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBib3hTdGFydCA9IGNoYXJCb3gubGVmdDtcbiAgICAgICAgICAgIGJveFdpZHRoID0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICAgIGxhc3RDb2xvciA9IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENvbG9yKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBsZWZ0T2Zmc2V0ICsgbGluZUxlZnRPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICAgIHRvcE9mZnNldCArIGxpbmVUb3BPZmZzZXQsXG4gICAgICAgICAgICBib3hXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZVRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3JpZ2luYWxGaWxsO1xuICAgICAgLy8gaWYgdGhlcmUgaXMgdGV4dCBiYWNrZ3JvdW5kIGNvbG9yIG5vXG4gICAgICAvLyBvdGhlciBzaGFkb3dzIHNob3VsZCBiZSBjYXN0ZWRcbiAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWNsIHN0eWxlIGRlY2xhcmF0aW9uIGZvciBjYWNoZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWNsLmZvbnRGYW1pbHkgZm9udEZhbWlseVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWNsLmZvbnRTdHlsZSBmb250U3R5bGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250V2VpZ2h0IGZvbnRXZWlnaHRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlZmVyZW5jZSB0byBjYWNoZVxuICAgICAqL1xuICAgIGdldEZvbnRDYWNoZTogZnVuY3Rpb24oZGVjbCkge1xuICAgICAgdmFyIGZvbnRGYW1pbHkgPSBkZWNsLmZvbnRGYW1pbHkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSkge1xuICAgICAgICBmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldID0geyB9O1xuICAgICAgfVxuICAgICAgdmFyIGNhY2hlID0gZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSxcbiAgICAgICAgICBjYWNoZVByb3AgPSBkZWNsLmZvbnRTdHlsZS50b0xvd2VyQ2FzZSgpICsgJ18nICsgKGRlY2wuZm9udFdlaWdodCArICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCFjYWNoZVtjYWNoZVByb3BdKSB7XG4gICAgICAgIGNhY2hlW2NhY2hlUHJvcF0gPSB7IH07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVbY2FjaGVQcm9wXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYXBwbHkgYWxsIHRoZSBjaGFyYWN0ZXIgc3R5bGUgdG8gY2FudmFzIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBfY2hhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkZWNsXVxuICAgICAqL1xuICAgIF9hcHBseUNoYXJTdHlsZXM6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGVEZWNsYXJhdGlvbikge1xuXG4gICAgICB0aGlzLl9zZXRGaWxsU3R5bGVzKGN0eCwgc3R5bGVEZWNsYXJhdGlvbik7XG4gICAgICB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4LCBzdHlsZURlY2xhcmF0aW9uKTtcblxuICAgICAgY3R4LmZvbnQgPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24oc3R5bGVEZWNsYXJhdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1lYXN1cmUgYW5kIHJldHVybiB0aGUgd2lkdGggb2YgYSBzaW5nbGUgY2hhcmFjdGVyLlxuICAgICAqIHBvc3NpYmx5IG92ZXJyaWRkZW4gdG8gYWNjb21tb2RhdGUgZGlmZmVyZW50IG1lYXN1cmUgbG9naWMgb3JcbiAgICAgKiB0byBob29rIHNvbWUgZXh0ZXJuYWwgbGliIGZvciBjaGFyYWN0ZXIgbWVhc3VyZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFyIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYXJTdHlsZSBzdHlsZSBvZiBjaGFyIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcmV2aW91c0NoYXJdIHByZXZpb3VzIGNoYXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3ByZXZDaGFyU3R5bGVdIHN0eWxlIG9mIHByZXZpb3VzIGNoYXJcbiAgICAgKi9cbiAgICBfbWVhc3VyZUNoYXI6IGZ1bmN0aW9uKF9jaGFyLCBjaGFyU3R5bGUsIHByZXZpb3VzQ2hhciwgcHJldkNoYXJTdHlsZSkge1xuICAgICAgLy8gZmlyc3QgaSB0cnkgdG8gcmV0dXJuIGZyb20gY2FjaGVcbiAgICAgIHZhciBmb250Q2FjaGUgPSB0aGlzLmdldEZvbnRDYWNoZShjaGFyU3R5bGUpLCBmb250RGVjbGFyYXRpb24gPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24oY2hhclN0eWxlKSxcbiAgICAgICAgICBwcmV2aW91c0ZvbnREZWNsYXJhdGlvbiA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihwcmV2Q2hhclN0eWxlKSwgY291cGxlID0gcHJldmlvdXNDaGFyICsgX2NoYXIsXG4gICAgICAgICAgc3R5bGVzQXJlRXF1YWwgPSBmb250RGVjbGFyYXRpb24gPT09IHByZXZpb3VzRm9udERlY2xhcmF0aW9uLCB3aWR0aCwgY291cGxlV2lkdGgsIHByZXZpb3VzV2lkdGgsXG4gICAgICAgICAgZm9udE11bHRpcGxpZXIgPSBjaGFyU3R5bGUuZm9udFNpemUgLyB0aGlzLkNBQ0hFX0ZPTlRfU0laRSwga2VybmVkV2lkdGg7XG5cbiAgICAgIGlmIChwcmV2aW91c0NoYXIgJiYgZm9udENhY2hlW3ByZXZpb3VzQ2hhcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmV2aW91c1dpZHRoID0gZm9udENhY2hlW3ByZXZpb3VzQ2hhcl07XG4gICAgICB9XG4gICAgICBpZiAoZm9udENhY2hlW19jaGFyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtlcm5lZFdpZHRoID0gd2lkdGggPSBmb250Q2FjaGVbX2NoYXJdO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlc0FyZUVxdWFsICYmIGZvbnRDYWNoZVtjb3VwbGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY291cGxlV2lkdGggPSBmb250Q2FjaGVbY291cGxlXTtcbiAgICAgICAga2VybmVkV2lkdGggPSBjb3VwbGVXaWR0aCAtIHByZXZpb3VzV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCB8fCBwcmV2aW91c1dpZHRoID09PSB1bmRlZmluZWQgfHwgY291cGxlV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5nZXRNZWFzdXJpbmdDb250ZXh0KCk7XG4gICAgICAgIC8vIHNlbmQgYSBUUlVFIHRvIHNwZWNpZnkgbWVhc3VyaW5nIGZvbnQgc2l6ZSBDQUNIRV9GT05UX1NJWkVcbiAgICAgICAgdGhpcy5fc2V0VGV4dFN0eWxlcyhjdHgsIGNoYXJTdHlsZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXJuZWRXaWR0aCA9IHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KF9jaGFyKS53aWR0aDtcbiAgICAgICAgZm9udENhY2hlW19jaGFyXSA9IHdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZpb3VzV2lkdGggPT09IHVuZGVmaW5lZCAmJiBzdHlsZXNBcmVFcXVhbCAmJiBwcmV2aW91c0NoYXIpIHtcbiAgICAgICAgcHJldmlvdXNXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChwcmV2aW91c0NoYXIpLndpZHRoO1xuICAgICAgICBmb250Q2FjaGVbcHJldmlvdXNDaGFyXSA9IHByZXZpb3VzV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVzQXJlRXF1YWwgJiYgY291cGxlV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB3ZSBjYW4gbWVhc3VyZSB0aGUga2VybmluZyBjb3VwbGUgYW5kIHN1YnRyYWN0IHRoZSB3aWR0aCBvZiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyXG4gICAgICAgIGNvdXBsZVdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGNvdXBsZSkud2lkdGg7XG4gICAgICAgIGZvbnRDYWNoZVtjb3VwbGVdID0gY291cGxlV2lkdGg7XG4gICAgICAgIGtlcm5lZFdpZHRoID0gY291cGxlV2lkdGggLSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoICogZm9udE11bHRpcGxpZXIsIGtlcm5lZFdpZHRoOiBrZXJuZWRXaWR0aCAqIGZvbnRNdWx0aXBsaWVyIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGhlaWdodCBvZiBjaGFyYWN0ZXIgYXQgZ2l2ZW4gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZSB0aGUgbGluZSBudW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhciB0aGUgY2hhcmFjdGVyIG51bWJlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gZm9udFNpemUgb2YgdGhlIGNoYXJhY3RlclxuICAgICAqL1xuICAgIGdldEhlaWdodE9mQ2hhcjogZnVuY3Rpb24obGluZSwgY2hhcikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZSwgY2hhciwgJ2ZvbnRTaXplJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1lYXN1cmUgYSB0ZXh0IGxpbmUgbWVhc3VyaW5nIGFsbCBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggbGluZSBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgd2lkdGhcbiAgICAgKi9cbiAgICBtZWFzdXJlTGluZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZUluZm8gPSB0aGlzLl9tZWFzdXJlTGluZShsaW5lSW5kZXgpO1xuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgbGluZUluZm8ud2lkdGggLT0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAobGluZUluZm8ud2lkdGggPCAwKSB7XG4gICAgICAgIGxpbmVJbmZvLndpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lSW5mbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbWVhc3VyZSBldmVyeSBncmFwaGVtZSBvZiBhIGxpbmUsIHBvcHVsYXRpbmcgX19jaGFyQm91bmRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LndpZHRoIHRvdGFsIHdpZHRoIG9mIGNoYXJhY3RlcnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aE9mU3BhY2VzIGxlbmd0aCBvZiBjaGFycyB0aGF0IG1hdGNoIHRoaXMuX3JlU3BhY2VzQW5kVGFic1xuICAgICAqL1xuICAgIF9tZWFzdXJlTGluZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgd2lkdGggPSAwLCBpLCBncmFwaGVtZSwgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLCBwcmV2R3JhcGhlbWUsXG4gICAgICAgICAgZ3JhcGhlbWVJbmZvLCBudW1PZlNwYWNlcyA9IDAsIGxpbmVCb3VuZHMgPSBuZXcgQXJyYXkobGluZS5sZW5ndGgpO1xuXG4gICAgICB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdID0gbGluZUJvdW5kcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyYXBoZW1lID0gbGluZVtpXTtcbiAgICAgICAgZ3JhcGhlbWVJbmZvID0gdGhpcy5fZ2V0R3JhcGhlbWVCb3goZ3JhcGhlbWUsIGxpbmVJbmRleCwgaSwgcHJldkdyYXBoZW1lKTtcbiAgICAgICAgbGluZUJvdW5kc1tpXSA9IGdyYXBoZW1lSW5mbztcbiAgICAgICAgd2lkdGggKz0gZ3JhcGhlbWVJbmZvLmtlcm5lZFdpZHRoO1xuICAgICAgICBwcmV2R3JhcGhlbWUgPSBncmFwaGVtZTtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMgbGF0ZXN0IGJvdW5kIGJveCByZXByZXNlbnQgdGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoZSBsaW5lXG4gICAgICAvLyB0byBzaW1wbGlmeSBjdXJzb3IgaGFuZGxpbmcgaW4gaW50ZXJhY3RpdmUgbW9kZS5cbiAgICAgIGxpbmVCb3VuZHNbaV0gPSB7XG4gICAgICAgIGxlZnQ6IGdyYXBoZW1lSW5mbyA/IGdyYXBoZW1lSW5mby5sZWZ0ICsgZ3JhcGhlbWVJbmZvLndpZHRoIDogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGtlcm5lZFdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuZm9udFNpemVcbiAgICAgIH07XG4gICAgICByZXR1cm4geyB3aWR0aDogd2lkdGgsIG51bU9mU3BhY2VzOiBudW1PZlNwYWNlcyB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlIGFuZCByZXR1cm4gdGhlIGluZm8gb2YgYSBzaW5nbGUgZ3JhcGhlbWUuXG4gICAgICogbmVlZHMgdGhlIHRoZSBpbmZvIG9mIHByZXZpb3VzIGdyYXBoZW1lcyBhbHJlYWR5IGZpbGxlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyYXBoZW1lIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCBvZiB0aGUgbGluZSB3aGVyZSB0aGUgY2hhciBpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggcG9zaXRpb24gaW4gdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3ByZXZHcmFwaGVtZV0gY2hhcmFjdGVyIHByZWNlZGluZyB0aGUgb25lIHRvIGJlIG1lYXN1cmVkXG4gICAgICovXG4gICAgX2dldEdyYXBoZW1lQm94OiBmdW5jdGlvbihncmFwaGVtZSwgbGluZUluZGV4LCBjaGFySW5kZXgsIHByZXZHcmFwaGVtZSwgc2tpcExlZnQpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgICBwcmV2U3R5bGUgPSBwcmV2R3JhcGhlbWUgPyB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCAtIDEpIDogeyB9LFxuICAgICAgICAgIGluZm8gPSB0aGlzLl9tZWFzdXJlQ2hhcihncmFwaGVtZSwgc3R5bGUsIHByZXZHcmFwaGVtZSwgcHJldlN0eWxlKSxcbiAgICAgICAgICBrZXJuZWRXaWR0aCA9IGluZm8ua2VybmVkV2lkdGgsXG4gICAgICAgICAgd2lkdGggPSBpbmZvLndpZHRoLCBjaGFyU3BhY2luZztcblxuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgY2hhclNwYWNpbmcgPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgICAgd2lkdGggKz0gY2hhclNwYWNpbmc7XG4gICAgICAgIGtlcm5lZFdpZHRoICs9IGNoYXJTcGFjaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm94ID0ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGhlaWdodDogc3R5bGUuZm9udFNpemUsXG4gICAgICAgIGtlcm5lZFdpZHRoOiBrZXJuZWRXaWR0aCxcbiAgICAgICAgZGVsdGFZOiBzdHlsZS5kZWx0YVksXG4gICAgICB9O1xuICAgICAgaWYgKGNoYXJJbmRleCA+IDAgJiYgIXNraXBMZWZ0KSB7XG4gICAgICAgIHZhciBwcmV2aW91c0JveCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4IC0gMV07XG4gICAgICAgIGJveC5sZWZ0ID0gcHJldmlvdXNCb3gubGVmdCArIHByZXZpb3VzQm94LndpZHRoICsgaW5mby5rZXJuZWRXaWR0aCAtIGluZm8ud2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm94O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgaGVpZ2h0IG9mIGxpbmUgYXQgJ2xpbmVJbmRleCdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGluZGV4IG9mIGxpbmUgdG8gY2FsY3VsYXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEhlaWdodE9mTGluZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fX2xpbmVIZWlnaHRzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIC8vIGNoYXIgMCBpcyBtZWFzdXJlZCBiZWZvcmUgdGhlIGxpbmUgY3ljbGUgYmVjYXVzZSBpdCBubmVkcyB0byBjaGFyXG4gICAgICAgICAgLy8gZW1wdHlsaW5lc1xuICAgICAgICAgIG1heEhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGxpbmVJbmRleCwgMCk7XG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gbGluZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heCh0aGlzLmdldEhlaWdodE9mQ2hhcihsaW5lSW5kZXgsIGkpLCBtYXhIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2xpbmVIZWlnaHRzW2xpbmVJbmRleF0gPSBtYXhIZWlnaHQgKiB0aGlzLmxpbmVIZWlnaHQgKiB0aGlzLl9mb250U2l6ZU11bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0ZXh0IGJveCBoZWlnaHRcbiAgICAgKi9cbiAgICBjYWxjVGV4dEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUhlaWdodCwgaGVpZ2h0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgICBoZWlnaHQgKz0gKGkgPT09IGxlbiAtIDEgPyBsaW5lSGVpZ2h0IC8gdGhpcy5saW5lSGVpZ2h0IDogbGluZUhlaWdodCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGVmdCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0TGVmdE9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gLXRoaXMud2lkdGggLyAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVG9wIG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRUb3BPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC10aGlzLmhlaWdodCAvIDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTWV0aG9kIG5hbWUgKFwiZmlsbFRleHRcIiBvciBcInN0cm9rZVRleHRcIilcbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dENvbW1vbjogZnVuY3Rpb24oY3R4LCBtZXRob2QpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgbGluZUhlaWdodHMgPSAwLCBsZWZ0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLCB0b3AgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKSxcbiAgICAgICAgICBvZmZzZXRzID0gdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0oY3R4LCBtZXRob2QgPT09ICdmaWxsVGV4dCcgPyB0aGlzLmZpbGwgOiB0aGlzLnN0cm9rZSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKSxcbiAgICAgICAgICAgIG1heEhlaWdodCA9IGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dExpbmUoXG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgICB0aGlzLl90ZXh0TGluZXNbaV0sXG4gICAgICAgICAgbGVmdCArIGxlZnRPZmZzZXQgLSBvZmZzZXRzLm9mZnNldFgsXG4gICAgICAgICAgdG9wICsgbGluZUhlaWdodHMgKyBtYXhIZWlnaHQgLSBvZmZzZXRzLm9mZnNldFksXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICBsaW5lSGVpZ2h0cyArPSBoZWlnaHRPZkxpbmU7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dEZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmZpbGwgJiYgIXRoaXMuc3R5bGVIYXMoJ2ZpbGwnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlbmRlclRleHRDb21tb24oY3R4LCAnZmlsbFRleHQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCghdGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkgJiYgdGhpcy5pc0VtcHR5U3R5bGVzKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaGFkb3cgJiYgIXRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSkge1xuICAgICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dENvbW1vbihjdHgsICdzdHJva2VUZXh0Jyk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmUgQ29udGVudCBvZiB0aGUgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhck9mZnNldFxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyczogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KSB7XG4gICAgICAvLyBzZXQgcHJvcGVyIGxpbmUgb2Zmc2V0XG4gICAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGxpbmVJbmRleCksXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBhY3R1YWxTdHlsZSxcbiAgICAgICAgICBuZXh0U3R5bGUsXG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnLFxuICAgICAgICAgIGNoYXJCb3gsXG4gICAgICAgICAgYm94V2lkdGggPSAwLFxuICAgICAgICAgIHRpbWVUb1JlbmRlcixcbiAgICAgICAgICBzaG9ydEN1dCA9ICFpc0p1c3RpZnkgJiYgdGhpcy5jaGFyU3BhY2luZyA9PT0gMCAmJiB0aGlzLmlzRW1wdHlTdHlsZXMobGluZUluZGV4KTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRvcCAtPSBsaW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVGcmFjdGlvbiAvIHRoaXMubGluZUhlaWdodDtcbiAgICAgIGlmIChzaG9ydEN1dCkge1xuICAgICAgICAvLyByZW5kZXIgYWxsIHRoZSBsaW5lIGluIG9uZSBwYXNzIHdpdGhvdXQgY2hlY2tpbmdcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2hhcihtZXRob2QsIGN0eCwgbGluZUluZGV4LCAwLCB0aGlzLnRleHRMaW5lc1tsaW5lSW5kZXhdLCBsZWZ0LCB0b3AsIGxpbmVIZWlnaHQpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZS5sZW5ndGggLSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHRpbWVUb1JlbmRlciA9IGkgPT09IGxlbiB8fCB0aGlzLmNoYXJTcGFjaW5nO1xuICAgICAgICBjaGFyc1RvUmVuZGVyICs9IGxpbmVbaV07XG4gICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2ldO1xuICAgICAgICBpZiAoYm94V2lkdGggPT09IDApIHtcbiAgICAgICAgICBsZWZ0ICs9IGNoYXJCb3gua2VybmVkV2lkdGggLSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNKdXN0aWZ5ICYmICF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcmVTcGFjZUFuZFRhYi50ZXN0KGxpbmVbaV0pKSB7XG4gICAgICAgICAgICB0aW1lVG9SZW5kZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIC8vIGlmIHdlIGhhdmUgY2hhclNwYWNpbmcsIHdlIHJlbmRlciBjaGFyIGJ5IGNoYXJcbiAgICAgICAgICBhY3R1YWxTdHlsZSA9IGFjdHVhbFN0eWxlIHx8IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSk7XG4gICAgICAgICAgbmV4dFN0eWxlID0gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpICsgMSk7XG4gICAgICAgICAgdGltZVRvUmVuZGVyID0gdGhpcy5faGFzU3R5bGVDaGFuZ2VkKGFjdHVhbFN0eWxlLCBuZXh0U3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGksIGNoYXJzVG9SZW5kZXIsIGxlZnQsIHRvcCwgbGluZUhlaWdodCk7XG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnO1xuICAgICAgICAgIGFjdHVhbFN0eWxlID0gbmV4dFN0eWxlO1xuICAgICAgICAgIGxlZnQgKz0gYm94V2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gX2NoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVIZWlnaHQgSGVpZ2h0IG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgX3JlbmRlckNoYXI6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGNoYXJJbmRleCwgX2NoYXIsIGxlZnQsIHRvcCkge1xuICAgICAgdmFyIGRlY2wgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgICBmdWxsRGVjbCA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgICBzaG91bGRGaWxsID0gbWV0aG9kID09PSAnZmlsbFRleHQnICYmIGZ1bGxEZWNsLmZpbGwsXG4gICAgICAgICAgc2hvdWxkU3Ryb2tlID0gbWV0aG9kID09PSAnc3Ryb2tlVGV4dCcgJiYgZnVsbERlY2wuc3Ryb2tlICYmIGZ1bGxEZWNsLnN0cm9rZVdpZHRoO1xuXG4gICAgICBpZiAoIXNob3VsZFN0cm9rZSAmJiAhc2hvdWxkRmlsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWNsICYmIGN0eC5zYXZlKCk7XG5cbiAgICAgIHRoaXMuX2FwcGx5Q2hhclN0eWxlcyhtZXRob2QsIGN0eCwgbGluZUluZGV4LCBjaGFySW5kZXgsIGZ1bGxEZWNsKTtcblxuICAgICAgaWYgKGRlY2wgJiYgZGVjbC50ZXh0QmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuICAgICAgaWYgKGRlY2wgJiYgZGVjbC5kZWx0YVkpIHtcbiAgICAgICAgdG9wICs9IGRlY2wuZGVsdGFZO1xuICAgICAgfVxuXG4gICAgICBzaG91bGRGaWxsICYmIGN0eC5maWxsVGV4dChfY2hhciwgbGVmdCwgdG9wKTtcbiAgICAgIHNob3VsZFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dChfY2hhciwgbGVmdCwgdG9wKTtcbiAgICAgIGRlY2wgJiYgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybnMgdGhlIGNoYXJhY3RlciBpbnRvIGEgJ3N1cGVyaW9yIGZpZ3VyZScgKGkuZS4gJ3N1cGVyc2NyaXB0JylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgc2VsZWN0aW9uIHN0YXJ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBzZWxlY3Rpb24gZW5kXG4gICAgICogQHJldHVybnMge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFN1cGVyc2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0U2NyaXB0KHN0YXJ0LCBlbmQsIHRoaXMuc3VwZXJzY3JpcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUdXJucyB0aGUgY2hhcmFjdGVyIGludG8gYW4gJ2luZmVyaW9yIGZpZ3VyZScgKGkuZS4gJ3N1YnNjcmlwdCcpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTdWJzY3JpcHQ6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRTY3JpcHQoc3RhcnQsIGVuZCwgdGhpcy5zdWJzY3JpcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzICdzY2hlbWEnIGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgc2VsZWN0aW9uIHN0YXJ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBzZWxlY3Rpb24gZW5kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjaGVtYVxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfc2V0U2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kLCBzY2hlbWEpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc3RhcnQsIHRydWUpLFxuICAgICAgICAgIGZvbnRTaXplID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4LCAnZm9udFNpemUnKSxcbiAgICAgICAgICBkeSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwgJ2RlbHRhWScpLFxuICAgICAgICAgIHN0eWxlID0geyBmb250U2l6ZTogZm9udFNpemUgKiBzY2hlbWEuc2l6ZSwgZGVsdGFZOiBkeSArIGZvbnRTaXplICogc2NoZW1hLmJhc2VsaW5lIH07XG4gICAgICB0aGlzLnNldFNlbGVjdGlvblN0eWxlcyhzdHlsZSwgc3RhcnQsIGVuZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJldlN0eWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRoaXNTdHlsZVxuICAgICAqL1xuICAgIF9oYXNTdHlsZUNoYW5nZWQ6IGZ1bmN0aW9uKHByZXZTdHlsZSwgdGhpc1N0eWxlKSB7XG4gICAgICByZXR1cm4gcHJldlN0eWxlLmZpbGwgIT09IHRoaXNTdHlsZS5maWxsIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5zdHJva2UgIT09IHRoaXNTdHlsZS5zdHJva2UgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLnN0cm9rZVdpZHRoICE9PSB0aGlzU3R5bGUuc3Ryb2tlV2lkdGggfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRTaXplICE9PSB0aGlzU3R5bGUuZm9udFNpemUgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRGYW1pbHkgIT09IHRoaXNTdHlsZS5mb250RmFtaWx5IHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250V2VpZ2h0ICE9PSB0aGlzU3R5bGUuZm9udFdlaWdodCB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udFN0eWxlICE9PSB0aGlzU3R5bGUuZm9udFN0eWxlIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5kZWx0YVkgIT09IHRoaXNTdHlsZS5kZWx0YVk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzU3R5bGVcbiAgICAgKi9cbiAgICBfaGFzU3R5bGVDaGFuZ2VkRm9yU3ZnOiBmdW5jdGlvbihwcmV2U3R5bGUsIHRoaXNTdHlsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1N0eWxlQ2hhbmdlZChwcmV2U3R5bGUsIHRoaXNTdHlsZSkgfHxcbiAgICAgICAgcHJldlN0eWxlLm92ZXJsaW5lICE9PSB0aGlzU3R5bGUub3ZlcmxpbmUgfHxcbiAgICAgICAgcHJldlN0eWxlLnVuZGVybGluZSAhPT0gdGhpc1N0eWxlLnVuZGVybGluZSB8fFxuICAgICAgICBwcmV2U3R5bGUubGluZXRocm91Z2ggIT09IHRoaXNTdHlsZS5saW5ldGhyb3VnaDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGluZGV4IHRleHQgbGluZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGluZSBsZWZ0IG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRMaW5lTGVmdE9mZnNldDogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgobGluZUluZGV4KTtcbiAgICAgIGlmICh0aGlzLnRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoIC0gbGluZVdpZHRoKSAvIDI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggLSBsaW5lV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LWNlbnRlcicgJiYgdGhpcy5pc0VuZE9mV3JhcHBpbmcobGluZUluZGV4KSkge1xuICAgICAgICByZXR1cm4gKHRoaXMud2lkdGggLSBsaW5lV2lkdGgpIC8gMjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHRBbGlnbiA9PT0gJ2p1c3RpZnktcmlnaHQnICYmIHRoaXMuaXNFbmRPZldyYXBwaW5nKGxpbmVJbmRleCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggLSBsaW5lV2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xlYXJDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9fbGluZVdpZHRocyA9IFtdO1xuICAgICAgdGhpcy5fX2xpbmVIZWlnaHRzID0gW107XG4gICAgICB0aGlzLl9fY2hhckJvdW5kcyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzaG91bGRDbGVhciA9IHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZTtcbiAgICAgIHNob3VsZENsZWFyIHx8IChzaG91bGRDbGVhciA9IHRoaXMuaGFzU3RhdGVDaGFuZ2VkKCdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnKSk7XG4gICAgICBpZiAoc2hvdWxkQ2xlYXIpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNob3VsZENsZWFyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlIGEgc2luZ2xlIGxpbmUgZ2l2ZW4gaXRzIGluZGV4LiBVc2VkIHRvIGNhbGN1bGF0ZSB0aGUgaW5pdGlhbFxuICAgICAqIHRleHQgYm91bmRpbmcgYm94LiBUaGUgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGFuZCBzdG9yZWQgaW4gX19saW5lV2lkdGhzIGNhY2hlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBsaW5lIG51bWJlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGluZSB3aWR0aFxuICAgICAqL1xuICAgIGdldExpbmVXaWR0aDogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoLCBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sIGxpbmVJbmZvO1xuXG4gICAgICBpZiAobGluZSA9PT0gJycpIHtcbiAgICAgICAgd2lkdGggPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxpbmVJbmZvID0gdGhpcy5tZWFzdXJlTGluZShsaW5lSW5kZXgpO1xuICAgICAgICB3aWR0aCA9IGxpbmVJbmZvLndpZHRoO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XSA9IHdpZHRoO1xuICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICBfZ2V0V2lkdGhPZkNoYXJTcGFjaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbnRTaXplICogdGhpcy5jaGFyU3BhY2luZyAvIDEwMDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eSBhdCBnaXZlbiBjaGFyYWN0ZXIgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRoZSBsaW5lIG51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggdGhlIGNoYXJhdGVyIG51bWJlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSB0aGUgcHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBvZiAncHJvcGVydHknXG4gICAgICovXG4gICAgZ2V0VmFsdWVPZlByb3BlcnR5QXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIGNoYXJTdHlsZSA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXgpO1xuICAgICAgaWYgKGNoYXJTdHlsZSAmJiB0eXBlb2YgY2hhclN0eWxlW3Byb3BlcnR5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJTdHlsZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1twcm9wZXJ0eV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0RGVjb3JhdGlvbjogZnVuY3Rpb24oY3R4LCB0eXBlKSB7XG4gICAgICBpZiAoIXRoaXNbdHlwZV0gJiYgIXRoaXMuc3R5bGVIYXModHlwZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhlaWdodE9mTGluZSwgc2l6ZSwgX3NpemUsXG4gICAgICAgICAgbGluZUxlZnRPZmZzZXQsIGR5LCBfZHksXG4gICAgICAgICAgbGluZSwgbGFzdERlY29yYXRpb24sXG4gICAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSxcbiAgICAgICAgICB0b3BPZmZzZXQgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKSwgdG9wLFxuICAgICAgICAgIGJveFN0YXJ0LCBib3hXaWR0aCwgY2hhckJveCwgY3VycmVudERlY29yYXRpb24sXG4gICAgICAgICAgbWF4SGVpZ2h0LCBjdXJyZW50RmlsbCwgbGFzdEZpbGwsXG4gICAgICAgICAgY2hhclNwYWNpbmcgPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaWYgKCF0aGlzW3R5cGVdICYmICF0aGlzLnN0eWxlSGFzKHR5cGUsIGkpKSB7XG4gICAgICAgICAgdG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGJveFN0YXJ0ID0gMDtcbiAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICBsYXN0RGVjb3JhdGlvbiA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgdHlwZSk7XG4gICAgICAgIGxhc3RGaWxsID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCAnZmlsbCcpO1xuICAgICAgICB0b3AgPSB0b3BPZmZzZXQgKyBtYXhIZWlnaHQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pO1xuICAgICAgICBzaXplID0gdGhpcy5nZXRIZWlnaHRPZkNoYXIoaSwgMCk7XG4gICAgICAgIGR5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCAnZGVsdGFZJyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgICAgY3VycmVudERlY29yYXRpb24gPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosIHR5cGUpO1xuICAgICAgICAgIGN1cnJlbnRGaWxsID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAnZmlsbCcpO1xuICAgICAgICAgIF9zaXplID0gdGhpcy5nZXRIZWlnaHRPZkNoYXIoaSwgaik7XG4gICAgICAgICAgX2R5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAnZGVsdGFZJyk7XG4gICAgICAgICAgaWYgKChjdXJyZW50RGVjb3JhdGlvbiAhPT0gbGFzdERlY29yYXRpb24gfHwgY3VycmVudEZpbGwgIT09IGxhc3RGaWxsIHx8IF9zaXplICE9PSBzaXplIHx8IF9keSAhPT0gZHkpICYmXG4gICAgICAgICAgICAgIGJveFdpZHRoID4gMCkge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhc3RGaWxsO1xuICAgICAgICAgICAgbGFzdERlY29yYXRpb24gJiYgbGFzdEZpbGwgJiYgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICBsZWZ0T2Zmc2V0ICsgbGluZUxlZnRPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICAgICAgdG9wICsgdGhpcy5vZmZzZXRzW3R5cGVdICogc2l6ZSArIGR5LFxuICAgICAgICAgICAgICBib3hXaWR0aCxcbiAgICAgICAgICAgICAgdGhpcy5mb250U2l6ZSAvIDE1XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYm94U3RhcnQgPSBjaGFyQm94LmxlZnQ7XG4gICAgICAgICAgICBib3hXaWR0aCA9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgICBsYXN0RGVjb3JhdGlvbiA9IGN1cnJlbnREZWNvcmF0aW9uO1xuICAgICAgICAgICAgbGFzdEZpbGwgPSBjdXJyZW50RmlsbDtcbiAgICAgICAgICAgIHNpemUgPSBfc2l6ZTtcbiAgICAgICAgICAgIGR5ID0gX2R5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdXJyZW50RmlsbDtcbiAgICAgICAgY3VycmVudERlY29yYXRpb24gJiYgY3VycmVudEZpbGwgJiYgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgIHRvcCArIHRoaXMub2Zmc2V0c1t0eXBlXSAqIHNpemUgKyBkeSxcbiAgICAgICAgICBib3hXaWR0aCAtIGNoYXJTcGFjaW5nLFxuICAgICAgICAgIHRoaXMuZm9udFNpemUgLyAxNVxuICAgICAgICApO1xuICAgICAgICB0b3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlcmUgaXMgdGV4dCBiYWNrZ3JvdW5kIGNvbG9yIG5vXG4gICAgICAvLyBvdGhlciBzaGFkb3dzIHNob3VsZCBiZSBjYXN0ZWRcbiAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gZm9udCBkZWNsYXJhdGlvbiBzdHJpbmcgZm9yIGNhbnZhcyBjb250ZXh0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZU9iamVjdF0gb2JqZWN0XG4gICAgICogQHJldHVybnMge1N0cmluZ30gZm9udCBkZWNsYXJhdGlvbiBmb3JtYXR0ZWQgZm9yIGNhbnZhcyBjb250ZXh0LlxuICAgICAqL1xuICAgIF9nZXRGb250RGVjbGFyYXRpb246IGZ1bmN0aW9uKHN0eWxlT2JqZWN0LCBmb3JNZWFzdXJpbmcpIHtcbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlT2JqZWN0IHx8IHRoaXMsIGZhbWlseSA9IHRoaXMuZm9udEZhbWlseSxcbiAgICAgICAgICBmb250SXNHZW5lcmljID0gZmFicmljLlRleHQuZ2VuZXJpY0ZvbnRzLmluZGV4T2YoZmFtaWx5LnRvTG93ZXJDYXNlKCkpID4gLTE7XG4gICAgICB2YXIgZm9udEZhbWlseSA9IGZhbWlseSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBmYW1pbHkuaW5kZXhPZignXFwnJykgPiAtMSB8fFxuICAgICAgZmFtaWx5LmluZGV4T2YoJ1wiJykgPiAtMSB8fCBmb250SXNHZW5lcmljXG4gICAgICAgID8gc3R5bGUuZm9udEZhbWlseSA6ICdcIicgKyBzdHlsZS5mb250RmFtaWx5ICsgJ1wiJztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC8vIG5vZGUtY2FudmFzIG5lZWRzIFwid2VpZ2h0IHN0eWxlXCIsIHdoaWxlIGJyb3dzZXJzIG5lZWQgXCJzdHlsZSB3ZWlnaHRcIlxuICAgICAgICAoZmFicmljLmlzTGlrZWx5Tm9kZSA/IHN0eWxlLmZvbnRXZWlnaHQgOiBzdHlsZS5mb250U3R5bGUpLFxuICAgICAgICAoZmFicmljLmlzTGlrZWx5Tm9kZSA/IHN0eWxlLmZvbnRTdHlsZSA6IHN0eWxlLmZvbnRXZWlnaHQpLFxuICAgICAgICBmb3JNZWFzdXJpbmcgPyB0aGlzLkNBQ0hFX0ZPTlRfU0laRSArICdweCcgOiBzdHlsZS5mb250U2l6ZSArICdweCcsXG4gICAgICAgIGZvbnRGYW1pbHlcbiAgICAgIF0uam9pbignICcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRleHQgaW5zdGFuY2Ugb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgLy8gZG8gbm90IHJlbmRlciBpZiBvYmplY3QgaXMgbm90IHZpc2libGVcbiAgICAgIGlmICghdGhpcy52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5za2lwT2Zmc2NyZWVuICYmICF0aGlzLmdyb3VwICYmICF0aGlzLmlzT25TY3JlZW4oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdyZW5kZXInLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZXh0IGFzIGFuIGFycmF5IG9mIGxpbmVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRleHQgdG8gc3BsaXRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IExpbmVzIGluIHRoZSB0ZXh0XG4gICAgICovXG4gICAgX3NwbGl0VGV4dEludG9MaW5lczogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCh0aGlzLl9yZU5ld2xpbmUpLFxuICAgICAgICAgIG5ld0xpbmVzID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCksXG4gICAgICAgICAgbmV3TGluZSA9IFsnXFxuJ10sXG4gICAgICAgICAgbmV3VGV4dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdMaW5lc1tpXSA9IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KGxpbmVzW2ldKTtcbiAgICAgICAgbmV3VGV4dCA9IG5ld1RleHQuY29uY2F0KG5ld0xpbmVzW2ldLCBuZXdMaW5lKTtcbiAgICAgIH1cbiAgICAgIG5ld1RleHQucG9wKCk7XG4gICAgICByZXR1cm4geyBfdW53cmFwcGVkTGluZXM6IG5ld0xpbmVzLCBsaW5lczogbGluZXMsIGdyYXBoZW1lVGV4dDogbmV3VGV4dCwgZ3JhcGhlbWVMaW5lczogbmV3TGluZXMgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gW1xuICAgICAgICAndGV4dCcsXG4gICAgICAgICdmb250U2l6ZScsXG4gICAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgICAnZm9udFN0eWxlJyxcbiAgICAgICAgJ2xpbmVIZWlnaHQnLFxuICAgICAgICAndW5kZXJsaW5lJyxcbiAgICAgICAgJ292ZXJsaW5lJyxcbiAgICAgICAgJ2xpbmV0aHJvdWdoJyxcbiAgICAgICAgJ3RleHRBbGlnbicsXG4gICAgICAgICd0ZXh0QmFja2dyb3VuZENvbG9yJyxcbiAgICAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgIF0uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgdmFyIG9iaiA9IHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzKTtcbiAgICAgIG9iai5zdHlsZXMgPSBjbG9uZSh0aGlzLnN0eWxlcywgdHJ1ZSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHByb3BlcnR5IHRvIGEgZ2l2ZW4gdmFsdWUuIFdoZW4gY2hhbmdpbmcgcG9zaXRpb24vZGltZW5zaW9uIC1yZWxhdGVkIHByb3BlcnRpZXMgKGxlZnQsIHRvcCwgc2NhbGUsIGFuZ2xlLCBldGMuKSBgc2V0YCBkb2VzIG5vdCB1cGRhdGUgcG9zaXRpb24gb2Ygb2JqZWN0J3MgYm9yZGVycy9jb250cm9scy4gSWYgeW91IG5lZWQgdG8gdXBkYXRlIHRob3NlLCBjYWxsIGBzZXRDb29yZHMoKWAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBrZXkgUHJvcGVydHkgbmFtZSBvciBvYmplY3QgKGlmIG9iamVjdCwgaXRlcmF0ZSBvdmVyIHRoZSBvYmplY3QgcHJvcGVydGllcylcbiAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgKGlmIGZ1bmN0aW9uLCB0aGUgdmFsdWUgaXMgcGFzc2VkIGludG8gaXQgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBhcyBhIG5ldyBvbmUpXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdzZXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIHZhciBuZWVkc0RpbXMgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBfa2V5IGluIGtleSkge1xuICAgICAgICAgIG5lZWRzRGltcyA9IG5lZWRzRGltcyB8fCB0aGlzLl9kaW1lbnNpb25BZmZlY3RpbmdQcm9wcy5pbmRleE9mKF9rZXkpICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5lZWRzRGltcyA9IHRoaXMuX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gICAgICB9XG4gICAgICBpZiAobmVlZHNEaW1zKSB7XG4gICAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuVGV4dC5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqIEBzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy90ZXh0Lmh0bWwjVGV4dEVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5UZXh0LkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoXG4gICAgJ3ggeSBkeCBkeSBmb250LWZhbWlseSBmb250LXN0eWxlIGZvbnQtd2VpZ2h0IGZvbnQtc2l6ZSBsZXR0ZXItc3BhY2luZyB0ZXh0LWRlY29yYXRpb24gdGV4dC1hbmNob3InLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IFNWRyBmb250IHNpemVcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICovXG4gIGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRSA9IDE2O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnQgKDxiPm5vdCB5ZXQgaW1wbGVtZW50ZWQ8L2I+KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIHBhcnNpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLlRleHQuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuVGV4dC5BVFRSSUJVVEVfTkFNRVMpLFxuICAgICAgICBwYXJzZWRBbmNob3IgPSBwYXJzZWRBdHRyaWJ1dGVzLnRleHRBbmNob3IgfHwgJ2xlZnQnO1xuICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKChvcHRpb25zID8gY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKTtcblxuICAgIG9wdGlvbnMudG9wID0gb3B0aW9ucy50b3AgfHwgMDtcbiAgICBvcHRpb25zLmxlZnQgPSBvcHRpb25zLmxlZnQgfHwgMDtcbiAgICBpZiAocGFyc2VkQXR0cmlidXRlcy50ZXh0RGVjb3JhdGlvbikge1xuICAgICAgdmFyIHRleHREZWNvcmF0aW9uID0gcGFyc2VkQXR0cmlidXRlcy50ZXh0RGVjb3JhdGlvbjtcbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCd1bmRlcmxpbmUnKSAhPT0gLTEpIHtcbiAgICAgICAgb3B0aW9ucy51bmRlcmxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRleHREZWNvcmF0aW9uLmluZGV4T2YoJ292ZXJsaW5lJykgIT09IC0xKSB7XG4gICAgICAgIG9wdGlvbnMub3ZlcmxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRleHREZWNvcmF0aW9uLmluZGV4T2YoJ2xpbmUtdGhyb3VnaCcpICE9PSAtMSkge1xuICAgICAgICBvcHRpb25zLmxpbmV0aHJvdWdoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBvcHRpb25zLnRleHREZWNvcmF0aW9uO1xuICAgIH1cbiAgICBpZiAoJ2R4JyBpbiBwYXJzZWRBdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLmxlZnQgKz0gcGFyc2VkQXR0cmlidXRlcy5keDtcbiAgICB9XG4gICAgaWYgKCdkeScgaW4gcGFyc2VkQXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy50b3AgKz0gcGFyc2VkQXR0cmlidXRlcy5keTtcbiAgICB9XG4gICAgaWYgKCEoJ2ZvbnRTaXplJyBpbiBvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5mb250U2l6ZSA9IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dENvbnRlbnQgPSAnJztcblxuICAgIC8vIFRoZSBYTUwgaXMgbm90IHByb3Blcmx5IHBhcnNlZCBpbiBJRTkgc28gYSB3b3JrYXJvdW5kIHRvIGdldFxuICAgIC8vIHRleHRDb250ZW50IGlzIHRocm91Z2ggZmlyc3RDaGlsZC5kYXRhLiBBbm90aGVyIHdvcmthcm91bmQgd291bGQgYmVcbiAgICAvLyB0byBjb252ZXJ0IFhNTCBsb2FkZWQgZnJvbSBhIGZpbGUgdG8gYmUgY29udmVydGVkIHVzaW5nIERPTVBhcnNlciAoc2FtZSB3YXkgbG9hZFNWR0Zyb21TdHJpbmcoKSBkb2VzKVxuICAgIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZWxlbWVudCkpIHtcbiAgICAgIGlmICgnZmlyc3RDaGlsZCcgaW4gZWxlbWVudCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCdkYXRhJyBpbiBlbGVtZW50LmZpcnN0Q2hpbGQgJiYgZWxlbWVudC5maXJzdENoaWxkLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICB0ZXh0Q29udGVudCA9IGVsZW1lbnQuZmlyc3RDaGlsZC5kYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGV4dENvbnRlbnQgPSBlbGVtZW50LnRleHRDb250ZW50O1xuICAgIH1cblxuICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQucmVwbGFjZSgvXlxccyt8XFxzKyR8XFxuKy9nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgIHZhciBvcmlnaW5hbFN0cm9rZVdpZHRoID0gb3B0aW9ucy5zdHJva2VXaWR0aDtcbiAgICBvcHRpb25zLnN0cm9rZVdpZHRoID0gMDtcblxuICAgIHZhciB0ZXh0ID0gbmV3IGZhYnJpYy5UZXh0KHRleHRDb250ZW50LCBvcHRpb25zKSxcbiAgICAgICAgdGV4dEhlaWdodFNjYWxlRmFjdG9yID0gdGV4dC5nZXRTY2FsZWRIZWlnaHQoKSAvIHRleHQuaGVpZ2h0LFxuICAgICAgICBsaW5lSGVpZ2h0RGlmZiA9ICh0ZXh0LmhlaWdodCArIHRleHQuc3Ryb2tlV2lkdGgpICogdGV4dC5saW5lSGVpZ2h0IC0gdGV4dC5oZWlnaHQsXG4gICAgICAgIHNjYWxlZERpZmYgPSBsaW5lSGVpZ2h0RGlmZiAqIHRleHRIZWlnaHRTY2FsZUZhY3RvcixcbiAgICAgICAgdGV4dEhlaWdodCA9IHRleHQuZ2V0U2NhbGVkSGVpZ2h0KCkgKyBzY2FsZWREaWZmLFxuICAgICAgICBvZmZYID0gMDtcbiAgICAvKlxuICAgICAgQWRqdXN0IHBvc2l0aW9uaW5nOlxuICAgICAgICB4L3kgYXR0cmlidXRlcyBpbiBTVkcgY29ycmVzcG9uZCB0byB0aGUgYm90dG9tLWxlZnQgY29ybmVyIG9mIHRleHQgYm91bmRpbmcgYm94XG4gICAgICAgIGZhYnJpYyBvdXRwdXQgYnkgZGVmYXVsdCBhdCB0b3AsIGxlZnQuXG4gICAgKi9cbiAgICBpZiAocGFyc2VkQW5jaG9yID09PSAnY2VudGVyJykge1xuICAgICAgb2ZmWCA9IHRleHQuZ2V0U2NhbGVkV2lkdGgoKSAvIDI7XG4gICAgfVxuICAgIGlmIChwYXJzZWRBbmNob3IgPT09ICdyaWdodCcpIHtcbiAgICAgIG9mZlggPSB0ZXh0LmdldFNjYWxlZFdpZHRoKCk7XG4gICAgfVxuICAgIHRleHQuc2V0KHtcbiAgICAgIGxlZnQ6IHRleHQubGVmdCAtIG9mZlgsXG4gICAgICB0b3A6IHRleHQudG9wIC0gKHRleHRIZWlnaHQgLSB0ZXh0LmZvbnRTaXplICogKDAuMDcgKyB0ZXh0Ll9mb250U2l6ZUZyYWN0aW9uKSkgLyB0ZXh0LmxpbmVIZWlnaHQsXG4gICAgICBzdHJva2VXaWR0aDogdHlwZW9mIG9yaWdpbmFsU3Ryb2tlV2lkdGggIT09ICd1bmRlZmluZWQnID8gb3JpZ2luYWxTdHJva2VXaWR0aCA6IDEsXG4gICAgfSk7XG4gICAgY2FsbGJhY2sodGV4dCk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlRleHQgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuVGV4dCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuVGV4dC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdUZXh0Jywgb2JqZWN0LCBjYWxsYmFjaywgJ3RleHQnKTtcbiAgfTtcblxuICBmYWJyaWMuVGV4dC5nZW5lcmljRm9udHMgPSBbJ3NhbnMtc2VyaWYnLCAnc2VyaWYnLCAnY3Vyc2l2ZScsICdmYW50YXN5JywgJ21vbm9zcGFjZSddO1xuXG4gIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyAmJiBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMoZmFicmljLlRleHQpO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5UZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuVGV4dC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaGFzIG5vIHN0eWxpbmcgb3Igbm8gc3R5bGluZyBpbiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4ICwgbGluZUluZGV4IGlzIG9uIHdyYXBwZWQgbGluZXMuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5U3R5bGVzOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxpbmVJbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdHlwZW9mIGxpbmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnN0eWxlcyA6IHsgbGluZTogdGhpcy5zdHlsZXNbbGluZUluZGV4XSB9O1xuICAgICAgZm9yICh2YXIgcDEgaW4gb2JqKSB7XG4gICAgICAgIGZvciAodmFyIHAyIGluIG9ialtwMV0pIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICBmb3IgKHZhciBwMyBpbiBvYmpbcDFdW3AyXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaGFzIGEgc3R5bGUgcHJvcGVydHkgb3IgaGFzIGl0IGluYSBzcGVjaWZpZWQgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0eWxlSGFzOiBmdW5jdGlvbihwcm9wZXJ0eSwgbGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzIHx8ICFwcm9wZXJ0eSB8fCBwcm9wZXJ0eSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsaW5lSW5kZXggIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB0eXBlb2YgbGluZUluZGV4ID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc3R5bGVzIDogeyBsaW5lOiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdIH07XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gb2JqW3AxXSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW3AxXVtwMl1bcHJvcGVydHldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNoYXJhY3RlcnMgaW4gYSB0ZXh0IGhhdmUgYSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eVxuICAgICAqIHdob3NlIHZhbHVlIG1hdGNoZXMgdGhlIHRleHRib3gncyB2YWx1ZSBmb3IgdGhhdCBwcm9wZXJ0eS4gIElmIHNvLFxuICAgICAqIHRoZSBjaGFyYWN0ZXItbGV2ZWwgcHJvcGVydHkgaXMgZGVsZXRlZC4gIElmIHRoZSBjaGFyYWN0ZXJcbiAgICAgKiBoYXMgbm8gb3RoZXIgcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbHNvIGRlbGV0ZWQuICBGaW5hbGx5LFxuICAgICAqIGlmIHRoZSBsaW5lIGNvbnRhaW5pbmcgdGhhdCBjaGFyYWN0ZXIgaGFzIG5vIG90aGVyIGNoYXJhY3RlcnNcbiAgICAgKiB0aGVuIGl0IGFsc28gaXMgZGVsZXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgdG8gY29tcGFyZSBiZXR3ZWVuIGNoYXJhY3RlcnMgYW5kIHRleHQuXG4gICAgICovXG4gICAgY2xlYW5TdHlsZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMgfHwgIXByb3BlcnR5IHx8IHByb3BlcnR5ID09PSAnJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdGhpcy5zdHlsZXMsIHN0eWxlc0NvdW50ID0gMCwgbGV0dGVyQ291bnQsIHN0eWxlUHJvcGVydHlWYWx1ZSxcbiAgICAgICAgICBhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCA9IHRydWUsIGdyYXBoZW1lQ291bnQgPSAwLCBzdHlsZU9iamVjdDtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZm9yICh2YXIgcDEgaW4gb2JqKSB7XG4gICAgICAgIGxldHRlckNvdW50ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGZvciAodmFyIHAyIGluIG9ialtwMV0pIHtcbiAgICAgICAgICB2YXIgc3R5bGVPYmplY3QgPSBvYmpbcDFdW3AyXSxcbiAgICAgICAgICAgICAgc3R5bGVQcm9wZXJ0eUhhc0JlZW5TZXQgPSBzdHlsZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSk7XG5cbiAgICAgICAgICBzdHlsZXNDb3VudCsrO1xuXG4gICAgICAgICAgaWYgKHN0eWxlUHJvcGVydHlIYXNCZWVuU2V0KSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgICBzdHlsZVByb3BlcnR5VmFsdWUgPSBzdHlsZU9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHlsZU9iamVjdFtwcm9wZXJ0eV0gIT09IHN0eWxlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgICBhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3R5bGVPYmplY3RbcHJvcGVydHldID09PSB0aGlzW3Byb3BlcnR5XSkge1xuICAgICAgICAgICAgICBkZWxldGUgc3R5bGVPYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN0eWxlT2JqZWN0KS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGxldHRlckNvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtwMV1bcDJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXR0ZXJDb3VudCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbcDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpZiBldmVyeSBncmFwaGVtZSBoYXMgdGhlIHNhbWUgc3R5bGUgc2V0IHRoZW5cbiAgICAgIC8vIGRlbGV0ZSB0aG9zZSBzdHlsZXMgYW5kIHNldCBpdCBvbiB0aGUgcGFyZW50XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBncmFwaGVtZUNvdW50ICs9IHRoaXMuX3RleHRMaW5lc1tpXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggJiYgc3R5bGVzQ291bnQgPT09IGdyYXBoZW1lQ291bnQpIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBzdHlsZVByb3BlcnR5VmFsdWU7XG4gICAgICAgIHRoaXMucmVtb3ZlU3R5bGUocHJvcGVydHkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzdHlsZSBwcm9wZXJ0eSBvciBwcm9wZXJ0aWVzIGZyb20gYWxsIGluZGl2aWR1YWwgY2hhcmFjdGVyIHN0eWxlc1xuICAgICAqIGluIGEgdGV4dCBvYmplY3QuICBEZWxldGVzIHRoZSBjaGFyYWN0ZXIgc3R5bGUgb2JqZWN0IGlmIGl0IGNvbnRhaW5zIG5vIG90aGVyIHN0eWxlXG4gICAgICogcHJvcHMuICBEZWxldGVzIGEgbGluZSBzdHlsZSBvYmplY3QgaWYgaXQgY29udGFpbnMgbm8gb3RoZXIgY2hhcmFjdGVyIHN0eWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wcyBUaGUgcHJvcGVydHkgdG8gcmVtb3ZlIGZyb20gY2hhcmFjdGVyIHN0eWxlcy5cbiAgICAgKi9cbiAgICByZW1vdmVTdHlsZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMgfHwgIXByb3BlcnR5IHx8IHByb3BlcnR5ID09PSAnJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdGhpcy5zdHlsZXMsIGxpbmUsIGxpbmVOdW0sIGNoYXJOdW07XG4gICAgICBmb3IgKGxpbmVOdW0gaW4gb2JqKSB7XG4gICAgICAgIGxpbmUgPSBvYmpbbGluZU51bV07XG4gICAgICAgIGZvciAoY2hhck51bSBpbiBsaW5lKSB7XG4gICAgICAgICAgZGVsZXRlIGxpbmVbY2hhck51bV1bcHJvcGVydHldO1xuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhsaW5lW2NoYXJOdW1dKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsaW5lW2NoYXJOdW1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobGluZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtsaW5lTnVtXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9leHRlbmRTdHlsZXM6IGZ1bmN0aW9uKGluZGV4LCBzdHlsZXMpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oaW5kZXgpO1xuXG4gICAgICBpZiAoIXRoaXMuX2dldExpbmVTdHlsZShsb2MubGluZUluZGV4KSkge1xuICAgICAgICB0aGlzLl9zZXRMaW5lU3R5bGUobG9jLmxpbmVJbmRleCwge30pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCkpIHtcbiAgICAgICAgdGhpcy5fc2V0U3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4LCB7fSk7XG4gICAgICB9XG5cbiAgICAgIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQodGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4KSwgc3R5bGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAyZCByZXByZXNlbnRhdGlvbiAobGluZUluZGV4IGFuZCBjaGFySW5kZXgpIG9mIGN1cnNvciAob3Igc2VsZWN0aW9uIHN0YXJ0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2VsZWN0aW9uU3RhcnRdIE9wdGlvbmFsIGluZGV4LiBXaGVuIG5vdCBnaXZlbiwgY3VycmVudCBzZWxlY3Rpb25TdGFydCBpcyB1c2VkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBXcmFwcGluZ10gY29uc2lkZXIgdGhlIGxvY2F0aW9uIGZvciB1bndyYXBwZWQgbGluZXMuIHVzZWZ1bGwgdG8gbWFuYWdlIHN0eWxlcy5cbiAgICAgKi9cbiAgICBnZXQyREN1cnNvckxvY2F0aW9uOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCwgc2tpcFdyYXBwaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdGlvblN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9XG4gICAgICB2YXIgbGluZXMgPSBza2lwV3JhcHBpbmcgPyB0aGlzLl91bndyYXBwZWRUZXh0TGluZXMgOiB0aGlzLl90ZXh0TGluZXM7XG4gICAgICB2YXIgbGVuID0gbGluZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPD0gbGluZXNbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmVJbmRleDogaSxcbiAgICAgICAgICAgIGNoYXJJbmRleDogc2VsZWN0aW9uU3RhcnRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0IC09IGxpbmVzW2ldLmxlbmd0aCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lSW5kZXg6IGkgLSAxLFxuICAgICAgICBjaGFySW5kZXg6IGxpbmVzW2kgLSAxXS5sZW5ndGggPCBzZWxlY3Rpb25TdGFydCA/IGxpbmVzW2kgLSAxXS5sZW5ndGggOiBzZWxlY3Rpb25TdGFydFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uL2N1cnNvciAoYXQgdGhlIHN0YXJ0IHBvc2l0aW9uKVxuICAgICAqIGlmIHN0YXJ0SW5kZXggb3IgZW5kSW5kZXggYXJlIG5vdCBwcm92aWRlZCwgc2xlY3Rpb25TdGFydCBvciBzZWxlY3Rpb25FbmQgd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRJbmRleF0gU3RhcnQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kSW5kZXhdIEVuZCBpbmRleCB0byBnZXQgc3R5bGVzIGF0LCBpZiBub3Qgc3BlY2lmaWVkIHNlbGVjdGlvbkVuZCBvciBzdGFydEluZGV4ICsgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXBsZXRlXSBnZXQgZnVsbCBzdHlsZSBvciBub3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gc3R5bGVzIGFuIGFycmF5IHdpdGggb25lLCB6ZXJvIG9yIG1vcmUgU3R5bGUgb2JqZWN0c1xuICAgICAqL1xuICAgIGdldFNlbGVjdGlvblN0eWxlczogZnVuY3Rpb24oc3RhcnRJbmRleCwgZW5kSW5kZXgsIGNvbXBsZXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0SW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVuZEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbmRJbmRleCA9IHRoaXMuc2VsZWN0aW9uRW5kIHx8IHN0YXJ0SW5kZXg7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgc3R5bGVzLnB1c2godGhpcy5nZXRTdHlsZUF0UG9zaXRpb24oaSwgY29tcGxldGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgc3R5bGUgb2YgYSBjdXJyZW50IHNlbGVjdGlvbi9jdXJzb3IgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gIHRvIGdldCBzdHlsZXMgYXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wbGV0ZV0gZnVsbCBzdHlsZSBpZiB0cnVlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBTdHlsZSBvYmplY3QgYXQgYSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFN0eWxlQXRQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24sIGNvbXBsZXRlKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHBvc2l0aW9uKSxcbiAgICAgICAgICBzdHlsZSA9IGNvbXBsZXRlID8gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCkgOlxuICAgICAgICAgICAgdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4KTtcbiAgICAgIHJldHVybiBzdHlsZSB8fCB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uLCBpZiBubyBzZWxlY3Rpb24gZXhpc3QsIGRvIG5vdCBzZXQgYW55dGhpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZXNdIFN0eWxlcyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXhdIFN0YXJ0IGluZGV4IHRvIGdldCBzdHlsZXMgYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZEluZGV4XSBFbmQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdCwgaWYgbm90IHNwZWNpZmllZCBzZWxlY3Rpb25FbmQgb3Igc3RhcnRJbmRleCArIDFcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3R5bGVzOiBmdW5jdGlvbihzdHlsZXMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0SW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVuZEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbmRJbmRleCA9IHRoaXMuc2VsZWN0aW9uRW5kIHx8IHN0YXJ0SW5kZXg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgdGhpcy5fZXh0ZW5kU3R5bGVzKGksIHN0eWxlcyk7XG4gICAgICB9XG4gICAgICAvKiBub3QgaW5jbHVkZWQgaW4gX2V4dGVuZFN0eWxlcyB0byBhdm9pZCBjbGVhcmluZyBjYWNoZSBtb3JlIHRoYW4gb25jZSAqL1xuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHJlZmVyZW5jZSwgbm90IGEgY2xvbmUsIG9mIHRoZSBzdHlsZSBvYmplY3QgZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHN0eWxlIG9iamVjdFxuICAgICAqL1xuICAgIF9nZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIGxpbmVTdHlsZSA9IHRoaXMuc3R5bGVzICYmIHRoaXMuc3R5bGVzW2xpbmVJbmRleF07XG4gICAgICBpZiAoIWxpbmVTdHlsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lU3R5bGVbY2hhckluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgbmV3IG9iamVjdCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgc3R5bGUgcHJvcGVydHkgZm9yIGEgY2hhcmFjdGVyXG4gICAgICogdGhlIG9iamVjdCByZXR1cm5lZCBpcyBuZXdseSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBvZiB0aGUgbGluZSB3aGVyZSB0aGUgY2hhcmFjdGVyIGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBwb3NpdGlvbiBvZiB0aGUgY2hhcmFjdGVyIG9uIHRoZSBsaW5lXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB8fCB7IH0sXG4gICAgICAgICAgc3R5bGVPYmplY3QgPSB7IH0sIHByb3A7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N0eWxlUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm9wID0gdGhpcy5fc3R5bGVQcm9wZXJ0aWVzW2ldO1xuICAgICAgICBzdHlsZU9iamVjdFtwcm9wXSA9IHR5cGVvZiBzdHlsZVtwcm9wXSA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzW3Byb3BdIDogc3R5bGVbcHJvcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlKSB7XG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlbGV0ZVN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgsIHN0eWxlKSB7XG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdID0gc3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF07XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIHBhcnNlRGVjb3JhdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0LnRleHREZWNvcmF0aW9uKSB7XG4gICAgICBvYmplY3QudGV4dERlY29yYXRpb24uaW5kZXhPZigndW5kZXJsaW5lJykgPiAtMSAmJiAob2JqZWN0LnVuZGVybGluZSA9IHRydWUpO1xuICAgICAgb2JqZWN0LnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ2xpbmUtdGhyb3VnaCcpID4gLTEgJiYgKG9iamVjdC5saW5ldGhyb3VnaCA9IHRydWUpO1xuICAgICAgb2JqZWN0LnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ292ZXJsaW5lJykgPiAtMSAmJiAob2JqZWN0Lm92ZXJsaW5lID0gdHJ1ZSk7XG4gICAgICBkZWxldGUgb2JqZWN0LnRleHREZWNvcmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJVGV4dCBjbGFzcyAoaW50cm9kdWNlZCBpbiA8Yj52MS40PC9iPikgRXZlbnRzIGFyZSBhbHNvIGZpcmVkIHdpdGggXCJ0ZXh0OlwiXG4gICAqIHByZWZpeCB3aGVuIG9ic2VydmluZyBjYW52YXMuXG4gICAqIEBjbGFzcyBmYWJyaWMuSVRleHRcbiAgICogQGV4dGVuZHMgZmFicmljLlRleHRcbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqXG4gICAqIEBmaXJlcyBjaGFuZ2VkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y2hhbmdlZFxuICAgKiBAZmlyZXMgZWRpdGluZzplbnRlcmVkXG4gICAqIEBmaXJlcyBlZGl0aW5nOmV4aXRlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLklUZXh0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIDxwPlN1cHBvcnRlZCBrZXkgY29tYmluYXRpb25zOjwvcD5cbiAgICogPHByZT5cbiAgICogICBNb3ZlIGN1cnNvcjogICAgICAgICAgICAgICAgICAgIGxlZnQsIHJpZ2h0LCB1cCwgZG93blxuICAgKiAgIFNlbGVjdCBjaGFyYWN0ZXI6ICAgICAgICAgICAgICAgc2hpZnQgKyBsZWZ0LCBzaGlmdCArIHJpZ2h0XG4gICAqICAgU2VsZWN0IHRleHQgdmVydGljYWxseTogICAgICAgICBzaGlmdCArIHVwLCBzaGlmdCArIGRvd25cbiAgICogICBNb3ZlIGN1cnNvciBieSB3b3JkOiAgICAgICAgICAgIGFsdCArIGxlZnQsIGFsdCArIHJpZ2h0XG4gICAqICAgU2VsZWN0IHdvcmRzOiAgICAgICAgICAgICAgICAgICBzaGlmdCArIGFsdCArIGxlZnQsIHNoaWZ0ICsgYWx0ICsgcmlnaHRcbiAgICogICBNb3ZlIGN1cnNvciB0byBsaW5lIHN0YXJ0L2VuZDogIGNtZCArIGxlZnQsIGNtZCArIHJpZ2h0IG9yIGhvbWUsIGVuZFxuICAgKiAgIFNlbGVjdCB0aWxsIHN0YXJ0L2VuZCBvZiBsaW5lOiAgY21kICsgc2hpZnQgKyBsZWZ0LCBjbWQgKyBzaGlmdCArIHJpZ2h0IG9yIHNoaWZ0ICsgaG9tZSwgc2hpZnQgKyBlbmRcbiAgICogICBKdW1wIHRvIHN0YXJ0L2VuZCBvZiB0ZXh0OiAgICAgIGNtZCArIHVwLCBjbWQgKyBkb3duXG4gICAqICAgU2VsZWN0IHRpbGwgc3RhcnQvZW5kIG9mIHRleHQ6ICBjbWQgKyBzaGlmdCArIHVwLCBjbWQgKyBzaGlmdCArIGRvd24gb3Igc2hpZnQgKyBwZ1VwLCBzaGlmdCArIHBnRG93blxuICAgKiAgIERlbGV0ZSBjaGFyYWN0ZXI6ICAgICAgICAgICAgICAgYmFja3NwYWNlXG4gICAqICAgRGVsZXRlIHdvcmQ6ICAgICAgICAgICAgICAgICAgICBhbHQgKyBiYWNrc3BhY2VcbiAgICogICBEZWxldGUgbGluZTogICAgICAgICAgICAgICAgICAgIGNtZCArIGJhY2tzcGFjZVxuICAgKiAgIEZvcndhcmQgZGVsZXRlOiAgICAgICAgICAgICAgICAgZGVsZXRlXG4gICAqICAgQ29weSB0ZXh0OiAgICAgICAgICAgICAgICAgICAgICBjdHJsL2NtZCArIGNcbiAgICogICBQYXN0ZSB0ZXh0OiAgICAgICAgICAgICAgICAgICAgIGN0cmwvY21kICsgdlxuICAgKiAgIEN1dCB0ZXh0OiAgICAgICAgICAgICAgICAgICAgICAgY3RybC9jbWQgKyB4XG4gICAqICAgU2VsZWN0IGVudGlyZSB0ZXh0OiAgICAgICAgICAgICBjdHJsL2NtZCArIGFcbiAgICogICBRdWl0IGVkaXRpbmcgICAgICAgICAgICAgICAgICAgIHRhYiBvciBlc2NcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIDxwPlN1cHBvcnRlZCBtb3VzZS90b3VjaCBjb21iaW5hdGlvbjwvcD5cbiAgICogPHByZT5cbiAgICogICBQb3NpdGlvbiBjdXJzb3I6ICAgICAgICAgICAgICAgIGNsaWNrL3RvdWNoXG4gICAqICAgQ3JlYXRlIHNlbGVjdGlvbjogICAgICAgICAgICAgICBjbGljay90b3VjaCAmIGRyYWdcbiAgICogICBDcmVhdGUgc2VsZWN0aW9uOiAgICAgICAgICAgICAgIGNsaWNrICYgc2hpZnQgKyBjbGlja1xuICAgKiAgIFNlbGVjdCB3b3JkOiAgICAgICAgICAgICAgICAgICAgZG91YmxlIGNsaWNrXG4gICAqICAgU2VsZWN0IGxpbmU6ICAgICAgICAgICAgICAgICAgICB0cmlwbGUgY2xpY2tcbiAgICogPC9wcmU+XG4gICAqL1xuICBmYWJyaWMuSVRleHQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuVGV4dCwgZmFicmljLk9ic2VydmFibGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2ktdGV4dCcsXG5cbiAgICAvKipcbiAgICAgKiBJbmRleCB3aGVyZSB0ZXh0IHNlbGVjdGlvbiBzdGFydHMgKG9yIHdoZXJlIGN1cnNvciBpcyB3aGVuIHRoZXJlIGlzIG5vIHNlbGVjdGlvbilcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvblN0YXJ0OiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kZXggd2hlcmUgdGV4dCBzZWxlY3Rpb24gZW5kc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uRW5kOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgdGV4dCBzZWxlY3Rpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkNvbG9yOiAncmdiYSgxNywxMTksMjU1LDAuMyknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGV4dCBpcyBpbiBlZGl0aW5nIG1vZGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgYSB0ZXh0IGNhbiBiZSBlZGl0ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBlZGl0YWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEJvcmRlciBjb2xvciBvZiB0ZXh0IG9iamVjdCB3aGlsZSBpdCdzIGluIGVkaXRpbmcgbW9kZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZWRpdGluZ0JvcmRlckNvbG9yOiAncmdiYSgxMDIsMTUzLDI1NSwwLjI1KScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBjdXJzb3IgKGluIHB4KVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yV2lkdGg6IDIsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBkZWZhdWx0IGN1cnNvciAod2hlbiBub3Qgb3ZlcndyaXR0ZW4gYnkgY2hhcmFjdGVyIHN0eWxlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yQ29sb3I6ICcjMzMzJyxcblxuICAgIC8qKlxuICAgICAqIERlbGF5IGJldHdlZW4gY3Vyc29yIGJsaW5rIChpbiBtcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvckRlbGF5OiAxMDAwLFxuXG4gICAgLyoqXG4gICAgICogRHVyYXRpb24gb2YgY3Vyc29yIGZhZGVpbiAoaW4gbXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JEdXJhdGlvbjogNjAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgaW50ZXJuYWwgdGV4dCBjaGFyIHdpZHRocyBjYW4gYmUgY2FjaGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2FjaGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2U6IC9cXHN8XFxuLyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2N1cnJlbnRDdXJzb3JPcGFjaXR5OiAwLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VsZWN0aW9uRGlyZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWJvcnRDdXJzb3JBbmltYXRpb246IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3dpZHRoT2ZTcGFjZTogW10sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwcyBkZXRlcm1pbmluZyB3aGVuIHRoZSB0ZXh0IGlzIGluIGNvbXBvc2l0aW9uLCBzbyB0aGF0IHRoZSBjdXJzb3JcbiAgICAgKiByZW5kZXJpbmcgaXMgYWx0ZXJlZC5cbiAgICAgKi9cbiAgICBpbkNvbXBvc2l0aW9uTW9kZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgdGV4dCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmluaXRCZWhhdmlvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGlvbiBzdGFydCAobGVmdCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBzdGFydCB0b1xuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXJ0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaW5kZXggPSBNYXRoLm1heChpbmRleCwgMCk7XG4gICAgICB0aGlzLl91cGRhdGVBbmRGaXJlKCdzZWxlY3Rpb25TdGFydCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3Rpb24gZW5kIChyaWdodCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBlbmQgdG9cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25FbmQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0aGlzLnRleHQubGVuZ3RoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEZpcmUoJ3NlbGVjdGlvbkVuZCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgJ3NlbGVjdGlvblN0YXJ0JyBvciAnc2VsZWN0aW9uRW5kJ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBuZXcgcG9zaXRpb24gb2YgcHJvcGVydHlcbiAgICAgKi9cbiAgICBfdXBkYXRlQW5kRmlyZTogZnVuY3Rpb24ocHJvcGVydHksIGluZGV4KSB7XG4gICAgICBpZiAodGhpc1twcm9wZXJ0eV0gIT09IGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gaW5kZXg7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB0aGUgZXZlbiBvZiBzZWxlY3Rpb24gY2hhbmdlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNoYW5nZWQnKTtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6c2VsZWN0aW9uOmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0ZXh0IGRpbWVuc2lvbnMuIFJlbmRlciBhbGwgdGV4dCBvbiBnaXZlbiBjb250ZXh0XG4gICAgICogb3Igb24gYSBvZmZzY3JlZW4gY2FudmFzIHRvIGdldCB0aGUgdGV4dCB3aWR0aCB3aXRoIG1lYXN1cmVUZXh0LlxuICAgICAqIFVwZGF0ZXMgdGhpcy53aWR0aCBhbmQgdGhpcy5oZWlnaHQgd2l0aCB0aGUgcHJvcGVyIHZhbHVlcy5cbiAgICAgKiBEb2VzIG5vdCByZXR1cm4gZGltZW5zaW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdERpbWVuc2lvbnMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICAgIC8vIGNsZWFyIHRoZSBjdXJzb3JPZmZzZXRDYWNoZSwgc28gd2UgZW5zdXJlIHRvIGNhbGN1bGF0ZSBvbmNlIHBlciByZW5kZXJDdXJzb3JcbiAgICAgIC8vIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGJ1dCBub3QgYXQgZXZlcnkgY3Vyc29yIGFuaW1hdGlvbi5cbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXInLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIGFuZCBjbGVhbiB0aGUgY29udGV4dFRvcFxuICAgICAqL1xuICAgIGNsZWFyQ29udGV4dFRvcDogZnVuY3Rpb24oc2tpcFJlc3RvcmUpIHtcbiAgICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNvbnRleHRUb3ApIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIHYgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggJiYgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICAgICAgdGhpcy5fY2xlYXJUZXh0QXJlYShjdHgpO1xuICAgICAgICBza2lwUmVzdG9yZSB8fCBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGN1cnNvciBvciBzZWxlY3Rpb24gKGRlcGVuZGluZyBvbiB3aGF0IGV4aXN0cylcbiAgICAgKi9cbiAgICByZW5kZXJDdXJzb3JPclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaXNFZGl0aW5nIHx8ICF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYm91bmRhcmllcyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXMoKSwgY3R4O1xuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNvbnRleHRUb3ApIHtcbiAgICAgICAgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AodHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dENvbnRhaW5lcjtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLnJlbmRlckN1cnNvcihib3VuZGFyaWVzLCBjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uKGJvdW5kYXJpZXMsIGN0eCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICBfY2xlYXJUZXh0QXJlYTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAvLyB3ZSBhZGQgNCBwaXhlbCwgdG8gYmUgc3VyZSB0byBkbyBub3QgbGVhdmUgYW55IHBpeGVsIG91dFxuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCArIDQsIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgNDtcbiAgICAgIGN0eC5jbGVhclJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnNvciBib3VuZGFyaWVzIChsZWZ0LCB0b3AsIGxlZnRPZmZzZXQsIHRvcE9mZnNldClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNoYXJzIEFycmF5IG9mIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZU9mQm91bmRhcmllc1xuICAgICAqL1xuICAgIF9nZXRDdXJzb3JCb3VuZGFyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuXG4gICAgICAvLyBsZWZ0L3RvcCBhcmUgbGVmdC90b3Agb2YgZW50aXJlIHRleHQgYm94XG4gICAgICAvLyBsZWZ0T2Zmc2V0L3RvcE9mZnNldCBhcmUgb2Zmc2V0IGZyb20gdGhhdCBsZWZ0L3RvcCBwb2ludCBvZiBhIHRleHQgYm94XG5cbiAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksXG4gICAgICAgICAgb2Zmc2V0cyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzKHBvc2l0aW9uKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIGxlZnRPZmZzZXQ6IG9mZnNldHMubGVmdCxcbiAgICAgICAgdG9wT2Zmc2V0OiBvZmZzZXRzLnRvcFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q3Vyc29yQm91bmRhcmllc09mZnNldHM6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICBpZiAodGhpcy5jdXJzb3JPZmZzZXRDYWNoZSAmJiAndG9wJyBpbiB0aGlzLmN1cnNvck9mZnNldENhY2hlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvck9mZnNldENhY2hlO1xuICAgICAgfVxuICAgICAgdmFyIGxpbmVMZWZ0T2Zmc2V0LFxuICAgICAgICAgIGxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXgsXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gMCxcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gMCxcbiAgICAgICAgICBib3VuZGFyaWVzLFxuICAgICAgICAgIGN1cnNvclBvc2l0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHBvc2l0aW9uKTtcbiAgICAgIGNoYXJJbmRleCA9IGN1cnNvclBvc2l0aW9uLmNoYXJJbmRleDtcbiAgICAgIGxpbmVJbmRleCA9IGN1cnNvclBvc2l0aW9uLmxpbmVJbmRleDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZUluZGV4OyBpKyspIHtcbiAgICAgICAgdG9wT2Zmc2V0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgfVxuICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpO1xuICAgICAgdmFyIGJvdW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgICAgYm91bmQgJiYgKGxlZnRPZmZzZXQgPSBib3VuZC5sZWZ0KTtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwICYmIGNoYXJJbmRleCA9PT0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0ubGVuZ3RoKSB7XG4gICAgICAgIGxlZnRPZmZzZXQgLT0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICB9XG4gICAgICBib3VuZGFyaWVzID0ge1xuICAgICAgICB0b3A6IHRvcE9mZnNldCxcbiAgICAgICAgbGVmdDogbGluZUxlZnRPZmZzZXQgKyAobGVmdE9mZnNldCA+IDAgPyBsZWZ0T2Zmc2V0IDogMCksXG4gICAgICB9O1xuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IGJvdW5kYXJpZXM7XG4gICAgICByZXR1cm4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm91bmRhcmllc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdHJhbnNmb3JtZWQgY29udGV4dCB0byBkcmF3IG9uXG4gICAgICovXG4gICAgcmVuZGVyQ3Vyc29yOiBmdW5jdGlvbihib3VuZGFyaWVzLCBjdHgpIHtcbiAgICAgIHZhciBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbigpLFxuICAgICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXggPiAwID8gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4IC0gMSA6IDAsXG4gICAgICAgICAgY2hhckhlaWdodCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdmb250U2l6ZScpLFxuICAgICAgICAgIG11bHRpcGxpZXIgPSB0aGlzLnNjYWxlWCAqIHRoaXMuY2FudmFzLmdldFpvb20oKSxcbiAgICAgICAgICBjdXJzb3JXaWR0aCA9IHRoaXMuY3Vyc29yV2lkdGggLyBtdWx0aXBsaWVyLFxuICAgICAgICAgIHRvcE9mZnNldCA9IGJvdW5kYXJpZXMudG9wT2Zmc2V0LFxuICAgICAgICAgIGR5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsaW5lSW5kZXgsIGNoYXJJbmRleCwgJ2RlbHRhWScpO1xuXG4gICAgICB0b3BPZmZzZXQgKz0gKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSAqIHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGxpbmVJbmRleCkgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgLSBjaGFySGVpZ2h0ICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKTtcblxuICAgICAgaWYgKHRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTZWxlY3Rpb24oYm91bmRhcmllcywgY3R4KTtcbiAgICAgIH1cblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdmaWxsJyk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLl9faXNNb3VzZWRvd24gPyAxIDogdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHk7XG4gICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgIGJvdW5kYXJpZXMubGVmdCArIGJvdW5kYXJpZXMubGVmdE9mZnNldCAtIGN1cnNvcldpZHRoIC8gMixcbiAgICAgICAgdG9wT2Zmc2V0ICsgYm91bmRhcmllcy50b3AgKyBkeSxcbiAgICAgICAgY3Vyc29yV2lkdGgsXG4gICAgICAgIGNoYXJIZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRleHQgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJvdW5kYXJpZXMgT2JqZWN0IHdpdGggbGVmdC90b3AvbGVmdE9mZnNldC90b3BPZmZzZXRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRyYW5zZm9ybWVkIGNvbnRleHQgdG8gZHJhdyBvblxuICAgICAqL1xuICAgIHJlbmRlclNlbGVjdGlvbjogZnVuY3Rpb24oYm91bmRhcmllcywgY3R4KSB7XG5cbiAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPyB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0IDogdGhpcy5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBzZWxlY3Rpb25FbmQgPSB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQgOiB0aGlzLnNlbGVjdGlvbkVuZCxcbiAgICAgICAgICBpc0p1c3RpZnkgPSB0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xLFxuICAgICAgICAgIHN0YXJ0ID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHNlbGVjdGlvblN0YXJ0KSxcbiAgICAgICAgICBlbmQgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uRW5kKSxcbiAgICAgICAgICBzdGFydExpbmUgPSBzdGFydC5saW5lSW5kZXgsXG4gICAgICAgICAgZW5kTGluZSA9IGVuZC5saW5lSW5kZXgsXG4gICAgICAgICAgc3RhcnRDaGFyID0gc3RhcnQuY2hhckluZGV4IDwgMCA/IDAgOiBzdGFydC5jaGFySW5kZXgsXG4gICAgICAgICAgZW5kQ2hhciA9IGVuZC5jaGFySW5kZXggPCAwID8gMCA6IGVuZC5jaGFySW5kZXg7XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSkgfHwgMCxcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKSxcbiAgICAgICAgICAgIHJlYWxMaW5lSGVpZ2h0ID0gMCwgYm94U3RhcnQgPSAwLCBib3hFbmQgPSAwO1xuXG4gICAgICAgIGlmIChpID09PSBzdGFydExpbmUpIHtcbiAgICAgICAgICBib3hTdGFydCA9IHRoaXMuX19jaGFyQm91bmRzW3N0YXJ0TGluZV1bc3RhcnRDaGFyXS5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID49IHN0YXJ0TGluZSAmJiBpIDwgZW5kTGluZSkge1xuICAgICAgICAgIGJveEVuZCA9IGlzSnVzdGlmeSAmJiAhdGhpcy5pc0VuZE9mV3JhcHBpbmcoaSkgPyB0aGlzLndpZHRoIDogdGhpcy5nZXRMaW5lV2lkdGgoaSkgfHwgNTsgLy8gV1RGIGlzIHRoaXMgNT9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpID09PSBlbmRMaW5lKSB7XG4gICAgICAgICAgaWYgKGVuZENoYXIgPT09IDApIHtcbiAgICAgICAgICAgIGJveEVuZCA9IHRoaXMuX19jaGFyQm91bmRzW2VuZExpbmVdW2VuZENoYXJdLmxlZnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICAgICAgICBib3hFbmQgPSB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyIC0gMV0ubGVmdFxuICAgICAgICAgICAgICArIHRoaXMuX19jaGFyQm91bmRzW2VuZExpbmVdW2VuZENoYXIgLSAxXS53aWR0aCAtIGNoYXJTcGFjaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWFsTGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLmxpbmVIZWlnaHQgPCAxIHx8IChpID09PSBlbmRMaW5lICYmIHRoaXMubGluZUhlaWdodCA+IDEpKSB7XG4gICAgICAgICAgbGluZUhlaWdodCAvPSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb21wb3NpdGlvbkNvbG9yIHx8ICdibGFjayc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgYm91bmRhcmllcy5sZWZ0ICsgbGluZU9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgICAgYm91bmRhcmllcy50b3AgKyBib3VuZGFyaWVzLnRvcE9mZnNldCArIGxpbmVIZWlnaHQsXG4gICAgICAgICAgICBib3hFbmQgLSBib3hTdGFydCxcbiAgICAgICAgICAgIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIGJvdW5kYXJpZXMubGVmdCArIGxpbmVPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICAgIGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQsXG4gICAgICAgICAgICBib3hFbmQgLSBib3hTdGFydCxcbiAgICAgICAgICAgIGxpbmVIZWlnaHQpO1xuICAgICAgICB9XG5cblxuICAgICAgICBib3VuZGFyaWVzLnRvcE9mZnNldCArPSByZWFsTGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlnaCBsZXZlbCBmdW5jdGlvbiB0byBrbm93IHRoZSBoZWlnaHQgb2YgdGhlIGN1cnNvci5cbiAgICAgKiB0aGUgY3VycmVudENoYXIgaXMgdGhlIG9uZSB0aGF0IHByZWNlZGVzIHRoZSBjdXJzb3JcbiAgICAgKiBSZXR1cm5zIGZvbnRTaXplIG9mIGNoYXIgYXQgdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBDaGFyYWN0ZXIgZm9udCBzaXplXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENoYXJGb250U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3AgPSB0aGlzLl9nZXRDdXJyZW50Q2hhckluZGV4KCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChjcC5sLCBjcC5jLCAnZm9udFNpemUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlnaCBsZXZlbCBmdW5jdGlvbiB0byBrbm93IHRoZSBjb2xvciBvZiB0aGUgY3Vyc29yLlxuICAgICAqIHRoZSBjdXJyZW50Q2hhciBpcyB0aGUgb25lIHRoYXQgcHJlY2VkZXMgdGhlIGN1cnNvclxuICAgICAqIFJldHVybnMgY29sb3IgKGZpbGwpIG9mIGNoYXIgYXQgdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBDaGFyYWN0ZXIgY29sb3IgKGZpbGwpXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENoYXJDb2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3AgPSB0aGlzLl9nZXRDdXJyZW50Q2hhckluZGV4KCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChjcC5sLCBjcC5jLCAnZmlsbCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJzb3IgcG9zaXRpb24gZm9yIHRoZSBnZXRDdXJyZW50Li4gZnVuY3Rpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q3VycmVudENoYXJJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3Vyc29yUG9zaXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24odGhpcy5zZWxlY3Rpb25TdGFydCwgdHJ1ZSksXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yUG9zaXRpb24uY2hhckluZGV4ID4gMCA/IGN1cnNvclBvc2l0aW9uLmNoYXJJbmRleCAtIDEgOiAwO1xuICAgICAgcmV0dXJuIHsgbDogY3Vyc29yUG9zaXRpb24ubGluZUluZGV4LCBjOiBjaGFySW5kZXggfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5JVGV4dCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSVRleHRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuSVRleHQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBwYXJzZURlY29yYXRpb24ob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0LnN0eWxlcykge1xuICAgICAgZm9yICh2YXIgaSBpbiBvYmplY3Quc3R5bGVzKSB7XG4gICAgICAgIGZvciAodmFyIGogaW4gb2JqZWN0LnN0eWxlc1tpXSkge1xuICAgICAgICAgIHBhcnNlRGVjb3JhdGlvbihvYmplY3Quc3R5bGVzW2ldW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdJVGV4dCcsIG9iamVjdCwgY2FsbGJhY2ssICd0ZXh0Jyk7XG4gIH07XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYWxsIHRoZSBpbnRlcmFjdGl2ZSBiZWhhdmlvciBvZiBJVGV4dFxuICAgICAqL1xuICAgIGluaXRCZWhhdmlvcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmluaXRBZGRlZEhhbmRsZXIoKTtcbiAgICAgIHRoaXMuaW5pdFJlbW92ZWRIYW5kbGVyKCk7XG4gICAgICB0aGlzLmluaXRDdXJzb3JTZWxlY3Rpb25IYW5kbGVycygpO1xuICAgICAgdGhpcy5pbml0RG91YmxlQ2xpY2tTaW11bGF0aW9uKCk7XG4gICAgICB0aGlzLm1vdXNlTW92ZUhhbmRsZXIgPSB0aGlzLm1vdXNlTW92ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgb25EZXNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzRWRpdGluZyAmJiB0aGlzLmV4aXRFZGl0aW5nKCk7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIFwiYWRkZWRcIiBldmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgaW5pdEFkZGVkSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5vbignYWRkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IF90aGlzLmNhbnZhcztcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIGlmICghY2FudmFzLl9oYXNJVGV4dEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBjYW52YXMuX2hhc0lUZXh0SGFuZGxlcnMgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuX2luaXRDYW52YXNIYW5kbGVycyhjYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzID0gY2FudmFzLl9pVGV4dEluc3RhbmNlcyB8fCBbXTtcbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLnB1c2goX3RoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5pdFJlbW92ZWRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLm9uKCdyZW1vdmVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBfdGhpcy5jYW52YXM7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzID0gY2FudmFzLl9pVGV4dEluc3RhbmNlcyB8fCBbXTtcbiAgICAgICAgICBmYWJyaWMudXRpbC5yZW1vdmVGcm9tQXJyYXkoY2FudmFzLl9pVGV4dEluc3RhbmNlcywgX3RoaXMpO1xuICAgICAgICAgIGlmIChjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY2FudmFzLl9oYXNJVGV4dEhhbmRsZXJzID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fcmVtb3ZlQ2FudmFzSGFuZGxlcnMoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWdpc3RlciBjYW52YXMgZXZlbnQgdG8gbWFuYWdlIGV4aXRpbmcgb24gb3RoZXIgaW5zdGFuY2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdENhbnZhc0hhbmRsZXJzOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcykge1xuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIG9iai5fX2lzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjYW52YXMub24oJ21vdXNlOnVwJywgY2FudmFzLl9tb3VzZVVwSVRleHRIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGNhbnZhcyBldmVudCB0byBtYW5hZ2UgZXhpdGluZyBvbiBvdGhlciBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVDYW52YXNIYW5kbGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBjYW52YXMub2ZmKCdtb3VzZTp1cCcsIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY3VycmVudFRpY2tTdGF0ZSA9IHRoaXMuX2FuaW1hdGVDdXJzb3IodGhpcywgMSwgdGhpcy5jdXJzb3JEdXJhdGlvbiwgJ19vblRpY2tDb21wbGV0ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hbmltYXRlQ3Vyc29yOiBmdW5jdGlvbihvYmosIHRhcmdldE9wYWNpdHksIGR1cmF0aW9uLCBjb21wbGV0ZU1ldGhvZCkge1xuXG4gICAgICB2YXIgdGlja1N0YXRlO1xuXG4gICAgICB0aWNrU3RhdGUgPSB7XG4gICAgICAgIGlzQWJvcnRlZDogZmFsc2UsXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmlzQWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBvYmouYW5pbWF0ZSgnX2N1cnJlbnRDdXJzb3JPcGFjaXR5JywgdGFyZ2V0T3BhY2l0eSwge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGlja1N0YXRlLmlzQWJvcnRlZCkge1xuICAgICAgICAgICAgb2JqW2NvbXBsZXRlTWV0aG9kXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGFuaW1hdGUgYSBzZWxlY3Rpb24sIG9ubHkgY3Vyc29yXG4gICAgICAgICAgaWYgKG9iai5jYW52YXMgJiYgb2JqLnNlbGVjdGlvblN0YXJ0ID09PSBvYmouc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICBvYmoucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGlja1N0YXRlLmlzQWJvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGlja1N0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblRpY2tDb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9jdXJzb3JUaW1lb3V0MSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yVGltZW91dDEpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY3Vyc29yVGltZW91dDEgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlID0gX3RoaXMuX2FuaW1hdGVDdXJzb3IoX3RoaXMsIDAsIHRoaXMuY3Vyc29yRHVyYXRpb24gLyAyLCAnX3RpY2snKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGRlbGF5ZWQgY3Vyc29yXG4gICAgICovXG4gICAgaW5pdERlbGF5ZWRDdXJzb3I6IGZ1bmN0aW9uKHJlc3RhcnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgZGVsYXkgPSByZXN0YXJ0ID8gMCA6IHRoaXMuY3Vyc29yRGVsYXk7XG5cbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcbiAgICAgIHRoaXMuX2N1cnNvclRpbWVvdXQyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX3RpY2soKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWJvcnRzIGN1cnNvciBhbmltYXRpb24gYW5kIGNsZWFycyBhbGwgdGltZW91dHNcbiAgICAgKi9cbiAgICBhYm9ydEN1cnNvckFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2hvdWxkQ2xlYXIgPSB0aGlzLl9jdXJyZW50VGlja1N0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSxcbiAgICAgICAgICBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgJiYgdGhpcy5fY3VycmVudFRpY2tTdGF0ZS5hYm9ydCgpO1xuICAgICAgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlICYmIHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZS5hYm9ydCgpO1xuXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yVGltZW91dDEpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvclRpbWVvdXQyKTtcblxuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAwO1xuICAgICAgLy8gdG8gY2xlYXIganVzdCBpdGV4dCBhcmVhIHdlIG5lZWQgdG8gdHJhbnNmb3JtIHRoZSBjb250ZXh0XG4gICAgICAvLyBpdCBtYXkgbm90IGJlIHdvcnRoIGl0XG4gICAgICBpZiAoc2hvdWxkQ2xlYXIgJiYgY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcy5jbGVhckNvbnRleHQoY2FudmFzLmNvbnRleHRUb3AgfHwgY2FudmFzLmNvbnRleHRDb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgZW50aXJlIHRleHRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLl90ZXh0Lmxlbmd0aDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2VsZWN0ZWQgdGV4dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RleHQuc2xpY2UodGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQpLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIHN0YXJ0IG9mIGN1cnJlbnQgd29yZCBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIFN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZFdvcmRCb3VuZGFyeUxlZnQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tIC0gMTtcblxuICAgICAgLy8gcmVtb3ZlIHNwYWNlIGJlZm9yZSBjdXJzb3IgZmlyc3RcbiAgICAgIGlmICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKC9cXFMvLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4ID4gLTEpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gLSBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgZW5kIG9mIGN1cnJlbnQgd29yZCBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZFdvcmRCb3VuZGFyeVJpZ2h0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbTtcblxuICAgICAgLy8gcmVtb3ZlIHNwYWNlIGFmdGVyIGN1cnNvciBmaXJzdFxuICAgICAgaWYgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoL1xcUy8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPCB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tICsgb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIHN0YXJ0IG9mIGN1cnJlbnQgbGluZSBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZExpbmVCb3VuZGFyeUxlZnQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tIC0gMTtcblxuICAgICAgd2hpbGUgKCEvXFxuLy50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tIC0gb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIGVuZCBvZiBjdXJyZW50IGxpbmUgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRMaW5lQm91bmRhcnlSaWdodDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb207XG5cbiAgICAgIHdoaWxlICghL1xcbi8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPCB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tICsgb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBpbmRleCBjb3JyZXNwb25kaW5nIHRvIGJlZ2lubmluZyBvciBlbmQgb2YgYSB3b3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlbGVjdGlvblN0YXJ0IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiAxIG9yIC0xXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiB0aGUgYmVnaW5uaW5nIG9yIGVuZCBvZiBhIHdvcmRcbiAgICAgKi9cbiAgICBzZWFyY2hXb3JkQm91bmRhcnk6IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0LCBkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBpbmRleCAgICAgPSB0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy50ZXh0LmNoYXJBdChzZWxlY3Rpb25TdGFydCkpID8gc2VsZWN0aW9uU3RhcnQgLSAxIDogc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgX2NoYXIgICAgID0gdGhpcy50ZXh0LmNoYXJBdChpbmRleCksXG4gICAgICAgICAgcmVOb25Xb3JkID0gL1sgXFxuXFwuLDshXFw/XFwtXS87XG5cbiAgICAgIHdoaWxlICghcmVOb25Xb3JkLnRlc3QoX2NoYXIpICYmIGluZGV4ID4gMCAmJiBpbmRleCA8IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyZWN0aW9uO1xuICAgICAgICBfY2hhciA9IHRoaXMudGV4dC5jaGFyQXQoaW5kZXgpO1xuICAgICAgfVxuICAgICAgaWYgKHJlTm9uV29yZC50ZXN0KF9jaGFyKSAmJiBfY2hhciAhPT0gJ1xcbicpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyZWN0aW9uID09PSAxID8gMCA6IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSB3b3JkIGJhc2VkIG9uIHRoZSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqL1xuICAgIHNlbGVjdFdvcmQ6IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICBzZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlYXJjaFdvcmRCb3VuZGFyeShzZWxlY3Rpb25TdGFydCwgLTEpLCAvKiBzZWFyY2ggYmFja3dhcmRzICovXG4gICAgICAgICAgbmV3U2VsZWN0aW9uRW5kID0gdGhpcy5zZWFyY2hXb3JkQm91bmRhcnkoc2VsZWN0aW9uU3RhcnQsIDEpOyAvKiBzZWFyY2ggZm9yd2FyZCAqL1xuXG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbkVuZDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgbGluZSBiYXNlZCBvbiB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VsZWN0aW9uU3RhcnQgSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VsZWN0TGluZTogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQgfHwgdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIHZhciBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuZmluZExpbmVCb3VuZGFyeUxlZnQoc2VsZWN0aW9uU3RhcnQpLFxuICAgICAgICAgIG5ld1NlbGVjdGlvbkVuZCA9IHRoaXMuZmluZExpbmVCb3VuZGFyeVJpZ2h0KHNlbGVjdGlvblN0YXJ0KTtcblxuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25FbmQ7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbnRlcnMgZWRpdGluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBlbnRlckVkaXRpbmc6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLmlzRWRpdGluZyB8fCAhdGhpcy5lZGl0YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5jYWxjT2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuZXhpdEVkaXRpbmdPbk90aGVycyh0aGlzLmNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcblxuICAgICAgdGhpcy5pbml0SGlkZGVuVGV4dGFyZWEoZSk7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLmZvY3VzKCk7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlID0gdGhpcy50ZXh0O1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHRoaXMuX3NhdmVFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX3NldEVkaXRpbmdQcm9wcygpO1xuICAgICAgdGhpcy5fdGV4dEJlZm9yZUVkaXQgPSB0aGlzLnRleHQ7XG5cbiAgICAgIHRoaXMuX3RpY2soKTtcbiAgICAgIHRoaXMuZmlyZSgnZWRpdGluZzplbnRlcmVkJyk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6ZWRpdGluZzplbnRlcmVkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICB0aGlzLmluaXRNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZXhpdEVkaXRpbmdPbk90aGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcykge1xuICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgb2JqLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG9iai5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIG9iai5leGl0RWRpdGluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIFwibW91c2Vtb3ZlXCIgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIGluaXRNb3VzZU1vdmVIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2FudmFzLm9uKCdtb3VzZTptb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtb3VzZU1vdmVIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuX19pc01vdXNlZG93biB8fCAhdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIob3B0aW9ucy5lKSxcbiAgICAgICAgICBjdXJyZW50U3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIGN1cnJlbnRFbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICAgIGlmIChcbiAgICAgICAgKG5ld1NlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93biB8fCBjdXJyZW50U3RhcnQgPT09IGN1cnJlbnRFbmQpXG4gICAgICAgICYmXG4gICAgICAgIChjdXJyZW50U3RhcnQgPT09IG5ld1NlbGVjdGlvblN0YXJ0IHx8IGN1cnJlbnRFbmQgPT09IG5ld1NlbGVjdGlvblN0YXJ0KVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdTZWxlY3Rpb25TdGFydCA+IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93bjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd247XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gY3VycmVudFN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uRW5kICE9PSBjdXJyZW50RW5kKSB7XG4gICAgICAgIHRoaXMucmVzdGFydEN1cnNvcklmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0RWRpdGluZ1Byb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaG92ZXJDdXJzb3IgPSAndGV4dCc7XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yID0gdGhpcy5jYW52YXMubW92ZUN1cnNvciA9ICd0ZXh0JztcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IHRoaXMuZWRpdGluZ0JvcmRlckNvbG9yO1xuXG4gICAgICB0aGlzLmhhc0NvbnRyb2xzID0gdGhpcy5zZWxlY3RhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFggPSB0aGlzLmxvY2tNb3ZlbWVudFkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGZyb20gdGV4dGFyZWEgdG8gZ3JhcGhlbWUgaW5kZXhlc1xuICAgICAqL1xuICAgIGZyb21TdHJpbmdUb0dyYXBoZW1lU2VsZWN0aW9uOiBmdW5jdGlvbihzdGFydCwgZW5kLCB0ZXh0KSB7XG4gICAgICB2YXIgc21hbGxlclRleHRTdGFydCA9IHRleHQuc2xpY2UoMCwgc3RhcnQpLFxuICAgICAgICAgIGdyYXBoZW1lU3RhcnQgPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChzbWFsbGVyVGV4dFN0YXJ0KS5sZW5ndGg7XG4gICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0IH07XG4gICAgICB9XG4gICAgICB2YXIgc21hbGxlclRleHRFbmQgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgIGdyYXBoZW1lRW5kID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQoc21hbGxlclRleHRFbmQpLmxlbmd0aDtcbiAgICAgIHJldHVybiB7IHNlbGVjdGlvblN0YXJ0OiBncmFwaGVtZVN0YXJ0LCBzZWxlY3Rpb25FbmQ6IGdyYXBoZW1lU3RhcnQgKyBncmFwaGVtZUVuZCB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGZyb20gZmFicmljIHRvIHRleHRhcmVhIHZhbHVlc1xuICAgICAqL1xuICAgIGZyb21HcmFwaGVtZVRvU3RyaW5nU2VsZWN0aW9uOiBmdW5jdGlvbihzdGFydCwgZW5kLCBfdGV4dCkge1xuICAgICAgdmFyIHNtYWxsZXJUZXh0U3RhcnQgPSBfdGV4dC5zbGljZSgwLCBzdGFydCksXG4gICAgICAgICAgZ3JhcGhlbWVTdGFydCA9IHNtYWxsZXJUZXh0U3RhcnQuam9pbignJykubGVuZ3RoO1xuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCB9O1xuICAgICAgfVxuICAgICAgdmFyIHNtYWxsZXJUZXh0RW5kID0gX3RleHQuc2xpY2Uoc3RhcnQsIGVuZCksXG4gICAgICAgICAgZ3JhcGhlbWVFbmQgPSBzbWFsbGVyVGV4dEVuZC5qb2luKCcnKS5sZW5ndGg7XG4gICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0ICsgZ3JhcGhlbWVFbmQgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlVGV4dGFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IHsgfTtcbiAgICAgIGlmICghdGhpcy5oaWRkZW5UZXh0YXJlYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZnJvbUdyYXBoZW1lVG9TdHJpbmdTZWxlY3Rpb24odGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsIHRoaXMuX3RleHQpO1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25FbmQ7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVRleHRhcmVhUG9zaXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVGcm9tVGV4dEFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmhpZGRlblRleHRhcmVhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICB0aGlzLnRleHQgPSB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5mcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbihcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCwgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQsIHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvbkVuZDtcbiAgICAgIGlmICghdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlVGV4dGFyZWFQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5fY2FsY1RleHRhcmVhUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS5sZWZ0ID0gc3R5bGUubGVmdDtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS50b3AgPSBzdHlsZS50b3A7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBjb250YWlucyBzdHlsZSBmb3IgaGlkZGVuVGV4dGFyZWFcbiAgICAgKi9cbiAgICBfY2FsY1RleHRhcmVhUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4geyB4OiAxLCB5OiAxIH07XG4gICAgICB9XG4gICAgICB2YXIgZGVzaXJlZFBvc3Rpb24gPSB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5jb21wb3NpdGlvblN0YXJ0IDogdGhpcy5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBib3VuZGFyaWVzID0gdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllcyhkZXNpcmVkUG9zdGlvbiksXG4gICAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oZGVzaXJlZFBvc3Rpb24pLFxuICAgICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgICAgY2hhckhlaWdodCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdmb250U2l6ZScpICogdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSBib3VuZGFyaWVzLmxlZnRPZmZzZXQsXG4gICAgICAgICAgbSA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgIHAgPSB7XG4gICAgICAgICAgICB4OiBib3VuZGFyaWVzLmxlZnQgKyBsZWZ0T2Zmc2V0LFxuICAgICAgICAgICAgeTogYm91bmRhcmllcy50b3AgKyBib3VuZGFyaWVzLnRvcE9mZnNldCArIGNoYXJIZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwcGVyQ2FudmFzID0gdGhpcy5jYW52YXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICB1cHBlckNhbnZhc1dpZHRoID0gdXBwZXJDYW52YXMud2lkdGgsXG4gICAgICAgICAgdXBwZXJDYW52YXNIZWlnaHQgPSB1cHBlckNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgbWF4V2lkdGggPSB1cHBlckNhbnZhc1dpZHRoIC0gY2hhckhlaWdodCxcbiAgICAgICAgICBtYXhIZWlnaHQgPSB1cHBlckNhbnZhc0hlaWdodCAtIGNoYXJIZWlnaHQsXG4gICAgICAgICAgc2NhbGVYID0gdXBwZXJDYW52YXMuY2xpZW50V2lkdGggLyB1cHBlckNhbnZhc1dpZHRoLFxuICAgICAgICAgIHNjYWxlWSA9IHVwcGVyQ2FudmFzLmNsaWVudEhlaWdodCAvIHVwcGVyQ2FudmFzSGVpZ2h0O1xuXG4gICAgICBwID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocCwgbSk7XG4gICAgICBwID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocCwgdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm0pO1xuICAgICAgcC54ICo9IHNjYWxlWDtcbiAgICAgIHAueSAqPSBzY2FsZVk7XG4gICAgICBpZiAocC54IDwgMCkge1xuICAgICAgICBwLnggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHAueCA+IG1heFdpZHRoKSB7XG4gICAgICAgIHAueCA9IG1heFdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHAueSA8IDApIHtcbiAgICAgICAgcC55ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnkgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgcC55ID0gbWF4SGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgY2FudmFzIG9mZnNldCBvbiBkb2N1bWVudFxuICAgICAgcC54ICs9IHRoaXMuY2FudmFzLl9vZmZzZXQubGVmdDtcbiAgICAgIHAueSArPSB0aGlzLmNhbnZhcy5fb2Zmc2V0LnRvcDtcblxuICAgICAgcmV0dXJuIHsgbGVmdDogcC54ICsgJ3B4JywgdG9wOiBwLnkgKyAncHgnLCBmb250U2l6ZTogY2hhckhlaWdodCArICdweCcsIGNoYXJIZWlnaHQ6IGNoYXJIZWlnaHQgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2F2ZUVkaXRpbmdQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9zYXZlZFByb3BzID0ge1xuICAgICAgICBoYXNDb250cm9sczogdGhpcy5oYXNDb250cm9scyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMuYm9yZGVyQ29sb3IsXG4gICAgICAgIGxvY2tNb3ZlbWVudFg6IHRoaXMubG9ja01vdmVtZW50WCxcbiAgICAgICAgbG9ja01vdmVtZW50WTogdGhpcy5sb2NrTW92ZW1lbnRZLFxuICAgICAgICBob3ZlckN1cnNvcjogdGhpcy5ob3ZlckN1cnNvcixcbiAgICAgICAgZGVmYXVsdEN1cnNvcjogdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvcixcbiAgICAgICAgbW92ZUN1cnNvcjogdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMubW92ZUN1cnNvclxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzdG9yZUVkaXRpbmdQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX3NhdmVkUHJvcHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhvdmVyQ3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5ob3ZlckN1cnNvcjtcbiAgICAgIHRoaXMuaGFzQ29udHJvbHMgPSB0aGlzLl9zYXZlZFByb3BzLmhhc0NvbnRyb2xzO1xuICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IHRoaXMuX3NhdmVkUHJvcHMuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFggPSB0aGlzLl9zYXZlZFByb3BzLmxvY2tNb3ZlbWVudFg7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFkgPSB0aGlzLl9zYXZlZFByb3BzLmxvY2tNb3ZlbWVudFk7XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5kZWZhdWx0Q3Vyc29yO1xuICAgICAgICB0aGlzLmNhbnZhcy5tb3ZlQ3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5tb3ZlQ3Vyc29yO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGl0cyBmcm9tIGVkaXRpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZXhpdEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzVGV4dENoYW5nZWQgPSAodGhpcy5fdGV4dEJlZm9yZUVkaXQgIT09IHRoaXMudGV4dCk7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdHJ1ZTtcblxuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuXG4gICAgICBpZiAodGhpcy5oaWRkZW5UZXh0YXJlYSkge1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLmJsdXIgJiYgdGhpcy5oaWRkZW5UZXh0YXJlYS5ibHVyKCk7XG4gICAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuaGlkZGVuVGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmhpZGRlblRleHRhcmVhKTtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuX3Jlc3RvcmVFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMDtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdlZGl0aW5nOmV4aXRlZCcpO1xuICAgICAgaXNUZXh0Q2hhbmdlZCAmJiB0aGlzLmZpcmUoJ21vZGlmaWVkJyk7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMub2ZmKCdtb3VzZTptb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDplZGl0aW5nOmV4aXRlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgICBpc1RleHRDaGFuZ2VkICYmIHRoaXMuY2FudmFzLmZpcmUoJ29iamVjdDptb2RpZmllZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnN0eWxlcykge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHRMaW5lc1twcm9wXSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYW5kIHJlZmxvdyBhIHN0eWxlIGJsb2NrIGZyb20gc3RhcnQgdG8gZW5kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBsaW5lYXIgc3RhcnQgcG9zaXRpb24gZm9yIHJlbW92YWwgKGluY2x1ZGVkIGluIHJlbW92YWwpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBsaW5lYXIgZW5kIHBvc2l0aW9uIGZvciByZW1vdmFsICggZXhjbHVkZWQgZnJvbSByZW1vdmFsIClcbiAgICAgKi9cbiAgICByZW1vdmVTdHlsZUZyb21UbzogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGN1cnNvclN0YXJ0ID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBjdXJzb3JFbmQgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oZW5kLCB0cnVlKSxcbiAgICAgICAgICBsaW5lU3RhcnQgPSBjdXJzb3JTdGFydC5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhclN0YXJ0ID0gY3Vyc29yU3RhcnQuY2hhckluZGV4LFxuICAgICAgICAgIGxpbmVFbmQgPSBjdXJzb3JFbmQubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJFbmQgPSBjdXJzb3JFbmQuY2hhckluZGV4LFxuICAgICAgICAgIGksIHN0eWxlT2JqO1xuICAgICAgaWYgKGxpbmVTdGFydCAhPT0gbGluZUVuZCkge1xuICAgICAgICAvLyBzdGVwMSByZW1vdmUgdGhlIHRyYWlsaW5nIG9mIGxpbmVTdGFydFxuICAgICAgICBpZiAodGhpcy5zdHlsZXNbbGluZVN0YXJ0XSkge1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJTdGFydDsgaSA8IHRoaXMuX3Vud3JhcHBlZFRleHRMaW5lc1tsaW5lU3RhcnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZVN0YXJ0XVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RlcDIgbW92ZSB0aGUgdHJhaWxpbmcgb2YgbGluZUVuZCB0byBsaW5lU3RhcnQgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lRW5kXSkge1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJFbmQ7IGkgPCB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbbGluZUVuZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0eWxlT2JqID0gdGhpcy5zdHlsZXNbbGluZUVuZF1baV07XG4gICAgICAgICAgICBpZiAoc3R5bGVPYmopIHtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbGluZVN0YXJ0XSB8fCAodGhpcy5zdHlsZXNbbGluZVN0YXJ0XSA9IHsgfSk7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVTdGFydF1bY2hhclN0YXJ0ICsgaSAtIGNoYXJFbmRdID0gc3R5bGVPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXAzIGRldGVjdHMgbGluZXMgd2lsbCBiZSBjb21wbGV0ZWx5IHJlbW92ZWQuXG4gICAgICAgIGZvciAoaSA9IGxpbmVTdGFydCArIDE7IGkgPD0gbGluZUVuZDsgaSsrKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXA0IHNoaWZ0IHJlbWFpbmluZyBsaW5lcy5cbiAgICAgICAgdGhpcy5zaGlmdExpbmVTdHlsZXMobGluZUVuZCwgbGluZVN0YXJ0IC0gbGluZUVuZCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFuZCBzaGlmdCBsZWZ0IG9uIHRoZSBzYW1lIGxpbmVcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICBzdHlsZU9iaiA9IHRoaXMuc3R5bGVzW2xpbmVTdGFydF07XG4gICAgICAgICAgdmFyIGRpZmYgPSBjaGFyRW5kIC0gY2hhclN0YXJ0LCBudW1lcmljQ2hhciwgX2NoYXI7XG4gICAgICAgICAgZm9yIChpID0gY2hhclN0YXJ0OyBpIDwgY2hhckVuZDsgaSsrKSB7XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVPYmpbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoX2NoYXIgaW4gdGhpcy5zdHlsZXNbbGluZVN0YXJ0XSkge1xuICAgICAgICAgICAgbnVtZXJpY0NoYXIgPSBwYXJzZUludChfY2hhciwgMTApO1xuICAgICAgICAgICAgaWYgKG51bWVyaWNDaGFyID49IGNoYXJFbmQpIHtcbiAgICAgICAgICAgICAgc3R5bGVPYmpbbnVtZXJpY0NoYXIgLSBkaWZmXSA9IHN0eWxlT2JqW19jaGFyXTtcbiAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqW19jaGFyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hpZnRzIGxpbmUgc3R5bGVzIHVwIG9yIGRvd25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgQ2FuIGFueSBudW1iZXI/XG4gICAgICovXG4gICAgc2hpZnRMaW5lU3R5bGVzOiBmdW5jdGlvbihsaW5lSW5kZXgsIG9mZnNldCkge1xuICAgICAgLy8gc2hpZnQgYWxsIGxpbmUgc3R5bGVzIGJ5IG9mZnNldCB1cHdhcmQgb3IgZG93bndhcmRcbiAgICAgIC8vIGRvIG5vdCBjbG9uZSBkZWVwLiB3ZSBuZWVkIG5ldyBhcnJheSwgbm90IG5ldyBzdHlsZSBvYmplY3RzXG4gICAgICB2YXIgY2xvbmVkU3R5bGVzID0gY2xvbmUodGhpcy5zdHlsZXMpO1xuICAgICAgZm9yICh2YXIgbGluZSBpbiB0aGlzLnN0eWxlcykge1xuICAgICAgICB2YXIgbnVtZXJpY0xpbmUgPSBwYXJzZUludChsaW5lLCAxMCk7XG4gICAgICAgIGlmIChudW1lcmljTGluZSA+IGxpbmVJbmRleCkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW251bWVyaWNMaW5lICsgb2Zmc2V0XSA9IGNsb25lZFN0eWxlc1tudW1lcmljTGluZV07XG4gICAgICAgICAgaWYgKCFjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmUgLSBvZmZzZXRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbnVtZXJpY0xpbmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXN0YXJ0Q3Vyc29ySWZOZWVkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9jdXJyZW50VGlja1N0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUuaXNBYm9ydGVkXG4gICAgICAgIHx8ICF0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgfHwgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlLmlzQWJvcnRlZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBuZXcgc3R5bGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IEluZGV4IG9mIGEgY2hhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdHkgbnVtYmVyIG9mIGxpbmVzIHRvIGFkZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvcGllZFN0eWxlIEFycmF5IG9mIG9iamVjdHMgc3R5bGVzXG4gICAgICovXG4gICAgaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcXR5LCBjb3BpZWRTdHlsZSkge1xuICAgICAgdmFyIGN1cnJlbnRDaGFyU3R5bGUsXG4gICAgICAgICAgbmV3TGluZVN0eWxlcyA9IHt9LFxuICAgICAgICAgIHNvbWV0aGluZ0FkZGVkID0gZmFsc2U7XG5cbiAgICAgIHF0eSB8fCAocXR5ID0gMSk7XG4gICAgICB0aGlzLnNoaWZ0TGluZVN0eWxlcyhsaW5lSW5kZXgsIHF0eSk7XG4gICAgICBpZiAodGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICBjdXJyZW50Q2hhclN0eWxlID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggPT09IDAgPyBjaGFySW5kZXggOiBjaGFySW5kZXggLSAxXTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgY2xvbmUgc3R5bGVzIG9mIGFsbCBjaGFyc1xuICAgICAgLy8gYWZ0ZXIgY3Vyc29yIG9udG8gdGhlIGN1cnJlbnQgbGluZVxuICAgICAgZm9yICh2YXIgaW5kZXggaW4gdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICB2YXIgbnVtSW5kZXggPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgICAgICBpZiAobnVtSW5kZXggPj0gY2hhckluZGV4KSB7XG4gICAgICAgICAgc29tZXRoaW5nQWRkZWQgPSB0cnVlO1xuICAgICAgICAgIG5ld0xpbmVTdHlsZXNbbnVtSW5kZXggLSBjaGFySW5kZXhdID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XVtpbmRleF07XG4gICAgICAgICAgLy8gcmVtb3ZlIGxpbmVzIGZyb20gdGhlIHByZXZpb3VzIGxpbmUgc2luY2UgdGhleSdyZSBvbiBhIG5ldyBsaW5lIG5vd1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNvbWV0aGluZ0FkZGVkKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV0gPSBuZXdMaW5lU3R5bGVzO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldO1xuICAgICAgfVxuICAgICAgLy8gZm9yIHRoZSBvdGhlciBsaW5lc1xuICAgICAgLy8gd2UgY2xvbmUgY3VycmVudCBjaGFyIHN0eWxlIG9udG8gdGhlIG5leHQgKG90aGVyd2lzZSBlbXB0eSkgbGluZVxuICAgICAgd2hpbGUgKHF0eSA+IDEpIHtcbiAgICAgICAgcXR5LS07XG4gICAgICAgIGlmIChjb3BpZWRTdHlsZSAmJiBjb3BpZWRTdHlsZVtxdHldKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XSA9IHsgMDogY2xvbmUoY29waWVkU3R5bGVbcXR5XSkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50Q2hhclN0eWxlKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XSA9IHsgMDogY2xvbmUoY3VycmVudENoYXJTdHlsZSkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBzdHlsZSBvYmplY3QgZm9yIGEgZ2l2ZW4gbGluZS9jaGFyIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IEluZGV4IG9mIGEgY2hhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdWFudGl0eSBudW1iZXIgU3R5bGUgb2JqZWN0IHRvIGluc2VydCwgaWYgZ2l2ZW5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb3BpZWRTdHlsZSBhcnJheSBvZiBzdHlsZSBvYmplY3NcbiAgICAgKi9cbiAgICBpbnNlcnRDaGFyU3R5bGVPYmplY3Q6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBxdWFudGl0eSwgY29waWVkU3R5bGUpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50TGluZVN0eWxlcyAgICAgICA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0sXG4gICAgICAgICAgY3VycmVudExpbmVTdHlsZXNDbG9uZWQgPSBjdXJyZW50TGluZVN0eWxlcyA/IGNsb25lKGN1cnJlbnRMaW5lU3R5bGVzKSA6IHt9O1xuXG4gICAgICBxdWFudGl0eSB8fCAocXVhbnRpdHkgPSAxKTtcbiAgICAgIC8vIHNoaWZ0IGFsbCBjaGFyIHN0eWxlcyBieSBxdWFudGl0eSBmb3J3YXJkXG4gICAgICAvLyAwLDEsMiwzIC0+IChjaGFySW5kZXg9MikgLT4gMCwxLDMsNCAtPiAoaW5zZXJ0IDIpIC0+IDAsMSwyLDMsNFxuICAgICAgZm9yICh2YXIgaW5kZXggaW4gY3VycmVudExpbmVTdHlsZXNDbG9uZWQpIHtcbiAgICAgICAgdmFyIG51bWVyaWNJbmRleCA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gICAgICAgIGlmIChudW1lcmljSW5kZXggPj0gY2hhckluZGV4KSB7XG4gICAgICAgICAgY3VycmVudExpbmVTdHlsZXNbbnVtZXJpY0luZGV4ICsgcXVhbnRpdHldID0gY3VycmVudExpbmVTdHlsZXNDbG9uZWRbbnVtZXJpY0luZGV4XTtcbiAgICAgICAgICAvLyBvbmx5IGRlbGV0ZSB0aGUgc3R5bGUgaWYgdGhlcmUgd2FzIG5vdGhpbmcgbW92ZWQgdGhlcmVcbiAgICAgICAgICBpZiAoIWN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkW251bWVyaWNJbmRleCAtIHF1YW50aXR5XSkge1xuICAgICAgICAgICAgZGVsZXRlIGN1cnJlbnRMaW5lU3R5bGVzW251bWVyaWNJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSB0cnVlO1xuICAgICAgaWYgKGNvcGllZFN0eWxlKSB7XG4gICAgICAgIHdoaWxlIChxdWFudGl0eS0tKSB7XG4gICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhjb3BpZWRTdHlsZVtxdWFudGl0eV0pLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleCArIHF1YW50aXR5XSA9IGNsb25lKGNvcGllZFN0eWxlW3F1YW50aXR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFjdXJyZW50TGluZVN0eWxlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV3U3R5bGUgPSBjdXJyZW50TGluZVN0eWxlc1tjaGFySW5kZXggPyBjaGFySW5kZXggLSAxIDogMV07XG4gICAgICB3aGlsZSAobmV3U3R5bGUgJiYgcXVhbnRpdHktLSkge1xuICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleCArIHF1YW50aXR5XSA9IGNsb25lKG5ld1N0eWxlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBzdHlsZSBvYmplY3QocylcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbnNlcnRlZFRleHQgQ2hhcmFjdGVycyBhdCB0aGUgbG9jYXRpb24gd2hlcmUgc3R5bGUgaXMgaW5zZXJ0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgY3Vyc29yIGluZGV4IGZvciBpbnNlcnRpbmcgc3R5bGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29waWVkU3R5bGVdIGFycmF5IG9mIHN0eWxlIG9iamVjdHMgdG8gaW5zZXJ0LlxuICAgICAqL1xuICAgIGluc2VydE5ld1N0eWxlQmxvY2s6IGZ1bmN0aW9uKGluc2VydGVkVGV4dCwgc3RhcnQsIGNvcGllZFN0eWxlKSB7XG4gICAgICB2YXIgY3Vyc29yTG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBhZGRlZExpbmVzID0gWzBdLCBsaW5lc0xlbmdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc2VydGVkVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5zZXJ0ZWRUZXh0W2ldID09PSAnXFxuJykge1xuICAgICAgICAgIGxpbmVzTGVuZ2h0Kys7XG4gICAgICAgICAgYWRkZWRMaW5lc1tsaW5lc0xlbmdodF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFkZGVkTGluZXNbbGluZXNMZW5naHRdKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhZGRlZExpbmVzWzBdID4gMCkge1xuICAgICAgICB0aGlzLmluc2VydENoYXJTdHlsZU9iamVjdChjdXJzb3JMb2MubGluZUluZGV4LCBjdXJzb3JMb2MuY2hhckluZGV4LCBhZGRlZExpbmVzWzBdLCBjb3BpZWRTdHlsZSk7XG4gICAgICAgIGNvcGllZFN0eWxlID0gY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGUuc2xpY2UoYWRkZWRMaW5lc1swXSArIDEpO1xuICAgICAgfVxuICAgICAgbGluZXNMZW5naHQgJiYgdGhpcy5pbnNlcnROZXdsaW5lU3R5bGVPYmplY3QoXG4gICAgICAgIGN1cnNvckxvYy5saW5lSW5kZXgsIGN1cnNvckxvYy5jaGFySW5kZXggKyBhZGRlZExpbmVzWzBdLCBsaW5lc0xlbmdodCk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpbmVzTGVuZ2h0OyBpKyspIHtcbiAgICAgICAgaWYgKGFkZGVkTGluZXNbaV0gPiAwKSB7XG4gICAgICAgICAgdGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3QoY3Vyc29yTG9jLmxpbmVJbmRleCArIGksIDAsIGFkZGVkTGluZXNbaV0sIGNvcGllZFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3BpZWRTdHlsZSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW2N1cnNvckxvYy5saW5lSW5kZXggKyBpXVswXSA9IGNvcGllZFN0eWxlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvcGllZFN0eWxlID0gY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGUuc2xpY2UoYWRkZWRMaW5lc1tpXSArIDEpO1xuICAgICAgfVxuICAgICAgLy8gd2UgdXNlIGkgb3V0c2lkZSB0aGUgbG9vcCB0byBnZXQgaXQgbGlrZSBsaW5lc0xlbmd0aFxuICAgICAgaWYgKGFkZGVkTGluZXNbaV0gPiAwKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0Q2hhclN0eWxlT2JqZWN0KGN1cnNvckxvYy5saW5lSW5kZXggKyBpLCAwLCBhZGRlZExpbmVzW2ldLCBjb3BpZWRTdHlsZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBhY2NvcmRpbmcgdG8gdGhlIG5lIHBvc3Rpb24gb2YgY3Vyc29yXG4gICAgICogbWltaWMgdGhlIGtleSAtIG1vdXNlIG5hdmlnYXRpb24gd2hlbiBzaGlmdCBpcyBwcmVzc2VkLlxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0OiBmdW5jdGlvbihzdGFydCwgZW5kLCBuZXdTZWxlY3Rpb24pIHtcbiAgICAgIGlmIChuZXdTZWxlY3Rpb24gPD0gc3RhcnQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG5ld1NlbGVjdGlvbiA+IHN0YXJ0ICYmIG5ld1NlbGVjdGlvbiA8IGVuZCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIG5ld1NlbGVjdGlvbiBpcyA+IHNlbGVjdGlvbiBzdGFydCBhbmQgZW5kXG4gICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0U2VsZWN0aW9uSW5Cb3VuZGFyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPiBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPCAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uRW5kID4gbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25FbmQgPCAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5JVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcImRiY2xpY2tcIiBldmVudCBoYW5kbGVyXG4gICAqL1xuICBpbml0RG91YmxlQ2xpY2tTaW11bGF0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgIC8vIGZvciBkb3VibGUgY2xpY2tcbiAgICB0aGlzLl9fbGFzdENsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgLy8gZm9yIHRyaXBsZSBjbGlja1xuICAgIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgdGhpcy5fX2xhc3RQb2ludGVyID0geyB9O1xuXG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciB0byBzaW11bGF0ZSB0cmlwbGUgY2xpY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9fbmV3Q2xpY2tUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG5ld1BvaW50ZXIgPSBvcHRpb25zLnBvaW50ZXI7XG4gICAgaWYgKHRoaXMuaXNUcmlwbGVDbGljayhuZXdQb2ludGVyKSkge1xuICAgICAgdGhpcy5maXJlKCd0cmlwbGVjbGljaycsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc3RvcEV2ZW50KG9wdGlvbnMuZSk7XG4gICAgfVxuICAgIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA9IHRoaXMuX19sYXN0Q2xpY2tUaW1lO1xuICAgIHRoaXMuX19sYXN0Q2xpY2tUaW1lID0gdGhpcy5fX25ld0NsaWNrVGltZTtcbiAgICB0aGlzLl9fbGFzdFBvaW50ZXIgPSBuZXdQb2ludGVyO1xuICAgIHRoaXMuX19sYXN0SXNFZGl0aW5nID0gdGhpcy5pc0VkaXRpbmc7XG4gICAgdGhpcy5fX2xhc3RTZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWQ7XG4gIH0sXG5cbiAgaXNUcmlwbGVDbGljazogZnVuY3Rpb24obmV3UG9pbnRlcikge1xuICAgIHJldHVybiB0aGlzLl9fbmV3Q2xpY2tUaW1lIC0gdGhpcy5fX2xhc3RDbGlja1RpbWUgPCA1MDAgJiZcbiAgICAgICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgLSB0aGlzLl9fbGFzdExhc3RDbGlja1RpbWUgPCA1MDAgJiZcbiAgICAgICAgdGhpcy5fX2xhc3RQb2ludGVyLnggPT09IG5ld1BvaW50ZXIueCAmJlxuICAgICAgICB0aGlzLl9fbGFzdFBvaW50ZXIueSA9PT0gbmV3UG9pbnRlci55O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N0b3BFdmVudDogZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGV2ZW50IGhhbmRsZXJzIHJlbGF0ZWQgdG8gY3Vyc29yIG9yIHNlbGVjdGlvblxuICAgKi9cbiAgaW5pdEN1cnNvclNlbGVjdGlvbkhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluaXRNb3VzZWRvd25IYW5kbGVyKCk7XG4gICAgdGhpcy5pbml0TW91c2V1cEhhbmRsZXIoKTtcbiAgICB0aGlzLmluaXRDbGlja3MoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZG91YmxlIGFuZCB0cmlwbGUgY2xpY2sgZXZlbnQgaGFuZGxlcnNcbiAgICovXG4gIGluaXRDbGlja3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub24oJ21vdXNlZGJsY2xpY2snLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLnNlbGVjdFdvcmQodGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKG9wdGlvbnMuZSkpO1xuICAgIH0pO1xuICAgIHRoaXMub24oJ3RyaXBsZWNsaWNrJywgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5zZWxlY3RMaW5lKHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBoYW5kbGVyIGZvciB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzIG5lZWRlZCBvbiBfbW91c2VEb3duXG4gICAqIGNhbiBiZSBvdmVycmlkZGVuIHRvIGRvIHNvbWV0aGluZyBkaWZmZXJlbnQuXG4gICAqIFNjb3BlIG9mIHRoaXMgaW1wbGVtZW50YXRpb24gaXM6IGZpbmQgdGhlIGNsaWNrIHBvc2l0aW9uLCBzZXQgc2VsZWN0aW9uU3RhcnRcbiAgICogZmluZCBzZWxlY3Rpb25FbmQsIGluaXRpYWxpemUgdGhlIGRyYXdpbmcgb2YgZWl0aGVyIGN1cnNvciBvciBzZWxlY3Rpb24gYXJlYVxuICAgKi9cbiAgX21vdXNlRG93bkhhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzIHx8ICF0aGlzLmVkaXRhYmxlIHx8IChvcHRpb25zLmUuYnV0dG9uICYmIG9wdGlvbnMuZS5idXR0b24gIT09IDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fX2lzTW91c2Vkb3duID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICB0aGlzLnNldEN1cnNvckJ5Q2xpY2sob3B0aW9ucy5lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXMgbmVlZGVkIG9uIG1vdXNlZG93bjpiZWZvcmVcbiAgICogY2FuIGJlIG92ZXJyaWRkZW4gdG8gZG8gc29tZXRoaW5nIGRpZmZlcmVudC5cbiAgICogU2NvcGUgb2YgdGhpcyBpbXBsZW1lbnRhdGlvbiBpczogdmVyaWZ5IHRoZSBvYmplY3QgaXMgYWxyZWFkeSBzZWxlY3RlZCB3aGVuIG1vdXNpbmcgZG93blxuICAgKi9cbiAgX21vdXNlRG93bkhhbmRsZXJCZWZvcmU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzIHx8ICF0aGlzLmVkaXRhYmxlIHx8IChvcHRpb25zLmUuYnV0dG9uICYmIG9wdGlvbnMuZS5idXR0b24gIT09IDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzID09PSB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0KSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwibW91c2Vkb3duXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdE1vdXNlZG93bkhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMuX21vdXNlRG93bkhhbmRsZXIpO1xuICAgIHRoaXMub24oJ21vdXNlZG93bjpiZWZvcmUnLCB0aGlzLl9tb3VzZURvd25IYW5kbGVyQmVmb3JlKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgXCJtb3VzZXVwXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdE1vdXNldXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwSGFuZGxlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHN0YW5kYXJkIGhhbmRlciBmb3IgbW91c2UgdXAsIG92ZXJyaWRhYmxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBtb3VzZVVwSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuX19pc01vdXNlZG93biA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5lZGl0YWJsZSB8fCB0aGlzLmdyb3VwIHx8XG4gICAgICAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb3B0aW9ucy50cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkKSB8fFxuICAgICAgKG9wdGlvbnMuZS5idXR0b24gJiYgb3B0aW9ucy5lLmJ1dHRvbiAhPT0gMSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHZhciBjdXJyZW50QWN0aXZlID0gdGhpcy5jYW52YXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIGlmIChjdXJyZW50QWN0aXZlICYmIGN1cnJlbnRBY3RpdmUgIT09IHRoaXMpIHtcbiAgICAgICAgLy8gYXZvaWQgcnVubmluZyB0aGlzIGxvZ2ljIHdoZW4gdGhlcmUgaXMgYW4gYWN0aXZlIG9iamVjdFxuICAgICAgICAvLyB0aGlzIGJlY2F1c2UgaXMgcG9zc2libGUgd2l0aCBzaGlmdCBjbGljayBhbmQgZmFzdCBjbGlja3MsXG4gICAgICAgIC8vIHRvIHJhcGlkbHkgZGVzZWxlY3QgYW5kIHJlc2VsZWN0IHRoaXMgb2JqZWN0IGFuZCB0cmlnZ2VyIGFuIGVudGVyRWRpdFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX19sYXN0U2VsZWN0ZWQgJiYgIXRoaXMuX19jb3JuZXIpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19sYXN0U2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW50ZXJFZGl0aW5nKG9wdGlvbnMuZSk7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcih0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIGN1cnNvciBsb2NhdGlvbiBpbiBhIHRleHQgZGVwZW5kaW5nIG9uIHBhc3NlZCBwb2ludGVyICh4L3kpIG9iamVjdFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgc2V0Q3Vyc29yQnlDbGljazogZnVuY3Rpb24oZSkge1xuICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIoZSksXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCwgZW5kID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhcnRFbmRXaXRoU2hpZnQoc3RhcnQsIGVuZCwgbmV3U2VsZWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb247XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRWRpdGluZykge1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGluZGV4IG9mIGEgY2hhcmFjdGVyIGNvcnJlc3BvbmRpbmcgdG8gd2hlcmUgYW4gb2JqZWN0IHdhcyBjbGlja2VkXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm4ge051bWJlcn0gSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICovXG4gIGdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbW91c2VPZmZzZXQgPSB0aGlzLmdldExvY2FsUG9pbnRlcihlKSxcbiAgICAgICAgcHJldldpZHRoID0gMCxcbiAgICAgICAgd2lkdGggPSAwLFxuICAgICAgICBoZWlnaHQgPSAwLFxuICAgICAgICBjaGFySW5kZXggPSAwLFxuICAgICAgICBsaW5lSW5kZXggPSAwLFxuICAgICAgICBsaW5lTGVmdE9mZnNldCxcbiAgICAgICAgbGluZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChoZWlnaHQgPD0gbW91c2VPZmZzZXQueSkge1xuICAgICAgICBoZWlnaHQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSkgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgbGluZUluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgY2hhckluZGV4ICs9IHRoaXMuX3RleHRMaW5lc1tpIC0gMV0ubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCk7XG4gICAgd2lkdGggPSBsaW5lTGVmdE9mZnNldCAqIHRoaXMuc2NhbGVYO1xuICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XTtcbiAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICBwcmV2V2lkdGggPSB3aWR0aDtcbiAgICAgIC8vIGkgcmVtb3ZlZCBzb21ldGhpbmcgYWJvdXQgZmxpcFggaGVyZSwgY2hlY2suXG4gICAgICB3aWR0aCArPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2pdLmtlcm5lZFdpZHRoICogdGhpcy5zY2FsZVg7XG4gICAgICBpZiAod2lkdGggPD0gbW91c2VPZmZzZXQueCkge1xuICAgICAgICBjaGFySW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldChtb3VzZU9mZnNldCwgcHJldldpZHRoLCB3aWR0aCwgY2hhckluZGV4LCBqbGVuKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXROZXdTZWxlY3Rpb25TdGFydEZyb21PZmZzZXQ6IGZ1bmN0aW9uKG1vdXNlT2Zmc2V0LCBwcmV2V2lkdGgsIHdpZHRoLCBpbmRleCwgamxlbikge1xuICAgIC8vIHdlIG5lZWQgTWF0aC5hYnMgYmVjYXVzZSB3aGVuIHdpZHRoIGlzIGFmdGVyIHRoZSBsYXN0IGNoYXIsIHRoZSBvZmZzZXQgaXMgZ2l2ZW4gYXMgMSwgd2hpbGUgaXMgMFxuICAgIHZhciBkaXN0YW5jZUJ0d0xhc3RDaGFyQW5kQ3Vyc29yID0gbW91c2VPZmZzZXQueCAtIHByZXZXaWR0aCxcbiAgICAgICAgZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciA9IHdpZHRoIC0gbW91c2VPZmZzZXQueCxcbiAgICAgICAgb2Zmc2V0ID0gZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciA+IGRpc3RhbmNlQnR3TGFzdENoYXJBbmRDdXJzb3IgfHxcbiAgICAgICAgICBkaXN0YW5jZUJ0d05leHRDaGFyQW5kQ3Vyc29yIDwgMCA/IDAgOiAxLFxuICAgICAgICBuZXdTZWxlY3Rpb25TdGFydCA9IGluZGV4ICsgb2Zmc2V0O1xuICAgIC8vIGlmIG9iamVjdCBpcyBob3Jpem9udGFsbHkgZmxpcHBlZCwgbWlycm9yIGN1cnNvciBsb2NhdGlvbiBmcm9tIHRoZSBlbmRcbiAgICBpZiAodGhpcy5mbGlwWCkge1xuICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSBqbGVuIC0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKG5ld1NlbGVjdGlvblN0YXJ0ID4gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5fdGV4dC5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1NlbGVjdGlvblN0YXJ0O1xuICB9XG59KTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5JVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGhpZGRlbiB0ZXh0YXJlYSAobmVlZGVkIHRvIGJyaW5nIHVwIGtleWJvYXJkIGluIGlPUylcbiAgICovXG4gIGluaXRIaWRkZW5UZXh0YXJlYTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYSA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScsICdvZmYnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NvcnJlY3QnLCAnb2ZmJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2F1dG9jb21wbGV0ZScsICdvZmYnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnc3BlbGxjaGVjaycsICdmYWxzZScpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdkYXRhLWZhYnJpYy1oaWRkZW50ZXh0YXJlYScsICcnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnd3JhcCcsICdvZmYnKTtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLl9jYWxjVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgIC8vIGxpbmUtaGVpZ2h0OiAxcHg7IHdhcyByZW1vdmVkIGZyb20gdGhlIHN0eWxlIHRvIGZpeCB0aGlzOlxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg3MDk2NlxuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogJyArIHN0eWxlLnRvcCArXG4gICAgJzsgbGVmdDogJyArIHN0eWxlLmxlZnQgKyAnOyB6LWluZGV4OiAtOTk5OyBvcGFjaXR5OiAwOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFweDsgZm9udC1zaXplOiAxcHg7JyArXG4gICAgJyBwYWRkaW5n772wdG9wOiAnICsgc3R5bGUuZm9udFNpemUgKyAnOyc7XG4gICAgZmFicmljLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5oaWRkZW5UZXh0YXJlYSk7XG5cbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAna2V5ZG93bicsIHRoaXMub25LZXlEb3duLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnaW5wdXQnLCB0aGlzLm9uSW5wdXQuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvcHknLCB0aGlzLmNvcHkuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2N1dCcsIHRoaXMuY29weS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAncGFzdGUnLCB0aGlzLnBhc3RlLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbnN0YXJ0JywgdGhpcy5vbkNvbXBvc2l0aW9uU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvbXBvc2l0aW9udXBkYXRlJywgdGhpcy5vbkNvbXBvc2l0aW9uVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbmVuZCcsIHRoaXMub25Db21wb3NpdGlvbkVuZC5iaW5kKHRoaXMpKTtcblxuICAgIGlmICghdGhpcy5fY2xpY2tIYW5kbGVySW5pdGlhbGl6ZWQgJiYgdGhpcy5jYW52YXMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuY2FudmFzLnVwcGVyQ2FudmFzRWwsICdjbGljaycsIHRoaXMub25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX2NsaWNrSGFuZGxlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBmdW5jdGlvbmFsaXRpZXMgb24ga2V5RG93blxuICAgKiBNYXAgYSBzcGVjaWFsIGtleSB0byBhIGZ1bmN0aW9uIG9mIHRoZSBpbnN0YW5jZS9wcm90b3R5cGVcbiAgICogSWYgeW91IG5lZWQgZGlmZmVyZW50IGJlaGF2aW91ciBmb3IgRVNDIG9yIFRBQiBvciBhcnJvd3MsIHlvdSBoYXZlIHRvIGNoYW5nZVxuICAgKiB0aGlzIG1hcCBzZXR0aW5nIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gdGhhdCB5b3UgYnVpbGQgb24gdGhlIGZhYnJpYy5JdGV4dCBvclxuICAgKiB5b3VyIHByb3RvdHlwZS5cbiAgICogdGhlIG1hcCBjaGFuZ2Ugd2lsbCBhZmZlY3QgYWxsIEluc3RhbmNlcyB1bmxlc3MgeW91IG5lZWQgZm9yIG9ubHkgc29tZSB0ZXh0IEluc3RhbmNlc1xuICAgKiBpbiB0aGF0IGNhc2UgeW91IGhhdmUgdG8gY2xvbmUgdGhpcyBvYmplY3QgYW5kIGFzc2lnbiB5b3VyIEluc3RhbmNlLlxuICAgKiB0aGlzLmtleXNNYXAgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5rZXlzTWFwKTtcbiAgICogVGhlIGZ1bmN0aW9uIG11c3QgYmUgaW4gZmFicmljLkl0ZXh0LnByb3RvdHlwZS5teUZ1bmN0aW9uIEFuZCB3aWxsIHJlY2VpdmUgZXZlbnQgYXMgYXJnc1swXVxuICAgKi9cbiAga2V5c01hcDoge1xuICAgIDk6ICAnZXhpdEVkaXRpbmcnLFxuICAgIDI3OiAnZXhpdEVkaXRpbmcnLFxuICAgIDMzOiAnbW92ZUN1cnNvclVwJyxcbiAgICAzNDogJ21vdmVDdXJzb3JEb3duJyxcbiAgICAzNTogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgMzY6ICdtb3ZlQ3Vyc29yTGVmdCcsXG4gICAgMzc6ICdtb3ZlQ3Vyc29yTGVmdCcsXG4gICAgMzg6ICdtb3ZlQ3Vyc29yVXAnLFxuICAgIDM5OiAnbW92ZUN1cnNvclJpZ2h0JyxcbiAgICA0MDogJ21vdmVDdXJzb3JEb3duJyxcbiAgfSxcblxuICAvKipcbiAgICogRm9yIGZ1bmN0aW9uYWxpdGllcyBvbiBrZXlVcCArIGN0cmwgfHwgY21kXG4gICAqL1xuICBjdHJsS2V5c01hcFVwOiB7XG4gICAgNjc6ICdjb3B5JyxcbiAgICA4ODogJ2N1dCdcbiAgfSxcblxuICAvKipcbiAgICogRm9yIGZ1bmN0aW9uYWxpdGllcyBvbiBrZXlEb3duICsgY3RybCB8fCBjbWRcbiAgICovXG4gIGN0cmxLZXlzTWFwRG93bjoge1xuICAgIDY1OiAnc2VsZWN0QWxsJ1xuICB9LFxuXG4gIG9uQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgIC8vIE5vIG5lZWQgdG8gdHJpZ2dlciBjbGljayBldmVudCBoZXJlLCBmb2N1cyBpcyBlbm91Z2ggdG8gaGF2ZSB0aGUga2V5Ym9hcmQgYXBwZWFyIG9uIEFuZHJvaWRcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhICYmIHRoaXMuaGlkZGVuVGV4dGFyZWEuZm9jdXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBrZXl1cCBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgb25LZXlEb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZyB8fCB0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLmtleUNvZGUgaW4gdGhpcy5rZXlzTWFwKSB7XG4gICAgICB0aGlzW3RoaXMua2V5c01hcFtlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGUua2V5Q29kZSBpbiB0aGlzLmN0cmxLZXlzTWFwRG93bikgJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpKSB7XG4gICAgICB0aGlzW3RoaXMuY3RybEtleXNNYXBEb3duW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGUua2V5Q29kZSA+PSAzMyAmJiBlLmtleUNvZGUgPD0gNDApIHtcbiAgICAgIC8vIGlmIGkgcHJlc3MgYW4gYXJyb3cga2V5IGp1c3QgdXBkYXRlIHNlbGVjdGlvblxuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleXVwIGV2ZW50XG4gICAqIFdlIGhhbmRsZSBLZXlVcCBiZWNhdXNlIGllMTEgYW5kIGVkZ2UgaGF2ZSBkaWZmaWN1bHRpZXMgY29weS9wYXN0aW5nXG4gICAqIGlmIGEgY29weS9jdXQgZXZlbnQgZmlyZWQsIGtleXVwIGlzIGRpc21pc3NlZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgb25LZXlVcDogZnVuY3Rpb24oZSkge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgdGhpcy5fY29weURvbmUgfHwgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgdGhpcy5fY29weURvbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChlLmtleUNvZGUgaW4gdGhpcy5jdHJsS2V5c01hcFVwKSAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkpIHtcbiAgICAgIHRoaXNbdGhpcy5jdHJsS2V5c01hcFVwW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIG9uSW5wdXQgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uSW5wdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZnJvbVBhc3RlID0gdGhpcy5mcm9tUGFzdGU7XG4gICAgdGhpcy5mcm9tUGFzdGUgPSBmYWxzZTtcbiAgICBlICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBkZWNpc2lvbnMgYWJvdXQgc3R5bGUgY2hhbmdlcy5cbiAgICB2YXIgbmV4dFRleHQgPSB0aGlzLl9zcGxpdFRleHRJbnRvTGluZXModGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSkuZ3JhcGhlbWVUZXh0LFxuICAgICAgICBjaGFyQ291bnQgPSB0aGlzLl90ZXh0Lmxlbmd0aCxcbiAgICAgICAgbmV4dENoYXJDb3VudCA9IG5leHRUZXh0Lmxlbmd0aCxcbiAgICAgICAgcmVtb3ZlZFRleHQsIGluc2VydGVkVGV4dCxcbiAgICAgICAgY2hhckRpZmYgPSBuZXh0Q2hhckNvdW50IC0gY2hhckNvdW50O1xuICAgIGlmICh0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlID09PSAnJykge1xuICAgICAgdGhpcy5zdHlsZXMgPSB7IH07XG4gICAgICB0aGlzLnVwZGF0ZUZyb21UZXh0QXJlYSgpO1xuICAgICAgdGhpcy5maXJlKCdjaGFuZ2VkJyk7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDpjaGFuZ2VkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dGFyZWFTZWxlY3Rpb24gPSB0aGlzLmZyb21TdHJpbmdUb0dyYXBoZW1lU2VsZWN0aW9uKFxuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kLFxuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZVxuICAgICk7XG4gICAgdmFyIGJhY2tEZWxldGUgPSB0aGlzLnNlbGVjdGlvblN0YXJ0ID4gdGV4dGFyZWFTZWxlY3Rpb24uc2VsZWN0aW9uU3RhcnQ7XG5cbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIHJlbW92ZWRUZXh0ID0gdGhpcy5fdGV4dC5zbGljZSh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCk7XG4gICAgICBjaGFyRGlmZiArPSB0aGlzLnNlbGVjdGlvbkVuZCAtIHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5leHRDaGFyQ291bnQgPCBjaGFyQ291bnQpIHtcbiAgICAgIGlmIChiYWNrRGVsZXRlKSB7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gdGhpcy5fdGV4dC5zbGljZSh0aGlzLnNlbGVjdGlvbkVuZCArIGNoYXJEaWZmLCB0aGlzLnNlbGVjdGlvbkVuZCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlZFRleHQgPSB0aGlzLl90ZXh0LnNsaWNlKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uU3RhcnQgLSBjaGFyRGlmZik7XG4gICAgICB9XG4gICAgfVxuICAgIGluc2VydGVkVGV4dCA9IG5leHRUZXh0LnNsaWNlKHRleHRhcmVhU2VsZWN0aW9uLnNlbGVjdGlvbkVuZCAtIGNoYXJEaWZmLCB0ZXh0YXJlYVNlbGVjdGlvbi5zZWxlY3Rpb25FbmQpO1xuICAgIGlmIChyZW1vdmVkVGV4dCAmJiByZW1vdmVkVGV4dC5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLnJlbW92ZVN0eWxlRnJvbVRvKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJhY2tEZWxldGUpIHtcbiAgICAgICAgLy8gZGV0ZWN0IGRpZmZlcmVuY2llcyBiZXR3ZWVuIGZvcndhcmREZWxldGUgYW5kIGJhY2tEZWxldGVcbiAgICAgICAgdGhpcy5yZW1vdmVTdHlsZUZyb21Ubyh0aGlzLnNlbGVjdGlvbkVuZCAtIHJlbW92ZWRUZXh0Lmxlbmd0aCwgdGhpcy5zZWxlY3Rpb25FbmQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8odGhpcy5zZWxlY3Rpb25FbmQsIHRoaXMuc2VsZWN0aW9uRW5kICsgcmVtb3ZlZFRleHQubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc2VydGVkVGV4dC5sZW5ndGgpIHtcbiAgICAgIGlmIChmcm9tUGFzdGUgJiYgaW5zZXJ0ZWRUZXh0LmpvaW4oJycpID09PSBmYWJyaWMuY29waWVkVGV4dCkge1xuICAgICAgICB0aGlzLmluc2VydE5ld1N0eWxlQmxvY2soaW5zZXJ0ZWRUZXh0LCB0aGlzLnNlbGVjdGlvblN0YXJ0LCBmYWJyaWMuY29waWVkVGV4dFN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmluc2VydE5ld1N0eWxlQmxvY2soaW5zZXJ0ZWRUZXh0LCB0aGlzLnNlbGVjdGlvblN0YXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51cGRhdGVGcm9tVGV4dEFyZWEoKTtcbiAgICB0aGlzLmZpcmUoJ2NoYW5nZWQnKTtcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6Y2hhbmdlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIENvbXBvc2l0aW9uIHN0YXJ0XG4gICAqL1xuICBvbkNvbXBvc2l0aW9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wb3NpdGlvbiBlbmRcbiAgICovXG4gIG9uQ29tcG9zaXRpb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSBmYWxzZTtcbiAgfSxcblxuICAvLyAvKipcbiAgLy8gICogQ29tcG9zaXRpb24gdXBkYXRlXG4gIC8vICAqL1xuICBvbkNvbXBvc2l0aW9uVXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5jb21wb3NpdGlvblN0YXJ0ID0gZS50YXJnZXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgdGhpcy5jb21wb3NpdGlvbkVuZCA9IGUudGFyZ2V0LnNlbGVjdGlvbkVuZDtcbiAgICB0aGlzLnVwZGF0ZVRleHRhcmVhUG9zaXRpb24oKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29waWVzIHNlbGVjdGVkIHRleHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgLy9kbyBub3QgY3V0LWNvcHkgaWYgbm8gc2VsZWN0aW9uXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmFicmljLmNvcGllZFRleHQgPSB0aGlzLmdldFNlbGVjdGVkVGV4dCgpO1xuICAgIGZhYnJpYy5jb3BpZWRUZXh0U3R5bGUgPSB0aGlzLmdldFNlbGVjdGlvblN0eWxlcyh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCwgdHJ1ZSk7XG4gICAgdGhpcy5fY29weURvbmUgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXN0ZXMgdGV4dFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgcGFzdGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZnJvbVBhc3RlID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0fSBDbGlwYm9hcmQgZGF0YSBvYmplY3RcbiAgICovXG4gIF9nZXRDbGlwYm9hcmREYXRhOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIChlICYmIGUuY2xpcGJvYXJkRGF0YSkgfHwgZmFicmljLndpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgd2lkdGggaW4gcGl4ZWxzIGJlZm9yZSB0aGUgY3Vyc29yIG9uIHRoZSBzYW1lIGxpbmVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAqIEByZXR1cm4ge051bWJlcn0gd2lkdGhCZWZvcmVDdXJzb3Igd2lkdGggYmVmb3JlIGN1cnNvclxuICAgKi9cbiAgX2dldFdpZHRoQmVmb3JlQ3Vyc29yOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgIHZhciB3aWR0aEJlZm9yZUN1cnNvciA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCksIGJvdW5kO1xuXG4gICAgaWYgKGNoYXJJbmRleCA+IDApIHtcbiAgICAgIGJvdW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtjaGFySW5kZXggLSAxXTtcbiAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yICs9IGJvdW5kLmxlZnQgKyBib3VuZC53aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoQmVmb3JlQ3Vyc29yO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHN0YXJ0IG9mZnNldCBvZiBhIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0RG93bkN1cnNvck9mZnNldDogZnVuY3Rpb24oZSwgaXNSaWdodCkge1xuICAgIHZhciBzZWxlY3Rpb25Qcm9wID0gdGhpcy5fZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0KGUsIGlzUmlnaHQpLFxuICAgICAgICBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25Qcm9wKSxcbiAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4O1xuICAgIC8vIGlmIG9uIGxhc3QgbGluZSwgZG93biBjdXJzb3IgZ29lcyB0byBlbmQgb2YgbGluZVxuICAgIGlmIChsaW5lSW5kZXggPT09IHRoaXMuX3RleHRMaW5lcy5sZW5ndGggLSAxIHx8IGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDM0KSB7XG4gICAgICAvLyBtb3ZlIHRvIHRoZSBlbmQgb2YgYSB0ZXh0XG4gICAgICByZXR1cm4gdGhpcy5fdGV4dC5sZW5ndGggLSBzZWxlY3Rpb25Qcm9wO1xuICAgIH1cbiAgICB2YXIgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4LFxuICAgICAgICB3aWR0aEJlZm9yZUN1cnNvciA9IHRoaXMuX2dldFdpZHRoQmVmb3JlQ3Vyc29yKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgaW5kZXhPbk90aGVyTGluZSA9IHRoaXMuX2dldEluZGV4T25MaW5lKGxpbmVJbmRleCArIDEsIHdpZHRoQmVmb3JlQ3Vyc29yKSxcbiAgICAgICAgdGV4dEFmdGVyQ3Vyc29yID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0uc2xpY2UoY2hhckluZGV4KTtcbiAgICByZXR1cm4gdGV4dEFmdGVyQ3Vyc29yLmxlbmd0aCArIGluZGV4T25PdGhlckxpbmUgKyAyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBwcml2YXRlXG4gICAqIEhlbHBzIGZpbmRpbmcgaWYgdGhlIG9mZnNldCBzaG91bGQgYmUgY291bnRlZCBmcm9tIFN0YXJ0IG9yIEVuZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgX2dldFNlbGVjdGlvbkZvck9mZnNldDogZnVuY3Rpb24oZSwgaXNSaWdodCkge1xuICAgIGlmIChlLnNoaWZ0S2V5ICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kICYmIGlzUmlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSaWdodFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRVcEN1cnNvck9mZnNldDogZnVuY3Rpb24oZSwgaXNSaWdodCkge1xuICAgIHZhciBzZWxlY3Rpb25Qcm9wID0gdGhpcy5fZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0KGUsIGlzUmlnaHQpLFxuICAgICAgICBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25Qcm9wKSxcbiAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4O1xuICAgIGlmIChsaW5lSW5kZXggPT09IDAgfHwgZS5tZXRhS2V5IHx8IGUua2V5Q29kZSA9PT0gMzMpIHtcbiAgICAgIC8vIGlmIG9uIGZpcnN0IGxpbmUsIHVwIGN1cnNvciBnb2VzIHRvIHN0YXJ0IG9mIGxpbmVcbiAgICAgIHJldHVybiAtc2VsZWN0aW9uUHJvcDtcbiAgICB9XG4gICAgdmFyIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCxcbiAgICAgICAgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRXaWR0aEJlZm9yZUN1cnNvcihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgIGluZGV4T25PdGhlckxpbmUgPSB0aGlzLl9nZXRJbmRleE9uTGluZShsaW5lSW5kZXggLSAxLCB3aWR0aEJlZm9yZUN1cnNvciksXG4gICAgICAgIHRleHRCZWZvcmVDdXJzb3IgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XS5zbGljZSgwLCBjaGFySW5kZXgpO1xuICAgIC8vIHJldHVybiBhIG5lZ2F0aXZlIG9mZnNldFxuICAgIHJldHVybiAtdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleCAtIDFdLmxlbmd0aCArIGluZGV4T25PdGhlckxpbmUgLSB0ZXh0QmVmb3JlQ3Vyc29yLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogZm9yIGEgZ2l2ZW4gd2lkdGggaXQgZm91bmRzIHRoZSBtYXRjaGluZyBjaGFyYWN0ZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SW5kZXhPbkxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCwgd2lkdGgpIHtcblxuICAgIHZhciBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sXG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZUluZGV4KSxcbiAgICAgICAgd2lkdGhPZkNoYXJzT25MaW5lID0gbGluZUxlZnRPZmZzZXQsXG4gICAgICAgIGluZGV4T25MaW5lID0gMCwgY2hhcldpZHRoLCBmb3VuZE1hdGNoO1xuXG4gICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgY2hhcldpZHRoID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtqXS53aWR0aDtcbiAgICAgIHdpZHRoT2ZDaGFyc09uTGluZSArPSBjaGFyV2lkdGg7XG4gICAgICBpZiAod2lkdGhPZkNoYXJzT25MaW5lID4gd2lkdGgpIHtcbiAgICAgICAgZm91bmRNYXRjaCA9IHRydWU7XG4gICAgICAgIHZhciBsZWZ0RWRnZSA9IHdpZHRoT2ZDaGFyc09uTGluZSAtIGNoYXJXaWR0aCxcbiAgICAgICAgICAgIHJpZ2h0RWRnZSA9IHdpZHRoT2ZDaGFyc09uTGluZSxcbiAgICAgICAgICAgIG9mZnNldEZyb21MZWZ0RWRnZSA9IE1hdGguYWJzKGxlZnRFZGdlIC0gd2lkdGgpLFxuICAgICAgICAgICAgb2Zmc2V0RnJvbVJpZ2h0RWRnZSA9IE1hdGguYWJzKHJpZ2h0RWRnZSAtIHdpZHRoKTtcblxuICAgICAgICBpbmRleE9uTGluZSA9IG9mZnNldEZyb21SaWdodEVkZ2UgPCBvZmZzZXRGcm9tTGVmdEVkZ2UgPyBqIDogKGogLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVhY2hlZCBlbmRcbiAgICBpZiAoIWZvdW5kTWF0Y2gpIHtcbiAgICAgIGluZGV4T25MaW5lID0gbGluZS5sZW5ndGggLSAxO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleE9uTGluZTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgZG93blxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvckRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yVXBPckRvd24oJ0Rvd24nLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHVwXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yVXA6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yVXBPckRvd24oJ1VwJywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cCBvciBkb3duLCBmaXJlcyB0aGUgZXZlbnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gJ1VwJyBvciAnRG93bidcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIF9tb3ZlQ3Vyc29yVXBPckRvd246IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIC8vIGdldFVwQ3Vyc29yT2Zmc2V0XG4gICAgLy8gZ2V0RG93bkN1cnNvck9mZnNldFxuICAgIHZhciBhY3Rpb24gPSAnZ2V0JyArIGRpcmVjdGlvbiArICdDdXJzb3JPZmZzZXQnLFxuICAgICAgICBvZmZzZXQgPSB0aGlzW2FjdGlvbl0oZSwgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKTtcbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgdGhpcy5tb3ZlQ3Vyc29yV2l0aFNoaWZ0KG9mZnNldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlQ3Vyc29yV2l0aG91dFNoaWZ0KG9mZnNldCk7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uSW5Cb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDE7XG4gICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB3aXRoIHNoaWZ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIG1vdmVDdXJzb3JXaXRoU2hpZnQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0J1xuICAgICAgPyB0aGlzLnNlbGVjdGlvblN0YXJ0ICsgb2Zmc2V0XG4gICAgICA6IHRoaXMuc2VsZWN0aW9uRW5kICsgb2Zmc2V0O1xuICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhcnRFbmRXaXRoU2hpZnQodGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsIG5ld1NlbGVjdGlvbik7XG4gICAgcmV0dXJuIG9mZnNldCAhPT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHVwIHdpdGhvdXQgc2hpZnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgbW92ZUN1cnNvcldpdGhvdXRTaGlmdDogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kICs9IG9mZnNldDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCAhPT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGxlZnRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JMZWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IDAgJiYgdGhpcy5zZWxlY3Rpb25FbmQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvckxlZnRPclJpZ2h0KCdMZWZ0JywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIF9tb3ZlOiBmdW5jdGlvbihlLCBwcm9wLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgbmV3VmFsdWU7XG4gICAgaWYgKGUuYWx0S2V5KSB7XG4gICAgICBuZXdWYWx1ZSA9IHRoaXNbJ2ZpbmRXb3JkQm91bmRhcnknICsgZGlyZWN0aW9uXSh0aGlzW3Byb3BdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZS5tZXRhS2V5IHx8IGUua2V5Q29kZSA9PT0gMzUgfHwgIGUua2V5Q29kZSA9PT0gMzYgKSB7XG4gICAgICBuZXdWYWx1ZSA9IHRoaXNbJ2ZpbmRMaW5lQm91bmRhcnknICsgZGlyZWN0aW9uXSh0aGlzW3Byb3BdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzW3Byb3BdICs9IGRpcmVjdGlvbiA9PT0gJ0xlZnQnID8gLTEgOiAxO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3VmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzW3Byb3BdICE9PSBuZXdWYWx1ZSkge1xuICAgICAgdGhpc1twcm9wXSA9IG5ld1ZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdmVMZWZ0OiBmdW5jdGlvbihlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdmUoZSwgcHJvcCwgJ0xlZnQnKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb3ZlUmlnaHQ6IGZ1bmN0aW9uKGUsIHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZShlLCBwcm9wLCAnUmlnaHQnKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGxlZnQgd2l0aG91dCBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdFdpdGhvdXRTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIHZhciBjaGFuZ2UgPSB0cnVlO1xuICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcblxuICAgIC8vIG9ubHkgbW92ZSBjdXJzb3Igd2hlbiB0aGVyZSBpcyBubyBzZWxlY3Rpb24sXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGRpc2NhcmQgaXQsIGFuZCBsZWF2ZSBjdXJzb3Igb24gc2FtZSBwbGFjZVxuICAgIGlmICh0aGlzLnNlbGVjdGlvbkVuZCA9PT0gdGhpcy5zZWxlY3Rpb25TdGFydCAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSAwKSB7XG4gICAgICBjaGFuZ2UgPSB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcblxuICAgIH1cbiAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGxlZnQgd2hpbGUga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvckxlZnRXaXRoU2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZUxlZnQoZSwgJ3NlbGVjdGlvbkVuZCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSAwKXtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPj0gdGhpcy5fdGV4dC5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25FbmQgPj0gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvckxlZnRPclJpZ2h0KCdSaWdodCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgb3IgTGVmdCwgZmlyZXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAnTGVmdCcsICdSaWdodCdcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIF9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQ6IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIHZhciBhY3Rpb25OYW1lID0gJ21vdmVDdXJzb3InICsgZGlyZWN0aW9uICsgJ1dpdGgnO1xuICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcblxuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICBhY3Rpb25OYW1lICs9ICdTaGlmdCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWN0aW9uTmFtZSArPSAnb3V0U2hpZnQnO1xuICAgIH1cbiAgICBpZiAodGhpc1thY3Rpb25OYW1lXShlKSkge1xuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgd2hpbGUga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0V2l0aFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbkVuZCAhPT0gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25FbmQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodCB3aXRob3V0IGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yUmlnaHRXaXRob3V0U2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcblxuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgY2hhbmdlZCA9IHRoaXMuX21vdmVSaWdodChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGNoYXJhY3RlcnMgZnJvbSBzdGFydC9lbmRcbiAgICogc3RhcnQvZW5kIGFyIHBlciBncmFwaGVtZSBwb3NpdGlvbiBpbiBfdGV4dCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgZGVmYXVsdCB0byBzdGFydCArIDFcbiAgICovXG4gIHJlbW92ZUNoYXJzOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8oc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5fdGV4dC5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbiAgICB0aGlzLnRleHQgPSB0aGlzLl90ZXh0LmpvaW4oJycpO1xuICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogaW5zZXJ0IGNoYXJhY3RlcnMgYXQgc3RhcnQgcG9zaXRpb24sIGJlZm9yZSBzdGFydCBwb3NpdGlvbi5cbiAgICogc3RhcnQgIGVxdWFsIDEgaXQgbWVhbnMgdGhlIHRleHQgZ2V0IGluc2VydGVkIGJldHdlZW4gYWN0dWFsIGdyYXBoZW1lIDAgYW5kIDFcbiAgICogaWYgc3R5bGUgYXJyYXkgaXMgcHJvdmlkZWQsIGl0IG11c3QgYmUgYXMgdGhlIHNhbWUgbGVuZ3RoIG9mIHRleHQgaW4gZ3JhcGhlbWVzXG4gICAqIGlmIGVuZCBpcyBwcm92aWRlZCBhbmQgaXMgYmlnZ2VyIHRoYW4gc3RhcnQsIG9sZCB0ZXh0IGlzIHJlcGxhY2VkLlxuICAgKiBzdGFydC9lbmQgYXIgcGVyIGdyYXBoZW1lIHBvc2l0aW9uIGluIF90ZXh0IGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIGluc2VydFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHlsZSBhcnJheSBvZiBzdHlsZSBvYmplY3RzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIGRlZmF1bHQgdG8gc3RhcnQgKyAxXG4gICAqL1xuICBpbnNlcnRDaGFyczogZnVuY3Rpb24odGV4dCwgc3R5bGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8oc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHZhciBncmFwaGVtZXMgPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdCh0ZXh0KTtcbiAgICB0aGlzLmluc2VydE5ld1N0eWxlQmxvY2soZ3JhcGhlbWVzLCBzdGFydCwgc3R5bGUpO1xuICAgIHRoaXMuX3RleHQgPSBbXS5jb25jYXQodGhpcy5fdGV4dC5zbGljZSgwLCBzdGFydCksIGdyYXBoZW1lcywgdGhpcy5fdGV4dC5zbGljZShlbmQpKTtcbiAgICB0aGlzLnRleHQgPSB0aGlzLl90ZXh0LmpvaW4oJycpO1xuICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXMoKTtcbiAgfSxcblxufSk7XG5cblxuLyogX1RPX1NWR19TVEFSVF8gKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgbXVsdGlwbGVTcGFjZXNSZWdleCA9IC8gICsvZztcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5UZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBvZmZzZXRzID0gdGhpcy5fZ2V0U1ZHTGVmdFRvcE9mZnNldHMoKSxcbiAgICAgICAgICB0ZXh0QW5kQmcgPSB0aGlzLl9nZXRTVkdUZXh0QW5kQmcob2Zmc2V0cy50ZXh0VG9wLCBvZmZzZXRzLnRleHRMZWZ0KSxcbiAgICAgICAgICBpbnRlcm5hbE1hcmt1cCA9IHRoaXMuX3dyYXBTVkdUZXh0QW5kQmcodGV4dEFuZEJnKTtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKFxuICAgICAgICBpbnRlcm5hbE1hcmt1cCwgeyByZXZpdmVyOiByZXZpdmVyLCBub1N0eWxlOiB0cnVlLCB3aXRoU2hhZG93OiB0cnVlIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTVkdMZWZ0VG9wT2Zmc2V0czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0TGVmdDogLXRoaXMud2lkdGggLyAyLFxuICAgICAgICB0ZXh0VG9wOiAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICBsaW5lVG9wOiB0aGlzLmdldEhlaWdodE9mTGluZSgwKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfd3JhcFNWR1RleHRBbmRCZzogZnVuY3Rpb24odGV4dEFuZEJnKSB7XG4gICAgICB2YXIgbm9TaGFkb3cgPSB0cnVlLFxuICAgICAgICAgIHRleHREZWNvcmF0aW9uID0gdGhpcy5nZXRTdmdUZXh0RGVjb3JhdGlvbih0aGlzKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRleHRBbmRCZy50ZXh0QmdSZWN0cy5qb2luKCcnKSxcbiAgICAgICAgJ1xcdFxcdDx0ZXh0IHhtbDpzcGFjZT1cInByZXNlcnZlXCIgJyxcbiAgICAgICAgKHRoaXMuZm9udEZhbWlseSA/ICdmb250LWZhbWlseT1cIicgKyB0aGlzLmZvbnRGYW1pbHkucmVwbGFjZSgvXCIvZywgJ1xcJycpICsgJ1wiICcgOiAnJyksXG4gICAgICAgICh0aGlzLmZvbnRTaXplID8gJ2ZvbnQtc2l6ZT1cIicgKyB0aGlzLmZvbnRTaXplICsgJ1wiICcgOiAnJyksXG4gICAgICAgICh0aGlzLmZvbnRTdHlsZSA/ICdmb250LXN0eWxlPVwiJyArIHRoaXMuZm9udFN0eWxlICsgJ1wiICcgOiAnJyksXG4gICAgICAgICh0aGlzLmZvbnRXZWlnaHQgPyAnZm9udC13ZWlnaHQ9XCInICsgdGhpcy5mb250V2VpZ2h0ICsgJ1wiICcgOiAnJyksXG4gICAgICAgICh0ZXh0RGVjb3JhdGlvbiA/ICd0ZXh0LWRlY29yYXRpb249XCInICsgdGV4dERlY29yYXRpb24gKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgJ3N0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMobm9TaGFkb3cpLCAnXCInLCB0aGlzLmFkZFBhaW50T3JkZXIoKSwgJyA+JyxcbiAgICAgICAgdGV4dEFuZEJnLnRleHRTcGFucy5qb2luKCcnKSxcbiAgICAgICAgJzwvdGV4dD5cXG4nXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0VG9wT2Zmc2V0IFRleHQgdG9wIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0TGVmdE9mZnNldCBUZXh0IGxlZnQgb2Zmc2V0XG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIF9nZXRTVkdUZXh0QW5kQmc6IGZ1bmN0aW9uKHRleHRUb3BPZmZzZXQsIHRleHRMZWZ0T2Zmc2V0KSB7XG4gICAgICB2YXIgdGV4dFNwYW5zID0gW10sXG4gICAgICAgICAgdGV4dEJnUmVjdHMgPSBbXSxcbiAgICAgICAgICBoZWlnaHQgPSB0ZXh0VG9wT2Zmc2V0LCBsaW5lT2Zmc2V0O1xuICAgICAgLy8gYm91bmRpbmctYm94IGJhY2tncm91bmRcbiAgICAgIHRoaXMuX3NldFNWR0JnKHRleHRCZ1JlY3RzKTtcblxuICAgICAgLy8gdGV4dCBhbmQgdGV4dC1iYWNrZ3JvdW5kXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dEJhY2tncm91bmRDb2xvciB8fCB0aGlzLnN0eWxlSGFzKCd0ZXh0QmFja2dyb3VuZENvbG9yJywgaSkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRTVkdUZXh0TGluZUJnKHRleHRCZ1JlY3RzLCBpLCB0ZXh0TGVmdE9mZnNldCArIGxpbmVPZmZzZXQsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0U1ZHVGV4dExpbmVUZXh0KHRleHRTcGFucywgaSwgdGV4dExlZnRPZmZzZXQgKyBsaW5lT2Zmc2V0LCBoZWlnaHQpO1xuICAgICAgICBoZWlnaHQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHRTcGFuczogdGV4dFNwYW5zLFxuICAgICAgICB0ZXh0QmdSZWN0czogdGV4dEJnUmVjdHNcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVRleHRDaGFyU3BhbjogZnVuY3Rpb24oX2NoYXIsIHN0eWxlRGVjbCwgbGVmdCwgdG9wKSB7XG4gICAgICB2YXIgc2hvdWxkVXNlV2hpdGVzcGFjZSA9IF9jaGFyICE9PSBfY2hhci50cmltKCkgfHwgX2NoYXIubWF0Y2gobXVsdGlwbGVTcGFjZXNSZWdleCksXG4gICAgICAgICAgc3R5bGVQcm9wcyA9IHRoaXMuZ2V0U3ZnU3BhblN0eWxlcyhzdHlsZURlY2wsIHNob3VsZFVzZVdoaXRlc3BhY2UpLFxuICAgICAgICAgIGZpbGxTdHlsZXMgPSBzdHlsZVByb3BzID8gJ3N0eWxlPVwiJyArIHN0eWxlUHJvcHMgKyAnXCInIDogJycsXG4gICAgICAgICAgZHkgPSBzdHlsZURlY2wuZGVsdGFZLCBkeVNwYW4gPSAnJyxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgaWYgKGR5KSB7XG4gICAgICAgIGR5U3BhbiA9ICcgZHk9XCInICsgdG9GaXhlZChkeSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8dHNwYW4geD1cIicsIHRvRml4ZWQobGVmdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksICdcIiB5PVwiJyxcbiAgICAgICAgdG9GaXhlZCh0b3AsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnXCIgJywgZHlTcGFuLFxuICAgICAgICBmaWxsU3R5bGVzLCAnPicsXG4gICAgICAgIGZhYnJpYy51dGlsLnN0cmluZy5lc2NhcGVYbWwoX2NoYXIpLFxuICAgICAgICAnPC90c3Bhbj4nXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHVGV4dExpbmVUZXh0OiBmdW5jdGlvbih0ZXh0U3BhbnMsIGxpbmVJbmRleCwgdGV4dExlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpIHtcbiAgICAgIC8vIHNldCBwcm9wZXIgbGluZSBvZmZzZXRcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUobGluZUluZGV4KSxcbiAgICAgICAgICBpc0p1c3RpZnkgPSB0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xLFxuICAgICAgICAgIGFjdHVhbFN0eWxlLFxuICAgICAgICAgIG5leHRTdHlsZSxcbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJycsXG4gICAgICAgICAgY2hhckJveCwgc3R5bGUsXG4gICAgICAgICAgYm94V2lkdGggPSAwLFxuICAgICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICB0aW1lVG9SZW5kZXI7XG5cbiAgICAgIHRleHRUb3BPZmZzZXQgKz0gbGluZUhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZS5sZW5ndGggLSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHRpbWVUb1JlbmRlciA9IGkgPT09IGxlbiB8fCB0aGlzLmNoYXJTcGFjaW5nO1xuICAgICAgICBjaGFyc1RvUmVuZGVyICs9IGxpbmVbaV07XG4gICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2ldO1xuICAgICAgICBpZiAoYm94V2lkdGggPT09IDApIHtcbiAgICAgICAgICB0ZXh0TGVmdE9mZnNldCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoIC0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSnVzdGlmeSAmJiAhdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChsaW5lW2ldKSkge1xuICAgICAgICAgICAgdGltZVRvUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGNoYXJTcGFjaW5nLCB3ZSByZW5kZXIgY2hhciBieSBjaGFyXG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBhY3R1YWxTdHlsZSB8fCB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpO1xuICAgICAgICAgIG5leHRTdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSArIDEpO1xuICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRoaXMuX2hhc1N0eWxlQ2hhbmdlZEZvclN2ZyhhY3R1YWxTdHlsZSwgbmV4dFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSkgfHwgeyB9O1xuICAgICAgICAgIHRleHRTcGFucy5wdXNoKHRoaXMuX2NyZWF0ZVRleHRDaGFyU3BhbihjaGFyc1RvUmVuZGVyLCBzdHlsZSwgdGV4dExlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpKTtcbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJyc7XG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBuZXh0U3R5bGU7XG4gICAgICAgICAgdGV4dExlZnRPZmZzZXQgKz0gYm94V2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9wdXNoVGV4dEJnUmVjdDogZnVuY3Rpb24odGV4dEJnUmVjdHMsIGNvbG9yLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgdGV4dEJnUmVjdHMucHVzaChcbiAgICAgICAgJ1xcdFxcdDxyZWN0ICcsXG4gICAgICAgIHRoaXMuX2dldEZpbGxBdHRyaWJ1dGVzKGNvbG9yKSxcbiAgICAgICAgJyB4PVwiJyxcbiAgICAgICAgdG9GaXhlZChsZWZ0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiIHk9XCInLFxuICAgICAgICB0b0ZpeGVkKHRvcCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIiB3aWR0aD1cIicsXG4gICAgICAgIHRvRml4ZWQod2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgdG9GaXhlZChoZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCI+PC9yZWN0PlxcbicpO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHVGV4dExpbmVCZzogZnVuY3Rpb24odGV4dEJnUmVjdHMsIGksIGxlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpIHtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldLFxuICAgICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpIC8gdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgIGJveFdpZHRoID0gMCxcbiAgICAgICAgICBib3hTdGFydCA9IDAsXG4gICAgICAgICAgY2hhckJveCwgY3VycmVudENvbG9yLFxuICAgICAgICAgIGxhc3RDb2xvciA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ3RleHRCYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2ldW2pdO1xuICAgICAgICBjdXJyZW50Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgIGlmIChjdXJyZW50Q29sb3IgIT09IGxhc3RDb2xvcikge1xuICAgICAgICAgIGxhc3RDb2xvciAmJiB0aGlzLl9wdXNoVGV4dEJnUmVjdCh0ZXh0QmdSZWN0cywgbGFzdENvbG9yLCBsZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICB0ZXh0VG9wT2Zmc2V0LCBib3hXaWR0aCwgaGVpZ2h0T2ZMaW5lKTtcbiAgICAgICAgICBib3hTdGFydCA9IGNoYXJCb3gubGVmdDtcbiAgICAgICAgICBib3hXaWR0aCA9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgbGFzdENvbG9yID0gY3VycmVudENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnRDb2xvciAmJiB0aGlzLl9wdXNoVGV4dEJnUmVjdCh0ZXh0QmdSZWN0cywgY3VycmVudENvbG9yLCBsZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgIHRleHRUb3BPZmZzZXQsIGJveFdpZHRoLCBoZWlnaHRPZkxpbmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZG9iZSBJbGx1c3RyYXRvciAoYXQgbGVhc3QgQ1M1KSBpcyB1bmFibGUgdG8gcmVuZGVyIHJnYmEoKS1iYXNlZCBmaWxsIHZhbHVlc1xuICAgICAqIHdlIHdvcmsgYXJvdW5kIGl0IGJ5IFwibW92aW5nXCIgYWxwaGEgY2hhbm5lbCBpbnRvIG9wYWNpdHkgYXR0cmlidXRlIGFuZCBzZXR0aW5nIGZpbGwncyBhbHBoYSB0byAxXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgX2dldEZpbGxBdHRyaWJ1dGVzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZpbGxDb2xvciA9ICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSA/IG5ldyBmYWJyaWMuQ29sb3IodmFsdWUpIDogJyc7XG4gICAgICBpZiAoIWZpbGxDb2xvciB8fCAhZmlsbENvbG9yLmdldFNvdXJjZSgpIHx8IGZpbGxDb2xvci5nZXRBbHBoYSgpID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnZmlsbD1cIicgKyB2YWx1ZSArICdcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ29wYWNpdHk9XCInICsgZmlsbENvbG9yLmdldEFscGhhKCkgKyAnXCIgZmlsbD1cIicgKyBmaWxsQ29sb3Iuc2V0QWxwaGEoMSkudG9SZ2IoKSArICdcIic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFNWR0xpbmVUb3BPZmZzZXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVUb3BPZmZzZXQgPSAwLCBsYXN0SGVpZ2h0ID0gMDtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZUluZGV4OyBqKyspIHtcbiAgICAgICAgbGluZVRvcE9mZnNldCArPSB0aGlzLmdldEhlaWdodE9mTGluZShqKTtcbiAgICAgIH1cbiAgICAgIGxhc3RIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShqKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVUb3A6IGxpbmVUb3BPZmZzZXQsXG4gICAgICAgIG9mZnNldDogKHRoaXMuX2ZvbnRTaXplTXVsdCAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pICogbGFzdEhlaWdodCAvICh0aGlzLmxpbmVIZWlnaHQgKiB0aGlzLl9mb250U2l6ZU11bHQpXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0eWxlcy1zdHJpbmcgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBTaGFkb3cgYSBib29sZWFuIHRvIHNraXAgc2hhZG93IGZpbHRlciBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3R5bGVzOiBmdW5jdGlvbihza2lwU2hhZG93KSB7XG4gICAgICB2YXIgc3ZnU3R5bGUgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5nZXRTdmdTdHlsZXMuY2FsbCh0aGlzLCBza2lwU2hhZG93KTtcbiAgICAgIHJldHVybiBzdmdTdHlsZSArICcgd2hpdGUtc3BhY2U6IHByZTsnO1xuICAgIH0sXG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7fSk7XG5cbiAgLyoqXG4gICAqIFRleHRib3ggY2xhc3MsIGJhc2VkIG9uIElUZXh0LCBhbGxvd3MgdGhlIHVzZXIgdG8gcmVzaXplIHRoZSB0ZXh0IHJlY3RhbmdsZVxuICAgKiBhbmQgd3JhcHMgbGluZXMgYXV0b21hdGljYWxseS4gVGV4dGJveGVzIGhhdmUgdGhlaXIgWSBzY2FsaW5nIGxvY2tlZCwgdGhlXG4gICAqIHVzZXIgY2FuIG9ubHkgY2hhbmdlIHdpZHRoLiBIZWlnaHQgaXMgYWRqdXN0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiB0aGVcbiAgICogd3JhcHBpbmcgb2YgbGluZXMuXG4gICAqIEBjbGFzcyBmYWJyaWMuVGV4dGJveFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSVRleHRcbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0Ym94fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UZXh0Ym94I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuVGV4dGJveCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5JVGV4dCwgZmFicmljLk9ic2VydmFibGUsIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndGV4dGJveCcsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHdpZHRoIG9mIHRleHRib3gsIGluIHBpeGVscy5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pbldpZHRoOiAyMCxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gY2FsY3VsYXRlZCB3aWR0aCBvZiBhIHRleHRib3gsIGluIHBpeGVscy5cbiAgICAgKiBmaXhlZCB0byAyIHNvIHRoYXQgYW4gZW1wdHkgdGV4dGJveCBjYW5ub3QgZ28gdG8gMFxuICAgICAqIGFuZCBpcyBzdGlsbCBzZWxlY3RhYmxlIHdpdGhvdXQgdGV4dC5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGR5bmFtaWNNaW5XaWR0aDogMixcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBhcnJheSBvZiB0ZXh0IHdyYXBwaW5nLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgX19jYWNoZWRMaW5lczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHN0YW5kYXJkIE9iamVjdCBjbGFzcyB2YWx1ZXNcbiAgICAgKi9cbiAgICBsb2NrU2NhbGluZ0ZsaXA6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBzdGFuZGFyZCBPYmplY3QgY2xhc3MgdmFsdWVzXG4gICAgICogVGV4dGJveCBuZWVkcyB0aGlzIG9uIGZhbHNlXG4gICAgICovXG4gICAgbm9TY2FsZUNhY2hlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgd2hpY2ggd2hlbiBzZXQgY2F1c2Ugb2JqZWN0IHRvIGNoYW5nZSBkaW1lbnNpb25zXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHM6IGZhYnJpYy5UZXh0LnByb3RvdHlwZS5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMuY29uY2F0KCd3aWR0aCcpLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIHNwbGl0IHN0cmluZ3MgaW4gYnJlYWthYmxlIGxpbmVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfd29yZEpvaW5lcnM6IC9bIFxcdFxcclxcdTIwMEJcXHUyMDBDXS8sXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBib29sZWFuIHByb3BlcnR5IGluIG9yZGVyIHRvIHNwbGl0IHN0cmluZ3MgdGhhdCBoYXZlIG5vIHdoaXRlIHNwYWNlIGNvbmNlcHQuXG4gICAgICogdGhpcyBpcyBhIGNoZWFwIHdheSB0byBoZWxwIHdpdGggY2hpbmVzZS9qYXBhZW5zZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMi42LjBcbiAgICAgKi9cbiAgICBzcGxpdEJ5R3JhcGhlbWU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVW5saWtlIHN1cGVyY2xhc3MncyB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb24sIFRleHRib3ggZG9lcyBub3QgdXBkYXRlXG4gICAgICogaXRzIHdpZHRoLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgaW5pdERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX19za2lwRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgICAvLyBjbGVhciBkeW5hbWljTWluV2lkdGggYXMgaXQgd2lsbCBiZSBkaWZmZXJlbnQgYWZ0ZXIgd2UgcmUtd3JhcCBsaW5lXG4gICAgICB0aGlzLmR5bmFtaWNNaW5XaWR0aCA9IDA7XG4gICAgICAvLyB3cmFwIGxpbmVzXG4gICAgICB0aGlzLl9zdHlsZU1hcCA9IHRoaXMuX2dlbmVyYXRlU3R5bGVNYXAodGhpcy5fc3BsaXRUZXh0KCkpO1xuICAgICAgLy8gaWYgYWZ0ZXIgd3JhcHBpbmcsIHRoZSB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gZHluYW1pY01pbldpZHRoLCBjaGFuZ2UgdGhlIHdpZHRoIGFuZCByZS13cmFwXG4gICAgICBpZiAodGhpcy5keW5hbWljTWluV2lkdGggPiB0aGlzLndpZHRoKSB7XG4gICAgICAgIHRoaXMuX3NldCgnd2lkdGgnLCB0aGlzLmR5bmFtaWNNaW5XaWR0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSkge1xuICAgICAgICAvLyBvbmNlIHRleHQgaXMgbWVhc3VyZWQgd2UgbmVlZCB0byBtYWtlIHNwYWNlIGZhdHRlciB0byBtYWtlIGp1c3RpZmllZCB0ZXh0LlxuICAgICAgICB0aGlzLmVubGFyZ2VTcGFjZXMoKTtcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFyIGNhY2hlIGFuZCByZS1jYWxjdWxhdGUgaGVpZ2h0XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FsY1RleHRIZWlnaHQoKTtcbiAgICAgIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBvYmplY3QgdGhhdCB0cmFuc2xhdGVzIHRoZSBzdHlsZSBvYmplY3Qgc28gdGhhdCBpdCBpc1xuICAgICAqIGJyb2tlbiB1cCBieSB2aXN1YWwgbGluZXMgKG5ldyBsaW5lcyBhbmQgYXV0b21hdGljIHdyYXBwaW5nKS5cbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCBzdHlsZXMgb2JqZWN0IGlzIGJyb2tlbiB1cCBieSBhY3R1YWwgbGluZXMgKG5ldyBsaW5lcyBvbmx5KSxcbiAgICAgKiB3aGljaCBpcyBvbmx5IHN1ZmZpY2llbnQgZm9yIFRleHQgLyBJVGV4dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dlbmVyYXRlU3R5bGVNYXA6IGZ1bmN0aW9uKHRleHRJbmZvKSB7XG4gICAgICB2YXIgcmVhbExpbmVDb3VudCAgICAgPSAwLFxuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ID0gMCxcbiAgICAgICAgICBjaGFyQ291bnQgICAgICAgICA9IDAsXG4gICAgICAgICAgbWFwICAgICAgICAgICAgICAgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0SW5mby5ncmFwaGVtZUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXh0SW5mby5ncmFwaGVtZVRleHRbY2hhckNvdW50XSA9PT0gJ1xcbicgJiYgaSA+IDApIHtcbiAgICAgICAgICByZWFsTGluZUNoYXJDb3VudCA9IDA7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgICAgcmVhbExpbmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdCh0ZXh0SW5mby5ncmFwaGVtZVRleHRbY2hhckNvdW50XSkgJiYgaSA+IDApIHtcbiAgICAgICAgICAvLyB0aGlzIGNhc2UgZGVhbHMgd2l0aCBzcGFjZSdzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBlbmQgb2YgbGluZXMgd2hlbiB3cmFwcGluZ1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50Kys7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbaV0gPSB7IGxpbmU6IHJlYWxMaW5lQ291bnQsIG9mZnNldDogcmVhbExpbmVDaGFyQ291bnQgfTtcblxuICAgICAgICBjaGFyQ291bnQgKz0gdGV4dEluZm8uZ3JhcGhlbWVMaW5lc1tpXS5sZW5ndGg7XG4gICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ICs9IHRleHRJbmZvLmdyYXBoZW1lTGluZXNbaV0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBhIHN0eWxlIHByb3BlcnR5IG9yIGhhcyBpdCBpbmEgc3BlY2lmaWVkIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdHlsZUhhczogZnVuY3Rpb24ocHJvcGVydHksIGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwICYmICF0aGlzLmlzV3JhcHBpbmcpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5UZXh0LnByb3RvdHlwZS5zdHlsZUhhcy5jYWxsKHRoaXMsIHByb3BlcnR5LCBsaW5lSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBubyBzdHlsaW5nIG9yIG5vIHN0eWxpbmcgaW4gYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCAsIGxpbmVJbmRleCBpcyBvbiB3cmFwcGVkIGxpbmVzLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgbmV4dExpbmVJbmRleCA9IGxpbmVJbmRleCArIDEsIG5leHRPZmZzZXQsIG9iaiwgc2hvdWxkTGltaXQgPSBmYWxzZTtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgdmFyIG1hcE5leHRMaW5lID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4ICsgMV07XG4gICAgICBpZiAobWFwKSB7XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBvZmZzZXQgPSBtYXAub2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG1hcE5leHRMaW5lKSB7XG4gICAgICAgIG5leHRMaW5lSW5kZXggPSBtYXBOZXh0TGluZS5saW5lO1xuICAgICAgICBzaG91bGRMaW1pdCA9IG5leHRMaW5lSW5kZXggPT09IGxpbmVJbmRleDtcbiAgICAgICAgbmV4dE9mZnNldCA9IG1hcE5leHRMaW5lLm9mZnNldDtcbiAgICAgIH1cbiAgICAgIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgaWYgKHAyID49IG9mZnNldCAmJiAoIXNob3VsZExpbWl0IHx8IHAyIDwgbmV4dE9mZnNldCkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdfZ2V0U3R5bGVEZWNsYXJhdGlvbicsIGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGUpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuXG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogcHJvYmFibHkgYnJva2VuIG5lZWQgYSBmaXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgcmV0dXJuIHRoaXMuc3R5bGVzW21hcC5saW5lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcHJvYmFibHkgYnJva2VuIG5lZWQgYSBmaXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgsIHN0eWxlKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHRoaXMuc3R5bGVzW21hcC5saW5lXSA9IHN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwcm9iYWJseSBicm9rZW4gbmVlZCBhIGZpeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbWFwLmxpbmVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyB0ZXh0IHVzaW5nIHRoZSAnd2lkdGgnIHByb3BlcnR5IG9mIFRleHRib3guIEZpcnN0IHRoaXMgZnVuY3Rpb25cbiAgICAgKiBzcGxpdHMgdGV4dCBvbiBuZXdsaW5lcywgc28gd2UgcHJlc2VydmUgbmV3bGluZXMgZW50ZXJlZCBieSB0aGUgdXNlci5cbiAgICAgKiBUaGVuIGl0IHdyYXBzIGVhY2ggbGluZSB1c2luZyB0aGUgd2lkdGggb2YgdGhlIFRleHRib3ggYnkgY2FsbGluZ1xuICAgICAqIF93cmFwTGluZSgpLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVzIFRoZSBzdHJpbmcgYXJyYXkgb2YgdGV4dCB0aGF0IGlzIHNwbGl0IGludG8gbGluZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzaXJlZFdpZHRoIHdpZHRoIHlvdSB3YW50IHRvIHdyYXAgdG9cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzXG4gICAgICovXG4gICAgX3dyYXBUZXh0OiBmdW5jdGlvbihsaW5lcywgZGVzaXJlZFdpZHRoKSB7XG4gICAgICB2YXIgd3JhcHBlZCA9IFtdLCBpO1xuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gdHJ1ZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5jb25jYXQodGhpcy5fd3JhcExpbmUobGluZXNbaV0sIGksIGRlc2lyZWRXaWR0aCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gd3JhcHBlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIG1lYXN1cmUgYSBzdHJpbmcgb2YgdGV4dCwgZ2l2ZW4gaXRzIGxpbmVJbmRleCBhbmQgY2hhckluZGV4IG9mZnNldFxuICAgICAqIGl0IGdldHMgY2FsbGVkIHdoZW4gY2hhckJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSB5ZXQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyT2Zmc2V0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tZWFzdXJlV29yZDogZnVuY3Rpb24od29yZCwgbGluZUluZGV4LCBjaGFyT2Zmc2V0KSB7XG4gICAgICB2YXIgd2lkdGggPSAwLCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0ID0gdHJ1ZTtcbiAgICAgIGNoYXJPZmZzZXQgPSBjaGFyT2Zmc2V0IHx8IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd29yZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYm94ID0gdGhpcy5fZ2V0R3JhcGhlbWVCb3god29yZFtpXSwgbGluZUluZGV4LCBpICsgY2hhck9mZnNldCwgcHJldkdyYXBoZW1lLCBza2lwTGVmdCk7XG4gICAgICAgIHdpZHRoICs9IGJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgcHJldkdyYXBoZW1lID0gd29yZFtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgYSBsaW5lIG9mIHRleHQgdXNpbmcgdGhlIHdpZHRoIG9mIHRoZSBUZXh0Ym94IGFuZCBhIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGluZSBUaGUgZ3JhcGhlbWUgYXJyYXkgdGhhdCByZXByZXNlbnQgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc2lyZWRXaWR0aCB3aWR0aCB5b3Ugd2FudCB0byB3cmFwIHRoZSBsaW5lIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlc2VydmVkU3BhY2Ugc3BhY2UgdG8gcmVtb3ZlIGZyb20gd3JhcHBpbmcgZm9yIGN1c3RvbSBmdW5jdGlvbmFsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmUocykgaW50byB3aGljaCB0aGUgZ2l2ZW4gdGV4dCBpcyB3cmFwcGVkXG4gICAgICogdG8uXG4gICAgICovXG4gICAgX3dyYXBMaW5lOiBmdW5jdGlvbihfbGluZSwgbGluZUluZGV4LCBkZXNpcmVkV2lkdGgsIHJlc2VydmVkU3BhY2UpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSAwLFxuICAgICAgICAgIHNwbGl0QnlHcmFwaGVtZSA9IHRoaXMuc3BsaXRCeUdyYXBoZW1lLFxuICAgICAgICAgIGdyYXBoZW1lTGluZXMgPSBbXSxcbiAgICAgICAgICBsaW5lID0gW10sXG4gICAgICAgICAgLy8gc3BhY2VzIGluIGRpZmZlcmVudCBsYW5ndWdlcz9cbiAgICAgICAgICB3b3JkcyA9IHNwbGl0QnlHcmFwaGVtZSA/IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KF9saW5lKSA6IF9saW5lLnNwbGl0KHRoaXMuX3dvcmRKb2luZXJzKSxcbiAgICAgICAgICB3b3JkID0gJycsXG4gICAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgICBpbmZpeCA9IHNwbGl0QnlHcmFwaGVtZSA/ICcnIDogJyAnLFxuICAgICAgICAgIHdvcmRXaWR0aCA9IDAsXG4gICAgICAgICAgaW5maXhXaWR0aCA9IDAsXG4gICAgICAgICAgbGFyZ2VzdFdvcmRXaWR0aCA9IDAsXG4gICAgICAgICAgbGluZUp1c3RTdGFydGVkID0gdHJ1ZSxcbiAgICAgICAgICBhZGRpdGlvbmFsU3BhY2UgPSBzcGxpdEJ5R3JhcGhlbWUgPyAwIDogdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCksXG4gICAgICAgICAgcmVzZXJ2ZWRTcGFjZSA9IHJlc2VydmVkU3BhY2UgfHwgMDtcblxuICAgICAgZGVzaXJlZFdpZHRoIC09IHJlc2VydmVkU3BhY2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGkgd291bGQgYXZvaWQgcmVzcGxpdHRpbmcgdGhlIGdyYXBoZW1lc1xuICAgICAgICB3b3JkID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQod29yZHNbaV0pO1xuICAgICAgICB3b3JkV2lkdGggPSB0aGlzLl9tZWFzdXJlV29yZCh3b3JkLCBsaW5lSW5kZXgsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB3b3JkLmxlbmd0aDtcblxuICAgICAgICBsaW5lV2lkdGggKz0gaW5maXhXaWR0aCArIHdvcmRXaWR0aCAtIGFkZGl0aW9uYWxTcGFjZTtcblxuICAgICAgICBpZiAobGluZVdpZHRoID49IGRlc2lyZWRXaWR0aCAmJiAhbGluZUp1c3RTdGFydGVkKSB7XG4gICAgICAgICAgZ3JhcGhlbWVMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICBsaW5lV2lkdGggPSB3b3JkV2lkdGg7XG4gICAgICAgICAgbGluZUp1c3RTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsaW5lV2lkdGggKz0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaW5lSnVzdFN0YXJ0ZWQpIHtcbiAgICAgICAgICBsaW5lLnB1c2goaW5maXgpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSBsaW5lLmNvbmNhdCh3b3JkKTtcblxuICAgICAgICBpbmZpeFdpZHRoID0gdGhpcy5fbWVhc3VyZVdvcmQoW2luZml4XSwgbGluZUluZGV4LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgbGluZUp1c3RTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgbGFyZ2VzdCB3b3JkXG4gICAgICAgIGlmICh3b3JkV2lkdGggPiBsYXJnZXN0V29yZFdpZHRoKSB7XG4gICAgICAgICAgbGFyZ2VzdFdvcmRXaWR0aCA9IHdvcmRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpICYmIGdyYXBoZW1lTGluZXMucHVzaChsaW5lKTtcblxuICAgICAgaWYgKGxhcmdlc3RXb3JkV2lkdGggKyByZXNlcnZlZFNwYWNlID4gdGhpcy5keW5hbWljTWluV2lkdGgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljTWluV2lkdGggPSBsYXJnZXN0V29yZFdpZHRoIC0gYWRkaXRpb25hbFNwYWNlICsgcmVzZXJ2ZWRTcGFjZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyYXBoZW1lTGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiB0aGUgdGV4dCBsaW5lIGlzIGVuZGVkIHdpdGggYW4gaGFyZCBicmVha1xuICAgICAqIHRleHQgYW5kIGl0ZXh0IGRvIG5vdCBoYXZlIHdyYXBwaW5nLCByZXR1cm4gZmFsc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRleHQgdG8gc3BsaXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW5kT2ZXcmFwcGluZzogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdKSB7XG4gICAgICAgIC8vIGlzIGxhc3QgbGluZSwgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdLmxpbmUgIT09IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF0ubGluZSkge1xuICAgICAgICAvLyB0aGlzIGlzIGxhc3QgbGluZSBiZWZvcmUgYSBsaW5lIGJyZWFrLCByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogR2V0cyBsaW5lcyBvZiB0ZXh0IHRvIHJlbmRlciBpbiB0aGUgVGV4dGJveC4gVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzXG4gICAgKiB0ZXh0IHdyYXBwaW5nIG9uIHRoZSBmbHkgZXZlcnkgdGltZSBpdCBpcyBjYWxsZWQuXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIHNwbGl0XG4gICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzIGluIHRoZSBUZXh0Ym94LlxuICAgICogQG92ZXJyaWRlXG4gICAgKi9cbiAgICBfc3BsaXRUZXh0SW50b0xpbmVzOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgbmV3VGV4dCA9IGZhYnJpYy5UZXh0LnByb3RvdHlwZS5fc3BsaXRUZXh0SW50b0xpbmVzLmNhbGwodGhpcywgdGV4dCksXG4gICAgICAgICAgZ3JhcGhlbWVMaW5lcyA9IHRoaXMuX3dyYXBUZXh0KG5ld1RleHQubGluZXMsIHRoaXMud2lkdGgpLFxuICAgICAgICAgIGxpbmVzID0gbmV3IEFycmF5KGdyYXBoZW1lTGluZXMubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaGVtZUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmVzW2ldID0gZ3JhcGhlbWVMaW5lc1tpXS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIG5ld1RleHQubGluZXMgPSBsaW5lcztcbiAgICAgIG5ld1RleHQuZ3JhcGhlbWVMaW5lcyA9IGdyYXBoZW1lTGluZXM7XG4gICAgICByZXR1cm4gbmV3VGV4dDtcbiAgICB9LFxuXG4gICAgZ2V0TWluV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubWluV2lkdGgsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ21pbldpZHRoJywgJ3NwbGl0QnlHcmFwaGVtZSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dGJveCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dGJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5UZXh0Ym94IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5UZXh0Ym94LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1RleHRib3gnLCBvYmplY3QsIGNhbGxiYWNrLCAndGV4dCcpO1xuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgX3NldE9iamVjdFNjYWxlIGFuZCBhZGQgVGV4dGJveCBzcGVjaWZpYyByZXNpemluZyBiZWhhdmlvci4gUmVzaXppbmdcbiAgICogYSBUZXh0Ym94IGRvZXNuJ3Qgc2NhbGUgdGV4dCwgaXQgb25seSBjaGFuZ2VzIHdpZHRoIGFuZCBtYWtlcyB0ZXh0IHdyYXAgYXV0b21hdGljYWxseS5cbiAgICovXG4gIHZhciBzZXRPYmplY3RTY2FsZU92ZXJyaWRkZW4gPSBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5fc2V0T2JqZWN0U2NhbGU7XG5cbiAgZmFicmljLkNhbnZhcy5wcm90b3R5cGUuX3NldE9iamVjdFNjYWxlID0gZnVuY3Rpb24obG9jYWxNb3VzZSwgdHJhbnNmb3JtLFxuICAgIGxvY2tTY2FsaW5nWCwgbG9ja1NjYWxpbmdZLCBieSwgbG9ja1NjYWxpbmdGbGlwLCBfZGltKSB7XG5cbiAgICB2YXIgdCA9IHRyYW5zZm9ybS50YXJnZXQsIHNjYWxlZCxcbiAgICAgICAgc2NhbGVYID0gbG9jYWxNb3VzZS54ICogdC5zY2FsZVggLyBfZGltLngsXG4gICAgICAgIHNjYWxlWSA9IGxvY2FsTW91c2UueSAqIHQuc2NhbGVZIC8gX2RpbS55O1xuICAgIGlmIChieSA9PT0gJ3gnICYmIHQgaW5zdGFuY2VvZiBmYWJyaWMuVGV4dGJveCkge1xuICAgICAgdmFyIHR3ID0gdC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueDtcbiAgICAgIHZhciB3ID0gdC53aWR0aCAqIChsb2NhbE1vdXNlLnggLyB0dyk7XG4gICAgICB0cmFuc2Zvcm0ubmV3U2NhbGVYID0gc2NhbGVYO1xuICAgICAgdHJhbnNmb3JtLm5ld1NjYWxlWSA9IHNjYWxlWTtcbiAgICAgIGlmICh3ID49IHQuZ2V0TWluV2lkdGgoKSkge1xuICAgICAgICBzY2FsZWQgPSB3ICE9PSB0LndpZHRoO1xuICAgICAgICB0LnNldCgnd2lkdGgnLCB3KTtcbiAgICAgICAgcmV0dXJuIHNjYWxlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gc2V0T2JqZWN0U2NhbGVPdmVycmlkZGVuLmNhbGwoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIGxvY2FsTW91c2UsIHRyYW5zZm9ybSxcbiAgICAgICAgbG9ja1NjYWxpbmdYLCBsb2NrU2NhbGluZ1ksIGJ5LCBsb2NrU2NhbGluZ0ZsaXAsIF9kaW0pO1xuICAgIH1cbiAgfTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5UZXh0Ym94LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5fc3R5bGVNYXApIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbdGhpcy5fc3R5bGVNYXBbcHJvcF0ubGluZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gIH0pO1xufSkoKTtcblxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJpbXBvcnQge2ZhYnJpY30gZnJvbSBcImZhYnJpY1wiXHJcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gXCIuL21vZGVsL1JlY3RhbmdsZVwiO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gXCIuL21vZGVsL0NvbG9yXCI7XHJcblxyXG52YXIgY2FudmFzID0gbmV3IGZhYnJpYy5DYW52YXMoXCJjYW52YXNcIik7XHJcbnZhciBkZWZhdWx0VmFsdWUgPSBuZXcgUmVjdGFuZ2xlKDEwMCwgMTYwLCAxNzApO1xyXG5kZWZhdWx0VmFsdWUuc2V0Q29sb3IoQ29sb3IuR3JlZW4pO1xyXG5cclxudmFyIHJlY3QgPSBuZXcgZmFicmljLlJlY3Qoe1xyXG4gICAgdG9wIDogMTAwLFxyXG4gICAgICAgICAgICBsZWZ0IDogZGVmYXVsdFZhbHVlLkxlZnQsXHJcbiAgICAgICAgICAgIHdpZHRoIDogZGVmYXVsdFZhbHVlLldpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQgOiBkZWZhdWx0VmFsdWUuSGVpZ2h0LFxyXG4gICAgICAgICAgICBmaWxsIDogZGVmYXVsdFZhbHVlLkZpbGxDb2xvclxyXG59KTtcclxuXHJcbmNhbnZhcy5hZGQocmVjdCk7XHJcbiIsImV4cG9ydCBlbnVtIENvbG9yIHtcclxuICAgIFJlZCA9IFwicmVkXCIsIFxyXG4gICAgR3JlZW4gPSBcImdyZWVuXCIsIFxyXG4gICAgQmx1ZSA9IFwiYmx1ZVwiXHJcbn1cclxuIiwiXHJcbmltcG9ydCB7IElSZWN0IH0gZnJvbSBcIi4uL2ludGVyZmFjZS9JUmVjdFwiO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gXCIuL0NvbG9yXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUmVjdGFuZ2xlIGltcGxlbWVudHMgSVJlY3Rcclxue1xyXG4gICAgTGVmdCA6IG51bWJlcjtcclxuICAgIFdpZHRoIDogbnVtYmVyO1xyXG4gICAgSGVpZ2h0IDogbnVtYmVyO1xyXG4gICAgRmlsbENvbG9yIDogc3RyaW5nO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGxlZnQgOiBudW1iZXIsIHdpZHRoOm51bWJlciwgaGVpZ2h0IDogbnVtYmVyKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuTGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5XaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuSGVpZ2h0ICA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLkZpbGxDb2xvciA9IFwiXCI7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHB1YmxpYyBzZXRDb2xvcihjb2xvciA6IENvbG9yKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuRmlsbENvbG9yID0gY29sb3I7XHJcbiAgICB9XHJcbn0iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9